# Context-Action 스토어 통합 아키텍처

## 1. 개요 및 핵심 개념

### Context-Action 아키텍처란?

Context-Action 프레임워크는 문서 중심의 컨텍스트 분리와 효과적인 아티팩트 관리를 통해 기존 라이브러리의 근본적인 한계를 극복하도록 설계된 **혁신적인 상태 관리 시스템**입니다.

#### 프로젝트 철학

Context-Action 프레임워크는 현대 상태 관리의 중요한 문제들을 해결합니다:

**기존 라이브러리의 문제점:**
- **높은 React 결합도**: 강한 통합으로 컴포넌트 모듈화와 props 처리가 어려움
- **이진 상태 접근법**: 단순한 전역/로컬 상태 이분법으로는 특정 범위 기반 분리를 처리하기 어려움  
- **부적절한 핸들러/트리거 관리**: 복잡한 상호작용과 비즈니스 로직 처리에 대한 부족한 지원

**Context-Action의 솔루션:**
- **문서-아티팩트 중심 설계**: 문서 테마와 결과물 관리를 기반으로 한 컨텍스트 분리
- **완벽한 관심사 분리**: 
  - 뷰 디자인 격리 → 디자인 컨텍스트
  - 개발 아키텍처 격리 → 아키텍처 컨텍스트
  - 비즈니스 로직 격리 → 비즈니스 컨텍스트  
  - 데이터 검증 격리 → 검증 컨텍스트
- **명확한 경계**: 구현 결과가 뚜렷하고 잘 정의된 도메인 경계를 유지
- **효과적인 문서-아티팩트 관리**: 문서와 결과물 간의 관계를 적극적으로 지원하는 상태 관리 라이브러리

### 아키텍처 구현

프레임워크는 완전한 도메인 격리를 위해 **선언적 스토어 패턴**과 결합된 MVVM에서 영감을 받은 패턴을 통해 명확한 관심사 분리를 구현합니다:

- **액션**이 비즈니스 로직을 처리 (ViewModel 레이어)
- **선언적 스토어 패턴**이 도메인 격리로 상태를 관리 (Model 레이어)
- **컴포넌트**가 UI를 렌더링 (View 레이어)
- **컨텍스트 경계**가 기능 도메인을 격리
- **도메인별 훅**을 통한 **타입 안전한 통합**

### 핵심 아키텍처 흐름

```
[컴포넌트] → dispatch → [액션 파이프라인] → handlers → [스토어] → subscribe → [컴포넌트]
```

### 컨텍스트 분리 전략

#### 도메인 기반 컨텍스트 아키텍처
- **비즈니스 컨텍스트**: 비즈니스 로직, 데이터 처리, 도메인 규칙
- **UI 컨텍스트**: 화면 상태, 사용자 상호작용, 컴포넌트 동작  
- **검증 컨텍스트**: 데이터 검증, 폼 처리, 에러 핸들링
- **디자인 컨텍스트**: 테마 관리, 스타일링, 레이아웃, 비주얼 상태
- **아키텍처 컨텍스트**: 시스템 설정, 인프라스트럭처, 기술적 결정

#### 문서 기반 컨텍스트 설계
각 컨텍스트는 해당하는 문서와 결과물을 관리하도록 설계됩니다:
- **디자인 문서** → 디자인 컨텍스트 (테마, 컴포넌트 사양, 스타일 가이드)
- **비즈니스 요구사항** → 비즈니스 컨텍스트 (워크플로, 규칙, 도메인 로직)  
- **아키텍처 문서** → 아키텍처 컨텍스트 (시스템 설계, 기술적 결정)
- **검증 사양** → 검증 컨텍스트 (규칙, 스키마, 에러 핸들링)
- **UI 사양** → UI 컨텍스트 (상호작용, 상태 관리, 사용자 플로우)

### 고급 핸들러 및 트리거 관리

Context-Action은 기존 라이브러리에서 부족한 정교한 핸들러 및 트리거 관리를 제공합니다:

#### 우선순위 기반 핸들러 실행
- **순차 처리**: 적절한 비동기 처리와 함께 우선순위 순서로 핸들러 실행
- **도메인 격리**: 각 컨텍스트가 자체 핸들러 레지스트리를 유지
- **교차 컨텍스트 조정**: 도메인 컨텍스트 간 제어된 통신
- **결과 수집**: 복잡한 워크플로를 위한 여러 핸들러의 결과 집계

#### 지능형 트리거 시스템
- **상태 변경 트리거**: 스토어 값 변경에 기반한 자동 트리거
- **교차 컨텍스트 트리거**: 도메인 경계가 다른 컨텍스트의 액션을 트리거
- **조건부 트리거**: 비즈니스 규칙과 조건에 기반한 스마트 트리거
- **트리거 정리**: 자동 정리가 메모리 누수와 오래된 참조를 방지

### 주요 장점

1. **문서-아티팩트 관리**: 문서와 구현 간의 직접적인 관계
2. **도메인 격리**: 각 컨텍스트가 완전한 독립성을 유지
3. **고급 핸들러 관리**: 정교한 트리거 시스템을 가진 우선순위 기반 핸들러 실행
4. **타입 안전성**: 프레임워크 전반에 걸친 완전한 TypeScript 지원
5. **성능**: 영향받는 컴포넌트만 다시 렌더링
6. **팀 협업**: 서로 다른 팀이 서로 다른 도메인에서 작업 가능

## MVVM 패턴 통합

### 선언적 스토어 패턴 (주요)

**도메인 격리를 통한 타입 안전한 상태 관리**:
- **액션**이 비즈니스 로직을 처리 (ViewModel 레이어) via `createActionContext`
- **선언적 스토어 패턴**이 타입 안전성으로 상태를 관리 (Model 레이어)
- **컴포넌트**가 UI를 렌더링 (View 레이어)
- **패턴 조합**이 유연한 아키텍처를 허용
- **타입 안전한 통합** 패턴별 훅을 통해

### 스토어 통합 3단계 프로세스
1. **현재 상태 읽기** `store.getValue()`를 사용하여 스토어에서
2. **비즈니스 로직 실행** 페이로드와 현재 상태를 사용하여  
3. **스토어 업데이트** `store.setValue()` 또는 `store.update()` 사용

### 핸들러 등록 모범 사례
최적의 성능과 적절한 정리를 위해 `useActionHandler` + `useEffect` 패턴 사용:
- 재등록을 방지하기 위해 `useCallback`으로 핸들러 감싸기
- 현재 상태를 위해 `stores.getStore()`로 지연 평가 사용
- 등록 해제 함수를 사용하여 정리와 함께 핸들러 등록

## 아키텍처 패턴

- **Action Only 패턴**: 순수 액션 디스패칭을 위한 `createActionContext()`
- **선언적 스토어 패턴**: 타입 안전한 상태 관리를 위한 `createDeclarativeStorePattern()`
- **스토어 통합 패턴**: 핸들러 구현을 위한 3단계 프로세스
- **HOC 패턴**: 자동 컴포넌트 감싸기를 위한 `withProvider()` (Store Pattern)
- **패턴 조합**: 복잡한 애플리케이션을 위한 Action Only + Store Only 패턴 결합
- **Provider 격리**: 패턴별 독립적인 컨텍스트 관리