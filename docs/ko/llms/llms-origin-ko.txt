# Context-Action Framework - Complete Documentation

Generated: 2025-08-14
Type: Origin (Full Documents)
Language: KO

This document contains the complete original content of all Context-Action framework documentation files, organized by priority.

---


# Guide Concepts

**Source**: `guide/concepts.md`  
**Priority**: 100 (critical)  

# 핵심 개념

Context-Action 프레임워크의 기본 개념을 이해하는 것은 효과적인 구현을 위해 필수적입니다. 이 가이드는 핵심 구성 요소와 그들의 관계를 다룹니다.

## 아키텍처 개요

Context-Action 프레임워크는 세 가지 주요 계층을 통해 깔끔한 관심사 분리를 구현합니다:

```mermaid
graph TB
    subgraph "VIEW LAYER"
        A[React 컴포넌트<br/>UI 프레젠테이션]
    end
    
    subgraph "VIEWMODEL LAYER"  
        B[액션 핸들러<br/>비즈니스 로직]
    end
    
    subgraph "MODEL LAYER"
        C[스토어 시스템<br/>상태 관리]
    end
    
    A -->|액션 디스패치| B
    B -->|스토어 업데이트| C
    C -->|구독/리렌더| A
    
    style A fill:#e3f2fd
    style B fill:#fff8e1
    style C fill:#e8f5e8
```

## 핵심 구성 요소

### 1. 도메인별 훅 패턴

프레임워크의 기초는 구조 분해 할당을 통해 도메인별 훅을 생성하는 것입니다:

```typescript
// 도메인 데이터 구조 정의
interface UserData {
  profile: { id: string; name: string; email: string };
  preferences: { theme: 'light' | 'dark'; language: string };
}

// 도메인별 스토어 훅 생성
export const {
  Provider: UserProvider,
  useStore: useUserStore,        // 도메인별 스토어 접근
  useStores: useUserStores,      // 스토어 레지스트리 접근
} = createDeclarativeStores<UserData>('User', {
  profile: { initialValue: { id: '', name: '', email: '' } },
  preferences: { initialValue: { theme: 'light', language: 'en' } }
});

// 도메인별 액션 훅 생성
export const {
  Provider: UserActionProvider,
  useAction: useUserAction,      // 도메인별 액션 디스패처
  useActionRegister: useUserActionRegister
} = createActionContext<UserActions>({ name: 'UserAction' });
```

**장점:**
- 완전한 TypeScript 추론
- 명확한 도메인 경계
- 직관적이고 자동완성 친화적인 API
- 리팩토링 안전성

### 2. 스토어 시스템

스토어는 프로바이더 경계 내에서 싱글톤 동작으로 상태를 관리합니다:

```typescript
function UserProfile() {
  // 도메인별 스토어 가져오기
  const profileStore = useUserStore('profile');
  
  // 변경 사항 구독 (반응형)
  const profile = useStoreValue(profileStore);
  
  // 직접 스토어 조작 (필요시)
  const updateName = (name: string) => {
    profileStore.setValue({ ...profile, name });
  };
  
  return <div>안녕하세요, {profile.name}님!</div>;
}
```

**스토어 패턴:**

1. **싱글톤 동작:** 프로바이더 범위 내에서 동일한 스토어 이름이 동일한 인스턴스 반환
2. **반응형 구독:** 컴포넌트가 변경 사항에 자동으로 리렌더링
3. **타입 안전성:** 도메인별 타입과 완전한 TypeScript 지원

### 3. 액션 파이프라인 시스템

액션은 우선순위 기반 핸들러 시스템을 통해 흐릅니다:

```typescript
// 액션 인터페이스 정의
interface UserActions {
  updateProfile: { data: Partial<UserData['profile']> };
  deleteUser: { userId: string };
  resetUser: void;
}

// 핸들러 등록
function useUserHandlers() {
  const register = useUserActionRegister();
  const registry = useUserRegistry();
  
  const updateProfileHandler = useCallback(async (payload, controller) => {
    // 현재 상태 가져오기 (지연 평가)
    const profileStore = registry.getStore('profile');
    const currentProfile = profileStore.getValue();
    
    // 검증
    if (!payload.data.email?.includes('@')) {
      controller.abort('잘못된 이메일 형식');
      return;
    }
    
    // 비즈니스 로직
    const updatedProfile = { ...currentProfile, ...payload.data };
    profileStore.setValue(updatedProfile);
    
    // 결과 반환
    return { success: true, profile: updatedProfile };
  }, [registry]);
  
  // 정리와 함께 등록
  useEffect(() => {
    if (!register) return;
    const unregister = register('updateProfile', updateProfileHandler, {
      priority: 100,
      blocking: true,
      id: 'profile-updater'
    });
    return unregister; // 중요: 언마운트 시 정리
  }, [register, updateProfileHandler]);
}
```

**핸들러 기능:**

- **우선순위 기반 실행:** 높은 우선순위 핸들러가 먼저 실행
- **블로킹/논블로킹:** 비동기 실행 흐름 제어
- **결과 수집:** 여러 핸들러로부터 결과 수집
- **오류 처리:** 내장된 오류 관리 및 중단 메커니즘

### 4. 프로바이더 구성

중첩된 프로바이더로 도메인 구성:

```typescript
// 도메인별 프로바이더 구성
function UserProvider({ children }: { children: React.ReactNode }) {
  return (
    <UserStoreProvider>
      <UserActionProvider>
        <UserHandlersSetup />
        {children}
      </UserActionProvider>
    </UserStoreProvider>
  );
}

// 핸들러 설정 컴포넌트
function UserHandlersSetup() {
  useUserHandlers(); // 모든 도메인 핸들러 등록
  return null;
}

// 사용법
function App() {
  return (
    <UserProvider>
      <UserProfile />
    </UserProvider>
  );
}
```

## 데이터 흐름 패턴

### 1. 컴포넌트 → 액션 → 스토어 → 컴포넌트

표준 반응형 흐름:

```typescript
function UserEditor() {
  // 스토어 구독
  const profile = useStoreValue(useUserStore('profile'));
  const dispatch = useUserAction();
  
  // 액션 트리거
  const handleSave = () => {
    dispatch('updateProfile', { 
      data: { name: '업데이트된 이름' } 
    });
  };
  
  // 프로필이 변경되면 컴포넌트 리렌더링
  return (
    <form onSubmit={handleSave}>
      <input defaultValue={profile.name} />
      <button type="submit">저장</button>
    </form>
  );
}
```

### 2. 핸들러 접근 패턴

스토어 접근을 위한 세 가지 유효한 패턴:

```typescript
// 패턴 1: 컴포넌트 접근 (반응형)
const store = useUserStore('profile');
const profile = useStoreValue(store);

// 패턴 2: 핸들러 접근 (지연 평가)
const handler = async (payload, controller) => {
  const profileStore = registry.getStore('profile');
  const currentProfile = profileStore.getValue(); // 최신 값
};

// 패턴 3: 컨텍스트 스토어 패턴 (격리됨)
const store = UserStores.useStore('profile', initialValue);
```

### 3. 크로스 도메인 커뮤니케이션

도메인 간 상호작용이 필요한 경우:

```typescript
function useUserCartIntegration() {
  // 여러 도메인 접근
  const userProfile = useUserStore('profile');
  const cartItems = useCartStore('items');
  const userAction = useUserAction();
  const cartAction = useCartAction();
  
  const profile = useStoreValue(userProfile);
  const items = useStoreValue(cartItems);
  
  const processCheckout = useCallback(async () => {
    // 크로스 도메인 검증
    if (!profile.id) {
      await userAction('requireLogin', {});
      return;
    }
    
    // 크로스 도메인 액션
    await cartAction('processCheckout', {
      userId: profile.id,
      items: items
    });
  }, [profile.id, items, userAction, cartAction]);
  
  return { processCheckout };
}
```

## 핸들러 등록 패턴

### 최선의 패턴

항상 `useActionRegister` + `useEffect`를 정리와 함께 사용:

```typescript
function useUserHandlers() {
  const register = useUserActionRegister();
  const registry = useUserRegistry();
  
  // useCallback으로 핸들러 래핑
  const handler = useCallback(async (payload, controller) => {
    // 여기에 핸들러 로직
  }, [registry]);
  
  // 정리와 함께 등록
  useEffect(() => {
    if (!register) return;
    
    const unregister = register('actionName', handler, {
      priority: 100,
      blocking: true,
      id: 'unique-handler-id'
    });
    
    return unregister; // 중요: 언마운트 시 정리
  }, [register, handler]);
}
```

### 핸들러 구성 옵션

```typescript
interface HandlerConfig {
  priority?: number;        // 실행 순서 (높을수록 먼저)
  blocking?: boolean;       // 비동기 완료 대기
  tags?: string[];         // 필터링용
  id?: string;            // 명시적 핸들러 ID
  category?: string;      // 핸들러 카테고리
  returnType?: 'value';   // 반환값 수집 활성화
}
```

## 컨텍스트 경계 & 도메인 격리

### 단일 도메인 아키텍처

```typescript
// 도메인별 스토어
const UserStores = createContextStorePattern('User');

// 격리된 프로바이더 경계
<UserStores.Provider registryId="user-domain">
  <UserComponents />
</UserStores.Provider>

// 도메인별 사용법
const userStore = UserStores.useStore('profile', initialData);
```

### 다중 도메인 아키텍처

```typescript
function App() {
  return (
    <UserProvider>        {/* 사용자 도메인 경계 */}
      <CartProvider>      {/* 장바구니 도메인 경계 */}
        <OrderProvider>   {/* 주문 도메인 경계 */}
          <ApplicationComponents />
        </OrderProvider>
      </CartProvider>
    </UserProvider>
  );
}
```

## 메모리 관리

### 스토어 생명주기

- **생성:** 프로바이더 내에서 처음 접근될 때 스토어가 생성됨
- **지속성:** 프로바이더의 생명주기 동안 스토어가 지속됨
- **정리:** 프로바이더가 언마운트되면 스토어가 정리됨

### 핸들러 정리

```typescript
// ❌ 메모리 누수 - 정리 없음
useEffect(() => {
  register('action', handler);
}, []);

// ✅ 적절한 정리
useEffect(() => {
  if (!register) return;
  const unregister = register('action', handler);
  return unregister; // 언마운트 시 정리
}, [register, handler]);
```

## 타입 안전성 기능

### 자동 타입 추론

```typescript
// 타입이 자동으로 추론됨
const store = useUserStore('profile'); // Store<UserProfile>
const profile = useStoreValue(store);  // UserProfile
const dispatch = useUserAction();      // Dispatch<UserActions>
```

### 컴파일 시 안전성

```typescript
// 잘못된 액션 이름 - 컴파일 에러
dispatch('invalidAction', {}); 
// TS 에러: '"invalidAction"' 형식의 인수를 할당할 수 없습니다

// 잘못된 페이로드 - 컴파일 에러  
dispatch('updateProfile', { invalid: 'data' });
// TS 에러: 객체 리터럴은 알려진 속성만 지정할 수 있습니다
```

---

## 요약

Context-Action 프레임워크의 핵심 개념들이 함께 작동하여 다음을 제공합니다:

- 컨텍스트 경계를 통한 **도메인 격리**
- 자동 추론을 통한 **타입 안전성**
- 최소한의 리렌더링을 통한 **반응형 상태 관리**
- 중앙화된 비즈니스 로직을 통한 **선언적 액션**
- 적절한 정리 패턴을 통한 **메모리 안전성**

이러한 개념을 이해하면 명확한 아키텍처 경계를 가진 확장 가능하고 유지 관리 가능한 애플리케이션을 구축할 수 있습니다.

---

::: tip 다음 단계
구현할 준비가 되셨나요? 완전한 패턴과 예제를 위해 [전체 구현 가이드](./full)를 확인하거나, 실습 코딩을 위해 [빠른 시작](./quick-start)으로 이동하세요.
:::

---


# Guide Overview

**Source**: `guide/overview.md`  
**Priority**: 100 (critical)  

# Context Action 프레임워크 개요

Context-Action 프레임워크는 완전한 도메인 격리를 위한 **컨텍스트 스토어 패턴**과 결합된 MVVM에서 영감을 받은 패턴을 통해 깔끔한 관심사 분리를 구현합니다.

## 아키텍처 개요

```mermaid
graph LR
    A[컴포넌트] -->|디스패치| B[액션 파이프라인]
    B -->|핸들러| C[스토어]
    C -->|구독| A
    
    style A fill:#e3f2fd
    style B fill:#fff8e1
    style C fill:#e8f5e8
```

## 주요 장점

1. **도메인 격리** - 각 컨텍스트가 완전한 독립성을 유지
2. **타입 안전성** - 도메인별 훅과 함께 완전한 TypeScript 지원
3. **성능** - 영향을 받는 컴포넌트만 리렌더링
4. **확장성** - 기존 도메인에 영향을 주지 않고 새 도메인 추가 용이
5. **팀 협업** - 다른 팀이 다른 도메인에서 작업 가능

## 빠른 탐색

- [완전한 구현 가이드](./full) - 모든 패턴이 포함된 완전한 구현 가이드
- [빠른 시작](./quick-start) - 빠르게 시작하기
- [핵심 개념](./concepts) - 기본 개념 이해하기
- [설정 & 사용법](./setup-usage) - 상세한 설정 방법

## 프레임워크 철학

Context-Action 프레임워크는 다음 핵심 원칙을 따릅니다:

- **액션**이 비즈니스 로직을 처리 (ViewModel 계층)
- **컨텍스트 스토어 패턴**이 도메인 격리와 함께 상태를 관리 (Model 계층)
- **컴포넌트**가 UI를 렌더링 (View 계층)
- **컨텍스트 경계**가 기능 도메인을 격리
- 도메인별 훅을 통한 **타입 안전 통합**

---

::: tip 다음 단계
포괄적인 이해를 위해 [완전한 구현 가이드](./full)부터 시작하거나, 바로 코딩을 시작하고 싶다면 [빠른 시작](./quick-start)으로 이동하세요.
:::

---


# Guide Quick Start

**Source**: `guide/quick-start.md`  
**Priority**: 95 (critical)  

# 빠른 시작

Context-Action 프레임워크를 사용하여 빠르게 시작해보세요. 이 가이드는 5분 안에 첫 번째 애플리케이션을 실행할 수 있도록 도와줍니다.

## 설치

```bash
npm install @context-action/core @context-action/react
# 또는
yarn add @context-action/core @context-action/react
```

## 1단계: 도메인 정의

먼저 애플리케이션 도메인을 정의합니다:

```typescript
// stores/user.store.ts
import { createDeclarativeStores, createActionContext } from '@context-action/react';

// 데이터 구조 정의
export interface UserData {
  profile: {
    id: string;
    name: string;
    email: string;
  };
  preferences: {
    theme: 'light' | 'dark';
    language: string;
  };
}

// 액션 정의
export interface UserActions {
  login: { email: string; password: string };
  updateProfile: { data: Partial<UserData['profile']> };
  logout: void;
}

// 스토어 훅 생성
export const {
  Provider: UserStoreProvider,
  useStore: useUserStore,
  useStores: useUserStores
} = createDeclarativeStores<UserData>('User', {
  profile: {
    initialValue: { id: '', name: '', email: '' }
  },
  preferences: {
    initialValue: { theme: 'light', language: 'ko' }
  }
});

// 액션 훅 생성
export const {
  Provider: UserActionProvider,
  useAction: useUserAction,
  useActionHandler: useUserActionHandler
} = createActionContext<UserActions>({ name: 'UserAction' });
```

## 2단계: 비즈니스 로직 (핸들러)

```typescript
// hooks/useUserHandlers.ts
import { useCallback, useEffect } from 'react';
import { useUserActionHandler, useUserStores } from '../stores/user.store';

export function useUserHandlers() {
  const addHandler = useUserActionHandler();
  const stores = useUserStores();
  
  // 로그인 핸들러
  const loginHandler = useCallback(async (payload, controller) => {
    const profileStore = stores.getStore('profile');
    
    try {
      // 간단한 로그인 로직 (실제 환경에서는 API 호출)
      if (payload.email === 'test@example.com' && payload.password === 'password') {
        profileStore.setValue({
          id: '1',
          name: '테스트 사용자',
          email: payload.email
        });
        return { success: true };
      } else {
        controller.abort('잘못된 자격증명');
        return { success: false };
      }
    } catch (error) {
      controller.abort('로그인 실패', error);
      return { success: false };
    }
  }, [stores]);
  
  // 프로필 업데이트 핸들러
  const updateProfileHandler = useCallback(async (payload, controller) => {
    const profileStore = stores.getStore('profile');
    const currentProfile = profileStore.getValue();
    
    // 업데이트
    const updatedProfile = { ...currentProfile, ...payload.data };
    profileStore.setValue(updatedProfile);
    
    return { success: true, profile: updatedProfile };
  }, [stores]);
  
  // 로그아웃 핸들러
  const logoutHandler = useCallback(async (payload, controller) => {
    const profileStore = stores.getStore('profile');
    profileStore.setValue({ id: '', name: '', email: '' });
    return { success: true };
  }, [stores]);
  
  // 핸들러 등록
  useEffect(() => {
    if (!addHandler) return;
    
    const unregisterLogin = addHandler('login', loginHandler, {
      priority: 100,
      blocking: true,
      id: 'user-login'
    });
    
    const unregisterUpdate = addHandler('updateProfile', updateProfileHandler, {
      priority: 100,
      blocking: true,
      id: 'profile-update'
    });
    
    const unregisterLogout = addHandler('logout', logoutHandler, {
      priority: 100,
      blocking: true,
      id: 'user-logout'
    });
    
    return () => {
      unregisterLogin();
      unregisterUpdate();
      unregisterLogout();
    };
  }, [addHandler, loginHandler, updateProfileHandler, logoutHandler]);
}
```

## 3단계: UI 컴포넌트

```typescript
// components/UserProfile.tsx
import { useState, useCallback } from 'react';
import { useStoreValue } from '@context-action/react';
import { useUserStore, useUserAction } from '../stores/user.store';

export function UserProfile() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  const dispatch = useUserAction();
  
  const [loginForm, setLoginForm] = useState({ email: '', password: '' });
  const [isEditing, setIsEditing] = useState(false);
  const [editForm, setEditForm] = useState({ name: profile.name });
  
  // 로그인 처리
  const handleLogin = useCallback(async () => {
    await dispatch('login', loginForm);
  }, [dispatch, loginForm]);
  
  // 프로필 업데이트 처리
  const handleUpdateProfile = useCallback(async () => {
    await dispatch('updateProfile', { data: { name: editForm.name } });
    setIsEditing(false);
  }, [dispatch, editForm.name]);
  
  // 로그아웃 처리
  const handleLogout = useCallback(() => {
    dispatch('logout');
  }, [dispatch]);
  
  // 로그인되지 않은 경우
  if (!profile.id) {
    return (
      <div>
        <h2>로그인</h2>
        <div>
          <input
            type="email"
            placeholder="이메일"
            value={loginForm.email}
            onChange={(e) => setLoginForm(prev => ({ ...prev, email: e.target.value }))}
          />
        </div>
        <div>
          <input
            type="password"
            placeholder="비밀번호"
            value={loginForm.password}
            onChange={(e) => setLoginForm(prev => ({ ...prev, password: e.target.value }))}
          />
        </div>
        <button onClick={handleLogin}>로그인</button>
        <p><small>테스트: test@example.com / password</small></p>
      </div>
    );
  }
  
  // 로그인된 경우
  return (
    <div>
      <h2>사용자 프로필</h2>
      <div>
        <p><strong>이메일:</strong> {profile.email}</p>
        <div>
          <strong>이름:</strong>
          {isEditing ? (
            <span>
              <input
                value={editForm.name}
                onChange={(e) => setEditForm({ name: e.target.value })}
              />
              <button onClick={handleUpdateProfile}>저장</button>
              <button onClick={() => setIsEditing(false)}>취소</button>
            </span>
          ) : (
            <span>
              {profile.name || '이름 없음'}
              <button onClick={() => {
                setEditForm({ name: profile.name });
                setIsEditing(true);
              }}>
                편집
              </button>
            </span>
          )}
        </div>
        <button onClick={handleLogout}>로그아웃</button>
      </div>
    </div>
  );
}
```

## 4단계: 프로바이더 설정

```typescript
// providers/UserProvider.tsx
import React from 'react';
import { UserStoreProvider, UserActionProvider } from '../stores/user.store';
import { useUserHandlers } from '../hooks/useUserHandlers';

// 핸들러 설정 컴포넌트
function UserHandlersSetup() {
  useUserHandlers();
  return null;
}

// 통합 사용자 프로바이더
export function UserProvider({ children }: { children: React.ReactNode }) {
  return (
    <UserStoreProvider>
      <UserActionProvider>
        <UserHandlersSetup />
        {children}
      </UserActionProvider>
    </UserStoreProvider>
  );
}
```

## 5단계: 앱 설정

```typescript
// App.tsx
import React from 'react';
import { UserProvider } from './providers/UserProvider';
import { UserProfile } from './components/UserProfile';

function App() {
  return (
    <UserProvider>
      <div style={{ padding: '20px' }}>
        <h1>Context-Action 빠른 시작</h1>
        <UserProfile />
      </div>
    </UserProvider>
  );
}

export default App;
```

## 결과

이제 다음 기능을 가진 완전한 애플리케이션이 있습니다:

- ✅ **타입 안전한** 상태 관리
- ✅ **반응형** UI 업데이트
- ✅ **중앙화된** 비즈니스 로직
- ✅ **도메인 격리**
- ✅ **자동 정리** (메모리 누수 없음)

## 애플리케이션 실행

```bash
npm run dev
# 또는
yarn dev
```

브라우저에서 다음을 볼 수 있습니다:
1. 로그인 폼
2. `test@example.com` / `password`로 로그인
3. 프로필 편집 기능
4. 로그아웃 기능

## 주요 개념 요약

### 1. 도메인별 훅
```typescript
const store = useUserStore('profile');  // 타입 안전한 스토어 접근
const dispatch = useUserAction();       // 타입 안전한 액션 디스패치
```

### 2. 반응형 구독
```typescript
const profile = useStoreValue(profileStore);  // 자동 리렌더링
```

### 3. 중앙화된 비즈니스 로직
```typescript
// 컴포넌트에서
dispatch('login', { email, password });

// 핸들러에서 처리됨
const loginHandler = async (payload, controller) => { /* 로직 */ };
```

### 4. 자동 정리
```typescript
useEffect(() => {
  const unregister = addHandler('action', handler);
  return unregister;  // 자동 정리
}, []);
```

---

## 다음 단계

축하합니다! 첫 번째 Context-Action 애플리케이션을 성공적으로 만들었습니다.

### 더 학습하기

- [핵심 개념](./concepts) - 깊이 있는 이해
- [설정 & 사용법](./setup-usage) - 고급 설정 옵션
- [최선의 실습](./best-practices) - 프로덕션 환경 팁
- [성능 최적화](./performance) - 성능 향상 기법

### 확장하기

이제 다음을 추가해볼 수 있습니다:
- 새로운 도메인 (Cart, Order 등)
- 더 복잡한 비즈니스 로직
- API 통합
- 테스트 작성
- 오류 처리 개선

Happy coding! 🚀

---


# 액션 핸들러

**Source**: `guide/action-handlers.md`  
**Priority**: 80 (essential)  

# 액션 핸들러

액션 핸들러는 Context-Action 프레임워크의 비즈니스 로직 계층으로, 선언적 액션을 실제 상태 변경과 부수 효과로 변환합니다. 이 가이드는 효과적인 핸들러 작성과 관리 패턴을 다룹니다.

## 핸들러 기본 구조

### 핸들러 시그니처

모든 액션 핸들러는 표준화된 시그니처를 따릅니다:

```typescript
type ActionHandler<TPayload> = (
  payload: TPayload,
  controller: ActionController
) => Promise<any> | any;
```

### 기본 핸들러 패턴

```typescript
function useUserHandlers() {
  const register = useUserActionRegister();
  const registry = useUserStores();
  
  // 핸들러 구현
  const updateProfileHandler = useCallback(async (
    payload: UserActions['updateProfile'],
    controller: ActionController
  ) => {
    // 1. 현재 상태 획득 (지연 평가)
    const profileStore = registry.getStore('profile');
    const currentProfile = profileStore.getValue();
    
    // 2. 입력 검증
    if (!payload.data.email?.includes('@')) {
      controller.abort('잘못된 이메일 형식');
      return { success: false, error: 'INVALID_EMAIL' };
    }
    
    // 3. 비즈니스 로직 실행
    try {
      const updatedProfile = {
        ...currentProfile,
        ...payload.data,
        lastModified: Date.now()
      };
      
      // 4. 상태 업데이트
      profileStore.setValue(updatedProfile);
      
      // 5. 결과 반환
      return { 
        success: true, 
        profile: updatedProfile,
        timestamp: Date.now()
      };
      
    } catch (error) {
      // 6. 오류 처리
      controller.abort('프로필 업데이트 실패', error);
      return { success: false, error: 'UPDATE_FAILED' };
    }
  }, [registry]);
  
  // 7. 핸들러 등록
  useEffect(() => {
    if (!register) return;
    
    const unregister = register('updateProfile', updateProfileHandler, {
      priority: 100,
      blocking: true,
      id: 'profile-updater'
    });
    
    return unregister; // 정리
  }, [register, updateProfileHandler]);
}
```

## 핸들러 구성 옵션

### 우선순위 시스템

핸들러는 우선순위에 따라 실행됩니다 (높은 숫자가 먼저):

```typescript
// 검증 핸들러 (가장 먼저 실행)
register('updateProfile', validationHandler, {
  priority: 200,
  blocking: true,
  id: 'profile-validator'
});

// 메인 비즈니스 로직 (두 번째)
register('updateProfile', updateHandler, {
  priority: 100,
  blocking: true,
  id: 'profile-updater'
});

// 로깅/감사 (마지막)
register('updateProfile', loggingHandler, {
  priority: 50,
  blocking: false,
  id: 'profile-logger'
});
```

### 블로킹 vs 논블로킹

```typescript
// 블로킹: 핸들러 완료를 기다림
register('criticalAction', criticalHandler, {
  priority: 100,
  blocking: true  // 다음 핸들러 실행 전 대기
});

// 논블로킹: 즉시 다음 핸들러 실행
register('logAction', loggingHandler, {
  priority: 50,
  blocking: false  // 병렬 실행
});
```

### 핸들러 메타데이터

```typescript
register('updateProfile', handler, {
  priority: 100,
  blocking: true,
  id: 'profile-updater',           // 고유 식별자
  tags: ['profile', 'user', 'api'], // 분류 태그
  category: 'business-logic',       // 카테고리
  description: '사용자 프로필 업데이트', // 설명
  version: '1.0.0'                 // 버전
});
```

## 고급 핸들러 패턴

### 1. 조건부 실행 핸들러

```typescript
const conditionalHandler = useCallback(async (payload, controller) => {
  const sessionStore = registry.getStore('session');
  const session = sessionStore.getValue();
  
  // 조건 체크
  if (!session.isLoggedIn) {
    controller.abort('인증이 필요합니다');
    return { success: false, error: 'AUTHENTICATION_REQUIRED' };
  }
  
  if (session.role !== 'admin' && payload.adminAction) {
    controller.abort('권한이 없습니다');
    return { success: false, error: 'INSUFFICIENT_PERMISSIONS' };
  }
  
  // 조건을 만족하는 경우에만 실행
  return await executeBusinessLogic(payload);
}, [registry]);
```

### 2. 낙관적 업데이트 핸들러

```typescript
const optimisticUpdateHandler = useCallback(async (payload, controller) => {
  const profileStore = registry.getStore('profile');
  const currentProfile = profileStore.getValue();
  
  // 1. 즉시 낙관적 업데이트
  const optimisticProfile = { ...currentProfile, ...payload.data };
  profileStore.setValue(optimisticProfile);
  
  try {
    // 2. 서버 API 호출
    const response = await updateProfileOnServer(payload.data);
    
    // 3. 서버 응답으로 최종 업데이트
    profileStore.setValue(response.profile);
    
    return { success: true, profile: response.profile };
    
  } catch (error) {
    // 4. 실패 시 롤백
    profileStore.setValue(currentProfile);
    controller.abort('서버 업데이트 실패', error);
    return { success: false, error: 'SERVER_ERROR' };
  }
}, [registry]);
```

### 3. 배치 처리 핸들러

```typescript
const batchUpdateHandler = useCallback(async (payload, controller) => {
  const { updates } = payload;
  const results = [];
  const errors = [];
  
  // 배치 처리
  for (const update of updates) {
    try {
      const result = await processSingleUpdate(update);
      results.push(result);
    } catch (error) {
      errors.push({ update, error });
    }
  }
  
  // 부분 성공 처리
  if (errors.length > 0) {
    controller.abort('일부 업데이트 실패', { errors });
    return { 
      success: false, 
      results, 
      errors,
      partialSuccess: results.length > 0
    };
  }
  
  return { success: true, results, processed: updates.length };
}, []);
```

### 4. 디바운스 핸들러

```typescript
function useDebouncedHandler(delay: number = 500) {
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  const registry = useUserStores();
  
  const debouncedHandler = useCallback(async (payload, controller) => {
    // 이전 타이머 취소
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    
    return new Promise((resolve) => {
      timeoutRef.current = setTimeout(async () => {
        try {
          const result = await performUpdate(payload);
          resolve({ success: true, result });
        } catch (error) {
          controller.abort('업데이트 실패', error);
          resolve({ success: false, error });
        }
      }, delay);
    });
  }, [delay]);
  
  // 컴포넌트 언마운트 시 타이머 정리
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);
  
  return debouncedHandler;
}
```

### 5. 리트라이 메커니즘

```typescript
const retryHandler = useCallback(async (payload, controller) => {
  const maxRetries = 3;
  let attempt = 0;
  
  while (attempt < maxRetries) {
    try {
      const result = await unstableOperation(payload);
      return { success: true, result, attempts: attempt + 1 };
      
    } catch (error) {
      attempt++;
      
      if (attempt >= maxRetries) {
        controller.abort('최대 재시도 횟수 초과', { 
          error, 
          attempts: attempt 
        });
        return { success: false, error: 'MAX_RETRIES_EXCEEDED' };
      }
      
      // 지수 백오프
      const delay = Math.pow(2, attempt) * 1000;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}, []);
```

## 오류 처리 패턴

### 1. 계층적 오류 처리

```typescript
const robustHandler = useCallback(async (payload, controller) => {
  try {
    // Level 1: 입력 검증
    validatePayload(payload);
    
    // Level 2: 비즈니스 규칙 검증
    await validateBusinessRules(payload);
    
    // Level 3: 외부 의존성
    const externalData = await fetchExternalData();
    
    // Level 4: 상태 업데이트
    updateStores(payload, externalData);
    
    return { success: true };
    
  } catch (error) {
    // 오류 타입별 처리
    if (error instanceof ValidationError) {
      controller.abort('검증 실패', { 
        type: 'VALIDATION_ERROR',
        details: error.details 
      });
      return { success: false, error: 'VALIDATION_FAILED' };
    }
    
    if (error instanceof NetworkError) {
      controller.abort('네트워크 오류', { 
        type: 'NETWORK_ERROR',
        retryable: true 
      });
      return { success: false, error: 'NETWORK_FAILED', retryable: true };
    }
    
    // 예상치 못한 오류
    controller.abort('예기치 않은 오류', { 
      type: 'UNKNOWN_ERROR',
      originalError: error.message 
    });
    return { success: false, error: 'UNKNOWN_ERROR' };
  }
}, []);
```

### 2. 복구 가능한 오류 처리

```typescript
const recoverableHandler = useCallback(async (payload, controller) => {
  const profileStore = registry.getStore('profile');
  const backup = profileStore.getValue();
  
  try {
    // 위험한 작업 수행
    const result = await riskyOperation(payload);
    profileStore.setValue(result.profile);
    
    return { success: true, result };
    
  } catch (error) {
    // 자동 복구 시도
    try {
      await automaticRecovery(backup);
      controller.abort('자동 복구됨', { recovered: true });
      return { success: false, recovered: true };
      
    } catch (recoveryError) {
      // 복구 실패 - 원본 상태로 롤백
      profileStore.setValue(backup);
      controller.abort('복구 실패', { 
        originalError: error,
        recoveryError 
      });
      return { success: false, rollback: true };
    }
  }
}, [registry]);
```

## 결과 수집 패턴

### 1. 단일 결과 수집

```typescript
function UserComponent() {
  const dispatchWithResult = useUserActionWithResult();
  
  const handleUpdate = useCallback(async () => {
    const result = await dispatchWithResult('updateProfile', 
      { data: { name: '새 이름' } },
      { result: { collect: true, strategy: 'first' } }
    );
    
    if (result.success) {
      console.log('첫 번째 핸들러 결과:', result.results[0]);
    } else {
      console.error('오류:', result.errors);
    }
  }, [dispatchWithResult]);
}
```

### 2. 모든 결과 수집

```typescript
const handleComplexAction = useCallback(async () => {
  const result = await dispatchWithResult('complexAction', payload, {
    result: { collect: true, strategy: 'all' }
  });
  
  if (result.success) {
    // 모든 핸들러 결과 처리
    result.results.forEach((handlerResult, index) => {
      console.log(`핸들러 ${index + 1} 결과:`, handlerResult);
    });
  }
}, [dispatchWithResult]);
```

### 3. 조건부 결과 수집

```typescript
const handleConditionalResult = useCallback(async () => {
  const result = await dispatchWithResult('action', payload, {
    result: { 
      collect: true, 
      strategy: 'all',
      filter: (result) => result && result.important === true
    }
  });
  
  // 중요한 결과만 수집됨
  console.log('중요한 결과들:', result.results);
}, [dispatchWithResult]);
```

## 핸들러 조합 패턴

### 1. 파이프라인 패턴

```typescript
// 단계별 처리 핸들러
const validationHandler = useCallback(async (payload, controller) => {
  // 검증만 수행
  const errors = validatePayload(payload);
  if (errors.length > 0) {
    controller.abort('검증 실패', { errors });
    return { valid: false, errors };
  }
  return { valid: true };
}, []);

const transformHandler = useCallback(async (payload, controller) => {
  // 데이터 변환
  const transformed = transformData(payload);
  return { transformed };
}, []);

const persistHandler = useCallback(async (payload, controller) => {
  // 영속성 처리
  await saveToStorage(payload);
  return { saved: true };
}, []);

// 등록 시 우선순위로 파이프라인 구성
useEffect(() => {
  if (!register) return;
  
  const unregisterValidation = register('processData', validationHandler, {
    priority: 300, // 첫 번째
    blocking: true
  });
  
  const unregisterTransform = register('processData', transformHandler, {
    priority: 200, // 두 번째
    blocking: true
  });
  
  const unregisterPersist = register('processData', persistHandler, {
    priority: 100, // 세 번째
    blocking: true
  });
  
  return () => {
    unregisterValidation();
    unregisterTransform();
    unregisterPersist();
  };
}, [register, validationHandler, transformHandler, persistHandler]);
```

### 2. 플러그인 패턴

```typescript
// 플러그인 기반 핸들러 시스템
function usePluginSystem() {
  const register = useUserActionRegister();
  
  const coreHandler = useCallback(async (payload, controller) => {
    // 핵심 비즈니스 로직
    const coreResult = await processCoreLogic(payload);
    return { ...coreResult, source: 'core' };
  }, []);
  
  const auditPlugin = useCallback(async (payload, controller) => {
    // 감사 로그
    await logAction('userAction', payload);
    return { audited: true, source: 'audit' };
  }, []);
  
  const metricsPlugin = useCallback(async (payload, controller) => {
    // 메트릭 수집
    metrics.increment('user.actions.count');
    return { metricsRecorded: true, source: 'metrics' };
  }, []);
  
  useEffect(() => {
    if (!register) return;
    
    const unregisterCore = register('userAction', coreHandler, {
      priority: 100,
      blocking: true,
      id: 'core-handler'
    });
    
    const unregisterAudit = register('userAction', auditPlugin, {
      priority: 50,
      blocking: false,
      id: 'audit-plugin'
    });
    
    const unregisterMetrics = register('userAction', metricsPlugin, {
      priority: 50,
      blocking: false,
      id: 'metrics-plugin'
    });
    
    return () => {
      unregisterCore();
      unregisterAudit();
      unregisterMetrics();
    };
  }, [register, coreHandler, auditPlugin, metricsPlugin]);
}
```

## 테스팅 패턴

### 1. 핸들러 단위 테스트

```typescript
// __tests__/handlers/userHandlers.test.ts
import { renderHook } from '@testing-library/react-hooks';
import { createMockController, createMockRegistry } from '@/test-utils';

describe('User Handlers', () => {
  let mockRegistry;
  let mockController;
  
  beforeEach(() => {
    mockRegistry = createMockRegistry();
    mockController = createMockController();
  });
  
  it('프로필 업데이트 성공', async () => {
    // Arrange
    const initialProfile = { id: '1', name: 'Old Name', email: 'old@example.com' };
    mockRegistry.getStore('profile').getValue.mockReturnValue(initialProfile);
    
    // Act
    const result = await updateProfileHandler(
      { data: { name: 'New Name' } },
      mockController
    );
    
    // Assert
    expect(result.success).toBe(true);
    expect(result.profile.name).toBe('New Name');
    expect(mockRegistry.getStore('profile').setValue).toHaveBeenCalledWith({
      ...initialProfile,
      name: 'New Name',
      lastModified: expect.any(Number)
    });
  });
  
  it('잘못된 이메일로 업데이트 실패', async () => {
    // Arrange
    const invalidPayload = { data: { email: 'invalid-email' } };
    
    // Act
    const result = await updateProfileHandler(invalidPayload, mockController);
    
    // Assert
    expect(result.success).toBe(false);
    expect(result.error).toBe('INVALID_EMAIL');
    expect(mockController.abort).toHaveBeenCalledWith('잘못된 이메일 형식');
  });
});
```

### 2. 통합 테스트

```typescript
// __tests__/integration/userFlow.test.tsx
import { render, fireEvent, waitFor } from '@testing-library/react';
import { UserProvider } from '@/providers/UserProvider';
import { UserProfile } from '@/components/UserProfile';

describe('User Flow Integration', () => {
  it('프로필 업데이트 전체 흐름', async () => {
    // Arrange
    const { getByTestId } = render(
      <UserProvider>
        <UserProfile />
      </UserProvider>
    );
    
    // Act
    fireEvent.change(getByTestId('name-input'), {
      target: { value: '새 이름' }
    });
    fireEvent.click(getByTestId('save-button'));
    
    // Assert
    await waitFor(() => {
      expect(getByTestId('name-display')).toHaveTextContent('새 이름');
    });
  });
});
```

## 모범 사례

### 1. 핸들러 설계 원칙

```typescript
// ✅ 좋음: 단일 책임 원칙
const updateProfileHandler = useCallback(async (payload, controller) => {
  // 프로필 업데이트만 담당
  const profileStore = registry.getStore('profile');
  // ...
}, [registry]);

const notifyUsersHandler = useCallback(async (payload, controller) => {
  // 알림 전송만 담당
  await sendNotification(payload.userId, 'profile-updated');
}, []);

// ❌ 피하기: 여러 책임
const monolithicHandler = useCallback(async (payload, controller) => {
  // 프로필 업데이트 + 알림 + 로깅 + 메트릭 등등...
  // 하나의 핸들러에 너무 많은 책임
}, []);
```

### 2. 오류 처리 일관성

```typescript
// 표준 오류 응답 형식 정의
interface StandardError {
  success: false;
  error: string;
  code?: string;
  details?: any;
  retryable?: boolean;
}

interface StandardSuccess<T = any> {
  success: true;
  data?: T;
  timestamp?: number;
}

type HandlerResult<T = any> = StandardSuccess<T> | StandardError;
```

### 3. 핸들러 문서화

```typescript
/**
 * 사용자 프로필 업데이트 핸들러
 * 
 * @description 사용자 프로필 정보를 검증하고 업데이트합니다.
 * @priority 100 (메인 비즈니스 로직)
 * @blocking true (완료 후 다음 핸들러 실행)
 * 
 * @param payload.data - 업데이트할 프로필 필드들
 * @returns {HandlerResult} 성공 시 업데이트된 프로필, 실패 시 오류 정보
 * 
 * @throws 'INVALID_EMAIL' - 이메일 형식이 잘못된 경우
 * @throws 'UPDATE_FAILED' - 데이터 업데이트 실패
 * 
 * @example
 * ```typescript
 * dispatch('updateProfile', { data: { name: '새 이름' } });
 * ```
 */
const updateProfileHandler = useCallback(async (payload, controller) => {
  // 구현...
}, [registry]);
```

---

## 요약

액션 핸들러는 Context-Action 프레임워크의 핵심 비즈니스 로직 계층입니다:

- **표준화된 시그니처**로 일관된 패턴 구현
- **우선순위 기반 실행**으로 복잡한 워크플로우 지원
- **강력한 오류 처리**로 안정적인 애플리케이션 구축
- **결과 수집**으로 핸들러 간 통신 지원
- **테스트 친화적**으로 품질 보장

올바른 핸들러 패턴을 따르면 유지보수 가능하고 확장 가능한 비즈니스 로직을 구현할 수 있습니다.

---

::: tip 다음 단계
- [React 통합](./react-integration) - React 컴포넌트와의 통합 패턴
- [프로바이더 구성](./provider-composition) - 핸들러 설정과 도메인 경계
- [성능 최적화](./performance) - 핸들러 성능 최적화 기법
:::

---


# Guide Best Practices

**Source**: `guide/best-practices.md`  
**Priority**: 80 (essential)  

# 개발 모범 사례

Context-Action 프레임워크로 유지보수 가능하고 확장 가능한 애플리케이션을 구축하기 위한 필수 모범 사례입니다. 코드 품질, 성능, 팀 생산성을 보장하기 위해 이러한 가이드라인을 따르세요.

## 핸들러 등록 모범 사례

### 1. 항상 `useActionRegister` + `useEffect` 패턴 사용

```typescript
// ✅ 올바름: 정리와 함께 적절한 등록
function useUserHandlers() {
  const register = useUserActionRegister();
  const registry = useUserRegistry();
  
  const handler = useCallback(async (payload, controller) => {
    // 핸들러 로직
  }, [registry]);
  
  useEffect(() => {
    if (!register) return;
    const unregister = register('action', handler, {
      priority: 100,
      blocking: true
    });
    return unregister; // 중요: 언마운트 시 정리
  }, [register, handler]);
}

// ❌ 잘못됨: 정리 없음
function useUserHandlers() {
  const register = useUserActionRegister();
  
  useEffect(() => {
    register('action', handler); // 메모리 누수!
  }, []);
}
```

### 2. 순차 비동기 핸들러에는 `blocking: true` 사용

```typescript
// ✅ 올바름: 순차 실행
register('asyncAction', asyncHandler, { 
  priority: 100, 
  blocking: true // 완료 대기
});

// ❌ 잘못됨: 핸들러들이 동시에 실행됨
register('asyncAction', asyncHandler, { 
  priority: 100 
  // blocking: true 누락
});
```

### 3. 디버깅과 중요 핸들러에 명시적 ID 고려

```typescript
// ✅ 좋음: 디버깅을 위한 명시적 ID
register('updateProfile', handler, {
  priority: 100,
  blocking: true,
  id: 'profile-updater-main' // 디버깅에 도움
});

// ✅ 역시 좋음: 간단한 경우 자동 생성 ID
register('updateProfile', handler, {
  priority: 100,
  blocking: true
  // 프레임워크가 자동으로 ID 생성
});
```

### 4. 재등록 방지를 위해 `useCallback`으로 핸들러 래핑

```typescript
// ✅ 올바름: 안정된 핸들러 참조
const handler = useCallback(async (payload, controller) => {
  // 핸들러 로직
}, [registry]); // 안정된 의존성만

// ❌ 잘못됨: 매 렌더링마다 핸들러 재생성
const handler = async (payload, controller) => {
  // 매 렌더링마다 새 함수 생성
};
```

## 스토어 접근 모범 사례

### 5. 컴포넌트에서는 도메인별 훅 사용

```typescript
// ✅ 올바름: 도메인별 훅
function UserProfile() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  const dispatch = useUserAction();
  
  return <div>{profile.name}</div>;
}

// ❌ 잘못됨: 제네릭 훅 (타입 안전성 없음)
function UserProfile() {
  const store = useStore('user-profile'); // 타입 정보 없음
  const dispatch = useDispatch(); // 액션 안전성 없음
}
```

### 6. 핸들러에서는 지연 평가를 위해 `registry.getStore()` 사용

```typescript
// ✅ 올바름: 지연 평가 (최신 값)
const handler = useCallback(async (payload, controller) => {
  const profileStore = registry.getStore('profile');
  const currentProfile = profileStore.getValue(); // 현재 값
  
  // 최신 데이터로 비즈니스 로직
}, [registry]);

// ❌ 잘못됨: 오래된 클로저
const profile = profileStore.getValue();
const handler = useCallback(async (payload, controller) => {
  console.log(profile); // 등록 시점의 오래된 값
}, [profile]);
```

### 7. null이 아닌 적절한 초기값 제공

```typescript
// ✅ 올바름: 적절한 초기값
export const userStores = createDeclarativeStores<UserData>('User', {
  profile: {
    initialValue: {
      id: '',
      name: '',
      email: ''
    }
  }
});

// ❌ 잘못됨: null 값은 타입 문제 야기
export const userStores = createDeclarativeStores<UserData>('User', {
  profile: {
    initialValue: null // TypeScript 오류, 런타임 문제
  }
});
```

### 8. 스토어 업데이트를 예측 가능하고 추적 가능하게 유지

```typescript
// ✅ 올바름: 명확하고 추적 가능한 업데이트
const updateProfile = useCallback(async (updates: Partial<UserProfile>) => {
  const profileStore = registry.getStore('profile');
  const currentProfile = profileStore.getValue();
  
  const newProfile = {
    ...currentProfile,
    ...updates,
    updatedAt: Date.now() // 메타데이터 추가
  };
  
  profileStore.setValue(newProfile);
  
  // 디버깅용 로그
  console.log('프로필 업데이트:', { from: currentProfile, to: newProfile });
}, [registry]);

// ❌ 잘못됨: 불명확한 변경
const updateProfile = useCallback((updates) => {
  // 직접 변경 (디버깅 어려움)
  Object.assign(currentProfile, updates);
}, []);
```

## 타입 안전성 (권장)

### 9. 더 나은 타입 안전성을 위한 인터페이스 정의

```typescript
// ✅ 좋음: 명확한 인터페이스
export interface UserData {
  profile: {
    id: string;
    name: string;
    email: string;
    role: 'admin' | 'user' | 'guest';
  };
  preferences: {
    theme: 'light' | 'dark';
    language: string;
  };
}

export interface UserActions {
  updateProfile: { data: Partial<UserData['profile']> };
  deleteUser: { userId: string };
  resetUser: void; // 페이로드 없는 액션에 명시적 void
}

// ❌ 피하기: any 타입 (안전성 상실)
export interface UserActions {
  updateProfile: any;
  deleteUser: any;
}
```

### 10. 타입 추론을 위해 도메인별 훅 사용

```typescript
// ✅ 올바름: 자동 타입 추론
function UserComponent() {
  const profileStore = useUserStore('profile'); // Store<UserProfile>
  const profile = useStoreValue(profileStore);  // UserProfile
  const dispatch = useUserAction();             // 타입된 디스패처
  
  dispatch('updateProfile', { 
    data: { name: '새 이름' } // ✓ 타입 체크됨
  });
}
```

### 11. `any` 타입 피하기 - TypeScript 활용

```typescript
// ✅ 올바름: 적절한 타이핑
const handler = useCallback(async (
  payload: UserActions['updateProfile'],
  controller: ActionController
) => {
  // 완전히 타입된 핸들러
}, []);

// ❌ 잘못됨: any 타입이 목적을 무산
const handler = useCallback(async (payload: any, controller: any) => {
  // 모든 타입 안전성 상실
}, []);
```

## 성능 모범 사례

### 12. 필요한 스토어만 구독

```typescript
// ✅ 올바름: 최소한의 구독
function UserName() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  // 프로필 변경시만 리렌더링
  return <span>{profile.name}</span>;
}

// ❌ 잘못됨: 과도한 구독
function UserName() {
  const profileStore = useUserStore('profile');
  const preferencesStore = useUserStore('preferences'); // 불필요
  const sessionStore = useUserStore('session'); // 불필요
  
  const profile = useStoreValue(profileStore);
  const preferences = useStoreValue(preferencesStore); // 추가 리렌더링 유발
  const session = useStoreValue(sessionStore); // 추가 리렌더링 유발
  
  return <span>{profile.name}</span>; // 프로필만 필요
}
```

### 13. 적절한 핸들러 우선순위 사용

```typescript
// ✅ 올바름: 논리적 우선순위 순서
register('updateProfile', validationHandler, { 
  priority: 200, // 검증 먼저
  blocking: true 
});

register('updateProfile', updateHandler, { 
  priority: 100, // 메인 로직 다음
  blocking: true 
});

register('updateProfile', loggingHandler, { 
  priority: 50,  // 로깅 마지막
  blocking: true 
});
```

### 14. 언마운트 시 핸들러 정리

```typescript
// ✅ 올바름: 모든 핸들러 정리됨
useEffect(() => {
  if (!register) return;
  
  const unregisterA = register('actionA', handlerA);
  const unregisterB = register('actionB', handlerB);
  const unregisterC = register('actionC', handlerC);
  
  return () => {
    unregisterA();
    unregisterB();
    unregisterC();
  };
}, [register, handlerA, handlerB, handlerC]);
```

### 15. 결과 수집을 선택적으로 사용

```typescript
// ✅ 좋음: 결과가 필요할 때만
const dispatchWithResult = useUserActionWithResult();

const criticalAction = async () => {
  const result = await dispatchWithResult('importantAction', payload, {
    result: { collect: true, strategy: 'all' }
  });
  
  // 결과 처리
  return result.results;
};

// ✅ 역시 좋음: 결과가 불필요할 때는 일반 디스패치
const dispatch = useUserAction();

const simpleAction = () => {
  dispatch('simpleAction', payload); // 결과 수집 오버헤드 없음
};
```

## 아키텍처 모범 사례

### 16. 하나의 도메인 = 하나의 컨텍스트 경계

```typescript
// ✅ 올바름: 명확한 도메인 경계
function App() {
  return (
    <UserProvider>        {/* 사용자 도메인 */}
      <CartProvider>      {/* 장바구니 도메인 */}
        <OrderProvider>   {/* 주문 도메인 */}
          <AppContent />
        </OrderProvider>
      </CartProvider>
    </UserProvider>
  );
}
```

### 17. 비즈니스와 UI 관심사 분리

```typescript
// ✅ 올바름: 관심사 분리
// 비즈니스 데이터
interface UserBusinessData {
  profile: UserProfile;
  session: UserSession;
}

// UI 상태  
interface UserUIState {
  isEditing: boolean;
  selectedTab: string;
  loadingState: LoadingState;
}

// 분리된 프로바이더
<UserBusinessProvider>
  <UserUIProvider>
    <UserComponents />
  </UserUIProvider>
</UserBusinessProvider>
```

### 18. 도메인 격리 선호 - 필요시에만 크로스 도메인 사용

```typescript
// ✅ 좋음: 도메인 격리 (선호)
function UserProfile() {
  const profileStore = useUserStore('profile');
  const userAction = useUserAction();
  // 자체 포함된 사용자 로직
}

// ✅ 역시 좋음: 진짜 필요할 때만 크로스 도메인
function useCheckoutProcess() {
  const userProfile = useUserStore('profile');
  const cartItems = useCartStore('items');
  const userAction = useUserAction();
  const cartAction = useCartAction();
  
  // 진짜로 도메인을 횡단하는 비즈니스 로직
}

// ❌ 피하기: 불필요한 결합
function UserProfile() {
  const cartItems = useCartStore('items'); // 왜 사용자 프로필이 장바구니가 필요한가?
}
```

### 19. 도메인 경계를 명확하게 문서화

```typescript
// ✅ 좋음: 명확한 문서화
/**
 * 사용자 도메인
 * 
 * 책임사항:
 * - 사용자 인증 및 프로필 관리
 * - 사용자 환경설정 및 설정
 * - 사용자 세션 관리
 * 
 * 의존성:
 * - 없음 (자체 포함)
 * 
 * 다른 도메인에 제공:
 * - 데이터 연결을 위한 사용자 ID
 * - 인증 상태
 */
export interface UserData {
  // 도메인 데이터 정의
}
```

## 코드 구성 모범 사례

### 23. 일관된 파일 구조

```mermaid
graph TD
    A[src/] --> B[stores/]
    A --> C[hooks/]
    A --> D[components/]
    A --> E[providers/]
    
    B --> B1[user/]
    B --> B2[cart/]
    B --> B3[index.ts]
    
    B1 --> B1a[userBusiness.store.ts]
    B1 --> B1b[userUI.store.ts]
    B1 --> B1c[index.ts]
    
    B2 --> B2a[cart.store.ts]
    B2 --> B2b[index.ts]
    
    C --> C1[handlers/]
    C --> C2[logic/]
    C --> C3[integration/]
    
    C1 --> C1a[useUserHandlers.ts]
    C1 --> C1b[useCartHandlers.ts]
    C1 --> C1c[index.ts]
    
    C2 --> C2a[useUserLogic.ts]
    C2 --> C2b[useCartLogic.ts]
    C2 --> C2c[index.ts]
    
    C3 --> C3a[useUserCartIntegration.ts]
    C3 --> C3b[index.ts]
    
    D --> D1[user/]
    D --> D2[cart/]
    D --> D3[shared/]
    
    E --> E1[UserProvider.tsx]
    E --> E2[CartProvider.tsx]
    E --> E3[AppProvider.tsx]
    
    style A fill:#e3f2fd
    style B fill:#fff8e1
    style C fill:#e8f5e8
    style D fill:#fce4ec
    style E fill:#f3e5f5
```

### 24. 배럴 내보내기 사용

```typescript
// stores/user/index.ts
export * from './userBusiness.store';
export * from './userUI.store';

// stores/index.ts  
export * from './user';
export * from './cart';
export * from './order';

// 사용법
import { useUserStore, useCartStore } from '@/stores';
```

### 25. 일관된 명명 규칙 구현

```typescript
// ✅ 일관된 명명
// 스토어
export const useUserBusinessStore = ...;
export const useUserUIStore = ...;

// 액션
export const useUserBusinessAction = ...;
export const useUserUIAction = ...;

// 핸들러
export const useUserBusinessHandlers = ...;
export const useUserUIHandlers = ...;

// 로직 훅
export const useUserProfile = ...;
export const useUserSettings = ...;
```

---

## 요약 체크리스트

### 핸들러 등록 ✓
- [ ] 항상 `useActionRegister` + `useEffect` 패턴 사용
- [ ] 정리를 위해 unregister 함수 반환
- [ ] 순차 비동기 핸들러에 `blocking: true` 사용
- [ ] 디버깅과 중요 핸들러에 명시적 ID 고려
- [ ] 재등록 방지를 위해 `useCallback`으로 핸들러 래핑

### 스토어 접근 ✓
- [ ] 컴포넌트에서 도메인별 훅 사용
- [ ] 핸들러에서 지연 평가를 위해 `registry.getStore()` 사용
- [ ] null이 아닌 적절한 초기값 제공
- [ ] 스토어 업데이트를 예측 가능하고 추적 가능하게 유지

### 타입 안전성 ✓
- [ ] 더 나은 타입 안전성을 위한 인터페이스 정의
- [ ] 타입 추론을 위해 도메인별 훅 사용
- [ ] `any` 타입 피하기 - TypeScript 활용

### 성능 ✓
- [ ] 필요한 스토어만 구독
- [ ] 적절한 핸들러 우선순위 사용
- [ ] 언마운트 시 핸들러 정리
- [ ] 결과 수집을 선택적으로 사용

### 아키텍처 ✓
- [ ] 하나의 도메인 = 하나의 컨텍스트 경계
- [ ] 비즈니스와 UI 관심사 분리
- [ ] 도메인 격리 선호 - 필요시에만 크로스 도메인 사용
- [ ] 도메인 경계를 명확하게 문서화

이러한 모범 사례를 따르면 Context-Action 프레임워크로 유지보수 가능하고 확장 가능하며 성능이 뛰어난 애플리케이션을 보장할 수 있습니다.

---

::: tip 지속적인 개선
이 체크리스트에 대해 정기적으로 코드베이스를 검토하세요. 개발 워크플로우에서 이러한 패턴을 강제하기 위해 ESLint 규칙과 자동화된 검사 설정을 고려해보세요.
:::

---


# Guide Common Pitfalls

**Source**: `guide/common-pitfalls.md`  
**Priority**: 80 (essential)  

# 공통 함정

Context-Action 구현에서 자주 발생하는 실수들을 학습하고 이를 피하는 방법을 알아보세요. 이 가이드는 개발자들이 가장 자주 겪는 문제들과 해결 방법을 다룹니다.

## 핸들러 등록 문제

### ❌ 정리 누락

**문제:** 컴포넌트 언마운트 시 핸들러가 정리되지 않아 메모리 누수 발생.

```typescript
// ❌ 잘못됨 - 메모리 누수
function useUserHandlers() {
  const register = useUserActionRegister();
  
  useEffect(() => {
    register('updateProfile', handler);
  }, []); // 정리 없음 - 핸들러가 메모리에 누적됨
}
```

**해결책:** 항상 unregister 함수를 반환하세요.

```typescript
// ✅ 올바름 - 적절한 정리
function useUserHandlers() {
  const register = useUserActionRegister();
  
  const handler = useCallback(async (payload, controller) => {
    // 핸들러 로직
  }, []);
  
  useEffect(() => {
    if (!register) return;
    const unregister = register('updateProfile', handler);
    return unregister; // 중요: 언마운트 시 정리
  }, [register, handler]);
}
```

**증상:**
- 시간이 지남에 따라 메모리 사용량 증가
- 핸들러가 여러 번 실행됨
- 스테일 클로저 오류

### ❌ 비동기 핸들러에서 `blocking` 누락

**문제:** 비동기 핸들러들이 순차가 아닌 동시에 실행됨.

```typescript
// ❌ 잘못됨 - 핸들러가 동시에 실행됨
register('processOrder', asyncHandler1, { priority: 100 });
register('processOrder', asyncHandler2, { priority: 90 });
register('processOrder', asyncHandler3, { priority: 80 });
// 모두 동시에 실행됨!
```

**해결책:** 순차 실행이 필요한 비동기 핸들러에는 `blocking: true`를 사용하세요.

```typescript
// ✅ 올바름 - 순차 실행
register('processOrder', asyncHandler1, { 
  priority: 100, 
  blocking: true // 완료까지 대기
});
register('processOrder', asyncHandler2, { 
  priority: 90, 
  blocking: true // handler1 완료 후 실행
});
```

**증상:**
- 핸들러 간 경합 조건
- 일관성 없는 상태 업데이트
- 핸들러가 서로의 변경사항을 덮어씀

### ❌ 스테일 클로저 사용

**문제:** 핸들러가 등록 시점의 오래된 값을 캡처함.

```typescript
// ❌ 잘못됨 - 스테일 클로저
function useUserHandlers() {
  const profileStore = useUserStore('profile');
  const profile = profileStore.getValue(); // 등록 시점에 캡처됨
  
  const handler = useCallback(async (payload, controller) => {
    console.log(profile); // 이건 스테일 데이터!
    // 핸들러가 등록된 시점의 프로필만 보여줌
  }, [profile]); // 의존성에 스테일 값 포함
}
```

**해결책:** registry.getStore()를 사용한 지연 평가 사용.

```typescript
// ✅ 올바름 - 지연 평가
function useUserHandlers() {
  const register = useUserActionRegister();
  const registry = useUserRegistry();
  
  const handler = useCallback(async (payload, controller) => {
    const profileStore = registry.getStore('profile');
    const profile = profileStore.getValue(); // 실행 시점의 최신 값
    console.log(profile); // 항상 현재 데이터
  }, [registry]); // 의존성에는 registry만
}
```

**증상:**
- 핸들러가 오래된 데이터로 작업
- 스테일 값에 기반한 상태 업데이트
- 현재 애플리케이션 상태를 반영하지 않는 로직

## 스토어 접근 문제

### ❌ 반응형 구독 미사용

**문제:** 스토어 데이터가 변경되어도 컴포넌트가 재렌더링되지 않음.

```typescript
// ❌ 잘못됨 - 반응형이 아님
function UserProfile() {
  const profileStore = useUserStore('profile');
  const profile = profileStore.getValue(); // 일회성 접근, 반응형 아님
  
  // 프로필이 변경되어도 컴포넌트가 재렌더링되지 않음
  return <div>{profile.name}</div>;
}
```

**해결책:** 반응형 구독을 위해 `useStoreValue()`를 사용하세요.

```typescript
// ✅ 올바름 - 반응형 구독
function UserProfile() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore); // 반응형 구독
  
  // 프로필이 변경되면 컴포넌트가 재렌더링됨
  return <div>{profile.name}</div>;
}
```

**증상:**
- 상태가 변경되어도 컴포넌트가 업데이트되지 않음
- 현재 데이터를 반영하지 않는 스테일 UI
- 변경사항을 보기 위해 수동 새로고침 필요

### ❌ 직접 스토어 변경

**문제:** setValue 대신 스토어 객체를 직접 변경함.

```typescript
// ❌ 잘못됨 - 직접 변경
function updateUserName(newName: string) {
  const profileStore = useUserStore('profile');
  const profile = profileStore.getValue();
  
  profile.name = newName; // 직접 변경 - 구독자들에게 알림 안됨
  // 컴포넌트들이 재렌더링되지 않음!
}
```

**해결책:** 업데이트에 항상 setValue를 사용하세요.

```typescript
// ✅ 올바름 - 불변 업데이트
function updateUserName(newName: string) {
  const profileStore = useUserStore('profile');
  const profile = profileStore.getValue();
  
  profileStore.setValue({
    ...profile,
    name: newName // 새 객체 - 구독자들에게 알림됨
  });
}
```

**증상:**
- UI에 변경사항이 반영되지 않음
- 컴포넌트 간 일관성 없는 상태
- 상태 변경 시점에 대한 디버깅 혼란

### ❌ Null/Undefined 초기값

**문제:** 초기값으로 null이나 undefined 사용 시 TypeScript와 런타임 문제 발생.

```typescript
// ❌ 잘못됨 - Null 초기값
const userStores = createDeclarativeStores<UserData>('User', {
  profile: {
    initialValue: null // TypeScript 오류, 런타임 문제
  }
});

function UserProfile() {
  const profile = useStoreValue(useUserStore('profile'));
  return <div>{profile.name}</div>; // profile이 null이면 런타임 오류
}
```

**해결책:** 적절한 기본값을 제공하세요.

```typescript
// ✅ 올바름 - 적절한 초기값
const userStores = createDeclarativeStores<UserData>('User', {
  profile: {
    initialValue: {
      id: '',
      name: '',
      email: ''
    }
  }
});

function UserProfile() {
  const profile = useStoreValue(useUserStore('profile'));
  return <div>{profile.name || '이름 없음'}</div>; // 안전한 접근
}
```

**증상:**
- TypeScript 컴파일 오류
- 런타임 null/undefined 오류
- 모든 곳에서 방어적 코딩 필요

## 타입 안전성 문제

### ❌ 제네릭 훅 사용

**문제:** 도메인별 훅 대신 제네릭 훅 사용으로 타입 안전성 상실.

```typescript
// ❌ 잘못됨 - 타입 안전성 없음
function UserProfile() {
  const store = useStore('user-profile'); // any 타입
  const dispatch = useDispatch(); // any 액션 타입
  
  dispatch('updateUser', { anyData: 'here' }); // 컴파일 타임 체크 없음
}
```

**해결책:** 완전한 타입 안전성을 위해 도메인별 훅을 사용하세요.

```typescript
// ✅ 올바름 - 완전한 타입 안전성
function UserProfile() {
  const profileStore = useUserStore('profile'); // Store<UserProfile>
  const dispatch = useUserAction(); // 타입된 디스패처
  
  dispatch('updateProfile', { 
    data: { name: 'John' } // 컴파일 타임 타입 체크
  });
}
```

### ❌ 인터페이스에서 Any 타입

**문제:** `any` 타입 사용으로 TypeScript의 목적 무력화.

```typescript
// ❌ 잘못됨 - 타입 안전성 상실
interface UserActions {
  updateProfile: any;
  deleteUser: any;
}
```

**해결책:** 적절하고 구체적인 타입을 정의하세요.

```typescript
// ✅ 올바름 - 구체적인 타입
interface UserActions {
  updateProfile: { data: Partial<UserProfile> };
  deleteUser: { userId: string };
  resetProfile: void; // 페이로드 없음을 명시적으로 void
}
```

## Provider 설정 문제

### ❌ 잘못된 Provider 순서

**문제:** 잘못된 provider 중첩으로 컨텍스트 오류 발생.

```typescript
// ❌ 잘못됨 - 액션 provider가 스토어 provider 밖에 있음
function App() {
  return (
    <UserActionProvider>  {/* 액션이 스토어의 존재를 필요로 함 */}
      <UserProvider>      {/* 스토어가 여기서 생성됨 */}
        <UserProfile />
      </UserProvider>
    </UserActionProvider>
  );
}
// 오류: 액션이 스토어에 접근할 수 없음
```

**해결책:** 스토어 provider가 액션 provider를 감싸야 합니다.

```typescript
// ✅ 올바름 - 스토어 provider가 액션 provider를 감쌈
function App() {
  return (
    <UserProvider>         {/* 스토어가 먼저 생성됨 */}
      <UserActionProvider> {/* 액션이 스토어에 접근 가능 */}
        <UserProfile />
      </UserActionProvider>
    </UserProvider>
  );
}
```

### ❌ 핸들러 설정 누락

**문제:** Provider 트리에서 핸들러 설정을 깜빡함.

```typescript
// ❌ 잘못됨 - 핸들러가 등록되지 않음
function App() {
  return (
    <UserProvider>
      <UserActionProvider>
        <UserProfile /> {/* 액션은 디스패치되지만 응답하는 핸들러가 없음 */}
      </UserActionProvider>
    </UserProvider>
  );
}
```

**해결책:** 핸들러 설정 컴포넌트를 포함하세요.

```typescript
// ✅ 올바름 - 핸들러가 적절히 설정됨
function HandlerSetup() {
  useUserHandlers(); // 모든 핸들러 등록
  return null;
}

function App() {
  return (
    <UserProvider>
      <UserActionProvider>
        <HandlerSetup />    {/* 핸들러가 등록됨 */}
        <UserProfile />
      </UserActionProvider>
    </UserProvider>
  );
}
```

## 성능 문제

### ❌ 과도한 구독

**문제:** 필요 이상으로 많은 스토어를 구독하는 컴포넌트.

```typescript
// ❌ 잘못됨 - 불필요한 구독
function UserName() {
  const profile = useStoreValue(useUserStore('profile'));
  const preferences = useStoreValue(useUserStore('preferences')); // 필요 없음
  const session = useStoreValue(useUserStore('session')); // 필요 없음
  const history = useStoreValue(useUserStore('history')); // 필요 없음
  
  // 이 중 아무거나 변경되면 컴포넌트가 재렌더링됨
  return <span>{profile.name}</span>; // profile만 필요함
}
```

**해결책:** 실제로 사용하는 스토어만 구독하세요.

```typescript
// ✅ 올바름 - 최소 구독
function UserName() {
  const profile = useStoreValue(useUserStore('profile'));
  
  // profile이 변경될 때만 재렌더링됨
  return <span>{profile.name}</span>;
}
```

### ❌ 핸들러 재생성

**문제:** 렌더링마다 새로운 핸들러 함수 생성.

```typescript
// ❌ 잘못됨 - 렌더링마다 핸들러 재생성
function useUserHandlers() {
  const register = useUserActionRegister();
  
  // 렌더링마다 새 함수 생성
  const handler = async (payload, controller) => {
    // 핸들러 로직
  };
  
  useEffect(() => {
    const unregister = register('action', handler);
    return unregister;
  }, [register, handler]); // handler가 렌더링마다 바뀜!
}
```

**해결책:** 핸들러 참조를 안정화하기 위해 `useCallback`을 사용하세요.

```typescript
// ✅ 올바름 - 안정한 핸들러 참조
function useUserHandlers() {
  const register = useUserActionRegister();
  const registry = useUserRegistry();
  
  // 안정한 함수 참조
  const handler = useCallback(async (payload, controller) => {
    // 핸들러 로직
  }, [registry]); // registry가 변경될 때만 변함
  
  useEffect(() => {
    const unregister = register('action', handler);
    return unregister;
  }, [register, handler]); // 필요할 때만 effect 실행
}
```

## 크로스 도메인 문제

### ❌ 도메인 간 강한 결합

**문제:** 도메인이 서로의 내부를 직접 접근함.

```typescript
// ❌ 잘못됨 - 직접 도메인 결합
function useUserHandlers() {
  const cartStore = useCartStore('items'); // User 도메인이 Cart 내부 접근
  
  const loginHandler = useCallback(async (payload, controller) => {
    // 로그인 로직
    
    // 다른 도메인 직접 조작
    cartStore.setValue([]); // 강한 결합!
  }, [cartStore]);
}
```

**해결책:** 크로스 도메인 통신에는 통합 훅이나 이벤트를 사용하세요.

```typescript
// ✅ 올바름 - 통합을 통한 느슨한 결합
function useUserCartIntegration() {
  const userAction = useUserAction();
  const cartAction = useCartAction();
  
  const loginWithCartReset = useCallback(async (loginData) => {
    await userAction('login', loginData);
    await cartAction('clearCart'); // 적절한 도메인 경계
  }, [userAction, cartAction]);
  
  return { loginWithCartReset };
}
```

### ❌ 순환 의존성

**문제:** 서로를 의존하는 도메인으로 순환 import 발생.

```typescript
// ❌ 잘못됨 - 순환 의존성
// user.store.ts
import { useCartAction } from './cart.store'; // User가 Cart import

// cart.store.ts  
import { useUserAction } from './user.store'; // Cart가 User import
// 순환 의존성!
```

**해결책:** 별도의 통합 모듈을 생성하세요.

```typescript
// ✅ 올바름 - 통합 모듈
// integration/userCartIntegration.ts
import { useUserAction } from '../stores/user.store';
import { useCartAction } from '../stores/cart.store';

export function useUserCartIntegration() {
  const userAction = useUserAction();
  const cartAction = useCartAction();
  
  // 통합 로직
  return { /* 통합 메소드 */ };
}
```

## 디버깅 문제

### ❌ 불분명한 에러 메시지

**문제:** 핸들러가 조용히 실패하거나 도움이 되지 않는 오류 발생.

```typescript
// ❌ 잘못됨 - 불분명한 오류 처리
const handler = useCallback(async (payload, controller) => {
  try {
    await riskyOperation();
  } catch (error) {
    controller.abort(); // 무엇이 실패했는지 컨텍스트 없음
  }
}, []);
```

**해결책:** 상세한 오류 컨텍스트를 제공하세요.

```typescript
// ✅ 올바름 - 상세한 오류 처리
const handler = useCallback(async (payload, controller) => {
  try {
    await riskyOperation();
  } catch (error) {
    controller.abort(`프로필 업데이트 실패: ${error.message}`, {
      operation: 'updateProfile',
      payload,
      timestamp: Date.now(),
      error: error.stack
    });
  }
}, []);
```

### ❌ 핸들러 ID 없음

**문제:** 어떤 핸들러가 문제를 일으키는지 디버깅하기 어려움.

```typescript
// ❌ 잘못됨 - 핸들러 식별 없음
register('updateProfile', handler, {
  priority: 100,
  blocking: true
  // ID 없음 - 디버깅 어려움
});
```

**해결책:** 디버깅을 위해 설명적인 ID를 사용하세요.

```typescript
// ✅ 올바름 - 명확한 핸들러 식별
register('updateProfile', handler, {
  priority: 100,
  blocking: true,
  id: 'profile-validation-handler' // 명확한 식별
});
```

---

## 문제 해결 체크리스트

뭔가 작동하지 않을 때, 다음 일반적인 문제들을 확인하세요:

### 핸들러 문제 ✓
- [ ] 핸들러가 unregister 함수를 반환하고 있나요?
- [ ] 비동기 핸들러가 `blocking: true`를 사용하고 있나요?
- [ ] 핸들러가 지연 평가(`registry.getStore()`)를 사용하고 있나요?
- [ ] 핸들러가 `useCallback`으로 래핑되어 있나요?

### 스토어 문제 ✓
- [ ] 컴포넌트가 반응성을 위해 `useStoreValue()`를 사용하고 있나요?
- [ ] 스토어 업데이트가 직접 변경 대신 `setValue()`를 사용하고 있나요?
- [ ] 초기값이 적절히 정의되어 있나요(null이 아님)?

### Provider 문제 ✓
- [ ] 스토어 provider가 액션 provider를 감싸고 있나요?
- [ ] 핸들러 설정 컴포넌트가 포함되어 있나요?
- [ ] Provider가 올바른 순서로 되어 있나요?

### 타입 문제 ✓
- [ ] 도메인별 훅을 사용하고 있나요?
- [ ] 인터페이스가 `any` 타입 없이 적절히 정의되어 있나요?
- [ ] 액션 페이로드가 인터페이스 정의와 일치하나요?

### 성능 문제 ✓
- [ ] 컴포넌트가 필요한 스토어만 구독하고 있나요?
- [ ] 핸들러가 `useCallback`으로 안정화되어 있나요?
- [ ] 불필요한 재렌더링을 피하고 있나요?

---

## 요약

Context-Action 문제의 대부분은 다음에서 비롯됩니다:

1. **메모리 관리**: 핸들러 정리하지 않기
2. **비동기 조율**: `blocking: true` 누락  
3. **반응성**: 반응형 구독 사용하지 않기
4. **타입 안전성**: 도메인별 대신 제네릭 훅 사용
5. **Provider 설정**: 잘못된 provider 순서나 핸들러 누락

이 가이드의 패턴을 따르면 이러한 일반적인 함정을 피하고 더 견고한 애플리케이션을 구축할 수 있습니다.

---

::: tip 예방
이러한 문제들을 조기에 발견하기 위해 ESLint 규칙과 코드 리뷰 체크리스트를 설정하세요. 팀의 코드베이스에서 올바른 패턴을 강제하는 커스텀 훅을 만드는 것도 고려해보세요.
:::

---


# Guide Cross Domain Integration

**Source**: `guide/cross-domain-integration.md`  
**Priority**: 80 (essential)  

# 크로스 도메인 통합

크로스 도메인 통합은 Context-Action 프레임워크에서 서로 다른 도메인 간의 안전하고 효율적인 상호작용을 구현하는 고급 패턴입니다. 이 가이드는 도메인 경계를 넘나드는 복잡한 비즈니스 로직을 구현하는 방법을 다룹니다.

## 크로스 도메인 기본 개념

### 도메인 경계와 통합 필요성

```typescript
// 독립적인 도메인들
interface UserDomain {
  profile: UserProfile;
  session: UserSession;
  preferences: UserPreferences;
}

interface CartDomain {
  items: CartItem[];
  totals: CartTotals;
  discounts: CartDiscount[];
}

interface OrderDomain {
  orders: Order[];
  history: OrderHistory[];
  tracking: OrderTracking;
}

// 크로스 도메인이 필요한 시나리오
// 1. 결제 프로세스: User + Cart + Order
// 2. 사용자 추천: User + Product + Cart
// 3. 알림 시스템: 모든 도메인의 이벤트
```

### 통합 접근 방식

Context-Action에서는 세 가지 주요 크로스 도메인 패턴을 제공합니다:

1. **직접 접근**: 여러 도메인의 훅을 직접 사용
2. **통합 훅**: 크로스 도메인 비즈니스 로직을 캡슐화
3. **이벤트 기반**: 도메인 간 이벤트 발행/구독

## 직접 접근 패턴

### 기본 크로스 도메인 접근

```typescript
function CheckoutComponent() {
  // 여러 도메인의 상태 구독
  const profile = useStoreValue(useUserStore('profile'));
  const cartItems = useStoreValue(useCartStore('items'));
  const cartTotals = useStoreValue(useCartStore('totals'));
  
  // 여러 도메인의 액션 접근
  const userAction = useUserAction();
  const cartAction = useCartAction();
  const orderAction = useOrderAction();
  
  const handleCheckout = useCallback(async () => {
    // 크로스 도메인 비즈니스 로직
    try {
      // 1. 사용자 인증 확인
      if (!profile.id) {
        await userAction('requireLogin', {});
        return;
      }
      
      // 2. 장바구니 검증
      if (cartItems.length === 0) {
        throw new Error('장바구니가 비어있습니다');
      }
      
      // 3. 주문 생성
      const order = await orderAction('createOrder', {
        userId: profile.id,
        items: cartItems,
        totals: cartTotals
      });
      
      // 4. 결제 처리
      const payment = await orderAction('processPayment', {
        orderId: order.id,
        amount: cartTotals.finalAmount,
        userId: profile.id
      });
      
      // 5. 장바구니 정리
      if (payment.success) {
        await cartAction('clearCart', {});
      }
      
    } catch (error) {
      console.error('결제 처리 실패:', error);
    }
  }, [profile, cartItems, cartTotals, userAction, cartAction, orderAction]);
  
  return (
    <button onClick={handleCheckout} disabled={!profile.id || cartItems.length === 0}>
      결제하기
    </button>
  );
}
```

### 제한적 크로스 도메인 접근

```typescript
// 필요한 경우에만 제한적으로 크로스 도메인 접근
function UserCartSummary() {
  const profile = useStoreValue(useUserStore('profile'));
  
  // 로그인된 사용자만 장바구니 정보 접근
  const cartItems = useStoreValue(
    useCartStore('items'),
    profile.id ? undefined : () => [] // 비로그인시 빈 배열
  );
  
  if (!profile.id) {
    return <div>로그인 후 장바구니를 확인하세요</div>;
  }
  
  return (
    <div>
      <h3>{profile.name}님의 장바구니</h3>
      <p>상품 {cartItems.length}개</p>
    </div>
  );
}
```

## 통합 훅 패턴

### 1. 복합 비즈니스 로직 훅

```typescript
// 결제 프로세스를 위한 통합 훅
export function useCheckoutProcess() {
  // 다중 도메인 접근
  const profile = useStoreValue(useUserStore('profile'));
  const session = useStoreValue(useUserStore('session'));
  const cartItems = useStoreValue(useCartStore('items'));
  const cartTotals = useStoreValue(useCartStore('totals'));
  
  const userAction = useUserAction();
  const cartAction = useCartAction();
  const orderAction = useOrderAction();
  
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // 결제 가능 여부 계산
  const canCheckout = useMemo(() => {
    return (
      session.isLoggedIn &&
      profile.id &&
      cartItems.length > 0 &&
      cartTotals.finalAmount > 0
    );
  }, [session.isLoggedIn, profile.id, cartItems.length, cartTotals.finalAmount]);
  
  // 결제 프로세스 실행
  const processCheckout = useCallback(async (paymentMethod: PaymentMethod) => {
    if (!canCheckout) {
      setError('결제 조건을 만족하지 않습니다');
      return { success: false };
    }
    
    setIsProcessing(true);
    setError(null);
    
    try {
      // 1. 주문 생성
      const orderResult = await orderAction('createOrder', {
        userId: profile.id,
        items: cartItems,
        totals: cartTotals,
        timestamp: Date.now()
      });
      
      if (!orderResult.success) {
        throw new Error(orderResult.error || '주문 생성 실패');
      }
      
      // 2. 결제 처리
      const paymentResult = await orderAction('processPayment', {
        orderId: orderResult.order.id,
        amount: cartTotals.finalAmount,
        paymentMethod,
        userId: profile.id
      });
      
      if (!paymentResult.success) {
        // 주문 취소
        await orderAction('cancelOrder', { orderId: orderResult.order.id });
        throw new Error(paymentResult.error || '결제 처리 실패');
      }
      
      // 3. 장바구니 정리
      await cartAction('clearCart', {});
      
      // 4. 사용자 통계 업데이트
      await userAction('updatePurchaseStats', {
        orderId: orderResult.order.id,
        amount: cartTotals.finalAmount
      });
      
      return {
        success: true,
        order: orderResult.order,
        payment: paymentResult.payment
      };
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : '결제 처리 중 오류 발생';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setIsProcessing(false);
    }
  }, [canCheckout, profile.id, cartItems, cartTotals, userAction, cartAction, orderAction]);
  
  // 빠른 재주문
  const reorder = useCallback(async (orderId: string) => {
    try {
      // 1. 기존 주문 정보 조회
      const orderResult = await orderAction('getOrder', { orderId });
      if (!orderResult.success) {
        throw new Error('주문 정보를 찾을 수 없습니다');
      }
      
      // 2. 장바구니에 상품 추가
      for (const item of orderResult.order.items) {
        await cartAction('addItem', {
          productId: item.productId,
          quantity: item.quantity
        });
      }
      
      return { success: true };
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : '재주문 처리 실패';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    }
  }, [cartAction, orderAction]);
  
  return {
    // 상태
    canCheckout,
    isProcessing,
    error,
    
    // 데이터
    profile,
    cartItems,
    cartTotals,
    
    // 액션
    processCheckout,
    reorder,
    clearError: () => setError(null)
  };
}

// 사용법
function CheckoutPage() {
  const {
    canCheckout,
    isProcessing,
    error,
    cartItems,
    cartTotals,
    processCheckout,
    clearError
  } = useCheckoutProcess();
  
  const [selectedPaymentMethod, setSelectedPaymentMethod] = useState<PaymentMethod>('card');
  
  const handleCheckout = useCallback(async () => {
    const result = await processCheckout(selectedPaymentMethod);
    if (result.success) {
      // 성공 페이지로 이동
      navigate(`/order-success/${result.order.id}`);
    }
  }, [processCheckout, selectedPaymentMethod]);
  
  return (
    <div>
      <h2>결제</h2>
      
      {error && (
        <div className="error-message">
          {error}
          <button onClick={clearError}>×</button>
        </div>
      )}
      
      <div className="cart-summary">
        <h3>주문 요약</h3>
        {cartItems.map(item => (
          <div key={item.id}>
            {item.name} × {item.quantity} = {item.total}
          </div>
        ))}
        <div className="total">총액: {cartTotals.finalAmount}</div>
      </div>
      
      <PaymentMethodSelector 
        value={selectedPaymentMethod}
        onChange={setSelectedPaymentMethod}
      />
      
      <button 
        onClick={handleCheckout}
        disabled={!canCheckout || isProcessing}
      >
        {isProcessing ? '처리 중...' : '결제하기'}
      </button>
    </div>
  );
}
```

### 2. 데이터 집계 훅

```typescript
// 여러 도메인의 데이터를 집계하는 훅
export function useUserDashboardData() {
  // 다중 도메인 데이터 구독
  const profile = useStoreValue(useUserStore('profile'));
  const preferences = useStoreValue(useUserStore('preferences'));
  const cartItems = useStoreValue(useCartStore('items'));
  const recentOrders = useStoreValue(useOrderStore('recentOrders'));
  const notifications = useStoreValue(useNotificationStore('unread'));
  
  // 대시보드 요약 데이터 계산
  const dashboardSummary = useMemo(() => {
    const cartValue = cartItems.reduce((sum, item) => sum + item.total, 0);
    const totalOrders = recentOrders.length;
    const unreadCount = notifications.length;
    
    const recentOrdersValue = recentOrders
      .slice(0, 5)
      .reduce((sum, order) => sum + order.totalAmount, 0);
    
    return {
      user: {
        name: profile.name,
        email: profile.email,
        memberSince: profile.createdAt,
        theme: preferences.theme
      },
      cart: {
        itemCount: cartItems.length,
        totalValue: cartValue,
        hasItems: cartItems.length > 0
      },
      orders: {
        totalCount: totalOrders,
        recentValue: recentOrdersValue,
        lastOrderDate: recentOrders[0]?.createdAt
      },
      notifications: {
        unreadCount,
        hasUnread: unreadCount > 0
      },
      summary: {
        completionRate: calculateProfileCompletion(profile),
        activityScore: calculateActivityScore(recentOrders, cartItems),
        loyaltyTier: calculateLoyaltyTier(recentOrders)
      }
    };
  }, [profile, preferences, cartItems, recentOrders, notifications]);
  
  return dashboardSummary;
}

// 보조 계산 함수들
function calculateProfileCompletion(profile: UserProfile): number {
  const fields = ['name', 'email', 'avatar', 'phone', 'address'];
  const completed = fields.filter(field => profile[field]).length;
  return Math.round((completed / fields.length) * 100);
}

function calculateActivityScore(orders: Order[], cartItems: CartItem[]): number {
  const orderScore = orders.length * 10;
  const cartScore = cartItems.length * 2;
  return Math.min(orderScore + cartScore, 100);
}

function calculateLoyaltyTier(orders: Order[]): 'bronze' | 'silver' | 'gold' | 'platinum' {
  const totalSpent = orders.reduce((sum, order) => sum + order.totalAmount, 0);
  
  if (totalSpent >= 1000000) return 'platinum';
  if (totalSpent >= 500000) return 'gold';
  if (totalSpent >= 200000) return 'silver';
  return 'bronze';
}

// 사용법
function UserDashboard() {
  const dashboardData = useUserDashboardData();
  
  return (
    <div className={`dashboard theme-${dashboardData.user.theme}`}>
      <header>
        <h1>안녕하세요, {dashboardData.user.name}님!</h1>
        <div className="loyalty-badge">
          {dashboardData.summary.loyaltyTier.toUpperCase()} 회원
        </div>
      </header>
      
      <div className="dashboard-grid">
        <div className="profile-card">
          <h3>프로필 완성도</h3>
          <div className="progress-bar">
            <div 
              className="progress"
              style={{ width: `${dashboardData.summary.completionRate}%` }}
            />
          </div>
          <span>{dashboardData.summary.completionRate}% 완료</span>
        </div>
        
        <div className="cart-card">
          <h3>장바구니</h3>
          <p>{dashboardData.cart.itemCount}개 상품</p>
          <p>총 {dashboardData.cart.totalValue.toLocaleString()}원</p>
        </div>
        
        <div className="orders-card">
          <h3>주문 내역</h3>
          <p>총 {dashboardData.orders.totalCount}회 주문</p>
          <p>최근 주문: {dashboardData.orders.recentValue.toLocaleString()}원</p>
        </div>
        
        <div className="notifications-card">
          <h3>알림</h3>
          <p>
            {dashboardData.notifications.hasUnread 
              ? `${dashboardData.notifications.unreadCount}개의 새 알림`
              : '새 알림 없음'
            }
          </p>
        </div>
      </div>
    </div>
  );
}
```

## 이벤트 기반 통합

### 1. 도메인 이벤트 시스템

```typescript
// 도메인 이벤트 타입 정의
interface DomainEvents {
  // 사용자 도메인 이벤트
  'user.login': { userId: string; timestamp: number };
  'user.logout': { userId: string; timestamp: number };
  'user.profile.updated': { userId: string; changes: Partial<UserProfile> };
  
  // 장바구니 도메인 이벤트
  'cart.item.added': { userId: string; productId: string; quantity: number };
  'cart.item.removed': { userId: string; productId: string };
  'cart.cleared': { userId: string; timestamp: number };
  
  // 주문 도메인 이벤트
  'order.created': { orderId: string; userId: string; amount: number };
  'order.paid': { orderId: string; paymentId: string };
  'order.shipped': { orderId: string; trackingNumber: string };
}

// 이벤트 발행/구독 시스템
class DomainEventBus {
  private listeners = new Map<keyof DomainEvents, Function[]>();
  
  subscribe<T extends keyof DomainEvents>(
    event: T, 
    handler: (payload: DomainEvents[T]) => void
  ): () => void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    
    this.listeners.get(event)!.push(handler);
    
    // 구독 해제 함수 반환
    return () => {
      const handlers = this.listeners.get(event);
      if (handlers) {
        const index = handlers.indexOf(handler);
        if (index > -1) {
          handlers.splice(index, 1);
        }
      }
    };
  }
  
  publish<T extends keyof DomainEvents>(event: T, payload: DomainEvents[T]) {
    const handlers = this.listeners.get(event) || [];
    handlers.forEach(handler => {
      try {
        handler(payload);
      } catch (error) {
        console.error(`Error in event handler for ${event}:`, error);
      }
    });
  }
}

// 전역 이벤트 버스
export const domainEventBus = new DomainEventBus();

// 이벤트 기반 핸들러
function useEventBasedIntegration() {
  const cartAction = useCartAction();
  const orderAction = useOrderAction();
  const notificationAction = useNotificationAction();
  
  useEffect(() => {
    // 사용자 로그인 시 장바구니 동기화
    const unsubscribeLogin = domainEventBus.subscribe('user.login', async ({ userId }) => {
      await cartAction('syncFromServer', { userId });
    });
    
    // 장바구니 아이템 추가 시 추천 시스템 업데이트
    const unsubscribeCartAdd = domainEventBus.subscribe('cart.item.added', async ({ userId, productId }) => {
      // 추천 시스템에 사용자 행동 기록
      await fetch('/api/recommendations/track', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId, action: 'cart-add', productId })
      });
    });
    
    // 주문 생성 시 알림 발송
    const unsubscribeOrderCreated = domainEventBus.subscribe('order.created', async ({ orderId, userId }) => {
      await notificationAction('sendOrderConfirmation', { orderId, userId });
    });
    
    // 주문 배송 시 알림 발송
    const unsubscribeOrderShipped = domainEventBus.subscribe('order.shipped', async ({ orderId, trackingNumber }) => {
      await notificationAction('sendShippingNotification', { orderId, trackingNumber });
    });
    
    return () => {
      unsubscribeLogin();
      unsubscribeCartAdd();
      unsubscribeOrderCreated();
      unsubscribeOrderShipped();
    };
  }, [cartAction, orderAction, notificationAction]);
}
```

### 2. 이벤트 발행 핸들러

```typescript
// 이벤트를 발행하는 핸들러 패턴
function useUserHandlersWithEvents() {
  const register = useUserActionRegister();
  const registry = useUserStores();
  
  const loginHandler = useCallback(async (payload, controller) => {
    const sessionStore = registry.getStore('session');
    const profileStore = registry.getStore('profile');
    
    try {
      // 로그인 로직
      const loginResult = await performLogin(payload);
      
      sessionStore.setValue({
        isLoggedIn: true,
        token: loginResult.token,
        expiresAt: Date.now() + (loginResult.expiresIn * 1000)
      });
      
      profileStore.setValue(loginResult.user);
      
      // 로그인 이벤트 발행
      domainEventBus.publish('user.login', {
        userId: loginResult.user.id,
        timestamp: Date.now()
      });
      
      return { success: true, user: loginResult.user };
      
    } catch (error) {
      controller.abort('로그인 실패', error);
      return { success: false, error: 'LOGIN_FAILED' };
    }
  }, [registry]);
  
  const updateProfileHandler = useCallback(async (payload, controller) => {
    const profileStore = registry.getStore('profile');
    const currentProfile = profileStore.getValue();
    
    try {
      const updatedProfile = { ...currentProfile, ...payload.data };
      profileStore.setValue(updatedProfile);
      
      // 프로필 업데이트 이벤트 발행
      domainEventBus.publish('user.profile.updated', {
        userId: currentProfile.id,
        changes: payload.data
      });
      
      return { success: true, profile: updatedProfile };
      
    } catch (error) {
      controller.abort('프로필 업데이트 실패', error);
      return { success: false, error: 'UPDATE_FAILED' };
    }
  }, [registry]);
  
  // 핸들러 등록
  useEffect(() => {
    if (!register) return;
    
    const unregisterLogin = register('login', loginHandler, {
      id: 'user-login-with-events',
      priority: 100
    });
    
    const unregisterUpdate = register('updateProfile', updateProfileHandler, {
      id: 'user-profile-update-with-events',
      priority: 100
    });
    
    return () => {
      unregisterLogin();
      unregisterUpdate();
    };
  }, [register, loginHandler, updateProfileHandler]);
}
```

## 고급 통합 패턴

### 1. 조건부 크로스 도메인 접근

```typescript
// 조건에 따른 선택적 도메인 접근
export function useConditionalCrossDomain(features: {
  cart?: boolean;
  orders?: boolean;
  notifications?: boolean;
}) {
  const profile = useStoreValue(useUserStore('profile'));
  
  // 조건부 훅 사용
  const cartItems = features.cart 
    ? useStoreValue(useCartStore('items'))
    : [];
    
  const recentOrders = features.orders
    ? useStoreValue(useOrderStore('recent'))
    : [];
    
  const notifications = features.notifications
    ? useStoreValue(useNotificationStore('unread'))
    : [];
  
  // 사용 가능한 기능에 따른 데이터 집계
  const summary = useMemo(() => {
    const baseData = { profile };
    
    if (features.cart && cartItems.length > 0) {
      baseData.cartSummary = {
        itemCount: cartItems.length,
        totalValue: cartItems.reduce((sum, item) => sum + item.total, 0)
      };
    }
    
    if (features.orders && recentOrders.length > 0) {
      baseData.ordersSummary = {
        count: recentOrders.length,
        lastOrder: recentOrders[0]
      };
    }
    
    if (features.notifications && notifications.length > 0) {
      baseData.notificationsSummary = {
        unreadCount: notifications.length
      };
    }
    
    return baseData;
  }, [profile, cartItems, recentOrders, notifications, features]);
  
  return summary;
}
```

### 2. 트랜잭션 패턴

```typescript
// 여러 도메인에 걸친 트랜잭션 처리
export function useTransactionalOperation() {
  const userAction = useUserAction();
  const cartAction = useCartAction();
  const orderAction = useOrderAction();
  const paymentAction = usePaymentAction();
  
  const executeTransactionalCheckout = useCallback(async (checkoutData: CheckoutData) => {
    const rollbackActions: Array<() => Promise<void>> = [];
    
    try {
      // 1. 재고 예약
      const reservationResult = await orderAction('reserveInventory', {
        items: checkoutData.items
      });
      
      if (!reservationResult.success) {
        throw new Error('재고 부족');
      }
      
      rollbackActions.push(() => 
        orderAction('releaseInventoryReservation', { 
          reservationId: reservationResult.reservationId 
        })
      );
      
      // 2. 주문 생성
      const orderResult = await orderAction('createOrder', {
        userId: checkoutData.userId,
        items: checkoutData.items,
        reservationId: reservationResult.reservationId
      });
      
      if (!orderResult.success) {
        throw new Error('주문 생성 실패');
      }
      
      rollbackActions.push(() => 
        orderAction('cancelOrder', { 
          orderId: orderResult.order.id 
        })
      );
      
      // 3. 결제 처리
      const paymentResult = await paymentAction('processPayment', {
        orderId: orderResult.order.id,
        amount: checkoutData.amount,
        paymentMethod: checkoutData.paymentMethod
      });
      
      if (!paymentResult.success) {
        throw new Error('결제 처리 실패');
      }
      
      // 4. 장바구니 정리
      await cartAction('clearCart', {});
      
      // 5. 사용자 통계 업데이트
      await userAction('updatePurchaseHistory', {
        orderId: orderResult.order.id,
        amount: checkoutData.amount
      });
      
      return {
        success: true,
        order: orderResult.order,
        payment: paymentResult.payment
      };
      
    } catch (error) {
      // 롤백 실행 (역순)
      for (let i = rollbackActions.length - 1; i >= 0; i--) {
        try {
          await rollbackActions[i]();
        } catch (rollbackError) {
          console.error('롤백 실행 중 오류:', rollbackError);
        }
      }
      
      return {
        success: false,
        error: error instanceof Error ? error.message : '트랜잭션 실패'
      };
    }
  }, [userAction, cartAction, orderAction, paymentAction]);
  
  return { executeTransactionalCheckout };
}
```

## 모범 사례

### 1. 도메인 경계 원칙

```typescript
// ✅ 좋음: 명확한 목적의 크로스 도메인 접근
function useOrderSummaryWithUserInfo() {
  // 주문 요약을 위해 필요한 사용자 정보만 접근
  const userName = useStoreValue(useUserStore('profile'), profile => profile.name);
  const orders = useStoreValue(useOrderStore('recent'));
  
  return {
    userName,
    orders,
    summary: `${userName}님의 최근 주문 ${orders.length}건`
  };
}

// ❌ 피하기: 불필요한 크로스 도메인 의존성
function useUserProfileWithCartAndOrders() {
  // 프로필 컴포넌트에서 장바구니와 주문 정보까지 접근하는 것은 과도함
  const profile = useStoreValue(useUserStore('profile'));
  const cartItems = useStoreValue(useCartStore('items')); // 불필요
  const orders = useStoreValue(useOrderStore('all')); // 불필요
  
  return { profile, cartItems, orders }; // 너무 많은 책임
}
```

### 2. 성능 고려사항

```typescript
// ✅ 좋음: 조건부 구독으로 성능 최적화
function useOptimizedCrossDomain({ includeCart, includeOrders }: {
  includeCart?: boolean;
  includeOrders?: boolean;
}) {
  const profile = useStoreValue(useUserStore('profile'));
  
  // 필요한 경우에만 구독
  const cartData = includeCart 
    ? useStoreValue(useCartStore('items'))
    : null;
    
  const orderData = includeOrders 
    ? useStoreValue(useOrderStore('recent'))
    : null;
  
  return {
    profile,
    ...(cartData && { cart: cartData }),
    ...(orderData && { orders: orderData })
  };
}

// ❌ 피하기: 항상 모든 도메인 구독
function useInefficientCrossDomain() {
  // 사용하지 않아도 모든 데이터를 구독하는 것은 비효율적
  const profile = useStoreValue(useUserStore('profile'));
  const cartItems = useStoreValue(useCartStore('items'));
  const orders = useStoreValue(useOrderStore('all'));
  const notifications = useStoreValue(useNotificationStore('all'));
  
  return { profile }; // 다른 데이터는 사용하지 않음
}
```

### 3. 오류 처리 전략

```typescript
// 크로스 도메인 오류 처리
export function useSafeCrossDomainOperation() {
  const [errors, setErrors] = useState<Record<string, string>>({});
  
  const safeCrossOperation = useCallback(async (operation: () => Promise<any>) => {
    try {
      setErrors({});
      return await operation();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : '알 수 없는 오류';
      
      // 도메인별 오류 분류
      if (errorMessage.includes('사용자')) {
        setErrors(prev => ({ ...prev, user: errorMessage }));
      } else if (errorMessage.includes('장바구니')) {
        setErrors(prev => ({ ...prev, cart: errorMessage }));
      } else if (errorMessage.includes('주문')) {
        setErrors(prev => ({ ...prev, order: errorMessage }));
      } else {
        setErrors(prev => ({ ...prev, general: errorMessage }));
      }
      
      throw error;
    }
  }, []);
  
  return { errors, safeCrossOperation, clearErrors: () => setErrors({}) };
}
```

---

## 요약

크로스 도메인 통합은 다음 원칙을 따라야 합니다:

- **최소한의 결합** - 필요한 경우에만 도메인 간 접근
- **명확한 목적** - 비즈니스 요구사항에 기반한 통합
- **성능 최적화** - 조건부 구독과 지연 로딩 활용
- **안전한 실행** - 트랜잭션과 롤백 메커니즘
- **유지보수성** - 통합 로직의 캡슐화와 테스트 가능성

올바른 크로스 도메인 패턴을 사용하면 복잡한 비즈니스 요구사항을 깔끔하게 구현할 수 있습니다.

---

::: tip 다음 단계
- [MVVM 아키텍처](./mvvm-architecture) - MVVM 패턴과 크로스 도메인 통합
- [성능 최적화](./performance) - 크로스 도메인 성능 최적화
- [모범 사례](./best-practices) - 실제 프로덕션 환경 권장사항
:::

---


# Guide Domain Hooks Pattern

**Source**: `guide/domain-hooks-pattern.md`  
**Priority**: 80 (essential)  

# 도메인 훅 패턴

Context-Action 프레임워크의 **도메인 훅 패턴**은 타입 안전한 도메인별 인터페이스를 생성하는 핵심 메커니즘입니다. 구조 분해 할당을 통해 자동 타입 추론과 명확한 도메인 경계를 제공합니다.

## 패턴 개요

도메인 훅 패턴은 제네릭 훅 대신 도메인별로 특화된 훅을 생성하여 완전한 타입 안전성을 제공합니다:

```typescript
// ❌ 제네릭 접근법 (타입 정보 없음)
const store = useStore('user-profile');
const dispatch = useDispatch();

// ✅ 도메인 훅 패턴 (완전한 타입 안전성)
const store = useUserStore('profile');
const dispatch = useUserAction();
```

## 스토어 도메인 훅

### 기본 구조

```typescript
// stores/user.store.ts
import { createDeclarativeStores } from '@context-action/react';

export interface UserData {
  profile: {
    id: string;
    name: string;
    email: string;
    avatar?: string;
  };
  preferences: {
    theme: 'light' | 'dark';
    language: string;
    notifications: {
      email: boolean;
      push: boolean;
    };
  };
  session: {
    isLoggedIn: boolean;
    token: string | null;
    expiresAt: number | null;
  };
}

// 도메인별 스토어 훅 생성
export const {
  Provider: UserStoreProvider,
  useStore: useUserStore,           // Store<UserData[K]> 타입 반환
  useStores: useUserStores,         // StoreRegistry<UserData> 타입 반환
  useCreateStore: useCreateUserStore // 동적 스토어 생성
} = createDeclarativeStores<UserData>('User', {
  profile: {
    initialValue: {
      id: '',
      name: '',
      email: ''
    },
    strategy: 'deep'
  },
  preferences: {
    initialValue: {
      theme: 'light',
      language: 'ko',
      notifications: {
        email: true,
        push: true
      }
    },
    strategy: 'shallow'
  },
  session: {
    initialValue: {
      isLoggedIn: false,
      token: null,
      expiresAt: null
    },
    strategy: 'reference'
  }
});
```

### 사용 패턴

```typescript
// 컴포넌트에서 사용
function UserProfile() {
  // 자동 타입 추론: Store<UserData['profile']>
  const profileStore = useUserStore('profile');
  
  // 자동 타입 추론: UserData['profile']
  const profile = useStoreValue(profileStore);
  
  // 자동 타입 추론: UserData['preferences']
  const preferences = useStoreValue(useUserStore('preferences'));
  
  return (
    <div>
      <h2>안녕하세요, {profile.name}님</h2>
      <p>현재 테마: {preferences.theme}</p>
    </div>
  );
}

// 핸들러에서 사용
function useUserHandlers() {
  const registry = useUserStores(); // StoreRegistry<UserData>
  
  const handler = useCallback(async (payload, controller) => {
    // 지연 평가로 최신 값 접근
    const profileStore = registry.getStore('profile');
    const currentProfile = profileStore.getValue();
    
    // 타입 안전한 스토어 업데이트
    profileStore.setValue({
      ...currentProfile,
      name: payload.newName
    });
  }, [registry]);
}
```

## 액션 도메인 훅

### 기본 구조

```typescript
// stores/user.actions.ts
import { createActionContext } from '@context-action/react';

export interface UserActions {
  // 인증 액션
  login: { 
    email: string; 
    password: string; 
    rememberMe?: boolean; 
  };
  logout: void;
  refreshToken: void;
  
  // 프로필 액션
  updateProfile: { 
    data: Partial<UserData['profile']>; 
  };
  uploadAvatar: { 
    file: File; 
  };
  deleteProfile: { 
    confirmation: string; 
  };
  
  // 설정 액션
  updatePreferences: { 
    preferences: Partial<UserData['preferences']>; 
  };
  
  // 복합 액션
  resetUserData: void;
  syncWithServer: { 
    force?: boolean; 
  };
}

// 도메인별 액션 훅 생성
export const {
  Provider: UserActionProvider,
  useAction: useUserAction,                    // Dispatch<UserActions>
  useActionHandler: useUserActionHandler,      // RegisterHandler<UserActions>
  useActionDispatchWithResult: useUserActionWithResult // WithResult<UserActions>
} = createActionContext<UserActions>({
  name: 'UserAction',
  debug: process.env.NODE_ENV === 'development'
});
```

### 사용 패턴

```typescript
// 컴포넌트에서 액션 디스패치
function LoginForm() {
  const dispatch = useUserAction(); // 완전히 타입된 디스패처
  const [form, setForm] = useState({ email: '', password: '' });
  
  const handleLogin = useCallback(async () => {
    // 타입 안전한 액션 디스패치
    await dispatch('login', {
      email: form.email,
      password: form.password,
      rememberMe: true
    });
  }, [dispatch, form]);
  
  return (
    <form onSubmit={handleLogin}>
      <input 
        value={form.email}
        onChange={(e) => setForm(prev => ({ ...prev, email: e.target.value }))}
        type="email"
        placeholder="이메일"
      />
      <input 
        value={form.password}
        onChange={(e) => setForm(prev => ({ ...prev, password: e.target.value }))}
        type="password"
        placeholder="비밀번호"
      />
      <button type="submit">로그인</button>
    </form>
  );
}

// 결과를 필요로 하는 액션
function ProfileUpdater() {
  const dispatchWithResult = useUserActionWithResult();
  
  const handleUpdate = useCallback(async (data: Partial<UserData['profile']>) => {
    const result = await dispatchWithResult('updateProfile', { data }, {
      result: { collect: true, strategy: 'first' }
    });
    
    if (result.success) {
      console.log('업데이트 성공:', result.results);
    } else {
      console.error('업데이트 실패:', result.errors);
    }
  }, [dispatchWithResult]);
}
```

## 고급 패턴

### 1. 조건부 스토어 생성

```typescript
// 동적 스토어 생성
function UserDashboard({ userId }: { userId: string }) {
  const createStore = useCreateUserStore();
  
  // 사용자별 동적 스토어
  const userCache = createStore(`cache-${userId}`, {
    activities: [],
    lastFetch: null
  });
  
  const activities = useStoreValue(userCache);
  
  return <div>사용자 활동: {activities.length}개</div>;
}
```

### 2. 복합 도메인 훅

```typescript
// hooks/useUserProfile.ts - 복합 비즈니스 로직
export function useUserProfile() {
  const profileStore = useUserStore('profile');
  const sessionStore = useUserStore('session');
  const dispatch = useUserAction();
  
  const profile = useStoreValue(profileStore);
  const session = useStoreValue(sessionStore);
  
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // 프로필 업데이트 로직
  const updateProfile = useCallback(async (data: Partial<UserData['profile']>) => {
    setIsLoading(true);
    setError(null);
    
    try {
      const result = await dispatch('updateProfile', { data });
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : '업데이트 실패';
      setError(errorMessage);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [dispatch]);
  
  // 인증 상태 확인
  const isAuthenticated = useMemo(() => {
    return session.isLoggedIn && 
           session.token && 
           (session.expiresAt ? session.expiresAt > Date.now() : true);
  }, [session]);
  
  // 완전한 프로필 여부
  const hasCompleteProfile = useMemo(() => {
    return profile.name && profile.email && profile.id;
  }, [profile]);
  
  return {
    profile,
    session,
    isLoading,
    error,
    updateProfile,
    isAuthenticated,
    hasCompleteProfile,
    clearError: () => setError(null)
  };
}
```

### 3. 크로스 도메인 훅

```typescript
// hooks/useUserCartIntegration.ts - 다중 도메인 통합
export function useUserCartIntegration() {
  // 여러 도메인의 훅 사용
  const userProfile = useUserStore('profile');
  const cartItems = useCartStore('items');
  const userDispatch = useUserAction();
  const cartDispatch = useCartAction();
  
  const profile = useStoreValue(userProfile);
  const items = useStoreValue(cartItems);
  
  // 크로스 도메인 비즈니스 로직
  const processCheckout = useCallback(async () => {
    // 사용자 인증 확인
    if (!profile.id) {
      await userDispatch('login', { 
        /* 로그인 프롬프트 로직 */ 
      });
      return { success: false, reason: 'AUTH_REQUIRED' };
    }
    
    // 장바구니 검증
    if (items.length === 0) {
      return { success: false, reason: 'EMPTY_CART' };
    }
    
    // 결제 프로세스 시작
    const checkoutResult = await cartDispatch('processCheckout', {
      userId: profile.id,
      items: items,
      userEmail: profile.email
    });
    
    return checkoutResult;
  }, [profile, items, userDispatch, cartDispatch]);
  
  // 로그인 시 장바구니 동기화
  const syncCartOnLogin = useCallback(async () => {
    if (profile.id) {
      await cartDispatch('syncWithServer', { 
        userId: profile.id 
      });
    }
  }, [profile.id, cartDispatch]);
  
  // 장바구니 요약 정보
  const cartSummary = useMemo(() => {
    const totalItems = items.reduce((sum, item) => sum + item.quantity, 0);
    const totalPrice = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
    
    return {
      itemCount: totalItems,
      totalPrice,
      canCheckout: profile.id && totalItems > 0
    };
  }, [items, profile.id]);
  
  return {
    processCheckout,
    syncCartOnLogin,
    cartSummary,
    userProfile: profile,
    cartItems: items
  };
}
```

## 타입 안전성 장점

### 1. 컴파일 시 오류 검출

```typescript
// ❌ 컴파일 에러 - 존재하지 않는 스토어 키
const invalidStore = useUserStore('nonexistent');
// TS2345: Argument of type '"nonexistent"' is not assignable to parameter

// ❌ 컴파일 에러 - 잘못된 액션 이름
dispatch('invalidAction', {});
// TS2345: Argument of type '"invalidAction"' is not assignable

// ❌ 컴파일 에러 - 잘못된 페이로드 타입
dispatch('updateProfile', { invalidField: 'value' });
// TS2345: Object literal may only specify known properties
```

### 2. IDE 자동완성

```typescript
// 스토어 키 자동완성
const store = useUserStore('|'); // 'profile' | 'preferences' | 'session'

// 액션 이름 자동완성  
dispatch('|'); // 'login' | 'logout' | 'updateProfile' | ...

// 페이로드 타입 자동완성
dispatch('updateProfile', {
  data: {
    name: '|', // string 타입으로 추론
    email: '|' // string 타입으로 추론
  }
});
```

### 3. 리팩토링 안전성

```typescript
// 인터페이스 변경 시 관련 코드 자동 업데이트
interface UserData {
  profile: {
    id: string;
    fullName: string; // name에서 fullName으로 변경
    email: string;
  };
  // ...
}

// 모든 사용처에서 TypeScript 에러로 변경 필요 위치 표시
const profile = useStoreValue(useUserStore('profile'));
console.log(profile.name); // TS 에러: Property 'name' does not exist
console.log(profile.fullName); // ✅ 수정됨
```

## 성능 최적화

### 1. 선택적 구독

```typescript
// 필요한 스토어만 구독하여 불필요한 리렌더링 방지
function UserName() {
  const profile = useStoreValue(useUserStore('profile'));
  
  // preferences 변경 시에는 리렌더링되지 않음
  return <span>{profile.name}</span>;
}

function UserTheme() {
  const preferences = useStoreValue(useUserStore('preferences'));
  
  // profile 변경 시에는 리렌더링되지 않음
  return <div className={`theme-${preferences.theme}`} />;
}
```

### 2. 메모화와 조합

```typescript
function UserSummary() {
  const profile = useStoreValue(useUserStore('profile'));
  const preferences = useStoreValue(useUserStore('preferences'));
  
  // 프로필이나 환경설정이 변경될 때만 재계산
  const displayInfo = useMemo(() => ({
    greeting: `안녕하세요, ${profile.name}님`,
    themeClass: `user-theme-${preferences.theme}`,
    locale: preferences.language
  }), [profile.name, preferences.theme, preferences.language]);
  
  return (
    <div className={displayInfo.themeClass}>
      {displayInfo.greeting}
    </div>
  );
}
```

## 모범 사례

### 1. 명확한 도메인 경계

```typescript
// ✅ 좋음: 명확한 도메인별 분리
const userProfile = useUserStore('profile');
const cartItems = useCartStore('items');
const orderHistory = useOrderStore('history');

// ❌ 피하기: 하나의 훅에서 여러 도메인 접근 (필요한 경우 제외)
function ProfileComponent() {
  const profile = useUserStore('profile');
  const cartCount = useCartStore('items'); // 프로필에서 장바구니가 왜 필요한가?
}
```

### 2. 적절한 추상화 수준

```typescript
// ✅ 좋음: 도메인별 비즈니스 로직 훅
export function useUserAuthentication() {
  const sessionStore = useUserStore('session');
  const dispatch = useUserAction();
  
  return {
    login: (credentials) => dispatch('login', credentials),
    logout: () => dispatch('logout'),
    isAuthenticated: useStoreValue(sessionStore).isLoggedIn
  };
}

// 사용법
function LoginButton() {
  const { login, logout, isAuthenticated } = useUserAuthentication();
  
  return (
    <button onClick={isAuthenticated ? logout : () => login(credentials)}>
      {isAuthenticated ? '로그아웃' : '로그인'}
    </button>
  );
}
```

### 3. 일관된 명명 규칙

```typescript
// 스토어 훅
export const useUserStore = ...;
export const useCartStore = ...;
export const useOrderStore = ...;

// 액션 훅
export const useUserAction = ...;
export const useCartAction = ...;
export const useOrderAction = ...;

// 비즈니스 로직 훅
export const useUserProfile = ...;
export const useCartManagement = ...;
export const useOrderProcessing = ...;
```

---

## 요약

도메인 훅 패턴은 Context-Action 프레임워크의 핵심으로, 다음을 제공합니다:

- **완전한 타입 안전성** - 컴파일 시 오류 검출
- **명확한 도메인 경계** - 논리적 분리와 캡슐화
- **우수한 개발자 경험** - IDE 자동완성과 리팩토링 안전성
- **성능 최적화** - 선택적 구독과 최소한의 리렌더링
- **확장성** - 새로운 도메인과 기능의 쉬운 추가

이 패턴을 따르면 대규모 애플리케이션에서도 유지보수 가능하고 타입 안전한 상태 관리를 구현할 수 있습니다.

---

::: tip 다음 단계
- [스토어 관리](./store-management) - 스토어 시스템 심화 학습
- [액션 핸들러](./action-handlers) - 비즈니스 로직 구현 패턴
- [프로바이더 구성](./provider-composition) - 도메인 경계 관리
:::

---


# Guide Error Handling

**Source**: `guide/error-handling.md`  
**Priority**: 80 (essential)  

# 오류 처리

Context-Action 프레임워크에서의 오류 처리는 안정적이고 복원력 있는 애플리케이션을 구축하는 핵심 요소입니다. 이 가이드는 체계적인 오류 처리 전략과 복구 메커니즘을 다룹니다.

## 오류 처리 아키텍처

### 계층별 오류 처리

```typescript
// 오류 계층 구조
interface ErrorHandlingLayers {
  // 1. Handler Layer - 비즈니스 로직 오류
  handlerErrors: {
    validationErrors: ValidationError[];
    businessLogicErrors: BusinessLogicError[];
    externalServiceErrors: ExternalServiceError[];
  };
  
  // 2. Store Layer - 데이터 일관성 오류
  storeErrors: {
    stateValidationErrors: StateValidationError[];
    concurrencyErrors: ConcurrencyError[];
  };
  
  // 3. View Layer - UI 렌더링 오류
  viewErrors: {
    renderingErrors: RenderingError[];
    userInteractionErrors: UserInteractionError[];
  };
  
  // 4. System Layer - 시스템 수준 오류
  systemErrors: {
    networkErrors: NetworkError[];
    memoryErrors: MemoryError[];
    configurationErrors: ConfigurationError[];
  };
}
```

### 오류 타입 정의

```typescript
// 기본 오류 인터페이스
interface BaseError {
  code: string;
  message: string;
  timestamp: number;
  severity: 'low' | 'medium' | 'high' | 'critical';
  recoverable: boolean;
  context?: Record<string, any>;
  stackTrace?: string;
}

// 도메인 특화 오류 타입들
export class ValidationError extends Error implements BaseError {
  code = 'VALIDATION_ERROR';
  severity: 'medium' = 'medium';
  recoverable = true;
  timestamp = Date.now();
  
  constructor(
    message: string,
    public field: string,
    public value: any,
    public rule: string,
    public context?: Record<string, any>
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}

export class BusinessLogicError extends Error implements BaseError {
  code: string;
  severity: 'high' = 'high';
  recoverable: boolean;
  timestamp = Date.now();
  
  constructor(
    code: string,
    message: string,
    recoverable = true,
    public context?: Record<string, any>
  ) {
    super(message);
    this.name = 'BusinessLogicError';
    this.code = code;
    this.recoverable = recoverable;
  }
}

export class ExternalServiceError extends Error implements BaseError {
  code = 'EXTERNAL_SERVICE_ERROR';
  severity: 'high' = 'high';
  recoverable = true;
  timestamp = Date.now();
  
  constructor(
    message: string,
    public service: string,
    public statusCode?: number,
    public retryable = true,
    public context?: Record<string, any>
  ) {
    super(message);
    this.name = 'ExternalServiceError';
    this.recoverable = retryable;
  }
}

export class SystemError extends Error implements BaseError {
  code: string;
  severity: 'critical' = 'critical';
  recoverable = false;
  timestamp = Date.now();
  
  constructor(
    code: string,
    message: string,
    public context?: Record<string, any>
  ) {
    super(message);
    this.name = 'SystemError';
    this.code = code;
  }
}
```

## 핸들러 오류 처리

### 1. 구조화된 오류 처리 패턴

```typescript
// 포괄적인 핸들러 오류 처리
function useRobustUserHandlers() {
  const register = useUserActionRegister();
  const registry = useUserStores();
  
  const loginHandler = useCallback(async (
    payload: { email: string; password: string },
    controller: ActionController
  ) => {
    const operation = 'user-login';
    const context = { email: payload.email, timestamp: Date.now() };
    
    try {
      // 1단계: 입력 검증
      await validateLoginInput(payload);
      
      // 2단계: 비즈니스 규칙 검증
      await validateBusinessRules(payload);
      
      // 3단계: 외부 서비스 호출
      const authResult = await performAuthentication(payload);
      
      // 4단계: 상태 업데이트
      await updateUserState(authResult);
      
      return { 
        success: true, 
        user: authResult.user,
        timestamp: Date.now()
      };
      
    } catch (error) {
      return handleLoginError(error, controller, context);
    }
  }, [registry]);
  
  // 오류 처리 전용 함수
  const handleLoginError = (
    error: unknown,
    controller: ActionController,
    context: Record<string, any>
  ) => {
    // 오류 타입별 처리
    if (error instanceof ValidationError) {
      controller.abort(`입력 검증 실패: ${error.message}`, {
        type: 'validation',
        field: error.field,
        value: error.value,
        rule: error.rule,
        ...context
      });
      
      return {
        success: false,
        error: 'VALIDATION_FAILED',
        details: {
          field: error.field,
          message: error.message,
          rule: error.rule
        }
      };
    }
    
    if (error instanceof BusinessLogicError) {
      controller.abort(`비즈니스 로직 오류: ${error.message}`, {
        type: 'business-logic',
        code: error.code,
        recoverable: error.recoverable,
        ...context
      });
      
      return {
        success: false,
        error: error.code,
        recoverable: error.recoverable,
        message: error.message
      };
    }
    
    if (error instanceof ExternalServiceError) {
      controller.abort(`외부 서비스 오류: ${error.message}`, {
        type: 'external-service',
        service: error.service,
        statusCode: error.statusCode,
        retryable: error.retryable,
        ...context
      });
      
      return {
        success: false,
        error: 'EXTERNAL_SERVICE_ERROR',
        service: error.service,
        retryable: error.retryable,
        statusCode: error.statusCode
      };
    }
    
    // 예상치 못한 오류
    const systemError = new SystemError(
      'UNEXPECTED_LOGIN_ERROR',
      error instanceof Error ? error.message : '알 수 없는 로그인 오류',
      { originalError: error, ...context }
    );
    
    controller.abort(systemError.message, {
      type: 'system',
      code: systemError.code,
      severity: systemError.severity,
      ...context
    });
    
    // 시스템 오류 리포팅
    reportSystemError(systemError);
    
    return {
      success: false,
      error: 'SYSTEM_ERROR',
      message: '시스템 오류가 발생했습니다. 잠시 후 다시 시도해주세요.',
      severity: 'critical'
    };
  };
  
  // 핸들러 등록
  useEffect(() => {
    if (!register) return;
    
    const unregister = register('login', loginHandler, {
      id: 'robust-login-handler',
      priority: 100,
      blocking: true,
      onError: (error, context) => {
        // 핸들러 수준 오류 처리
        console.error('핸들러 실행 중 오류:', error, context);
        
        // 심각한 오류는 즉시 보고
        if (error.severity === 'critical') {
          reportCriticalError(error, context);
        }
      }
    });
    
    return unregister;
  }, [register, loginHandler]);
}
```

### 2. 재시도 메커니즘

```typescript
// 지수 백오프를 사용한 재시도 시스템
class RetryManager {
  static async withRetry<T>(
    operation: () => Promise<T>,
    options: {
      maxAttempts?: number;
      baseDelay?: number;
      maxDelay?: number;
      backoffFactor?: number;
      retryCondition?: (error: any) => boolean;
    } = {}
  ): Promise<T> {
    const {
      maxAttempts = 3,
      baseDelay = 1000,
      maxDelay = 10000,
      backoffFactor = 2,
      retryCondition = (error) => error instanceof ExternalServiceError && error.retryable
    } = options;
    
    let lastError: any;
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        
        // 재시도 조건 확인
        if (!retryCondition(error) || attempt === maxAttempts) {
          throw error;
        }
        
        // 지수 백오프 계산
        const delay = Math.min(baseDelay * Math.pow(backoffFactor, attempt - 1), maxDelay);
        
        console.warn(`작업 실패 (시도 ${attempt}/${maxAttempts}), ${delay}ms 후 재시도:`, error);
        
        // 지연 후 재시도
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    
    throw lastError;
  }
}

// 재시도가 적용된 핸들러
function useRetryableHandlers() {
  const register = useUserActionRegister();
  const registry = useUserStores();
  
  const updateProfileHandler = useCallback(async (payload, controller) => {
    try {
      const result = await RetryManager.withRetry(
        async () => {
          // 프로필 업데이트 API 호출
          const response = await fetch('/api/user/profile', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload.data)
          });
          
          if (!response.ok) {
            if (response.status >= 500) {
              throw new ExternalServiceError(
                '서버 오류',
                'user-api',
                response.status,
                true // 재시도 가능
              );
            } else if (response.status === 429) {
              throw new ExternalServiceError(
                '요청 한도 초과',
                'user-api',
                response.status,
                true // 재시도 가능
              );
            } else {
              throw new ExternalServiceError(
                '클라이언트 오류',
                'user-api',
                response.status,
                false // 재시도 불가능
              );
            }
          }
          
          return await response.json();
        },
        {
          maxAttempts: 3,
          baseDelay: 1000,
          retryCondition: (error) => 
            error instanceof ExternalServiceError && 
            error.retryable &&
            [429, 500, 502, 503, 504].includes(error.statusCode || 0)
        }
      );
      
      // 성공 시 상태 업데이트
      const profileStore = registry.getStore('profile');
      profileStore.setValue(result.profile);
      
      return { success: true, profile: result.profile };
      
    } catch (error) {
      controller.abort('프로필 업데이트 실패', { error, retryExhausted: true });
      
      if (error instanceof ExternalServiceError) {
        return {
          success: false,
          error: 'EXTERNAL_SERVICE_ERROR',
          retryable: error.retryable,
          service: error.service
        };
      }
      
      return {
        success: false,
        error: 'UNKNOWN_ERROR',
        message: '프로필 업데이트 중 오류가 발생했습니다.'
      };
    }
  }, [registry]);
  
  useEffect(() => {
    if (!register) return;
    
    const unregister = register('updateProfile', updateProfileHandler, {
      id: 'retryable-profile-updater',
      priority: 100,
      blocking: true
    });
    
    return unregister;
  }, [register, updateProfileHandler]);
}
```

### 3. 회로 차단기 패턴

```typescript
// 회로 차단기 구현
class CircuitBreaker {
  private failures = 0;
  private lastFailureTime = 0;
  private state: 'closed' | 'open' | 'half-open' = 'closed';
  
  constructor(
    private threshold: number = 5,
    private timeout: number = 60000,
    private monitor?: (state: string, error?: any) => void
  ) {}
  
  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === 'open') {
      if (Date.now() - this.lastFailureTime < this.timeout) {
        throw new Error('회로 차단기가 열려있습니다 (Circuit Breaker Open)');
      } else {
        this.state = 'half-open';
        this.monitor?.('half-open');
      }
    }
    
    try {
      const result = await operation();
      
      // 성공 시 회로 재설정
      if (this.state === 'half-open') {
        this.state = 'closed';
        this.failures = 0;
        this.monitor?.('closed');
      }
      
      return result;
      
    } catch (error) {
      this.failures += 1;
      this.lastFailureTime = Date.now();
      
      if (this.failures >= this.threshold) {
        this.state = 'open';
        this.monitor?.('open', error);
      }
      
      throw error;
    }
  }
  
  getState() {
    return {
      state: this.state,
      failures: this.failures,
      lastFailureTime: this.lastFailureTime
    };
  }
  
  reset() {
    this.state = 'closed';
    this.failures = 0;
    this.lastFailureTime = 0;
    this.monitor?.('reset');
  }
}

// 회로 차단기가 적용된 핸들러
function useCircuitBreakerHandlers() {
  const register = useUserActionRegister();
  const registry = useUserStores();
  
  // 외부 서비스별 회로 차단기
  const userApiCircuitBreaker = useMemo(
    () => new CircuitBreaker(3, 30000, (state, error) => {
      console.log(`사용자 API 회로 차단기 상태 변경: ${state}`, error);
      
      if (state === 'open') {
        // 회로가 열렸을 때 사용자에게 알림
        showNotification('사용자 서비스에 일시적인 문제가 있습니다. 잠시 후 다시 시도해주세요.');
      }
    }),
    []
  );
  
  const loadUserDataHandler = useCallback(async (payload, controller) => {
    try {
      const result = await userApiCircuitBreaker.execute(async () => {
        const response = await fetch(`/api/users/${payload.userId}`);
        
        if (!response.ok) {
          throw new ExternalServiceError(
            `사용자 데이터 로드 실패: ${response.status}`,
            'user-api',
            response.status
          );
        }
        
        return await response.json();
      });
      
      // 스토어 업데이트
      const profileStore = registry.getStore('profile');
      profileStore.setValue(result.profile);
      
      return { success: true, user: result };
      
    } catch (error) {
      if (error.message.includes('Circuit Breaker Open')) {
        controller.abort('서비스 일시 중단', {
          type: 'circuit-breaker',
          service: 'user-api',
          state: userApiCircuitBreaker.getState()
        });
        
        return {
          success: false,
          error: 'SERVICE_UNAVAILABLE',
          message: '사용자 서비스가 일시적으로 중단되었습니다.',
          retryAfter: 30000
        };
      }
      
      throw error;
    }
  }, [registry, userApiCircuitBreaker]);
  
  useEffect(() => {
    if (!register) return;
    
    const unregister = register('loadUserData', loadUserDataHandler, {
      id: 'circuit-breaker-user-loader',
      priority: 100,
      blocking: true
    });
    
    return unregister;
  }, [register, loadUserDataHandler]);
}
```

## React 컴포넌트 오류 처리

### 1. 오류 경계 구현

```typescript
// 도메인별 오류 경계
interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: React.ErrorInfo | null;
}

class UserDomainErrorBoundary extends React.Component<
  { children: React.ReactNode; fallback?: React.ComponentType<any> },
  ErrorBoundaryState
> {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null
    };
  }
  
  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    return {
      hasError: true,
      error
    };
  }
  
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    this.setState({
      error,
      errorInfo
    });
    
    // 오류 리포팅
    reportComponentError('UserDomain', error, errorInfo);
    
    // 심각도 분류
    const severity = this.classifyError(error);
    
    if (severity === 'critical') {
      // 시스템 관리자에게 즉시 알림
      alertSystemAdministrator(error, errorInfo);
    }
  }
  
  private classifyError(error: Error): 'low' | 'medium' | 'high' | 'critical' {
    if (error.name === 'ChunkLoadError') return 'medium';
    if (error.message.includes('Network Error')) return 'medium';
    if (error.message.includes('Out of memory')) return 'critical';
    if (error.stack?.includes('useState') || error.stack?.includes('useEffect')) return 'high';
    
    return 'medium';
  }
  
  private handleRetry = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null
    });
  };
  
  private handleReload = () => {
    window.location.reload();
  };
  
  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback || DefaultErrorFallback;
      
      return (
        <FallbackComponent
          error={this.state.error}
          errorInfo={this.state.errorInfo}
          onRetry={this.handleRetry}
          onReload={this.handleReload}
        />
      );
    }
    
    return this.props.children;
  }
}

// 기본 오류 폴백 컴포넌트
function DefaultErrorFallback({
  error,
  errorInfo,
  onRetry,
  onReload
}: {
  error: Error | null;
  errorInfo: React.ErrorInfo | null;
  onRetry: () => void;
  onReload: () => void;
}) {
  return (
    <div className="error-fallback">
      <div className="error-content">
        <h2>오류가 발생했습니다</h2>
        <p>사용자 인터페이스에 문제가 발생했습니다.</p>
        
        <div className="error-details">
          <details>
            <summary>기술적 세부사항</summary>
            <pre>{error?.message}</pre>
            {process.env.NODE_ENV === 'development' && (
              <pre>{error?.stack}</pre>
            )}
          </details>
        </div>
        
        <div className="error-actions">
          <button onClick={onRetry} className="btn-retry">
            다시 시도
          </button>
          <button onClick={onReload} className="btn-reload">
            페이지 새로고침
          </button>
        </div>
      </div>
    </div>
  );
}

// 특화된 오류 폴백들
function NetworkErrorFallback({ onRetry }: { onRetry: () => void }) {
  return (
    <div className="error-fallback network-error">
      <h3>네트워크 연결 오류</h3>
      <p>인터넷 연결을 확인해주세요.</p>
      <button onClick={onRetry}>재연결 시도</button>
    </div>
  );
}

function ValidationErrorFallback({ error, onRetry }: { 
  error: ValidationError;
  onRetry: () => void;
}) {
  return (
    <div className="error-fallback validation-error">
      <h3>입력 오류</h3>
      <p>{error.message}</p>
      <p>필드: {error.field}</p>
      <button onClick={onRetry}>수정하기</button>
    </div>
  );
}
```

### 2. 훅 기반 오류 처리

```typescript
// 전역 오류 상태 관리
interface GlobalErrorState {
  errors: Array<{
    id: string;
    error: BaseError;
    timestamp: number;
    acknowledged: boolean;
  }>;
  criticalErrors: BaseError[];
}

function useGlobalErrorHandler() {
  const [errorState, setErrorState] = useState<GlobalErrorState>({
    errors: [],
    criticalErrors: []
  });
  
  const addError = useCallback((error: BaseError) => {
    const errorEntry = {
      id: generateId(),
      error,
      timestamp: Date.now(),
      acknowledged: false
    };
    
    setErrorState(prev => ({
      ...prev,
      errors: [errorEntry, ...prev.errors.slice(0, 49)], // 최대 50개 유지
      criticalErrors: error.severity === 'critical' 
        ? [error, ...prev.criticalErrors.slice(0, 9)] // 최대 10개 유지
        : prev.criticalErrors
    }));
    
    // 심각한 오류는 즉시 처리
    if (error.severity === 'critical') {
      handleCriticalError(error);
    }
    
    // 자동 만료 (5분)
    setTimeout(() => {
      removeError(errorEntry.id);
    }, 5 * 60 * 1000);
    
  }, []);
  
  const removeError = useCallback((id: string) => {
    setErrorState(prev => ({
      ...prev,
      errors: prev.errors.filter(e => e.id !== id)
    }));
  }, []);
  
  const acknowledgeError = useCallback((id: string) => {
    setErrorState(prev => ({
      ...prev,
      errors: prev.errors.map(e => 
        e.id === id ? { ...e, acknowledged: true } : e
      )
    }));
  }, []);
  
  const clearAllErrors = useCallback(() => {
    setErrorState({
      errors: [],
      criticalErrors: []
    });
  }, []);
  
  return {
    errorState,
    addError,
    removeError,
    acknowledgeError,
    clearAllErrors
  };
}

// 액션별 오류 처리 훅
function useActionErrorHandler(actionName: string) {
  const { addError } = useGlobalErrorHandler();
  const [localError, setLocalError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  
  const dispatch = useUserAction();
  
  const executeAction = useCallback(async (payload: any) => {
    setIsLoading(true);
    setLocalError(null);
    
    try {
      const result = await dispatch(actionName, payload);
      
      if (!result.success) {
        const error = new BusinessLogicError(
          result.error || 'UNKNOWN_ERROR',
          result.message || '작업 실행 실패',
          result.recoverable !== false
        );
        
        addError(error);
        setLocalError(result.message || '작업 실행 실패');
      }
      
      return result;
      
    } catch (error) {
      const handledError = error instanceof Error 
        ? new SystemError('ACTION_EXECUTION_ERROR', error.message)
        : new SystemError('UNKNOWN_ACTION_ERROR', '알 수 없는 오류 발생');
      
      addError(handledError);
      setLocalError(handledError.message);
      
      throw handledError;
    } finally {
      setIsLoading(false);
    }
  }, [actionName, dispatch, addError]);
  
  const clearLocalError = useCallback(() => {
    setLocalError(null);
  }, []);
  
  return {
    executeAction,
    localError,
    isLoading,
    clearLocalError
  };
}

// 사용법 예시
function UserProfileForm() {
  const { executeAction, localError, isLoading, clearLocalError } = useActionErrorHandler('updateProfile');
  const [formData, setFormData] = useState({ name: '', email: '' });
  
  const handleSubmit = useCallback(async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      await executeAction({ data: formData });
      // 성공 처리
      showSuccessMessage('프로필이 업데이트되었습니다.');
    } catch (error) {
      // 오류는 이미 useActionErrorHandler에서 처리됨
      console.error('프로필 업데이트 실패:', error);
    }
  }, [executeAction, formData]);
  
  return (
    <form onSubmit={handleSubmit}>
      {localError && (
        <div className="error-message">
          {localError}
          <button onClick={clearLocalError}>×</button>
        </div>
      )}
      
      <input
        value={formData.name}
        onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
        placeholder="이름"
      />
      
      <input
        value={formData.email}
        onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
        placeholder="이메일"
        type="email"
      />
      
      <button type="submit" disabled={isLoading}>
        {isLoading ? '저장 중...' : '저장'}
      </button>
    </form>
  );
}
```

## 모니터링과 리포팅

### 1. 오류 수집과 분석

```typescript
// 오류 수집기
class ErrorCollector {
  private static instance: ErrorCollector;
  private errors: BaseError[] = [];
  private reportingEndpoint = '/api/errors';
  
  static getInstance() {
    if (!this.instance) {
      this.instance = new ErrorCollector();
    }
    return this.instance;
  }
  
  collect(error: BaseError, context?: Record<string, any>) {
    const enrichedError = {
      ...error,
      context: {
        ...error.context,
        ...context,
        userAgent: navigator.userAgent,
        url: window.location.href,
        timestamp: Date.now(),
        sessionId: getSessionId()
      }
    };
    
    this.errors.push(enrichedError);
    
    // 즉시 보고가 필요한 오류들
    if (error.severity === 'critical' || this.shouldReportImmediately(error)) {
      this.reportImmediately(enrichedError);
    }
    
    // 배치 보고 (최대 10개 또는 5분마다)
    if (this.errors.length >= 10) {
      this.flushErrors();
    }
  }
  
  private shouldReportImmediately(error: BaseError): boolean {
    return (
      error.code === 'AUTHENTICATION_FAILURE' ||
      error.code === 'SECURITY_VIOLATION' ||
      error.code === 'DATA_CORRUPTION' ||
      error.severity === 'high'
    );
  }
  
  private async reportImmediately(error: BaseError) {
    try {
      await fetch(this.reportingEndpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          errors: [error],
          immediate: true,
          priority: 'high'
        })
      });
    } catch (reportingError) {
      console.error('즉시 오류 보고 실패:', reportingError);
    }
  }
  
  private async flushErrors() {
    if (this.errors.length === 0) return;
    
    const errorsToReport = [...this.errors];
    this.errors = [];
    
    try {
      await fetch(this.reportingEndpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          errors: errorsToReport,
          immediate: false,
          priority: 'normal'
        })
      });
    } catch (reportingError) {
      console.error('배치 오류 보고 실패:', reportingError);
      // 실패한 오류들을 다시 큐에 추가
      this.errors.unshift(...errorsToReport);
    }
  }
  
  // 주기적 플러시 설정
  startPeriodicFlush(interval = 5 * 60 * 1000) { // 5분
    setInterval(() => {
      this.flushErrors();
    }, interval);
  }
}

// 전역 오류 수집 설정
function setupGlobalErrorCollection() {
  const collector = ErrorCollector.getInstance();
  collector.startPeriodicFlush();
  
  // 처리되지 않은 Promise 거부
  window.addEventListener('unhandledrejection', (event) => {
    const error = new SystemError(
      'UNHANDLED_PROMISE_REJECTION',
      event.reason?.message || '처리되지 않은 Promise 거부',
      { reason: event.reason }
    );
    
    collector.collect(error);
  });
  
  // 전역 JavaScript 오류
  window.addEventListener('error', (event) => {
    const error = new SystemError(
      'GLOBAL_JAVASCRIPT_ERROR',
      event.message,
      {
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack
      }
    );
    
    collector.collect(error);
  });
}
```

### 2. 성능 영향 모니터링

```typescript
// 오류가 성능에 미치는 영향 추적
interface PerformanceImpact {
  errorType: string;
  performanceMetrics: {
    renderTime: number;
    handlerExecutionTime: number;
    memoryUsage: number;
    userInteractionDelay: number;
  };
  userExperienceMetrics: {
    taskCompletionRate: number;
    userSatisfactionScore: number;
    bounceRate: number;
  };
}

class ErrorPerformanceMonitor {
  private impacts: PerformanceImpact[] = [];
  
  recordErrorImpact(error: BaseError, metrics: Partial<PerformanceImpact>) {
    const impact: PerformanceImpact = {
      errorType: error.code,
      performanceMetrics: {
        renderTime: 0,
        handlerExecutionTime: 0,
        memoryUsage: 0,
        userInteractionDelay: 0,
        ...metrics.performanceMetrics
      },
      userExperienceMetrics: {
        taskCompletionRate: 1,
        userSatisfactionScore: 5,
        bounceRate: 0,
        ...metrics.userExperienceMetrics
      }
    };
    
    this.impacts.push(impact);
    
    // 성능 임계값 초과 시 알림
    this.checkPerformanceThresholds(impact);
  }
  
  private checkPerformanceThresholds(impact: PerformanceImpact) {
    const thresholds = {
      renderTime: 100, // ms
      handlerExecutionTime: 1000, // ms
      memoryUsage: 50, // MB
      userInteractionDelay: 200, // ms
      taskCompletionRate: 0.8, // 80%
      userSatisfactionScore: 3, // 1-5 scale
      bounceRate: 0.3 // 30%
    };
    
    const violations: string[] = [];
    
    Object.entries(thresholds).forEach(([metric, threshold]) => {
      const value = impact.performanceMetrics[metric] || impact.userExperienceMetrics[metric];
      
      if (
        (metric === 'taskCompletionRate' || metric === 'userSatisfactionScore') ? 
        value < threshold : 
        value > threshold
      ) {
        violations.push(`${metric}: ${value}`);
      }
    });
    
    if (violations.length > 0) {
      console.warn(`성능 임계값 초과 (오류: ${impact.errorType}):`, violations);
      
      // 심각한 성능 저하 시 알림
      if (violations.length >= 3) {
        reportPerformanceDegradation(impact, violations);
      }
    }
  }
  
  getErrorPerformanceReport() {
    const groupedByType = this.impacts.reduce((acc, impact) => {
      if (!acc[impact.errorType]) {
        acc[impact.errorType] = [];
      }
      acc[impact.errorType].push(impact);
      return acc;
    }, {} as Record<string, PerformanceImpact[]>);
    
    return Object.entries(groupedByType).map(([errorType, impacts]) => {
      const avgPerformance = this.calculateAverageMetrics(impacts.map(i => i.performanceMetrics));
      const avgUserExperience = this.calculateAverageMetrics(impacts.map(i => i.userExperienceMetrics));
      
      return {
        errorType,
        frequency: impacts.length,
        averagePerformanceImpact: avgPerformance,
        averageUserExperienceImpact: avgUserExperience,
        severity: this.calculateSeverity(avgPerformance, avgUserExperience)
      };
    });
  }
  
  private calculateAverageMetrics(metricsList: any[]) {
    const keys = Object.keys(metricsList[0] || {});
    const averages = {};
    
    keys.forEach(key => {
      const sum = metricsList.reduce((acc, metrics) => acc + (metrics[key] || 0), 0);
      averages[key] = sum / metricsList.length;
    });
    
    return averages;
  }
  
  private calculateSeverity(perfMetrics: any, uxMetrics: any): 'low' | 'medium' | 'high' {
    const perfScore = (perfMetrics.renderTime > 100 ? 1 : 0) +
                     (perfMetrics.handlerExecutionTime > 1000 ? 1 : 0) +
                     (perfMetrics.memoryUsage > 50 ? 1 : 0);
    
    const uxScore = (uxMetrics.taskCompletionRate < 0.8 ? 1 : 0) +
                   (uxMetrics.userSatisfactionScore < 3 ? 1 : 0) +
                   (uxMetrics.bounceRate > 0.3 ? 1 : 0);
    
    const totalScore = perfScore + uxScore;
    
    if (totalScore >= 4) return 'high';
    if (totalScore >= 2) return 'medium';
    return 'low';
  }
}
```

## 복구 전략

### 1. 자동 복구 메커니즘

```typescript
// 자동 복구 관리자
class RecoveryManager {
  private recoveryStrategies = new Map<string, (error: BaseError) => Promise<boolean>>();
  
  registerRecoveryStrategy(errorCode: string, strategy: (error: BaseError) => Promise<boolean>) {
    this.recoveryStrategies.set(errorCode, strategy);
  }
  
  async attemptRecovery(error: BaseError): Promise<boolean> {
    const strategy = this.recoveryStrategies.get(error.code);
    
    if (!strategy) {
      console.warn(`복구 전략이 없습니다: ${error.code}`);
      return false;
    }
    
    try {
      console.log(`복구 시도 중: ${error.code}`);
      const recovered = await strategy(error);
      
      if (recovered) {
        console.log(`복구 성공: ${error.code}`);
        reportRecoverySuccess(error);
      } else {
        console.warn(`복구 실패: ${error.code}`);
        reportRecoveryFailure(error);
      }
      
      return recovered;
    } catch (recoveryError) {
      console.error(`복구 전략 실행 중 오류 발생:`, recoveryError);
      reportRecoveryError(error, recoveryError);
      return false;
    }
  }
}

// 복구 전략들
const recoveryManager = new RecoveryManager();

// 네트워크 오류 복구
recoveryManager.registerRecoveryStrategy('NETWORK_ERROR', async (error) => {
  // 연결 상태 확인
  if (!navigator.onLine) {
    return false; // 오프라인 상태에서는 복구 불가능
  }
  
  // 간단한 ping 테스트
  try {
    const response = await fetch('/api/health', { 
      method: 'HEAD',
      cache: 'no-cache'
    });
    return response.ok;
  } catch {
    return false;
  }
});

// 인증 오류 복구
recoveryManager.registerRecoveryStrategy('AUTHENTICATION_ERROR', async (error) => {
  try {
    // 토큰 갱신 시도
    const refreshResponse = await fetch('/api/auth/refresh', {
      method: 'POST',
      credentials: 'include'
    });
    
    if (refreshResponse.ok) {
      const newTokens = await refreshResponse.json();
      // 새 토큰으로 업데이트
      localStorage.setItem('accessToken', newTokens.accessToken);
      return true;
    }
  } catch (refreshError) {
    console.error('토큰 갱신 실패:', refreshError);
  }
  
  // 갱신 실패 시 로그인 페이지로 리다이렉트
  window.location.href = '/login';
  return false;
});

// 상태 불일치 복구
recoveryManager.registerRecoveryStrategy('STATE_INCONSISTENCY', async (error) => {
  try {
    // 서버에서 최신 상태 가져오기
    const response = await fetch('/api/user/current');
    const latestUserData = await response.json();
    
    // 로컬 상태 재설정
    const userStore = getUserStore();
    userStore.setValue(latestUserData);
    
    return true;
  } catch (syncError) {
    console.error('상태 동기화 실패:', syncError);
    return false;
  }
});

// 메모리 부족 복구
recoveryManager.registerRecoveryStrategy('OUT_OF_MEMORY', async (error) => {
  try {
    // 캐시 정리
    clearApplicationCaches();
    
    // 가비지 컬렉션 강제 실행 (가능한 경우)
    if (window.gc) {
      window.gc();
    }
    
    // 메모리 사용량 재확인
    if ('memory' in performance) {
      const memory = (performance as any).memory;
      const usedMB = memory.usedJSHeapSize / 1024 / 1024;
      
      return usedMB < 100; // 100MB 미만으로 감소했는지 확인
    }
    
    return true;
  } catch (cleanupError) {
    console.error('메모리 정리 실패:', cleanupError);
    return false;
  }
});
```

### 2. 우아한 성능 저하

```typescript
// 성능 저하 관리자
class GracefulDegradationManager {
  private currentMode: 'normal' | 'degraded' | 'minimal' = 'normal';
  private degradationTriggers: Array<{
    condition: () => boolean;
    mode: 'degraded' | 'minimal';
    description: string;
  }> = [];
  
  addDegradationTrigger(
    condition: () => boolean,
    mode: 'degraded' | 'minimal',
    description: string
  ) {
    this.degradationTriggers.push({ condition, mode, description });
  }
  
  checkDegradationConditions() {
    let targetMode: 'normal' | 'degraded' | 'minimal' = 'normal';
    let triggerDescription = '';
    
    for (const trigger of this.degradationTriggers) {
      if (trigger.condition()) {
        if (trigger.mode === 'minimal' || targetMode === 'normal') {
          targetMode = trigger.mode;
          triggerDescription = trigger.description;
        }
      }
    }
    
    if (targetMode !== this.currentMode) {
      this.switchMode(targetMode, triggerDescription);
    }
  }
  
  private switchMode(mode: 'normal' | 'degraded' | 'minimal', reason: string) {
    console.log(`성능 모드 변경: ${this.currentMode} → ${mode} (이유: ${reason})`);
    
    this.currentMode = mode;
    
    // 애플리케이션에 모드 변경 알림
    window.dispatchEvent(new CustomEvent('performance-mode-change', {
      detail: { mode, reason }
    }));
    
    // UI 알림
    if (mode !== 'normal') {
      showNotification(
        `성능 최적화를 위해 일부 기능이 제한됩니다. (이유: ${reason})`,
        'warning'
      );
    }
  }
  
  getCurrentMode() {
    return this.currentMode;
  }
  
  isNormalMode() {
    return this.currentMode === 'normal';
  }
  
  isDegradedMode() {
    return this.currentMode === 'degraded';
  }
  
  isMinimalMode() {
    return this.currentMode === 'minimal';
  }
}

// 성능 저하 조건들
const degradationManager = new GracefulDegradationManager();

// 메모리 부족
degradationManager.addDegradationTrigger(
  () => {
    if ('memory' in performance) {
      const memory = (performance as any).memory;
      return memory.usedJSHeapSize / memory.jsHeapSizeLimit > 0.8;
    }
    return false;
  },
  'degraded',
  '메모리 부족'
);

// 네트워크 속도 저하
degradationManager.addDegradationTrigger(
  () => {
    const connection = (navigator as any).connection;
    return connection && (
      connection.effectiveType === 'slow-2g' || 
      connection.effectiveType === '2g'
    );
  },
  'minimal',
  '네트워크 속도 저하'
);

// 오류 발생률 높음
let errorCount = 0;
let lastErrorReset = Date.now();

degradationManager.addDegradationTrigger(
  () => {
    const now = Date.now();
    
    // 1분마다 오류 횟수 리셋
    if (now - lastErrorReset > 60000) {
      errorCount = 0;
      lastErrorReset = now;
    }
    
    // 분당 5개 이상의 오류
    return errorCount > 5;
  },
  'degraded',
  '높은 오류 발생률'
);

// 주기적 성능 모드 체크
setInterval(() => {
  degradationManager.checkDegradationConditions();
}, 10000); // 10초마다

// 성능 모드에 따른 컴포넌트 동작
function PerformanceAwareComponent() {
  const [performanceMode, setPerformanceMode] = useState(degradationManager.getCurrentMode());
  
  useEffect(() => {
    const handleModeChange = (event: CustomEvent) => {
      setPerformanceMode(event.detail.mode);
    };
    
    window.addEventListener('performance-mode-change', handleModeChange as EventListener);
    return () => window.removeEventListener('performance-mode-change', handleModeChange as EventListener);
  }, []);
  
  // 성능 모드에 따른 렌더링
  if (degradationManager.isMinimalMode()) {
    return <MinimalModeComponent />;
  }
  
  if (degradationManager.isDegradedMode()) {
    return <DegradedModeComponent />;
  }
  
  return <FullFeatureComponent />;
}
```

---

## 모범 사례 체크리스트

### ✅ 오류 분류와 처리
- [ ] 오류 타입별 적절한 처리 전략
- [ ] 심각도 분류와 우선순위 설정
- [ ] 복구 가능성에 따른 분류
- [ ] 사용자 친화적인 오류 메시지

### ✅ 핸들러 오류 처리
- [ ] 구조화된 오류 처리 패턴
- [ ] 재시도 메커니즘 구현
- [ ] 회로 차단기 패턴 적용
- [ ] 적절한 오류 로깅

### ✅ UI 오류 처리
- [ ] 오류 경계 구현
- [ ] 폴백 컴포넌트 제공
- [ ] 사용자 액션별 오류 처리
- [ ] 로딩과 오류 상태 관리

### ✅ 모니터링과 리포팅
- [ ] 오류 수집과 분석
- [ ] 성능 영향 추적
- [ ] 자동 알림 시스템
- [ ] 오류 트렌드 분석

### ✅ 복구와 성능 저하
- [ ] 자동 복구 전략
- [ ] 우아한 성능 저하
- [ ] 상태 동기화 메커니즘
- [ ] 사용자 경험 보호

---

## 요약

효과적인 오류 처리는 다음 원칙을 따릅니다:

- **예방 우선** - 오류 발생을 미리 방지
- **빠른 감지** - 오류를 즉시 인식하고 분류
- **자동 복구** - 가능한 경우 자동으로 복구 시도
- **사용자 경험 보호** - 오류가 사용자에게 미치는 영향 최소화
- **지속적인 개선** - 오류 패턴 분석으로 시스템 개선

체계적인 오류 처리를 통해 안정적이고 신뢰할 수 있는 애플리케이션을 구축할 수 있습니다.

---

::: tip 다음 단계
- [공통 함정](./common-pitfalls) - 오류 처리 시 흔히 하는 실수들
- [모범 사례](./best-practices) - 프로덕션 환경 오류 처리 권장사항
:::

---


# Guide Handler Id Strategies

**Source**: `guide/handler-id-strategies.md`  
**Priority**: 80 (essential)  

# 핸들러 ID 전략

핸들러 ID는 Context-Action 프레임워크에서 핸들러를 식별하고 관리하는 핵심 메커니즘입니다. 효과적인 ID 전략은 디버깅, 모니터링, 그리고 핸들러 관리를 크게 개선합니다.

## 핸들러 ID 기본 개념

### 자동 생성 vs 명시적 ID

```typescript
// 자동 생성 ID (기본값)
register('updateProfile', handler, {
  priority: 100,
  blocking: true
  // id 없음 - 프레임워크가 자동 생성
});

// 명시적 ID (권장)
register('updateProfile', handler, {
  priority: 100,
  blocking: true,
  id: 'profile-updater' // 명시적 ID 지정
});
```

### ID 생성 규칙

프레임워크는 다음 순서로 ID를 결정합니다:

1. **명시적 ID**: 사용자가 제공한 `id` 값
2. **자동 생성**: `{액션명}-{핸들러번호}` 형식

```typescript
// 명시적 ID 예시
register('login', loginHandler, { 
  id: 'user-authentication-handler' 
});

// 자동 생성 ID 예시 (login-1, login-2, ...)
register('login', validationHandler);
register('login', mainHandler);
```

## ID 명명 규칙

### 1. 일관된 명명 컨벤션

```typescript
// ✅ 권장: 도메인-기능-역할 패턴
register('updateProfile', handler, { 
  id: 'user-profile-updater' 
});

register('validateProfile', handler, { 
  id: 'user-profile-validator' 
});

register('logProfileUpdate', handler, { 
  id: 'user-profile-logger' 
});

// ✅ 권장: 카테고리별 그룹화
register('login', authHandler, { 
  id: 'auth-login-main' 
});

register('login', auditHandler, { 
  id: 'audit-login-tracker' 
});

register('login', metricsHandler, { 
  id: 'metrics-login-counter' 
});
```

### 2. 계층적 명명 구조

```typescript
// 계층적 구조로 핸들러 조직화
const HandlerIds = {
  User: {
    Auth: {
      LOGIN_MAIN: 'user-auth-login-main',
      LOGIN_VALIDATOR: 'user-auth-login-validator',
      LOGOUT_MAIN: 'user-auth-logout-main'
    },
    Profile: {
      UPDATE_MAIN: 'user-profile-update-main',
      UPDATE_VALIDATOR: 'user-profile-update-validator',
      DELETE_MAIN: 'user-profile-delete-main'
    }
  },
  Cart: {
    Items: {
      ADD_MAIN: 'cart-items-add-main',
      REMOVE_MAIN: 'cart-items-remove-main',
      UPDATE_QUANTITY: 'cart-items-update-quantity'
    }
  }
} as const;

// 사용법
register('login', loginHandler, { 
  id: HandlerIds.User.Auth.LOGIN_MAIN,
  priority: 100 
});

register('updateProfile', updateHandler, { 
  id: HandlerIds.User.Profile.UPDATE_MAIN,
  priority: 100 
});
```

### 3. 환경별 ID 전략

```typescript
// 환경별 ID 접두사
const getHandlerId = (baseId: string, environment?: string) => {
  const env = environment || process.env.NODE_ENV || 'development';
  return `${env}-${baseId}`;
};

// 개발 환경: dev-user-profile-updater
// 프로덕션: prod-user-profile-updater
register('updateProfile', handler, {
  id: getHandlerId('user-profile-updater'),
  priority: 100
});
```

## 고급 ID 패턴

### 1. 동적 ID 생성

```typescript
// 사용자별 동적 핸들러
function createUserSpecificHandler(userId: string) {
  const handlerId = `user-${userId}-profile-updater`;
  
  return {
    id: handlerId,
    handler: async (payload, controller) => {
      // 특정 사용자를 위한 로직
      console.log(`Processing for user ${userId}`);
      // ...
    }
  };
}

// 등록
function useUserSpecificHandlers(userId: string) {
  const register = useUserActionRegister();
  
  useEffect(() => {
    if (!register || !userId) return;
    
    const { id, handler } = createUserSpecificHandler(userId);
    const unregister = register('updateProfile', handler, {
      id,
      priority: 100,
      tags: ['user-specific', userId]
    });
    
    return unregister;
  }, [register, userId]);
}
```

### 2. 버전 관리 ID

```typescript
// 핸들러 버전 관리
const HandlerVersions = {
  PROFILE_UPDATER_V1: 'user-profile-updater-v1',
  PROFILE_UPDATER_V2: 'user-profile-updater-v2',
  PROFILE_UPDATER_CURRENT: 'user-profile-updater-v2' // 현재 버전
} as const;

// 버전별 핸들러 등록
register('updateProfile', legacyHandler, {
  id: HandlerVersions.PROFILE_UPDATER_V1,
  priority: 90,
  deprecated: true
});

register('updateProfile', newHandler, {
  id: HandlerVersions.PROFILE_UPDATER_V2,
  priority: 100,
  version: '2.0.0'
});

// 기능 플래그와 결합
const useVersionedHandler = (useV2: boolean) => {
  const handlerId = useV2 
    ? HandlerVersions.PROFILE_UPDATER_V2 
    : HandlerVersions.PROFILE_UPDATER_V1;
    
  register('updateProfile', 
    useV2 ? newHandler : legacyHandler, 
    { id: handlerId, priority: 100 }
  );
};
```

### 3. 조건부 핸들러 ID

```typescript
// 조건에 따른 다른 핸들러
function useConditionalHandlers(userRole: 'admin' | 'user' | 'guest') {
  const register = useUserActionRegister();
  
  useEffect(() => {
    if (!register) return;
    
    const unregisterFunctions: Array<() => void> = [];
    
    // 기본 핸들러 (모든 역할)
    unregisterFunctions.push(
      register('updateProfile', baseHandler, {
        id: `profile-updater-${userRole}`,
        priority: 100
      })
    );
    
    // 관리자 전용 핸들러
    if (userRole === 'admin') {
      unregisterFunctions.push(
        register('updateProfile', adminAuditHandler, {
          id: 'profile-updater-admin-audit',
          priority: 150
        })
      );
    }
    
    // 일반 사용자 전용 핸들러
    if (userRole === 'user') {
      unregisterFunctions.push(
        register('updateProfile', userValidationHandler, {
          id: 'profile-updater-user-validation',
          priority: 110
        })
      );
    }
    
    return () => {
      unregisterFunctions.forEach(unregister => unregister());
    };
  }, [register, userRole]);
}
```

## 핸들러 발견과 관리

### 1. 핸들러 레지스트리 조회

```typescript
// 등록된 핸들러 정보 조회
function useHandlerInspector() {
  const registry = useUserActionRegister();
  
  const getHandlerInfo = useCallback((actionName: string) => {
    if (!registry) return [];
    
    // 특정 액션의 모든 핸들러 정보 조회
    return registry.getHandlers(actionName).map(handler => ({
      id: handler.id,
      priority: handler.priority,
      blocking: handler.blocking,
      tags: handler.tags,
      category: handler.category
    }));
  }, [registry]);
  
  const getAllHandlers = useCallback(() => {
    if (!registry) return {};
    
    // 모든 등록된 핸들러 정보
    return registry.getAllHandlers();
  }, [registry]);
  
  return { getHandlerInfo, getAllHandlers };
}

// 사용법
function HandlerDebugPanel() {
  const { getHandlerInfo, getAllHandlers } = useHandlerInspector();
  const [selectedAction, setSelectedAction] = useState('updateProfile');
  
  const handlers = getHandlerInfo(selectedAction);
  const allHandlers = getAllHandlers();
  
  return (
    <div>
      <h3>핸들러 검사기</h3>
      
      <select 
        value={selectedAction} 
        onChange={(e) => setSelectedAction(e.target.value)}
      >
        {Object.keys(allHandlers).map(action => (
          <option key={action} value={action}>{action}</option>
        ))}
      </select>
      
      <div>
        <h4>{selectedAction} 핸들러들:</h4>
        {handlers.map(handler => (
          <div key={handler.id}>
            <strong>{handler.id}</strong> 
            (우선순위: {handler.priority}, 
             블로킹: {handler.blocking ? 'Yes' : 'No'})
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 2. 핸들러 태깅 시스템

```typescript
// 태그 기반 핸들러 분류
const HandlerTags = {
  BUSINESS_LOGIC: 'business-logic',
  VALIDATION: 'validation',
  AUDIT: 'audit',
  METRICS: 'metrics',
  CACHE: 'cache',
  NOTIFICATION: 'notification'
} as const;

// 태그와 함께 핸들러 등록
register('updateProfile', validationHandler, {
  id: 'profile-validation',
  priority: 200,
  tags: [HandlerTags.VALIDATION, 'user-input'],
  category: 'validation'
});

register('updateProfile', businessHandler, {
  id: 'profile-business',
  priority: 100,
  tags: [HandlerTags.BUSINESS_LOGIC, 'core'],
  category: 'business'
});

register('updateProfile', auditHandler, {
  id: 'profile-audit',
  priority: 50,
  tags: [HandlerTags.AUDIT, 'security'],
  category: 'audit',
  blocking: false
});

// 태그 기반 쿼리
function useHandlersByTag(tag: string) {
  const registry = useUserActionRegister();
  
  return useCallback(() => {
    if (!registry) return [];
    
    return registry.getHandlersByTag(tag);
  }, [registry, tag]);
}
```

### 3. 핸들러 메트릭스

```typescript
// 핸들러 성능 추적
interface HandlerMetrics {
  id: string;
  executionCount: number;
  averageExecutionTime: number;
  errorCount: number;
  lastExecutionTime: number;
}

class HandlerMetricsCollector {
  private metrics = new Map<string, HandlerMetrics>();
  
  recordExecution(handlerId: string, executionTime: number, hasError = false) {
    const existing = this.metrics.get(handlerId) || {
      id: handlerId,
      executionCount: 0,
      averageExecutionTime: 0,
      errorCount: 0,
      lastExecutionTime: 0
    };
    
    existing.executionCount += 1;
    existing.averageExecutionTime = (
      (existing.averageExecutionTime * (existing.executionCount - 1)) + executionTime
    ) / existing.executionCount;
    
    if (hasError) {
      existing.errorCount += 1;
    }
    
    existing.lastExecutionTime = Date.now();
    this.metrics.set(handlerId, existing);
  }
  
  getMetrics(handlerId: string): HandlerMetrics | undefined {
    return this.metrics.get(handlerId);
  }
  
  getAllMetrics(): HandlerMetrics[] {
    return Array.from(this.metrics.values());
  }
}

// 메트릭스 수집 핸들러
const metricsCollector = new HandlerMetricsCollector();

const createMetricsWrapper = (handlerId: string, originalHandler: Function) => {
  return async (payload: any, controller: any) => {
    const startTime = performance.now();
    let hasError = false;
    
    try {
      const result = await originalHandler(payload, controller);
      return result;
    } catch (error) {
      hasError = true;
      throw error;
    } finally {
      const executionTime = performance.now() - startTime;
      metricsCollector.recordExecution(handlerId, executionTime, hasError);
    }
  };
};
```

## 디버깅과 모니터링

### 1. 핸들러 실행 추적

```typescript
// 핸들러 실행 로깅
const createLoggingWrapper = (handlerId: string, originalHandler: Function) => {
  return async (payload: any, controller: any) => {
    console.group(`🔧 Handler: ${handlerId}`);
    console.log('Payload:', payload);
    console.time(`Handler ${handlerId}`);
    
    try {
      const result = await originalHandler(payload, controller);
      console.log('Result:', result);
      console.log('✅ Handler completed successfully');
      return result;
    } catch (error) {
      console.error('❌ Handler failed:', error);
      throw error;
    } finally {
      console.timeEnd(`Handler ${handlerId}`);
      console.groupEnd();
    }
  };
};

// 개발 환경에서 자동 래핑
const registerWithLogging = (action: string, handler: Function, config: any) => {
  const wrappedHandler = process.env.NODE_ENV === 'development'
    ? createLoggingWrapper(config.id || 'anonymous', handler)
    : handler;
    
  return register(action, wrappedHandler, config);
};
```

### 2. 핸들러 상태 모니터링

```typescript
// 핸들러 상태 대시보드
function HandlerMonitorDashboard() {
  const [metrics, setMetrics] = useState<HandlerMetrics[]>([]);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setMetrics(metricsCollector.getAllMetrics());
    }, 1000);
    
    return () => clearInterval(interval);
  }, []);
  
  return (
    <div style={{ fontFamily: 'monospace', fontSize: '12px' }}>
      <h3>핸들러 모니터링 대시보드</h3>
      <table>
        <thead>
          <tr>
            <th>핸들러 ID</th>
            <th>실행 횟수</th>
            <th>평균 실행 시간</th>
            <th>오류 횟수</th>
            <th>마지막 실행</th>
          </tr>
        </thead>
        <tbody>
          {metrics.map(metric => (
            <tr key={metric.id}>
              <td>{metric.id}</td>
              <td>{metric.executionCount}</td>
              <td>{metric.averageExecutionTime.toFixed(2)}ms</td>
              <td style={{ color: metric.errorCount > 0 ? 'red' : 'green' }}>
                {metric.errorCount}
              </td>
              <td>
                {new Date(metric.lastExecutionTime).toLocaleTimeString()}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
```

## 모범 사례

### 1. ID 설계 원칙

```typescript
// ✅ 좋음: 설명적이고 일관된 ID
const HANDLER_IDS = {
  // 도메인-기능-역할 패턴
  USER_PROFILE_VALIDATOR: 'user-profile-validator',
  USER_PROFILE_UPDATER: 'user-profile-updater',
  USER_PROFILE_AUDITOR: 'user-profile-auditor',
  
  // 명확한 책임 표시
  CART_ITEM_ADDER: 'cart-item-adder',
  CART_TOTAL_CALCULATOR: 'cart-total-calculator',
  CART_PERSISTENCE_SYNC: 'cart-persistence-sync'
} as const;

// ❌ 피하기: 모호하거나 일관성 없는 ID
const BAD_IDS = {
  HANDLER1: 'handler1',           // 의미 없음
  UserStuff: 'UserStuff',         // 카멜케이스 + 모호함
  'update-thing': 'update-thing', // 너무 일반적
  'user_profile_UPDATER': 'user_profile_UPDATER' // 일관성 없는 케이스
};
```

### 2. 조직화 패턴

```typescript
// 도메인별 ID 조직화
export const UserHandlerIds = {
  Authentication: {
    LOGIN_MAIN: 'user-auth-login-main',
    LOGIN_VALIDATOR: 'user-auth-login-validator',
    LOGOUT_MAIN: 'user-auth-logout-main',
    TOKEN_REFRESH: 'user-auth-token-refresh'
  },
  Profile: {
    UPDATE_MAIN: 'user-profile-update-main',
    UPDATE_VALIDATOR: 'user-profile-update-validator',
    DELETE_MAIN: 'user-profile-delete-main',
    AVATAR_UPLOAD: 'user-profile-avatar-upload'
  }
} as const;

export const CartHandlerIds = {
  Items: {
    ADD_MAIN: 'cart-items-add-main',
    REMOVE_MAIN: 'cart-items-remove-main',
    UPDATE_QUANTITY: 'cart-items-update-quantity'
  },
  Calculation: {
    TOTAL_CALCULATOR: 'cart-calc-total',
    TAX_CALCULATOR: 'cart-calc-tax',
    DISCOUNT_APPLIER: 'cart-calc-discount'
  }
} as const;
```

### 3. 문서화 패턴

```typescript
/**
 * 사용자 프로필 업데이트 핸들러
 * 
 * @id user-profile-updater-main
 * @priority 100
 * @blocking true
 * @category business-logic
 * @tags ["user", "profile", "business"]
 * 
 * @description 사용자 프로필 정보를 검증하고 업데이트합니다.
 * @dependencies user-profile-validator (우선순위 200)
 * @affects user-profile-auditor (우선순위 50)
 * 
 * @author TeamName
 * @version 1.2.0
 * @since 1.0.0
 */
register('updateProfile', updateProfileHandler, {
  id: UserHandlerIds.Profile.UPDATE_MAIN,
  priority: 100,
  blocking: true,
  category: 'business-logic',
  tags: ['user', 'profile', 'business'],
  version: '1.2.0'
});
```

---

## 요약

효과적인 핸들러 ID 전략은 다음을 제공합니다:

- **명확한 식별** - 의미있고 일관된 명명 규칙
- **조직화된 구조** - 계층적이고 논리적인 ID 체계
- **디버깅 지원** - 추적 가능하고 모니터링 가능한 핸들러
- **확장성** - 동적이고 조건부 핸들러 관리
- **유지보수성** - 문서화되고 버전 관리되는 핸들러

올바른 ID 전략을 따르면 복잡한 핸들러 시스템도 쉽게 관리하고 디버깅할 수 있습니다.

---

::: tip 다음 단계
- [크로스 도메인 통합](./cross-domain-integration) - 도메인 간 핸들러 통신
- [성능 최적화](./performance) - 핸들러 성능 최적화 기법
- [모범 사례](./best-practices) - 프로덕션 환경 권장사항
:::

---


# Guide Mvvm Architecture

**Source**: `guide/mvvm-architecture.md`  
**Priority**: 80 (essential)  

# MVVM 아키텍처

Context-Action 프레임워크는 Model-View-ViewModel(MVVM) 패턴에서 영감을 받아 React 환경에 맞게 적응된 아키텍처를 제공합니다. 이 가이드는 MVVM 원칙이 어떻게 구현되고 활용되는지 설명합니다.

## MVVM 아키텍처 개요

### 전통적인 MVVM vs Context-Action MVVM

```mermaid
graph TB
    subgraph "Context-Action MVVM"
        V1[View Layer<br/>React Components]
        VM1[ViewModel Layer<br/>Action Handlers]
        M1[Model Layer<br/>Store System]
        
        V1 -->|Actions| VM1
        VM1 -->|State Updates| M1
        M1 -->|Reactive Updates| V1
        
        VM1 -.->|Business Logic| VM1
        M1 -.->|Data Validation| M1
    end
    
    style V1 fill:#e3f2fd
    style VM1 fill:#fff8e1
    style M1 fill:#e8f5e8
```

### 계층별 책임 분리

| 계층 | 역할 | Context-Action 구현체 |
|------|------|---------------------|
| **View** | UI 렌더링, 사용자 상호작용 | React 컴포넌트 |
| **ViewModel** | 비즈니스 로직, 상태 변환 | 액션 핸들러 |
| **Model** | 데이터 상태, 영속성 | 스토어 시스템 |

## Model 계층 (스토어 시스템)

### 1. 순수한 데이터 모델

```typescript
// Model Layer - 순수한 데이터 구조
interface UserModel {
  // 엔티티 데이터
  profile: {
    id: string;
    name: string;
    email: string;
    avatar?: string;
    createdAt: string;
    updatedAt: string;
  };
  
  // 상태 데이터
  session: {
    isLoggedIn: boolean;
    token: string | null;
    expiresAt: number | null;
    lastActivity: number;
  };
  
  // 설정 데이터
  preferences: {
    theme: 'light' | 'dark';
    language: string;
    notifications: {
      email: boolean;
      push: boolean;
      sms: boolean;
    };
  };
}

// Model Layer 구현
export const {
  Provider: UserModelProvider,
  useStore: useUserModel,
  useStores: useUserModelRegistry
} = createDeclarativeStores<UserModel>('UserModel', {
  profile: {
    initialValue: {
      id: '',
      name: '',
      email: '',
      createdAt: '',
      updatedAt: ''
    },
    strategy: 'deep', // 중첩 객체 변경 감지
    validation: (value) => {
      // 데이터 검증 로직
      if (value.email && !value.email.includes('@')) {
        throw new Error('유효하지 않은 이메일 형식');
      }
      return true;
    }
  },
  session: {
    initialValue: {
      isLoggedIn: false,
      token: null,
      expiresAt: null,
      lastActivity: Date.now()
    },
    strategy: 'shallow'
  },
  preferences: {
    initialValue: {
      theme: 'light',
      language: 'ko',
      notifications: {
        email: true,
        push: true,
        sms: false
      }
    },
    strategy: 'deep'
  }
});
```

### 2. Model 계층 규칙

```typescript
// ✅ Model Layer 모범 사례
class UserModelValidator {
  // 순수한 검증 로직
  static validateProfile(profile: UserModel['profile']): ValidationResult {
    const errors: string[] = [];
    
    if (!profile.name.trim()) {
      errors.push('이름은 필수입니다');
    }
    
    if (!profile.email || !profile.email.includes('@')) {
      errors.push('유효한 이메일이 필요합니다');
    }
    
    return { isValid: errors.length === 0, errors };
  }
  
  static validateSession(session: UserModel['session']): ValidationResult {
    const errors: string[] = [];
    
    if (session.isLoggedIn && !session.token) {
      errors.push('로그인 상태에는 토큰이 필요합니다');
    }
    
    if (session.expiresAt && session.expiresAt < Date.now()) {
      errors.push('세션이 만료되었습니다');
    }
    
    return { isValid: errors.length === 0, errors };
  }
}

// Model 계층에서 사용
const profileStore = useUserModel('profile');
const currentProfile = profileStore.getValue();

// ❌ 비즈니스 로직은 Model에서 제외
// Model 계층에서는 순수한 데이터 저장/검증만 담당
```

## ViewModel 계층 (액션 핸들러)

### 1. 비즈니스 로직 캡슐화

```typescript
// ViewModel Layer - 비즈니스 로직과 상태 변환
interface UserViewModelActions {
  // 인증 비즈니스 로직
  login: { email: string; password: string; rememberMe?: boolean };
  logout: void;
  refreshSession: void;
  
  // 프로필 비즈니스 로직
  updateProfile: { data: Partial<UserModel['profile']> };
  uploadAvatar: { file: File };
  deleteAccount: { confirmation: string };
  
  // 설정 비즈니스 로직
  updatePreferences: { preferences: Partial<UserModel['preferences']> };
  exportData: void;
  importData: { data: Partial<UserModel> };
}

// ViewModel 구현
function useUserViewModel() {
  const register = useUserActionRegister();
  const modelRegistry = useUserModelRegistry();
  
  // 로그인 비즈니스 로직
  const loginHandler = useCallback(async (
    payload: UserViewModelActions['login'],
    controller: ActionController
  ) => {
    const profileStore = modelRegistry.getStore('profile');
    const sessionStore = modelRegistry.getStore('session');
    
    try {
      // 1. 입력 검증 (ViewModel 책임)
      if (!payload.email || !payload.password) {
        controller.abort('이메일과 비밀번호를 입력하세요');
        return { success: false, error: 'INVALID_INPUT' };
      }
      
      // 2. 외부 서비스 호출 (ViewModel 책임)
      const authResult = await authService.authenticate({
        email: payload.email,
        password: payload.password
      });
      
      if (!authResult.success) {
        controller.abort('로그인 실패: ' + authResult.error);
        return { success: false, error: authResult.error };
      }
      
      // 3. 데이터 변환 (ViewModel 책임)
      const transformedUser = {
        ...authResult.user,
        updatedAt: new Date().toISOString()
      };
      
      // 4. Model 업데이트 (ViewModel → Model)
      profileStore.setValue(transformedUser);
      sessionStore.setValue({
        isLoggedIn: true,
        token: authResult.token,
        expiresAt: Date.now() + (authResult.expiresIn * 1000),
        lastActivity: Date.now()
      });
      
      // 5. 부수 효과 처리 (ViewModel 책임)
      if (payload.rememberMe) {
        localStorage.setItem('rememberUser', payload.email);
      }
      
      // 6. 외부 시스템 알림 (ViewModel 책임)
      analyticsService.track('user_login', {
        userId: transformedUser.id,
        timestamp: Date.now()
      });
      
      return { success: true, user: transformedUser };
      
    } catch (error) {
      // 7. 오류 처리와 복구 (ViewModel 책임)
      controller.abort('로그인 처리 중 오류 발생', error);
      
      // 오류 상황에서의 Model 상태 복구
      sessionStore.setValue({
        isLoggedIn: false,
        token: null,
        expiresAt: null,
        lastActivity: Date.now()
      });
      
      return { success: false, error: 'NETWORK_ERROR' };
    }
  }, [modelRegistry]);
  
  // 프로필 업데이트 비즈니스 로직
  const updateProfileHandler = useCallback(async (
    payload: UserViewModelActions['updateProfile'],
    controller: ActionController
  ) => {
    const profileStore = modelRegistry.getStore('profile');
    const sessionStore = modelRegistry.getStore('session');
    
    const currentProfile = profileStore.getValue();
    const session = sessionStore.getValue();
    
    try {
      // 1. 권한 검증 (ViewModel 책임)
      if (!session.isLoggedIn) {
        controller.abort('로그인이 필요합니다');
        return { success: false, error: 'UNAUTHORIZED' };
      }
      
      // 2. 비즈니스 규칙 검증 (ViewModel 책임)
      const validation = UserModelValidator.validateProfile({
        ...currentProfile,
        ...payload.data
      });
      
      if (!validation.isValid) {
        controller.abort('검증 실패: ' + validation.errors.join(', '));
        return { success: false, error: 'VALIDATION_FAILED', details: validation.errors };
      }
      
      // 3. 낙관적 업데이트 (ViewModel 전략)
      const optimisticProfile = {
        ...currentProfile,
        ...payload.data,
        updatedAt: new Date().toISOString()
      };
      
      profileStore.setValue(optimisticProfile);
      
      // 4. 서버 동기화 (ViewModel 책임)
      const updateResult = await userService.updateProfile(currentProfile.id, payload.data);
      
      if (!updateResult.success) {
        // 실패 시 롤백
        profileStore.setValue(currentProfile);
        controller.abort('서버 업데이트 실패');
        return { success: false, error: 'SERVER_ERROR' };
      }
      
      // 5. 최종 데이터로 Model 업데이트
      profileStore.setValue(updateResult.user);
      
      return { success: true, profile: updateResult.user };
      
    } catch (error) {
      // 오류 시 롤백
      profileStore.setValue(currentProfile);
      controller.abort('프로필 업데이트 중 오류', error);
      return { success: false, error: 'UNKNOWN_ERROR' };
    }
  }, [modelRegistry]);
  
  // 핸들러 등록
  useEffect(() => {
    if (!register) return;
    
    const unregisterLogin = register('login', loginHandler, {
      id: 'user-viewmodel-login',
      priority: 100,
      blocking: true,
      category: 'authentication'
    });
    
    const unregisterUpdate = register('updateProfile', updateProfileHandler, {
      id: 'user-viewmodel-update-profile',
      priority: 100,
      blocking: true,
      category: 'profile-management'
    });
    
    return () => {
      unregisterLogin();
      unregisterUpdate();
    };
  }, [register, loginHandler, updateProfileHandler]);
}
```

### 2. ViewModel 패턴 원칙

```typescript
// ViewModel 계층 책임 분리
class UserViewModel {
  // ✅ ViewModel이 담당해야 할 것들
  
  // 1. 비즈니스 로직
  async validateAndLogin(credentials: LoginCredentials) {
    // 복잡한 로그인 로직
  }
  
  // 2. 데이터 변환
  transformUserDataForUI(rawUserData: RawUserData): UIUserData {
    return {
      displayName: rawUserData.firstName + ' ' + rawUserData.lastName,
      memberSince: new Date(rawUserData.createdAt).getFullYear(),
      // ... 기타 변환 로직
    };
  }
  
  // 3. 외부 서비스 조율
  async syncUserData(userId: string) {
    const [profile, preferences, activity] = await Promise.all([
      userService.getProfile(userId),
      preferencesService.getPreferences(userId),
      activityService.getActivity(userId)
    ]);
    
    // Model 업데이트
    this.updateModels(profile, preferences, activity);
  }
  
  // 4. 상태 조율
  coordinateLogout() {
    // 여러 Model의 상태를 조율하여 로그아웃 처리
    this.clearUserModel();
    this.clearCartModel();
    this.clearNotificationModel();
  }
  
  // ❌ ViewModel이 담당하지 말아야 할 것들
  
  // UI 렌더링 (View 계층의 책임)
  // renderUserProfile() { ... }
  
  // 순수한 데이터 저장 (Model 계층의 책임)
  // storeUserData(data) { ... }
}
```

## View 계층 (React 컴포넌트)

### 1. 순수한 프레젠테이션 계층

```typescript
// View Layer - 순수한 UI 컴포넌트
interface UserViewProps {
  // View는 데이터만 받아서 렌더링
  user: UserModel['profile'];
  session: UserModel['session'];
  preferences: UserModel['preferences'];
  
  // View는 이벤트만 발생
  onLogin: (credentials: LoginCredentials) => void;
  onLogout: () => void;
  onUpdateProfile: (data: Partial<UserModel['profile']>) => void;
}

// ✅ 순수한 View 컴포넌트 (프레젠테이션만 담당)
function UserProfileView({ user, session, preferences, onLogin, onLogout, onUpdateProfile }: UserViewProps) {
  // View는 로컬 UI 상태만 관리
  const [isEditing, setIsEditing] = useState(false);
  const [formData, setFormData] = useState(user);
  
  // View는 UI 이벤트만 처리
  const handleSubmit = useCallback((e: React.FormEvent) => {
    e.preventDefault();
    onUpdateProfile(formData); // ViewModel로 전달
    setIsEditing(false);
  }, [formData, onUpdateProfile]);
  
  // View는 순수한 렌더링만 담당
  if (!session.isLoggedIn) {
    return <LoginForm onLogin={onLogin} />;
  }
  
  return (
    <div className={`profile-view theme-${preferences.theme}`}>
      <header className="profile-header">
        <img src={user.avatar} alt={`${user.name} 프로필`} />
        <h1>{user.name}</h1>
        <p>{user.email}</p>
        <button onClick={onLogout}>로그아웃</button>
      </header>
      
      <main className="profile-content">
        {isEditing ? (
          <form onSubmit={handleSubmit}>
            <input
              value={formData.name}
              onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
              placeholder="이름"
            />
            <input
              type="email"
              value={formData.email}
              onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
              placeholder="이메일"
            />
            <button type="submit">저장</button>
            <button type="button" onClick={() => setIsEditing(false)}>취소</button>
          </form>
        ) : (
          <div className="profile-display">
            <p><strong>이름:</strong> {user.name}</p>
            <p><strong>이메일:</strong> {user.email}</p>
            <p><strong>가입일:</strong> {new Date(user.createdAt).toLocaleDateString()}</p>
            <button onClick={() => setIsEditing(true)}>편집</button>
          </div>
        )}
      </main>
    </div>
  );
}

// ✅ View Controller (View와 ViewModel 연결)
function UserProfileContainer() {
  // Model 구독 (MVVM의 데이터 바인딩)
  const user = useStoreValue(useUserModel('profile'));
  const session = useStoreValue(useUserModel('session'));
  const preferences = useStoreValue(useUserModel('preferences'));
  
  // ViewModel 액션 연결
  const dispatch = useUserAction();
  
  // View 이벤트를 ViewModel 액션으로 변환
  const handleLogin = useCallback((credentials: LoginCredentials) => {
    dispatch('login', credentials);
  }, [dispatch]);
  
  const handleLogout = useCallback(() => {
    dispatch('logout');
  }, [dispatch]);
  
  const handleUpdateProfile = useCallback((data: Partial<UserModel['profile']>) => {
    dispatch('updateProfile', { data });
  }, [dispatch]);
  
  // View에게 데이터와 이벤트 핸들러 전달
  return (
    <UserProfileView
      user={user}
      session={session}
      preferences={preferences}
      onLogin={handleLogin}
      onLogout={handleLogout}
      onUpdateProfile={handleUpdateProfile}
    />
  );
}
```

### 2. View 계층 패턴

```typescript
// View 컴포넌트 설계 패턴
interface ViewComponentProps<TData, TActions> {
  // 데이터 (Model에서 온 것)
  data: TData;
  
  // 로딩/오류 상태 (ViewModel에서 관리)
  loading?: boolean;
  error?: string;
  
  // 액션 콜백 (ViewModel로 전달)
  actions: TActions;
  
  // UI 설정
  className?: string;
  theme?: 'light' | 'dark';
}

// 예시: 사용자 목록 View
interface UserListData {
  users: UserModel['profile'][];
  totalCount: number;
  currentPage: number;
}

interface UserListActions {
  onLoadUsers: (page: number) => void;
  onDeleteUser: (userId: string) => void;
  onEditUser: (user: UserModel['profile']) => void;
}

function UserListView({ 
  data, 
  loading, 
  error, 
  actions, 
  className 
}: ViewComponentProps<UserListData, UserListActions>) {
  if (loading) {
    return <div className="loading">사용자 목록 로딩 중...</div>;
  }
  
  if (error) {
    return <div className="error">오류: {error}</div>;
  }
  
  return (
    <div className={`user-list ${className || ''}`}>
      <header>
        <h2>사용자 목록 ({data.totalCount}명)</h2>
      </header>
      
      <div className="user-grid">
        {data.users.map(user => (
          <UserCard
            key={user.id}
            user={user}
            onEdit={() => actions.onEditUser(user)}
            onDelete={() => actions.onDeleteUser(user.id)}
          />
        ))}
      </div>
      
      <Pagination
        currentPage={data.currentPage}
        totalPages={Math.ceil(data.totalCount / 10)}
        onPageChange={actions.onLoadUsers}
      />
    </div>
  );
}

// View Controller
function UserListContainer() {
  // Model 구독
  const users = useStoreValue(useAdminModel('userList'));
  const pagination = useStoreValue(useAdminModel('pagination'));
  
  // ViewModel 상태
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // ViewModel 액션
  const dispatch = useAdminAction();
  
  const actions: UserListActions = {
    onLoadUsers: useCallback(async (page: number) => {
      setLoading(true);
      setError(null);
      try {
        await dispatch('loadUsers', { page });
      } catch (err) {
        setError(err instanceof Error ? err.message : '사용자 로드 실패');
      } finally {
        setLoading(false);
      }
    }, [dispatch]),
    
    onDeleteUser: useCallback(async (userId: string) => {
      if (confirm('정말 삭제하시겠습니까?')) {
        try {
          await dispatch('deleteUser', { userId });
        } catch (err) {
          setError(err instanceof Error ? err.message : '사용자 삭제 실패');
        }
      }
    }, [dispatch]),
    
    onEditUser: useCallback((user: UserModel['profile']) => {
      dispatch('openUserEditor', { user });
    }, [dispatch])
  };
  
  const data: UserListData = {
    users,
    totalCount: pagination.total,
    currentPage: pagination.current
  };
  
  return (
    <UserListView
      data={data}
      loading={loading}
      error={error}
      actions={actions}
    />
  );
}
```

## MVVM 통합 패턴

### 1. 단방향 데이터 흐름

```mermaid
graph LR
    subgraph "MVVM Data Flow"
        UI[View Layer<br/>React Components]
        VM[ViewModel Layer<br/>Action Handlers]
        M[Model Layer<br/>Store System]
        
        UI -->|User Actions| VM
        VM -->|Business Logic| VM
        VM -->|Update State| M
        M -->|State Changes| UI
        
        VM -.->|External APIs| API[External Services]
        VM -.->|Side Effects| SE[Analytics, Logging]
    end
    
    style UI fill:#e3f2fd
    style VM fill:#fff8e1
    style M fill:#e8f5e8
    style API fill:#ffebee
    style SE fill:#f3e5f5
```

### 2. 실제 구현 예시

```typescript
// 완전한 MVVM 패턴 구현 예시
export function useUserMVVM() {
  // Model Layer
  const userModel = useUserModel('profile');
  const sessionModel = useUserModel('session');
  const preferencesModel = useUserModel('preferences');
  
  // ViewModel Layer
  useUserViewModel(); // 핸들러들이 등록됨
  
  // View Layer 데이터 (Model → View)
  const viewData = {
    profile: useStoreValue(userModel),
    session: useStoreValue(sessionModel),
    preferences: useStoreValue(preferencesModel)
  };
  
  // View Layer 액션 (View → ViewModel)
  const dispatch = useUserAction();
  const viewActions = {
    login: useCallback((credentials: LoginCredentials) => {
      return dispatch('login', credentials);
    }, [dispatch]),
    
    logout: useCallback(() => {
      return dispatch('logout');
    }, [dispatch]),
    
    updateProfile: useCallback((data: Partial<UserModel['profile']>) => {
      return dispatch('updateProfile', { data });
    }, [dispatch]),
    
    updatePreferences: useCallback((preferences: Partial<UserModel['preferences']>) => {
      return dispatch('updatePreferences', { preferences });
    }, [dispatch])
  };
  
  return {
    data: viewData,
    actions: viewActions
  };
}

// 사용법
function UserApp() {
  const { data, actions } = useUserMVVM();
  
  return (
    <UserModelProvider>
      <UserActionProvider>
        <UserProfileView
          user={data.profile}
          session={data.session}
          preferences={data.preferences}
          onLogin={actions.login}
          onLogout={actions.logout}
          onUpdateProfile={actions.updateProfile}
        />
      </UserActionProvider>
    </UserModelProvider>
  );
}
```

## 모범 사례

### 1. 계층별 책임 분리

```typescript
// ✅ 올바른 계층별 책임 분리

// Model: 순수한 데이터와 검증
interface UserModel {
  profile: UserProfile;
  // 비즈니스 로직 없음, 순수한 데이터만
}

// ViewModel: 비즈니스 로직과 상태 조율
class UserViewModel {
  async handleLogin(credentials) {
    // 복잡한 로그인 로직
    // 외부 API 호출
    // 상태 변환
    // Model 업데이트
  }
}

// View: 순수한 UI 렌더링
function UserView({ data, actions }) {
  // UI 로직만, 비즈니스 로직 없음
  return <div>{data.name}</div>;
}

// ❌ 잘못된 책임 분리

// Model에 비즈니스 로직 (X)
interface BadUserModel {
  profile: UserProfile;
  loginUser: (credentials) => Promise<void>; // ViewModel 책임
}

// View에 비즈니스 로직 (X)
function BadUserView() {
  const handleLogin = async () => {
    // 복잡한 로그인 로직 - ViewModel 책임
    const result = await fetch('/api/login', ...);
    // ...
  };
  // ...
}
```

### 2. 데이터 흐름 관리

```typescript
// ✅ 단방향 데이터 흐름 준수
function ProperDataFlow() {
  // View → ViewModel (액션)
  const dispatch = useUserAction();
  
  // Model → View (상태)
  const user = useStoreValue(useUserModel('profile'));
  
  // 올바른 흐름: View → ViewModel → Model → View
  const handleUpdate = (data) => {
    dispatch('updateProfile', { data }); // View → ViewModel
    // ViewModel이 Model 업데이트
    // Model이 View에 자동 반영
  };
}

// ❌ 양방향 데이터 흐름 (피하기)
function ImproperDataFlow() {
  const userStore = useUserModel('profile');
  
  const handleUpdate = (data) => {
    // View에서 직접 Model 조작 (X)
    userStore.setValue(data);
  };
}
```

---

## 요약

Context-Action의 MVVM 아키텍처는 다음 이점을 제공합니다:

- **명확한 관심사 분리** - 각 계층의 책임이 명확함
- **테스트 가능성** - 각 계층을 독립적으로 테스트
- **유지보수성** - 변경사항의 영향 범위가 제한됨
- **재사용성** - View와 ViewModel의 독립적 재사용
- **확장성** - 계층별 독립적 확장 가능

MVVM 패턴을 올바르게 구현하면 복잡한 애플리케이션도 체계적으로 관리할 수 있습니다.

---

::: tip 다음 단계
- [성능 최적화](./performance) - MVVM 아키텍처 성능 최적화
- [모범 사례](./best-practices) - 실제 프로덕션 환경 권장사항
- [공통 함정](./common-pitfalls) - MVVM 구현 시 주의사항
:::

---


# Guide Performance

**Source**: `guide/performance.md`  
**Priority**: 80 (essential)  

# 성능 최적화

Context-Action 프레임워크에서의 성능 최적화는 반응형 상태 관리, 핸들러 실행, 그리고 컴포넌트 렌더링의 효율성을 극대화하는 것입니다. 이 가이드는 실제 애플리케이션에서 검증된 최적화 기법을 제공합니다.

## 기본 성능 원칙

### 1. 측정 기반 최적화

```typescript
// 성능 측정 유틸리티
class PerformanceProfiler {
  private static measurements = new Map<string, number[]>();
  
  static measure<T>(label: string, fn: () => T): T {
    const start = performance.now();
    const result = fn();
    const end = performance.now();
    
    const measurements = this.measurements.get(label) || [];
    measurements.push(end - start);
    this.measurements.set(label, measurements);
    
    // 최근 100개 측정값만 유지
    if (measurements.length > 100) {
      measurements.shift();
    }
    
    return result;
  }
  
  static async measureAsync<T>(label: string, fn: () => Promise<T>): Promise<T> {
    const start = performance.now();
    const result = await fn();
    const end = performance.now();
    
    const measurements = this.measurements.get(label) || [];
    measurements.push(end - start);
    this.measurements.set(label, measurements);
    
    return result;
  }
  
  static getStats(label: string) {
    const measurements = this.measurements.get(label) || [];
    if (measurements.length === 0) return null;
    
    const avg = measurements.reduce((sum, val) => sum + val, 0) / measurements.length;
    const max = Math.max(...measurements);
    const min = Math.min(...measurements);
    
    return { average: avg, max, min, count: measurements.length };
  }
  
  static getAllStats() {
    const stats = {};
    for (const [label, measurements] of this.measurements) {
      stats[label] = this.getStats(label);
    }
    return stats;
  }
}

// 사용법
const loginHandler = useCallback(async (payload, controller) => {
  return await PerformanceProfiler.measureAsync('user-login', async () => {
    // 로그인 로직
    return await performLogin(payload);
  });
}, []);
```

### 2. 성능 모니터링 대시보드

```typescript
// 개발 환경 성능 모니터
function PerformanceDashboard() {
  const [stats, setStats] = useState({});
  const [isVisible, setIsVisible] = useState(false);
  
  useEffect(() => {
    if (!process.env.NODE_ENV === 'development') return;
    
    const interval = setInterval(() => {
      setStats(PerformanceProfiler.getAllStats());
    }, 1000);
    
    return () => clearInterval(interval);
  }, []);
  
  if (!process.env.NODE_ENV === 'development' || !isVisible) {
    return (
      <button 
        className="perf-toggle"
        onClick={() => setIsVisible(true)}
        style={{
          position: 'fixed',
          bottom: '10px',
          right: '10px',
          zIndex: 9999
        }}
      >
        📊
      </button>
    );
  }
  
  return (
    <div style={{
      position: 'fixed',
      bottom: '10px',
      right: '10px',
      width: '400px',
      maxHeight: '300px',
      backgroundColor: 'rgba(0,0,0,0.9)',
      color: 'white',
      padding: '10px',
      borderRadius: '5px',
      fontSize: '12px',
      fontFamily: 'monospace',
      overflow: 'auto',
      zIndex: 9999
    }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '10px' }}>
        <h4>성능 통계</h4>
        <button onClick={() => setIsVisible(false)}>×</button>
      </div>
      
      {Object.entries(stats).map(([label, stat]: [string, any]) => (
        <div key={label} style={{ marginBottom: '8px' }}>
          <div><strong>{label}</strong></div>
          <div>평균: {stat?.average?.toFixed(2)}ms</div>
          <div>최대: {stat?.max?.toFixed(2)}ms</div>
          <div>최소: {stat?.min?.toFixed(2)}ms</div>
          <div>호출: {stat?.count}회</div>
          <hr style={{ margin: '5px 0', opacity: 0.3 }} />
        </div>
      ))}
    </div>
  );
}
```

## 스토어 성능 최적화

### 1. 선택적 구독 패턴

```typescript
// ✅ 효율적: 필요한 필드만 구독
function OptimizedUserName() {
  const profileStore = useUserStore('profile');
  
  // 이름만 변경될 때 리렌더링
  const name = useStoreValue(profileStore, profile => profile.name);
  
  return <span>{name}</span>;
}

function OptimizedUserEmail() {
  const profileStore = useUserStore('profile');
  
  // 이메일만 변경될 때 리렌더링
  const email = useStoreValue(profileStore, profile => profile.email);
  
  return <span>{email}</span>;
}

// ❌ 비효율적: 전체 프로필 구독
function InefficientUserInfo() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore); // 모든 변경에 리렌더링
  
  return (
    <div>
      <span>{profile.name}</span>
      <span>{profile.email}</span>
    </div>
  );
}

// ✅ 개선된 버전: 조합 컴포넌트
function EfficientUserInfo() {
  return (
    <div>
      <OptimizedUserName />
      <OptimizedUserEmail />
    </div>
  );
}
```

### 2. 조건부 구독 최적화

```typescript
// 조건에 따른 스마트 구독
function ConditionalUserData({ showDetails, isLoggedIn }: {
  showDetails: boolean;
  isLoggedIn: boolean;
}) {
  const profileStore = useUserStore('profile');
  
  // 로그인되고 상세보기일 때만 전체 데이터 구독
  const profileData = useStoreValue(
    profileStore,
    isLoggedIn && showDetails 
      ? (profile) => profile  // 전체 프로필
      : (profile) => ({ name: profile.name }) // 이름만
  );
  
  if (!isLoggedIn) {
    return <div>로그인이 필요합니다</div>;
  }
  
  if (!showDetails) {
    return <div>안녕하세요, {profileData.name}님</div>;
  }
  
  return (
    <div>
      <h2>{profileData.name}</h2>
      <p>이메일: {profileData.email}</p>
      <p>가입일: {profileData.createdAt}</p>
      {/* 기타 상세 정보 */}
    </div>
  );
}
```

### 3. 메모화된 선택자

```typescript
// 복잡한 계산을 메모화하는 선택자
const createMemoizedSelector = <T, R>(
  selector: (state: T) => R,
  equalityFn?: (a: R, b: R) => boolean
) => {
  let lastInput: T;
  let lastResult: R;
  let hasResult = false;
  
  return (state: T): R => {
    // 입력이 같으면 캐시된 결과 반환
    if (hasResult && Object.is(state, lastInput)) {
      return lastResult;
    }
    
    const result = selector(state);
    
    // 커스텀 등가성 검사가 있고 결과가 같으면 캐시 유지
    if (hasResult && equalityFn && equalityFn(result, lastResult)) {
      return lastResult;
    }
    
    lastInput = state;
    lastResult = result;
    hasResult = true;
    
    return result;
  };
};

// 사용법
function ExpensiveUserStats() {
  const profileStore = useUserStore('profile');
  const activityStore = useUserStore('activity');
  
  // 복잡한 계산을 메모화
  const expensiveSelector = useMemo(() => 
    createMemoizedSelector((profile: UserProfile) => {
      // 무거운 계산
      return PerformanceProfiler.measure('user-stats-calculation', () => {
        const accountAge = Date.now() - new Date(profile.createdAt).getTime();
        const ageDays = Math.floor(accountAge / (24 * 60 * 60 * 1000));
        
        return {
          accountAgeDays: ageDays,
          accountAgeCategory: ageDays > 365 ? 'veteran' : ageDays > 30 ? 'regular' : 'new',
          completionScore: calculateProfileCompleteness(profile)
        };
      });
    })
  , []);
  
  const profile = useStoreValue(profileStore);
  const userStats = expensiveSelector(profile);
  
  return (
    <div>
      <p>계정 사용일: {userStats.accountAgeDays}일</p>
      <p>사용자 등급: {userStats.accountAgeCategory}</p>
      <p>프로필 완성도: {userStats.completionScore}%</p>
    </div>
  );
}
```

## 핸들러 성능 최적화

### 1. 핸들러 배치 처리

```typescript
// 배치 처리를 위한 유틸리티
class BatchProcessor<T> {
  private queue: T[] = [];
  private timeoutId: NodeJS.Timeout | null = null;
  private readonly batchSize: number;
  private readonly delay: number;
  
  constructor(
    private processor: (items: T[]) => Promise<void>,
    batchSize = 10,
    delay = 100
  ) {
    this.batchSize = batchSize;
    this.delay = delay;
  }
  
  add(item: T) {
    this.queue.push(item);
    
    // 배치 크기에 도달하면 즉시 처리
    if (this.queue.length >= this.batchSize) {
      this.processBatch();
      return;
    }
    
    // 타이머 설정 (지연 처리)
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
    
    this.timeoutId = setTimeout(() => {
      this.processBatch();
    }, this.delay);
  }
  
  private async processBatch() {
    if (this.queue.length === 0) return;
    
    const batch = [...this.queue];
    this.queue = [];
    
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    
    try {
      await this.processor(batch);
    } catch (error) {
      console.error('배치 처리 실패:', error);
    }
  }
  
  flush() {
    if (this.queue.length > 0) {
      this.processBatch();
    }
  }
}

// 배치 처리 핸들러 예시
function useBatchedAnalytics() {
  const register = useUserActionRegister();
  
  // 분석 이벤트 배치 처리기
  const analyticsProcessor = useMemo(
    () => new BatchProcessor(
      async (events: AnalyticsEvent[]) => {
        await PerformanceProfiler.measureAsync('analytics-batch', async () => {
          await fetch('/api/analytics/batch', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ events })
          });
        });
      },
      20, // 배치 크기
      500 // 지연 시간 (ms)
    ),
    []
  );
  
  const trackingHandler = useCallback(async (payload, controller) => {
    // 즉시 배치에 추가 (논블로킹)
    analyticsProcessor.add({
      userId: payload.userId,
      action: payload.action,
      timestamp: Date.now(),
      metadata: payload.metadata
    });
    
    return { success: true, queued: true };
  }, [analyticsProcessor]);
  
  // 컴포넌트 언마운트 시 남은 배치 처리
  useEffect(() => {
    return () => {
      analyticsProcessor.flush();
    };
  }, [analyticsProcessor]);
  
  useEffect(() => {
    if (!register) return;
    
    const unregister = register('trackEvent', trackingHandler, {
      id: 'batched-analytics',
      priority: 50,
      blocking: false // 논블로킹으로 성능 개선
    });
    
    return unregister;
  }, [register, trackingHandler]);
}
```

### 2. 디바운싱과 쓰로틀링

```typescript
// 디바운스 훅
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  
  return debouncedValue;
}

// 쓰로틀 훅
function useThrottle<T extends (...args: any[]) => any>(
  callback: T,
  delay: number
): T {
  const lastCall = useRef<number>(0);
  const timeoutRef = useRef<NodeJS.Timeout>();
  
  return useCallback((...args: Parameters<T>) => {
    const now = Date.now();
    
    if (now - lastCall.current >= delay) {
      lastCall.current = now;
      return callback(...args);
    } else {
      // 마지막 호출을 예약
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      
      timeoutRef.current = setTimeout(() => {
        lastCall.current = Date.now();
        callback(...args);
      }, delay - (now - lastCall.current));
    }
  }, [callback, delay]) as T;
}

// 디바운스된 검색 핸들러
function useOptimizedSearch() {
  const register = useUserActionRegister();
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 300);
  
  const searchHandler = useCallback(async (payload, controller) => {
    return await PerformanceProfiler.measureAsync('user-search', async () => {
      const response = await fetch(`/api/search?q=${encodeURIComponent(payload.term)}`);
      return await response.json();
    });
  }, []);
  
  const throttledSearchHandler = useThrottle(searchHandler, 1000);
  
  useEffect(() => {
    if (!register) return;
    
    const unregister = register('search', throttledSearchHandler, {
      id: 'optimized-search',
      priority: 100,
      blocking: true
    });
    
    return unregister;
  }, [register, throttledSearchHandler]);
  
  // 디바운스된 검색어 변경에 자동 반응
  useEffect(() => {
    if (debouncedSearchTerm.length > 2) {
      throttledSearchHandler({ term: debouncedSearchTerm });
    }
  }, [debouncedSearchTerm, throttledSearchHandler]);
  
  return { searchTerm, setSearchTerm };
}
```

### 3. 우선순위 기반 핸들러 최적화

```typescript
// 핸들러 우선순위 최적화
function useOptimizedUserHandlers() {
  const register = useUserActionRegister();
  const registry = useUserStores();
  
  // 크리티컬 핸들러 (높은 우선순위, 블로킹)
  const criticalLoginHandler = useCallback(async (payload, controller) => {
    return await PerformanceProfiler.measureAsync('critical-login', async () => {
      // 필수 로그인 로직만
      const result = await authenticateUser(payload);
      
      if (result.success) {
        // 즉시 필요한 상태만 업데이트
        const sessionStore = registry.getStore('session');
        sessionStore.setValue({
          isLoggedIn: true,
          token: result.token,
          expiresAt: result.expiresAt,
          lastActivity: Date.now()
        });
      }
      
      return result;
    });
  }, [registry]);
  
  // 보조 핸들러 (낮은 우선순위, 논블로킹)
  const auxiliaryLoginHandler = useCallback(async (payload, controller) => {
    // 부가적인 작업들 (비동기적으로 처리)
    setTimeout(async () => {
      try {
        await Promise.all([
          updateLoginAnalytics(payload.userId),
          preloadUserPreferences(payload.userId),
          syncUserActivity(payload.userId)
        ]);
      } catch (error) {
        console.warn('보조 로그인 작업 실패:', error);
      }
    }, 0);
    
    return { success: true, auxiliary: true };
  }, []);
  
  useEffect(() => {
    if (!register) return;
    
    // 크리티컬 핸들러 먼저 등록
    const unregisterCritical = register('login', criticalLoginHandler, {
      id: 'login-critical',
      priority: 200, // 높은 우선순위
      blocking: true // 완료 대기
    });
    
    // 보조 핸들러는 나중에, 논블로킹으로
    const unregisterAuxiliary = register('login', auxiliaryLoginHandler, {
      id: 'login-auxiliary',
      priority: 50,  // 낮은 우선순위
      blocking: false // 비동기 처리
    });
    
    return () => {
      unregisterCritical();
      unregisterAuxiliary();
    };
  }, [register, criticalLoginHandler, auxiliaryLoginHandler]);
}
```

## 컴포넌트 렌더링 최적화

### 1. React.memo와 커스텀 비교 함수

```typescript
// 효율적인 메모화 컴포넌트
interface UserCardProps {
  user: UserProfile;
  onEdit: (userId: string) => void;
  onDelete: (userId: string) => void;
}

const UserCard = React.memo<UserCardProps>(({ user, onEdit, onDelete }) => {
  console.log(`UserCard 렌더링: ${user.name}`); // 개발 중 렌더링 추적
  
  return (
    <div className="user-card">
      <img src={user.avatar} alt={`${user.name} 프로필`} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <div>
        <button onClick={() => onEdit(user.id)}>편집</button>
        <button onClick={() => onDelete(user.id)}>삭제</button>
      </div>
    </div>
  );
}, (prevProps, nextProps) => {
  // 커스텀 비교 함수로 불필요한 리렌더링 방지
  return (
    prevProps.user.id === nextProps.user.id &&
    prevProps.user.name === nextProps.user.name &&
    prevProps.user.email === nextProps.user.email &&
    prevProps.user.avatar === nextProps.user.avatar &&
    prevProps.onEdit === nextProps.onEdit &&
    prevProps.onDelete === nextProps.onDelete
  );
});

// 안정된 콜백 사용
function UserList() {
  const users = useStoreValue(useUserStore('userList'));
  const dispatch = useUserAction();
  
  // 콜백 메모화로 불필요한 리렌더링 방지
  const handleEdit = useCallback((userId: string) => {
    dispatch('editUser', { userId });
  }, [dispatch]);
  
  const handleDelete = useCallback((userId: string) => {
    if (confirm('정말 삭제하시겠습니까?')) {
      dispatch('deleteUser', { userId });
    }
  }, [dispatch]);
  
  return (
    <div className="user-list">
      {users.map(user => (
        <UserCard
          key={user.id}
          user={user}
          onEdit={handleEdit}
          onDelete={handleDelete}
        />
      ))}
    </div>
  );
}
```

### 2. 가상화 (Virtualization)

```typescript
// 대용량 리스트 가상화
import { FixedSizeList as List } from 'react-window';

interface VirtualizedUserListProps {
  users: UserProfile[];
  onEdit: (userId: string) => void;
  onDelete: (userId: string) => void;
}

// 가상화된 아이템 컴포넌트
const VirtualizedUserItem = React.memo<{
  index: number;
  style: React.CSSProperties;
  data: {
    users: UserProfile[];
    onEdit: (userId: string) => void;
    onDelete: (userId: string) => void;
  };
}>(({ index, style, data }) => {
  const user = data.users[index];
  
  return (
    <div style={style}>
      <UserCard
        user={user}
        onEdit={data.onEdit}
        onDelete={data.onDelete}
      />
    </div>
  );
});

function VirtualizedUserList({ users, onEdit, onDelete }: VirtualizedUserListProps) {
  const itemData = useMemo(() => ({
    users,
    onEdit,
    onDelete
  }), [users, onEdit, onDelete]);
  
  return (
    <div style={{ height: '600px' }}>
      <List
        height={600}
        itemCount={users.length}
        itemSize={120} // 각 아이템의 높이
        itemData={itemData}
        overscanCount={5} // 미리 렌더링할 아이템 수
      >
        {VirtualizedUserItem}
      </List>
    </div>
  );
}

// 사용법
function OptimizedUserList() {
  const users = useStoreValue(useUserStore('userList'));
  const dispatch = useUserAction();
  
  const handleEdit = useCallback((userId: string) => {
    dispatch('editUser', { userId });
  }, [dispatch]);
  
  const handleDelete = useCallback((userId: string) => {
    dispatch('deleteUser', { userId });
  }, [dispatch]);
  
  // 사용자가 많을 때 가상화 사용
  if (users.length > 100) {
    return (
      <VirtualizedUserList
        users={users}
        onEdit={handleEdit}
        onDelete={handleDelete}
      />
    );
  }
  
  // 적은 수의 사용자는 일반 렌더링
  return (
    <div className="user-list">
      {users.map(user => (
        <UserCard
          key={user.id}
          user={user}
          onEdit={handleEdit}
          onDelete={handleDelete}
        />
      ))}
    </div>
  );
}
```

### 3. 지연 로딩과 코드 분할

```typescript
// 지연 로딩 컴포넌트
const LazyUserEditor = React.lazy(() => 
  import('./UserEditor').then(module => ({
    default: module.UserEditor
  }))
);

const LazyUserAnalytics = React.lazy(() => 
  import('./UserAnalytics').then(module => ({
    default: module.UserAnalytics
  }))
);

// 조건부 지연 로딩
function OptimizedUserDashboard() {
  const [activeTab, setActiveTab] = useState<'profile' | 'editor' | 'analytics'>('profile');
  const userRole = useStoreValue(useUserStore('session'), session => session.role);
  
  return (
    <div className="user-dashboard">
      <nav className="dashboard-nav">
        <button 
          onClick={() => setActiveTab('profile')}
          className={activeTab === 'profile' ? 'active' : ''}
        >
          프로필
        </button>
        <button 
          onClick={() => setActiveTab('editor')}
          className={activeTab === 'editor' ? 'active' : ''}
        >
          편집
        </button>
        {userRole === 'admin' && (
          <button 
            onClick={() => setActiveTab('analytics')}
            className={activeTab === 'analytics' ? 'active' : ''}
          >
            분석
          </button>
        )}
      </nav>
      
      <div className="dashboard-content">
        {activeTab === 'profile' && <UserProfile />}
        
        {activeTab === 'editor' && (
          <Suspense fallback={<div>편집기 로딩 중...</div>}>
            <LazyUserEditor />
          </Suspense>
        )}
        
        {activeTab === 'analytics' && userRole === 'admin' && (
          <Suspense fallback={<div>분석 도구 로딩 중...</div>}>
            <LazyUserAnalytics />
          </Suspense>
        )}
      </div>
    </div>
  );
}
```

## 네트워크 최적화

### 1. 요청 최적화

```typescript
// 요청 중복 제거와 캐싱
class RequestCache {
  private cache = new Map<string, Promise<any>>();
  private results = new Map<string, { data: any; timestamp: number }>();
  private readonly ttl: number;
  
  constructor(ttl = 60000) { // 기본 1분 TTL
    this.ttl = ttl;
  }
  
  async fetch<T>(key: string, fetcher: () => Promise<T>): Promise<T> {
    // 캐시된 결과가 유효한지 확인
    const cached = this.results.get(key);
    if (cached && Date.now() - cached.timestamp < this.ttl) {
      return cached.data;
    }
    
    // 진행 중인 요청이 있으면 재사용
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    
    // 새 요청 생성
    const promise = fetcher().then(data => {
      this.results.set(key, { data, timestamp: Date.now() });
      this.cache.delete(key);
      return data;
    }).catch(error => {
      this.cache.delete(key);
      throw error;
    });
    
    this.cache.set(key, promise);
    return promise;
  }
  
  invalidate(key: string) {
    this.cache.delete(key);
    this.results.delete(key);
  }
  
  clear() {
    this.cache.clear();
    this.results.clear();
  }
}

// 전역 요청 캐시
const requestCache = new RequestCache();

// 최적화된 사용자 데이터 핸들러
function useOptimizedUserDataHandlers() {
  const register = useUserActionRegister();
  const registry = useUserStores();
  
  const loadUserDataHandler = useCallback(async (payload, controller) => {
    const cacheKey = `user-data-${payload.userId}`;
    
    return await requestCache.fetch(cacheKey, async () => {
      return await PerformanceProfiler.measureAsync('user-data-fetch', async () => {
        const response = await fetch(`/api/users/${payload.userId}`);
        if (!response.ok) {
          throw new Error('사용자 데이터 로드 실패');
        }
        
        const userData = await response.json();
        
        // 스토어 업데이트
        const profileStore = registry.getStore('profile');
        profileStore.setValue(userData.profile);
        
        return userData;
      });
    });
  }, [registry]);
  
  // 사용자 데이터 무효화 핸들러
  const invalidateUserDataHandler = useCallback(async (payload, controller) => {
    const cacheKey = `user-data-${payload.userId}`;
    requestCache.invalidate(cacheKey);
    
    return { success: true, invalidated: true };
  }, []);
  
  useEffect(() => {
    if (!register) return;
    
    const unregisterLoad = register('loadUserData', loadUserDataHandler, {
      id: 'optimized-user-data-loader',
      priority: 100
    });
    
    const unregisterInvalidate = register('invalidateUserData', invalidateUserDataHandler, {
      id: 'user-data-cache-invalidator',
      priority: 100
    });
    
    return () => {
      unregisterLoad();
      unregisterInvalidate();
    };
  }, [register, loadUserDataHandler, invalidateUserDataHandler]);
}
```

### 2. 프리페칭과 백그라운드 로딩

```typescript
// 백그라운드 프리페칭
function useBackgroundPreloading() {
  const dispatch = useUserAction();
  
  // 사용자가 hover할 때 데이터 프리페치
  const preloadUserData = useCallback((userId: string) => {
    // 백그라운드에서 프리페치 (논블로킹)
    setTimeout(() => {
      dispatch('loadUserData', { userId }).catch(error => {
        console.warn('프리페치 실패:', error);
      });
    }, 0);
  }, [dispatch]);
  
  // 예상되는 네비게이션을 위한 프리페치
  const preloadNextPage = useCallback(() => {
    const currentPage = parseInt(location.pathname.split('/').pop() || '1');
    const nextPage = currentPage + 1;
    
    // 다음 페이지 데이터 미리 로드
    setTimeout(() => {
      dispatch('loadUserList', { page: nextPage }).catch(error => {
        console.warn('다음 페이지 프리페치 실패:', error);
      });
    }, 1000); // 1초 후 백그라운드 로딩
  }, [dispatch]);
  
  return { preloadUserData, preloadNextPage };
}

// 스마트 프리페칭이 적용된 사용자 카드
function SmartUserCard({ user }: { user: UserProfile }) {
  const { preloadUserData } = useBackgroundPreloading();
  const [isHovered, setIsHovered] = useState(false);
  
  const handleMouseEnter = useCallback(() => {
    setIsHovered(true);
    preloadUserData(user.id); // hover 시 프리페치
  }, [user.id, preloadUserData]);
  
  return (
    <div 
      className="user-card"
      onMouseEnter={handleMouseEnter}
      onMouseLeave={() => setIsHovered(false)}
    >
      <img src={user.avatar} alt={`${user.name} 프로필`} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      
      {isHovered && (
        <div className="hover-actions">
          <Link to={`/users/${user.id}`}>상세보기</Link>
        </div>
      )}
    </div>
  );
}
```

## 메모리 관리

### 1. 메모리 사용량 모니터링

```typescript
// 메모리 사용량 추적
class MemoryMonitor {
  private static instance: MemoryMonitor;
  private measurements: Array<{ timestamp: number; used: number }> = [];
  
  static getInstance() {
    if (!this.instance) {
      this.instance = new MemoryMonitor();
    }
    return this.instance;
  }
  
  measure() {
    if (typeof window !== 'undefined' && 'memory' in performance) {
      const memory = (performance as any).memory;
      const measurement = {
        timestamp: Date.now(),
        used: memory.usedJSHeapSize / 1024 / 1024 // MB 단위
      };
      
      this.measurements.push(measurement);
      
      // 최근 100개 측정값만 유지
      if (this.measurements.length > 100) {
        this.measurements.shift();
      }
      
      return measurement;
    }
    return null;
  }
  
  getStats() {
    if (this.measurements.length === 0) return null;
    
    const latest = this.measurements[this.measurements.length - 1];
    const first = this.measurements[0];
    const average = this.measurements.reduce((sum, m) => sum + m.used, 0) / this.measurements.length;
    const peak = Math.max(...this.measurements.map(m => m.used));
    
    return {
      current: latest.used,
      average,
      peak,
      trend: latest.used - first.used
    };
  }
}

// 메모리 모니터링 훅
function useMemoryMonitoring(interval = 5000) {
  const [memoryStats, setMemoryStats] = useState(null);
  
  useEffect(() => {
    if (process.env.NODE_ENV !== 'development') return;
    
    const monitor = MemoryMonitor.getInstance();
    
    const measureInterval = setInterval(() => {
      monitor.measure();
      setMemoryStats(monitor.getStats());
    }, interval);
    
    return () => clearInterval(measureInterval);
  }, [interval]);
  
  return memoryStats;
}
```

### 2. 메모리 누수 방지

```typescript
// 메모리 누수 방지 패턴
function useMemorySafeHandlers() {
  const register = useUserActionRegister();
  const registry = useUserStores();
  
  // WeakMap을 사용한 메모리 안전한 캐시
  const handlerCache = useMemo(() => new WeakMap(), []);
  
  const optimizedHandler = useCallback(async (payload, controller) => {
    // WeakMap 캐시 확인
    if (handlerCache.has(payload)) {
      return handlerCache.get(payload);
    }
    
    const result = await performExpensiveOperation(payload);
    
    // WeakMap에 결과 캐시 (자동 가비지 컬렉션)
    handlerCache.set(payload, result);
    
    return result;
  }, [handlerCache]);
  
  useEffect(() => {
    if (!register) return;
    
    const unregister = register('expensiveOperation', optimizedHandler, {
      id: 'memory-safe-handler',
      priority: 100
    });
    
    return () => {
      unregister();
      // WeakMap은 자동으로 정리되므로 추가 정리 불필요
    };
  }, [register, optimizedHandler]);
}

// 자동 정리가 적용된 구독
function useAutoCleanupSubscription() {
  const abortController = useMemo(() => new AbortController(), []);
  
  useEffect(() => {
    // AbortController를 사용한 자동 정리
    const subscription = someExternalService.subscribe(
      data => {
        // 데이터 처리
      },
      { signal: abortController.signal }
    );
    
    return () => {
      abortController.abort(); // 모든 관련 작업 취소
    };
  }, [abortController]);
}
```

## 성능 모니터링과 프로파일링

### 1. 실시간 성능 대시보드

```typescript
// 통합 성능 모니터
function usePerformanceMonitor() {
  const [performanceData, setPerformanceData] = useState({
    handlers: {},
    memory: null,
    renders: 0,
    storeUpdates: 0
  });
  
  // 렌더링 횟수 추적
  const renderCount = useRef(0);
  useEffect(() => {
    renderCount.current += 1;
    setPerformanceData(prev => ({ ...prev, renders: renderCount.current }));
  });
  
  // 스토어 업데이트 추적
  const updateCount = useRef(0);
  const profileStore = useUserStore('profile');
  
  useEffect(() => {
    const unsubscribe = profileStore.subscribe(() => {
      updateCount.current += 1;
      setPerformanceData(prev => ({ ...prev, storeUpdates: updateCount.current }));
    });
    
    return unsubscribe;
  }, [profileStore]);
  
  // 주기적 성능 데이터 수집
  useEffect(() => {
    const interval = setInterval(() => {
      const handlerStats = PerformanceProfiler.getAllStats();
      const memoryStats = MemoryMonitor.getInstance().getStats();
      
      setPerformanceData(prev => ({
        ...prev,
        handlers: handlerStats,
        memory: memoryStats
      }));
    }, 1000);
    
    return () => clearInterval(interval);
  }, []);
  
  return performanceData;
}

// 성능 대시보드 컴포넌트
function PerformanceMonitorDashboard() {
  const performanceData = usePerformanceMonitor();
  
  if (process.env.NODE_ENV !== 'development') {
    return null;
  }
  
  return (
    <div style={{
      position: 'fixed',
      top: '10px',
      left: '10px',
      width: '300px',
      backgroundColor: 'rgba(0,0,0,0.9)',
      color: 'white',
      padding: '10px',
      borderRadius: '5px',
      fontSize: '11px',
      fontFamily: 'monospace',
      zIndex: 10000
    }}>
      <h4>성능 모니터</h4>
      
      <div>
        <strong>렌더링:</strong> {performanceData.renders}회
      </div>
      
      <div>
        <strong>스토어 업데이트:</strong> {performanceData.storeUpdates}회
      </div>
      
      {performanceData.memory && (
        <div>
          <strong>메모리:</strong> {performanceData.memory.current.toFixed(1)}MB
          (평균: {performanceData.memory.average.toFixed(1)}MB)
        </div>
      )}
      
      <div style={{ marginTop: '10px' }}>
        <strong>핸들러 성능:</strong>
        {Object.entries(performanceData.handlers).map(([name, stats]: [string, any]) => (
          <div key={name} style={{ marginLeft: '10px', fontSize: '10px' }}>
            {name}: {stats.average?.toFixed(1)}ms (×{stats.count})
          </div>
        ))}
      </div>
    </div>
  );
}
```

---

## 모범 사례 체크리스트

### ✅ 스토어 최적화
- [ ] 선택적 구독 사용
- [ ] 조건부 구독 구현
- [ ] 복잡한 계산 메모화
- [ ] 적절한 변경 감지 전략 선택

### ✅ 핸들러 최적화
- [ ] 배치 처리 구현
- [ ] 디바운싱/쓰로틀링 적용
- [ ] 우선순위 기반 최적화
- [ ] 논블로킹 핸들러 활용

### ✅ 컴포넌트 최적화
- [ ] React.memo 적절히 사용
- [ ] 콜백 메모화
- [ ] 가상화 적용 (대용량 리스트)
- [ ] 지연 로딩 구현

### ✅ 네트워크 최적화
- [ ] 요청 중복 제거
- [ ] 캐싱 전략 구현
- [ ] 프리페칭 적용
- [ ] 백그라운드 로딩

### ✅ 메모리 관리
- [ ] 메모리 사용량 모니터링
- [ ] 자동 정리 구현
- [ ] WeakMap 활용
- [ ] 구독 해제 보장

### ✅ 성능 모니터링
- [ ] 핸들러 성능 추적
- [ ] 렌더링 최적화 검증
- [ ] 메모리 누수 감지
- [ ] 사용자 경험 메트릭

---

## 요약

Context-Action 프레임워크의 성능 최적화는 다음 원칙을 따릅니다:

- **측정 기반** - 실제 데이터로 최적화 결정
- **단계적 최적화** - 가장 큰 병목부터 해결
- **사용자 경험 우선** - 인지 가능한 성능 개선 집중
- **메모리 안전성** - 자동 정리와 누수 방지
- **모니터링 필수** - 지속적인 성능 추적

올바른 최적화 기법을 적용하면 대규모 애플리케이션에서도 우수한 성능을 유지할 수 있습니다.

---

::: tip 다음 단계
- [오류 처리](./error-handling) - 성능에 영향을 주는 오류 처리 최적화
- [모범 사례](./best-practices) - 프로덕션 환경 성능 권장사항
- [공통 함정](./common-pitfalls) - 성능 문제를 일으키는 일반적인 실수들
:::

---


# Guide Philosophy

**Source**: `guide/philosophy.md`  
**Priority**: 80 (essential)  

# 설계 철학

Context-Action 프레임워크는 모든 아키텍처 결정과 구현 패턴을 안내하는 기본 원칙들을 기반으로 구축되었습니다. 이러한 원칙을 이해하는 것은 효과적인 사용을 위해 필수적입니다.

## 핵심 철학

**"타입 안전한 도메인 격리를 통한 증거 기반 아키텍처"**

프레임워크는 MVVM에서 영감을 받은 패턴을 통해 깔끔한 관심사 분리를 구현합니다:

- **액션**이 비즈니스 로직 처리 (ViewModel 계층)
- **컨텍스트 스토어 패턴**이 도메인 격리와 함께 상태 관리 (Model 계층)  
- **컴포넌트**가 UI 렌더링 (View 계층)
- **컨텍스트 경계**가 기능 도메인 격리
- 도메인별 훅을 통한 **타입 안전 통합**

## 기본 원칙

### 1. 도메인 격리 우선

각 기능 도메인은 컨텍스트 경계를 통해 완전한 독립성을 유지합니다:

```typescript
// 각 도메인이 고유한 격리된 컨텍스트를 가짐
const UserDomain = createContextStorePattern('User');
const CartDomain = createContextStorePattern('Cart');
const OrderDomain = createContextStorePattern('Order');
```

**장점:**
- 도메인 간 우발적인 상태 결합 방지
- 팀이 다른 도메인에서 독립적으로 작업 가능
- 쉬운 테스팅과 디버깅
- 대규모 애플리케이션을 위한 확장 가능한 아키텍처

### 2. 모든 계층에서 타입 안전성

완전한 TypeScript 통합으로 컴파일 시 안전성 보장:

```typescript
// 도메인별 인터페이스
interface UserData {
  profile: { id: string; name: string; email: string };
  preferences: { theme: 'light' | 'dark' };
}

interface UserActions {
  updateProfile: { data: Partial<UserData['profile']> };
  toggleTheme: void;
}

// 타입 안전한 훅 자동 추론
const profileStore = useUserStore('profile'); // Store<UserData['profile']>로 타입됨
const dispatch = useUserAction(); // UserActions에 대한 타입 안전 디스패치
```

### 3. 선언적 액션 파이프라인

비즈니스 로직은 선언적 파이프라인 시스템을 통해 흐릅니다:

```typescript
// 어떻게가 아닌 무엇을 선언
dispatch('updateProfile', { data: { name: '새 이름' } });

// 프레임워크가 "어떻게"를 처리:
// 1. 액션 검증
// 2. 우선순위별 핸들러 실행
// 3. 스토어 업데이트
// 4. 컴포넌트 리렌더링
```

### 4. 반응형 상태 관리

컴포넌트가 관련 상태 변경에 자동으로 반응:

```typescript
function UserProfile() {
  const profile = useStoreValue(useUserStore('profile'));
  // ↑ 프로필이 변경될 때만 컴포넌트가 리렌더링됨
  
  return <div>환영합니다, {profile.name}님!</div>;
}
```

## 아키텍처 패턴

### MVVM에서 영감받은 분리

```mermaid
graph TD
    V[View 계층<br/>React 컴포넌트] --> VM[ViewModel 계층<br/>액션 핸들러]
    VM --> M[Model 계층<br/>스토어 시스템]
    M --> V
    
    subgraph "도메인 경계"
        VM
        M
    end
```

### 컨텍스트 스토어 패턴

도메인 격리를 위한 핵심 패턴:

```typescript
// 1. 도메인 컨텍스트 생성
const UserStores = createContextStorePattern('User');

// 2. 컨텍스트 경계 제공
<UserStores.Provider registryId="user-app">
  <UserComponents />
</UserStores.Provider>

// 3. 경계 내에서 사용
const userStore = UserStores.useStore('profile', initialData);
```

## 설계 결정

### 왜 도메인별 훅인가?

**전통적인 접근법 (제네릭):**
```typescript
const store = useStore('user-profile'); // 타입 정보 없음
const dispatch = useDispatch(); // 액션 타입 안전성 없음
```

**Context-Action 접근법 (도메인별):**
```typescript
const store = useUserStore('profile'); // 완전히 타입됨
const dispatch = useUserAction(); // 타입 안전한 액션
```

**장점:**
- 완전한 TypeScript 추론
- 명확한 도메인 경계
- 리팩토링 안전성
- 더 나은 개발자 경험

### 왜 직접 상태 업데이트 대신 액션 파이프라인인가?

**직접 업데이트 (안티패턴):**
```typescript
// 분산된 비즈니스 로직
function updateUser() {
  setUser(prev => ({ ...prev, name: '새 이름' }));
  logActivity('user_updated');
  validateUser();
  syncToServer();
}
```

**액션 파이프라인 (권장):**
```typescript
// 중앙화되고 테스트 가능한 비즈니스 로직
dispatch('updateUser', { name: '새 이름' });

// 핸들러가 복잡성 관리:
register('updateUser', async (payload, controller) => {
  const userStore = registry.getStore('user');
  // 업데이트, 로그, 검증, 동기화 - 한 곳에서
});
```

**장점:**
- 중앙화된 비즈니스 로직
- 테스트 가능한 핸들러
- 일관된 오류 처리
- 감사 가능한 액션 흐름

## 성능 철학

### 최소한의 리렌더링

변경된 데이터를 사용하는 컴포넌트만 리렌더링:

```typescript
// 컴포넌트 A는 프로필 사용
const profile = useStoreValue(useUserStore('profile'));

// 컴포넌트 B는 환경설정 사용  
const prefs = useStoreValue(useUserStore('preferences'));

// 프로필 업데이트해도 컴포넌트 B는 리렌더링되지 않음
dispatch('updateProfile', { name: '새 이름' });
```

### 핸들러에서 지연 평가

지연 스토어 접근으로 오래된 클로저 방지:

```typescript
const handler = async (payload, controller) => {
  // ❌ 오래됨: 등록 시점에 캡처됨
  const oldValue = profileStore.getValue();
  
  // ✅ 최신: 실행 시점에 평가됨
  const currentValue = registry.getStore('profile').getValue();
};
```

## 개발자 경험 우선순위

### 1. 형식 없는 타입 안전성

```typescript
// 자동 추론, 수동 타이핑 불필요
const store = useUserStore('profile'); // Store<UserProfile>
const profile = useStoreValue(store); // UserProfile
```

### 2. 직관적인 API 설계

```typescript
// 자연스럽고 React같은 패턴
const dispatch = useUserAction();
dispatch('updateProfile', { name: '새 이름' });
```

### 3. 명확한 오류 메시지

```typescript
// 컴파일 시 오류가 올바른 사용법을 안내
dispatch('invalidAction', { data: 'wrong' }); 
// TS 오류: 'invalidAction'은 UserActions에 존재하지 않습니다
```

### 4. 유연한 통합

```typescript
// 기존 React 패턴과 함께 작동
function useUserProfile() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  const dispatch = useUserAction();
  
  // 다른 훅과 자연스럽게 조합
  const memoizedData = useMemo(() => 
    processProfile(profile), [profile]
  );
  
  return { profile, memoizedData, dispatch };
}
```

## 아키텍처 장점

### 확장성

- **수평적:** 기존 도메인에 영향을 주지 않고 새 도메인 추가
- **수직적:** 도메인 간 오염 없이 도메인 내 기능 추가
- **팀:** 여러 팀이 다른 도메인에서 독립적으로 작업 가능

### 유지보수성

- **명확한 경계:** 도메인 격리가 예기치 않은 의존성 방지
- **테스트 가능성:** 핸들러의 비즈니스 로직을 쉽게 단위 테스트
- **디버그 가능성:** 액션 흐름이 감사 가능하고 추적 가능

### 성능

- **선택적 리렌더링:** 영향받은 컴포넌트만 업데이트
- **지연 로딩:** 도메인을 요청 시 로드 가능
- **메모리 효율성:** 컨텍스트 경계가 메모리 누수 방지

---

## 요약

Context-Action 프레임워크의 철학은 **반응형 상태 관리**와 함께 **타입 안전한 도메인 격리**를 중심으로 합니다. MVVM에서 영감받은 패턴과 선언적 액션 파이프라인을 따르면 애플리케이션이 더 유지보수하기 쉽고, 테스트하기 쉽고, 확장 가능해집니다.

프레임워크는 자동 타입 추론, 직관적인 API, 그리고 올바른 사용 패턴을 안내하는 명확한 아키텍처 경계를 통해 개발자 경험을 우선시합니다.

---

::: tip 다음 단계
이제 철학을 이해했으니, [핵심 개념](./concepts)을 탐색하여 이러한 원칙이 실용적인 구현 패턴으로 어떻게 변환되는지 확인해보세요.
:::

---


# Guide Provider Composition

**Source**: `guide/provider-composition.md`  
**Priority**: 80 (essential)  

# 프로바이더 구성

프로바이더 구성은 Context-Action 프레임워크에서 도메인 경계를 정의하고 애플리케이션 아키텍처를 구성하는 핵심 패턴입니다. 이 가이드는 효과적인 프로바이더 조합 전략을 다룹니다.

## 기본 프로바이더 구조

### 단일 도메인 프로바이더

```typescript
// providers/UserProvider.tsx
import React from 'react';
import { UserStoreProvider, UserActionProvider } from '@/stores/user';
import { useUserHandlers } from '@/hooks/handlers/useUserHandlers';

// 핸들러 설정 컴포넌트
function UserHandlersSetup() {
  useUserHandlers(); // 모든 사용자 핸들러 등록
  return null;
}

// 통합 사용자 프로바이더
export function UserProvider({ children }: { children: React.ReactNode }) {
  return (
    <UserStoreProvider>
      <UserActionProvider>
        <UserHandlersSetup />
        {children}
      </UserActionProvider>
    </UserStoreProvider>
  );
}

// 사용법
function UserSection() {
  return (
    <UserProvider>
      <UserProfile />
      <UserSettings />
    </UserProvider>
  );
}
```

### 다중 도메인 프로바이더

```typescript
// providers/AppProvider.tsx
import React from 'react';
import { UserProvider } from './UserProvider';
import { CartProvider } from './CartProvider';
import { OrderProvider } from './OrderProvider';
import { NotificationProvider } from './NotificationProvider';

// 계층적 프로바이더 구성
export function AppProvider({ children }: { children: React.ReactNode }) {
  return (
    <UserProvider>          {/* 최상위: 사용자 컨텍스트 */}
      <NotificationProvider> {/* 알림 시스템 */}
        <CartProvider>       {/* 장바구니 도메인 */}
          <OrderProvider>    {/* 주문 도메인 */}
            {children}
          </OrderProvider>
        </CartProvider>
      </NotificationProvider>
    </UserProvider>
  );
}
```

## 프로바이더 구성 패턴

### 1. 계층적 구성

```typescript
// 의존성 순서에 따른 계층 구성
function HierarchicalProviders({ children }: { children: React.ReactNode }) {
  return (
    // Level 1: 기반 서비스 (인증, 설정)
    <AuthProvider>
      <ConfigProvider>
        
        {/* Level 2: 핵심 비즈니스 도메인 */}
        <UserProvider>
          <ProductProvider>
            
            {/* Level 3: 상위 비즈니스 로직 */}
            <CartProvider>
              <OrderProvider>
                
                {/* Level 4: UI/UX 도메인 */}
                <NotificationProvider>
                  <ThemeProvider>
                    {children}
                  </ThemeProvider>
                </NotificationProvider>
                
              </OrderProvider>
            </CartProvider>
            
          </ProductProvider>
        </UserProvider>
        
      </ConfigProvider>
    </AuthProvider>
  );
}
```

### 2. 병렬 구성

```typescript
// 독립적인 도메인들의 병렬 구성
function ParallelProviders({ children }: { children: React.ReactNode }) {
  return (
    <div>
      {/* 각 도메인이 독립적으로 작동 */}
      <UserProvider>
        <UserSection />
      </UserProvider>
      
      <CartProvider>
        <ShoppingSection />
      </CartProvider>
      
      <OrderProvider>
        <OrderHistorySection />
      </OrderProvider>
      
      {/* 공통 영역은 여러 프로바이더로 래핑 */}
      <UserProvider>
        <CartProvider>
          <CheckoutSection />
        </CartProvider>
      </UserProvider>
    </div>
  );
}
```

### 3. 조건부 구성

```typescript
// 사용자 역할에 따른 조건부 프로바이더
interface ConditionalProvidersProps {
  children: React.ReactNode;
  userRole: 'guest' | 'user' | 'admin';
}

export function ConditionalProviders({ children, userRole }: ConditionalProvidersProps) {
  // 기본 프로바이더 (모든 역할)
  let providers = (
    <UserProvider>
      <ProductProvider>
        {children}
      </ProductProvider>
    </UserProvider>
  );
  
  // 로그인 사용자 전용
  if (userRole !== 'guest') {
    providers = (
      <UserProvider>
        <ProductProvider>
          <CartProvider>
            <OrderProvider>
              {children}
            </OrderProvider>
          </CartProvider>
        </ProductProvider>
      </UserProvider>
    );
  }
  
  // 관리자 전용
  if (userRole === 'admin') {
    providers = (
      <UserProvider>
        <ProductProvider>
          <CartProvider>
            <OrderProvider>
              <AdminProvider>
                <AnalyticsProvider>
                  {children}
                </AnalyticsProvider>
              </AdminProvider>
            </OrderProvider>
          </CartProvider>
        </ProductProvider>
      </UserProvider>
    );
  }
  
  return providers;
}
```

### 4. 동적 구성

```typescript
// 런타임에 프로바이더 동적 구성
interface DynamicProvidersProps {
  children: React.ReactNode;
  enabledFeatures: string[];
}

export function DynamicProviders({ children, enabledFeatures }: DynamicProvidersProps) {
  const [providers, setProviders] = useState<React.ComponentType<any>[]>([]);
  
  useEffect(() => {
    const providersList = [UserProvider]; // 기본 프로바이더
    
    // 기능별 프로바이더 추가
    if (enabledFeatures.includes('cart')) {
      providersList.push(CartProvider);
    }
    
    if (enabledFeatures.includes('notifications')) {
      providersList.push(NotificationProvider);
    }
    
    if (enabledFeatures.includes('analytics')) {
      providersList.push(AnalyticsProvider);
    }
    
    setProviders(providersList);
  }, [enabledFeatures]);
  
  // 프로바이더들을 중첩으로 구성
  const renderProviders = (providers: React.ComponentType<any>[], index = 0): React.ReactNode => {
    if (index >= providers.length) {
      return children;
    }
    
    const Provider = providers[index];
    return (
      <Provider>
        {renderProviders(providers, index + 1)}
      </Provider>
    );
  };
  
  return <>{renderProviders(providers)}</>;
}
```

## 고급 구성 패턴

### 1. 팩토리 패턴

```typescript
// 프로바이더 팩토리
interface ProviderConfig {
  user: boolean;
  cart: boolean;
  orders: boolean;
  admin?: boolean;
  analytics?: boolean;
}

export function createProviderStack(config: ProviderConfig) {
  return function ProviderStack({ children }: { children: React.ReactNode }) {
    let stack = children;
    
    // 역순으로 프로바이더 적용 (가장 안쪽부터)
    if (config.analytics) {
      stack = <AnalyticsProvider>{stack}</AnalyticsProvider>;
    }
    
    if (config.admin) {
      stack = <AdminProvider>{stack}</AdminProvider>;
    }
    
    if (config.orders) {
      stack = <OrderProvider>{stack}</OrderProvider>;
    }
    
    if (config.cart) {
      stack = <CartProvider>{stack}</CartProvider>;
    }
    
    if (config.user) {
      stack = <UserProvider>{stack}</UserProvider>;
    }
    
    return <>{stack}</>;
  };
}

// 사용법
const UserAppProviders = createProviderStack({
  user: true,
  cart: true,
  orders: false,
  admin: false
});

const AdminAppProviders = createProviderStack({
  user: true,
  cart: true,
  orders: true,
  admin: true,
  analytics: true
});

function UserApp() {
  return (
    <UserAppProviders>
      <UserDashboard />
    </UserAppProviders>
  );
}
```

### 2. 컨텍스트 전달 패턴

```typescript
// 상위 컨텍스트에서 하위 컨텍스트로 데이터 전달
interface CartProviderProps {
  children: React.ReactNode;
  userId?: string; // 상위에서 전달받은 사용자 ID
}

export function EnhancedCartProvider({ children, userId }: CartProviderProps) {
  return (
    <CartStoreProvider>
      <CartActionProvider>
        <CartHandlersSetup userId={userId} />
        {children}
      </CartActionProvider>
    </CartStoreProvider>
  );
}

function CartHandlersSetup({ userId }: { userId?: string }) {
  useCartHandlers(userId); // 사용자 ID를 핸들러에 전달
  return null;
}

// 통합 사용법
function IntegratedProviders({ children }: { children: React.ReactNode }) {
  const [currentUserId, setCurrentUserId] = useState<string>();
  
  return (
    <UserProvider>
      {/* 사용자 ID 획득을 위한 컴포넌트 */}
      <UserIdCapture onUserIdChange={setCurrentUserId} />
      
      {/* 사용자 ID를 장바구니 프로바이더에 전달 */}
      <EnhancedCartProvider userId={currentUserId}>
        {children}
      </EnhancedCartProvider>
    </UserProvider>
  );
}
```

### 3. 지연 로딩 프로바이더

```typescript
// 코드 분할을 활용한 지연 로딩
const LazyCartProvider = React.lazy(() => import('./CartProvider'));
const LazyOrderProvider = React.lazy(() => import('./OrderProvider'));
const LazyAdminProvider = React.lazy(() => import('./AdminProvider'));

interface LazyProvidersProps {
  children: React.ReactNode;
  features: {
    cart?: boolean;
    orders?: boolean;
    admin?: boolean;
  };
}

export function LazyProviders({ children, features }: LazyProvidersProps) {
  return (
    <UserProvider>
      <Suspense fallback={<div>기본 기능 로딩 중...</div>}>
        {features.cart ? (
          <LazyCartProvider>
            <Suspense fallback={<div>주문 기능 로딩 중...</div>}>
              {features.orders ? (
                <LazyOrderProvider>
                  <Suspense fallback={<div>관리자 기능 로딩 중...</div>}>
                    {features.admin ? (
                      <LazyAdminProvider>
                        {children}
                      </LazyAdminProvider>
                    ) : children}
                  </Suspense>
                </LazyOrderProvider>
              ) : children}
            </Suspense>
          </LazyCartProvider>
        ) : children}
      </Suspense>
    </UserProvider>
  );
}
```

## 프로바이더 최적화

### 1. 메모화된 프로바이더

```typescript
// 불필요한 리렌더링 방지
const MemoizedUserProvider = React.memo<{
  children: React.ReactNode;
  config?: UserProviderConfig;
}>(({ children, config }) => {
  return (
    <UserStoreProvider config={config}>
      <UserActionProvider>
        <UserHandlersSetup />
        {children}
      </UserActionProvider>
    </UserStoreProvider>
  );
});

// 설정이 변경될 때만 리렌더링
function OptimizedApp() {
  const [userConfig] = useState({ debug: false, logLevel: 'warn' });
  
  return (
    <MemoizedUserProvider config={userConfig}>
      <AppContent />
    </MemoizedUserProvider>
  );
}
```

### 2. 조건부 렌더링 최적화

```typescript
// 조건부 프로바이더 최적화
function ConditionalOptimizedProviders({ 
  children, 
  userRole 
}: { 
  children: React.ReactNode; 
  userRole: string;
}) {
  // 역할별 프로바이더 구성 메모화
  const ProviderComponent = useMemo(() => {
    switch (userRole) {
      case 'admin':
        return ({ children }) => (
          <UserProvider>
            <CartProvider>
              <OrderProvider>
                <AdminProvider>
                  {children}
                </AdminProvider>
              </OrderProvider>
            </CartProvider>
          </UserProvider>
        );
      
      case 'user':
        return ({ children }) => (
          <UserProvider>
            <CartProvider>
              <OrderProvider>
                {children}
              </OrderProvider>
            </CartProvider>
          </UserProvider>
        );
      
      default:
        return ({ children }) => (
          <UserProvider>
            {children}
          </UserProvider>
        );
    }
  }, [userRole]);
  
  return <ProviderComponent>{children}</ProviderComponent>;
}
```

### 3. 프로바이더 분할

```typescript
// 기능별 프로바이더 분할
function CoreProviders({ children }: { children: React.ReactNode }) {
  return (
    <ErrorBoundary>
      <UserProvider>
        <ConfigProvider>
          {children}
        </ConfigProvider>
      </UserProvider>
    </ErrorBoundary>
  );
}

function BusinessProviders({ children }: { children: React.ReactNode }) {
  return (
    <CartProvider>
      <OrderProvider>
        <PaymentProvider>
          {children}
        </PaymentProvider>
      </OrderProvider>
    </CartProvider>
  );
}

function UIProviders({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider>
      <NotificationProvider>
        <ModalProvider>
          {children}
        </ModalProvider>
      </NotificationProvider>
    </ThemeProvider>
  );
}

// 조합된 애플리케이션
function App() {
  return (
    <CoreProviders>
      <BusinessProviders>
        <UIProviders>
          <Router>
            <Routes />
          </Router>
        </UIProviders>
      </BusinessProviders>
    </CoreProviders>
  );
}
```

## 프로바이더 테스팅

### 1. 테스트 프로바이더

```typescript
// 테스트용 프로바이더 래퍼
export function TestProviders({ 
  children,
  initialStores = {}
}: {
  children: React.ReactNode;
  initialStores?: Record<string, any>;
}) {
  return (
    <UserProvider>
      <CartProvider>
        <TestStoreInitializer initialStores={initialStores}>
          {children}
        </TestStoreInitializer>
      </CartProvider>
    </UserProvider>
  );
}

// 테스트 유틸리티
export const renderWithProviders = (
  ui: React.ReactElement,
  options: {
    initialStores?: Record<string, any>;
    providerProps?: any;
  } = {}
) => {
  const { initialStores, providerProps } = options;
  
  const Wrapper = ({ children }) => (
    <TestProviders initialStores={initialStores} {...providerProps}>
      {children}
    </TestProviders>
  );
  
  return render(ui, { wrapper: Wrapper });
};

// 사용법
describe('UserProfile', () => {
  it('초기 사용자 데이터로 렌더링', () => {
    const initialStores = {
      'user.profile': { name: 'Test User', email: 'test@example.com' }
    };
    
    renderWithProviders(<UserProfile />, { initialStores });
    
    expect(screen.getByText('Test User')).toBeInTheDocument();
  });
});
```

### 2. 프로바이더 격리 테스트

```typescript
// 특정 도메인만 테스트
function renderWithUserProvider(ui: React.ReactElement) {
  return render(
    <UserProvider>
      {ui}
    </UserProvider>
  );
}

function renderWithCartProvider(ui: React.ReactElement) {
  return render(
    <CartProvider>
      {ui}
    </CartProvider>
  );
}

// 크로스 도메인 테스트
function renderWithMultipleProviders(ui: React.ReactElement) {
  return render(
    <UserProvider>
      <CartProvider>
        {ui}
      </CartProvider>
    </UserProvider>
  );
}
```

## 디버깅과 개발 도구

### 1. 개발 모드 로깅

```typescript
// 개발 환경에서 프로바이더 로깅
function DebuggableProvider({ children, name }: { 
  children: React.ReactNode; 
  name: string;
}) {
  useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      console.log(`${name} Provider mounted`);
      return () => console.log(`${name} Provider unmounted`);
    }
  }, [name]);
  
  return <>{children}</>;
}

// 사용법
export function UserProvider({ children }: { children: React.ReactNode }) {
  return (
    <DebuggableProvider name="User">
      <UserStoreProvider>
        <UserActionProvider>
          <UserHandlersSetup />
          {children}
        </UserActionProvider>
      </UserStoreProvider>
    </DebuggableProvider>
  );
}
```

### 2. 프로바이더 트리 시각화

```typescript
// 개발 도구용 프로바이더 트리 표시
function ProviderTreeDebugger() {
  if (process.env.NODE_ENV !== 'development') {
    return null;
  }
  
  return (
    <div style={{ 
      position: 'fixed', 
      top: 0, 
      right: 0, 
      background: 'rgba(0,0,0,0.8)',
      color: 'white',
      padding: '10px',
      fontSize: '12px'
    }}>
      <h4>Provider Tree</h4>
      <div>└ App</div>
      <div>&nbsp;&nbsp;└ UserProvider</div>
      <div>&nbsp;&nbsp;&nbsp;&nbsp;└ CartProvider</div>
      <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└ OrderProvider</div>
    </div>
  );
}
```

## 모범 사례

### 1. 의존성 순서

```typescript
// ✅ 좋음: 의존성 순서에 따른 구성
function ProperDependencyOrder({ children }: { children: React.ReactNode }) {
  return (
    <AuthProvider>      {/* 기반 인증 */}
      <UserProvider>    {/* 사용자 정보 (인증 의존) */}
        <CartProvider>  {/* 장바구니 (사용자 의존) */}
          <OrderProvider> {/* 주문 (사용자 + 장바구니 의존) */}
            {children}
          </OrderProvider>
        </CartProvider>
      </UserProvider>
    </AuthProvider>
  );
}

// ❌ 피하기: 잘못된 의존성 순서
function WrongDependencyOrder({ children }: { children: React.ReactNode }) {
  return (
    <OrderProvider>     {/* 주문이 최상위? */}
      <CartProvider>    {/* 장바구니가 사용자보다 위? */}
        <UserProvider>  {/* 사용자 정보가 마지막? */}
          <AuthProvider> {/* 인증이 가장 안쪽? */}
            {children}
          </AuthProvider>
        </UserProvider>
      </CartProvider>
    </OrderProvider>
  );
}
```

### 2. 적절한 경계 설정

```typescript
// ✅ 좋음: 명확한 도메인 경계
function App() {
  return (
    <div>
      {/* 사용자 관련 섹션 */}
      <UserProvider>
        <Header />
        <UserDashboard />
      </UserProvider>
      
      {/* 쇼핑 관련 섹션 */}
      <UserProvider>
        <CartProvider>
          <ShoppingArea />
          <Checkout />
        </CartProvider>
      </UserProvider>
      
      {/* 관리자 전용 섹션 */}
      <AdminProvider>
        <AdminPanel />
      </AdminProvider>
    </div>
  );
}
```

### 3. 성능 고려사항

```typescript
// ✅ 좋음: 필요한 곳에만 프로바이더 적용
function OptimizedLayout() {
  return (
    <div>
      <Header /> {/* 프로바이더 없음 - 정적 헤더 */}
      
      <main>
        <UserProvider>
          <UserContent /> {/* 사용자 데이터가 필요한 부분만 */}
        </UserProvider>
      </main>
      
      <Footer /> {/* 프로바이더 없음 - 정적 푸터 */}
    </div>
  );
}

// ❌ 피하기: 불필요한 전역 프로바이더
function InefficientLayout() {
  return (
    <UserProvider> {/* 모든 컴포넌트를 래핑 */}
      <Header />   {/* 사용자 데이터 불필요 */}
      <main>
        <UserContent />
      </main>
      <Footer />   {/* 사용자 데이터 불필요 */}
    </UserProvider>
  );
}
```

---

## 요약

효과적인 프로바이더 구성은 다음 원칙을 따릅니다:

- **명확한 도메인 경계** - 책임과 의존성에 따른 분리
- **적절한 계층 구조** - 의존성 순서에 따른 중첩
- **성능 최적화** - 필요한 곳에만 프로바이더 적용
- **유연한 구성** - 조건부 및 동적 프로바이더 지원
- **테스트 가능성** - 격리된 테스트를 위한 구조

올바른 프로바이더 구성을 통해 확장 가능하고 유지보수 가능한 애플리케이션 아키텍처를 구축할 수 있습니다.

---

::: tip 다음 단계
- [핸들러 ID 전략](./handler-id-strategies) - 핸들러 식별과 관리
- [크로스 도메인 통합](./cross-domain-integration) - 도메인 간 통신 패턴
- [성능 최적화](./performance) - 프로바이더 성능 최적화
:::

---


# Guide React Integration

**Source**: `guide/react-integration.md`  
**Priority**: 80 (essential)  

# React 통합

Context-Action 프레임워크는 React의 Context API와 훅 시스템을 완전히 활용하여 자연스러운 React 개발 경험을 제공합니다. 이 가이드는 효과적인 React 통합 패턴을 다룹니다.

## 기본 통합 패턴

### 컴포넌트에서의 상태 구독

```typescript
// 반응형 상태 구독
function UserProfile() {
  // 도메인별 스토어 접근
  const profileStore = useUserStore('profile');
  const settingsStore = useUserStore('settings');
  
  // 자동 구독과 리렌더링
  const profile = useStoreValue(profileStore);
  const settings = useStoreValue(settingsStore);
  
  return (
    <div className={`profile theme-${settings.theme}`}>
      <img src={profile.avatar} alt={`${profile.name}의 아바타`} />
      <h1>{profile.name}</h1>
      <p>{profile.email}</p>
    </div>
  );
}
```

### 액션 디스패치

```typescript
function UserEditor() {
  const dispatch = useUserAction();
  const [formData, setFormData] = useState({
    name: '',
    email: ''
  });
  
  const handleSubmit = useCallback(async (e: React.FormEvent) => {
    e.preventDefault();
    
    // 타입 안전한 액션 디스패치
    await dispatch('updateProfile', {
      data: formData
    });
    
    // 폼 초기화
    setFormData({ name: '', email: '' });
  }, [dispatch, formData]);
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        value={formData.name}
        onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
        placeholder="이름"
      />
      <input
        type="email"
        value={formData.email}
        onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
        placeholder="이메일"
      />
      <button type="submit">저장</button>
    </form>
  );
}
```

## 고급 통합 패턴

### 1. 선택적 구독

```typescript
function OptimizedUserDisplay() {
  const profileStore = useUserStore('profile');
  
  // 특정 필드만 구독하여 불필요한 리렌더링 방지
  const userName = useStoreValue(profileStore, profile => profile.name);
  const userEmail = useStoreValue(profileStore, profile => profile.email);
  
  // status 변경 시에는 리렌더링되지 않음
  return (
    <div>
      <h2>{userName}</h2>
      <p>{userEmail}</p>
    </div>
  );
}
```

### 2. 조건부 구독

```typescript
function ConditionalUserData({ showDetails }: { showDetails: boolean }) {
  const profileStore = useUserStore('profile');
  
  // showDetails가 true일 때만 프로필 데이터 구독
  const profile = useStoreValue(profileStore, 
    showDetails 
      ? (profile) => profile  // 전체 프로필 구독
      : () => null           // 구독 안함
  );
  
  if (!showDetails) {
    return <div>기본 정보만 표시</div>;
  }
  
  return (
    <div>
      <h2>{profile?.name}</h2>
      <p>이메일: {profile?.email}</p>
      <p>가입일: {profile?.joinDate}</p>
    </div>
  );
}
```

### 3. 파생 상태 패턴

```typescript
function UserStatsDisplay() {
  const profileStore = useUserStore('profile');
  const activityStore = useUserStore('activity');
  
  const profile = useStoreValue(profileStore);
  const activity = useStoreValue(activityStore);
  
  // 파생 상태 계산
  const stats = useMemo(() => {
    const accountAge = Date.now() - new Date(profile.joinDate).getTime();
    const avgDailyActivity = activity.totalActions / (accountAge / (24 * 60 * 60 * 1000));
    
    return {
      accountAgeDays: Math.floor(accountAge / (24 * 60 * 60 * 1000)),
      averageDailyActivity: Math.round(avgDailyActivity * 100) / 100,
      activityLevel: avgDailyActivity > 10 ? 'high' : avgDailyActivity > 5 ? 'medium' : 'low'
    };
  }, [profile.joinDate, activity.totalActions]);
  
  return (
    <div>
      <h3>사용자 통계</h3>
      <p>계정 사용 일수: {stats.accountAgeDays}일</p>
      <p>일평균 활동: {stats.averageDailyActivity}</p>
      <p>활동 수준: {stats.activityLevel}</p>
    </div>
  );
}
```

### 4. 사용자 정의 훅 조합

```typescript
// 복합 비즈니스 로직 훅
function useUserProfile() {
  const profileStore = useUserStore('profile');
  const sessionStore = useUserStore('session');
  const dispatch = useUserAction();
  
  const profile = useStoreValue(profileStore);
  const session = useStoreValue(sessionStore);
  
  const [isUpdating, setIsUpdating] = useState(false);
  
  // 프로필 업데이트 로직
  const updateProfile = useCallback(async (data: Partial<UserProfile>) => {
    setIsUpdating(true);
    try {
      await dispatch('updateProfile', { data });
    } finally {
      setIsUpdating(false);
    }
  }, [dispatch]);
  
  // 인증 상태 확인
  const isAuthenticated = useMemo(() => {
    return session.isLoggedIn && 
           session.token && 
           (!session.expiresAt || session.expiresAt > Date.now());
  }, [session]);
  
  // 프로필 완성도
  const completionRate = useMemo(() => {
    const fields = ['name', 'email', 'avatar', 'bio', 'location'];
    const completed = fields.filter(field => profile[field]).length;
    return Math.round((completed / fields.length) * 100);
  }, [profile]);
  
  return {
    profile,
    session,
    isUpdating,
    isAuthenticated,
    completionRate,
    updateProfile
  };
}

// 사용법
function UserProfileCard() {
  const { 
    profile, 
    isUpdating, 
    isAuthenticated, 
    completionRate, 
    updateProfile 
  } = useUserProfile();
  
  if (!isAuthenticated) {
    return <LoginPrompt />;
  }
  
  return (
    <div className="profile-card">
      <div className="profile-header">
        <img src={profile.avatar} alt="프로필 사진" />
        <h2>{profile.name}</h2>
        <div className="completion-badge">
          프로필 완성도: {completionRate}%
        </div>
      </div>
      
      <ProfileEditForm 
        profile={profile}
        onUpdate={updateProfile}
        isLoading={isUpdating}
      />
    </div>
  );
}
```

### 5. 폼 상태 통합

```typescript
// 폼과 글로벌 상태의 통합
function UserSettingsForm() {
  const settingsStore = useUserStore('settings');
  const settings = useStoreValue(settingsStore);
  const dispatch = useUserAction();
  
  // 로컬 폼 상태 (임시 편집 상태)
  const [localSettings, setLocalSettings] = useState(settings);
  const [hasChanges, setHasChanges] = useState(false);
  
  // 글로벌 상태 변경 시 로컬 상태 동기화
  useEffect(() => {
    setLocalSettings(settings);
    setHasChanges(false);
  }, [settings]);
  
  // 폼 변경 감지
  const handleFieldChange = useCallback((field: string, value: any) => {
    setLocalSettings(prev => {
      const updated = { ...prev, [field]: value };
      setHasChanges(JSON.stringify(updated) !== JSON.stringify(settings));
      return updated;
    });
  }, [settings]);
  
  // 저장
  const handleSave = useCallback(async () => {
    if (hasChanges) {
      await dispatch('updateSettings', { settings: localSettings });
    }
  }, [dispatch, localSettings, hasChanges]);
  
  // 취소
  const handleCancel = useCallback(() => {
    setLocalSettings(settings);
    setHasChanges(false);
  }, [settings]);
  
  return (
    <form>
      <div>
        <label>테마</label>
        <select
          value={localSettings.theme}
          onChange={(e) => handleFieldChange('theme', e.target.value)}
        >
          <option value="light">라이트</option>
          <option value="dark">다크</option>
        </select>
      </div>
      
      <div>
        <label>언어</label>
        <select
          value={localSettings.language}
          onChange={(e) => handleFieldChange('language', e.target.value)}
        >
          <option value="ko">한국어</option>
          <option value="en">English</option>
        </select>
      </div>
      
      <div>
        <label>
          <input
            type="checkbox"
            checked={localSettings.notifications}
            onChange={(e) => handleFieldChange('notifications', e.target.checked)}
          />
          알림 받기
        </label>
      </div>
      
      <div className="form-actions">
        <button 
          type="button" 
          onClick={handleSave}
          disabled={!hasChanges}
        >
          저장
        </button>
        <button 
          type="button" 
          onClick={handleCancel}
          disabled={!hasChanges}
        >
          취소
        </button>
      </div>
    </form>
  );
}
```

## 성능 최적화 패턴

### 1. 컴포넌트 분할

```typescript
// ❌ 비효율적: 하나의 컴포넌트에서 모든 상태 구독
function LargeUserComponent() {
  const profile = useStoreValue(useUserStore('profile'));
  const settings = useStoreValue(useUserStore('settings'));
  const activity = useStoreValue(useUserStore('activity'));
  const notifications = useStoreValue(useUserStore('notifications'));
  
  // 모든 상태 변경 시 전체 컴포넌트 리렌더링
  return (
    <div>
      <UserHeader profile={profile} />
      <UserSettings settings={settings} />
      <UserActivity activity={activity} />
      <UserNotifications notifications={notifications} />
    </div>
  );
}

// ✅ 효율적: 책임별로 컴포넌트 분할
function OptimizedUserDashboard() {
  return (
    <div>
      <UserHeader />      {/* profile 변경 시만 리렌더링 */}
      <UserSettings />    {/* settings 변경 시만 리렌더링 */}
      <UserActivity />    {/* activity 변경 시만 리렌더링 */}
      <UserNotifications /> {/* notifications 변경 시만 리렌더링 */}
    </div>
  );
}

function UserHeader() {
  const profile = useStoreValue(useUserStore('profile'));
  return (
    <header>
      <h1>{profile.name}</h1>
      <img src={profile.avatar} alt="프로필" />
    </header>
  );
}

function UserSettings() {
  const settings = useStoreValue(useUserStore('settings'));
  return (
    <div className={`settings theme-${settings.theme}`}>
      <h2>설정</h2>
      {/* 설정 UI */}
    </div>
  );
}
```

### 2. React.memo 활용

```typescript
// 메모화된 컴포넌트
const UserCard = React.memo<{
  user: UserProfile;
  onEdit: (id: string) => void;
}>(({ user, onEdit }) => {
  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>편집</button>
    </div>
  );
});

// 메모화된 액션 핸들러
function UserList() {
  const usersStore = useUserStore('userList');
  const users = useStoreValue(usersStore);
  const dispatch = useUserAction();
  
  // 메모화된 콜백
  const handleEdit = useCallback((userId: string) => {
    dispatch('openUserEditor', { userId });
  }, [dispatch]);
  
  return (
    <div className="user-list">
      {users.map(user => (
        <UserCard 
          key={user.id}
          user={user}
          onEdit={handleEdit} // 메모화되어 불필요한 리렌더링 방지
        />
      ))}
    </div>
  );
}
```

### 3. 지연 로딩

```typescript
// 조건부 컴포넌트 로딩
function UserDashboard() {
  const [activeTab, setActiveTab] = useState<'profile' | 'settings' | 'activity'>('profile');
  
  return (
    <div>
      <nav>
        <button 
          onClick={() => setActiveTab('profile')}
          className={activeTab === 'profile' ? 'active' : ''}
        >
          프로필
        </button>
        <button 
          onClick={() => setActiveTab('settings')}
          className={activeTab === 'settings' ? 'active' : ''}
        >
          설정
        </button>
        <button 
          onClick={() => setActiveTab('activity')}
          className={activeTab === 'activity' ? 'active' : ''}
        >
          활동
        </button>
      </nav>
      
      <div className="tab-content">
        {activeTab === 'profile' && <UserProfile />}
        {activeTab === 'settings' && <UserSettings />}
        {activeTab === 'activity' && <UserActivity />}
      </div>
    </div>
  );
}

// React.lazy로 코드 분할
const UserActivity = React.lazy(() => import('./UserActivity'));
const UserSettings = React.lazy(() => import('./UserSettings'));

function LazyUserDashboard() {
  const [activeTab, setActiveTab] = useState<'profile' | 'settings' | 'activity'>('profile');
  
  return (
    <div>
      <nav>{/* 탭 네비게이션 */}</nav>
      
      <Suspense fallback={<div>로딩 중...</div>}>
        <div className="tab-content">
          {activeTab === 'profile' && <UserProfile />}
          {activeTab === 'settings' && <UserSettings />}
          {activeTab === 'activity' && <UserActivity />}
        </div>
      </Suspense>
    </div>
  );
}
```

## 에러 경계 통합

### 1. 도메인별 에러 경계

```typescript
// 사용자 도메인 에러 경계
class UserErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean; error?: Error }
> {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // 사용자 도메인 오류 로깅
    console.error('User domain error:', error, errorInfo);
    
    // 오류 리포팅 서비스에 전송
    reportError('user-domain', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>사용자 정보를 불러오는 중 오류가 발생했습니다</h2>
          <button onClick={() => this.setState({ hasError: false })}>
            다시 시도
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// 사용법
function App() {
  return (
    <UserProvider>
      <UserErrorBoundary>
        <UserDashboard />
      </UserErrorBoundary>
    </UserProvider>
  );
}
```

### 2. 액션 에러 처리

```typescript
function UserActionComponent() {
  const dispatch = useUserAction();
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  
  const handleRiskyAction = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      const result = await dispatch('riskyUserAction', { /* payload */ });
      
      if (!result.success) {
        setError(result.error || '알 수 없는 오류가 발생했습니다');
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : '네트워크 오류');
    } finally {
      setIsLoading(false);
    }
  }, [dispatch]);
  
  return (
    <div>
      {error && (
        <div className="error-message">
          오류: {error}
          <button onClick={() => setError(null)}>×</button>
        </div>
      )}
      
      <button 
        onClick={handleRiskyAction}
        disabled={isLoading}
      >
        {isLoading ? '처리 중...' : '위험한 액션 실행'}
      </button>
    </div>
  );
}
```

## 테스팅 통합

### 1. 컴포넌트 테스트

```typescript
// __tests__/components/UserProfile.test.tsx
import { render, screen } from '@testing-library/react';
import { UserProvider } from '@/providers/UserProvider';
import { UserProfile } from '@/components/UserProfile';

// 테스트 유틸리티
const renderWithUserProvider = (ui: React.ReactElement) => {
  return render(
    <UserProvider>
      {ui}
    </UserProvider>
  );
};

describe('UserProfile', () => {
  it('사용자 정보를 올바르게 표시', async () => {
    renderWithUserProvider(<UserProfile />);
    
    // 기본 프로필 정보 확인
    expect(screen.getByText('Guest User')).toBeInTheDocument();
    expect(screen.getByText('guest@example.com')).toBeInTheDocument();
  });
  
  it('프로필 업데이트 후 변경된 정보 표시', async () => {
    const { container } = renderWithUserProvider(
      <div>
        <UserProfile />
        <UserEditor />
      </div>
    );
    
    // 프로필 편집
    const nameInput = screen.getByPlaceholderText('이름');
    const saveButton = screen.getByText('저장');
    
    fireEvent.change(nameInput, { target: { value: '새 이름' } });
    fireEvent.click(saveButton);
    
    // 업데이트된 정보 확인
    await waitFor(() => {
      expect(screen.getByText('새 이름')).toBeInTheDocument();
    });
  });
});
```

### 2. 훅 테스트

```typescript
// __tests__/hooks/useUserProfile.test.ts
import { renderHook, act } from '@testing-library/react-hooks';
import { UserProvider } from '@/providers/UserProvider';
import { useUserProfile } from '@/hooks/useUserProfile';

const wrapper = ({ children }) => (
  <UserProvider>{children}</UserProvider>
);

describe('useUserProfile', () => {
  it('초기 프로필 데이터 반환', () => {
    const { result } = renderHook(() => useUserProfile(), { wrapper });
    
    expect(result.current.profile).toEqual({
      id: '',
      name: '',
      email: '',
      avatar: null
    });
    expect(result.current.isAuthenticated).toBe(false);
  });
  
  it('프로필 업데이트 동작', async () => {
    const { result } = renderHook(() => useUserProfile(), { wrapper });
    
    await act(async () => {
      await result.current.updateProfile({ name: '테스트 사용자' });
    });
    
    expect(result.current.profile.name).toBe('테스트 사용자');
  });
});
```

## 모범 사례

### 1. 컴포넌트 설계 원칙

```typescript
// ✅ 좋음: 단일 책임 컴포넌트
function UserAvatar({ size = 'medium' }: { size?: 'small' | 'medium' | 'large' }) {
  const profile = useStoreValue(useUserStore('profile'));
  
  return (
    <img 
      className={`avatar avatar-${size}`}
      src={profile.avatar || '/default-avatar.png'}
      alt={`${profile.name}의 아바타`}
    />
  );
}

function UserName({ showEmail = false }: { showEmail?: boolean }) {
  const profile = useStoreValue(useUserStore('profile'));
  
  return (
    <div>
      <h2>{profile.name || '이름 없음'}</h2>
      {showEmail && <p>{profile.email}</p>}
    </div>
  );
}

// 조합을 통한 복합 컴포넌트
function UserCard() {
  return (
    <div className="user-card">
      <UserAvatar size="large" />
      <UserName showEmail={true} />
    </div>
  );
}
```

### 2. 상태와 UI의 분리

```typescript
// ✅ 좋음: 프레젠테이션 컴포넌트 분리
interface UserProfileViewProps {
  profile: UserProfile;
  isEditing: boolean;
  onEdit: () => void;
  onSave: (data: Partial<UserProfile>) => void;
  onCancel: () => void;
}

function UserProfileView({ 
  profile, 
  isEditing, 
  onEdit, 
  onSave, 
  onCancel 
}: UserProfileViewProps) {
  // 순수한 UI 렌더링만 담당
  if (isEditing) {
    return <UserEditForm profile={profile} onSave={onSave} onCancel={onCancel} />;
  }
  
  return (
    <div>
      <h1>{profile.name}</h1>
      <p>{profile.email}</p>
      <button onClick={onEdit}>편집</button>
    </div>
  );
}

// 컨테이너 컴포넌트에서 상태 관리
function UserProfileContainer() {
  const profile = useStoreValue(useUserStore('profile'));
  const dispatch = useUserAction();
  const [isEditing, setIsEditing] = useState(false);
  
  const handleEdit = useCallback(() => setIsEditing(true), []);
  const handleSave = useCallback(async (data: Partial<UserProfile>) => {
    await dispatch('updateProfile', { data });
    setIsEditing(false);
  }, [dispatch]);
  const handleCancel = useCallback(() => setIsEditing(false), []);
  
  return (
    <UserProfileView
      profile={profile}
      isEditing={isEditing}
      onEdit={handleEdit}
      onSave={handleSave}
      onCancel={handleCancel}
    />
  );
}
```

### 3. 일관된 네이밍

```typescript
// 일관된 명명 규칙
export const useUserProfile = () => { /* 사용자 프로필 로직 */ };
export const useUserSettings = () => { /* 사용자 설정 로직 */ };
export const useUserActivity = () => { /* 사용자 활동 로직 */ };

// 컴포넌트
export const UserProfile = () => { /* 프로필 컴포넌트 */ };
export const UserSettings = () => { /* 설정 컴포넌트 */ };
export const UserActivity = () => { /* 활동 컴포넌트 */ };

// 프로바이더
export const UserProvider = ({ children }) => { /* 사용자 프로바이더 */ };
```

---

## 요약

Context-Action과 React의 통합은 다음 이점을 제공합니다:

- **자연스러운 React 패턴** - 훅과 컨텍스트 API 활용
- **타입 안전한 상태 관리** - 완전한 TypeScript 지원
- **최적화된 리렌더링** - 선택적 구독과 메모화
- **테스트 가능한 구조** - 분리된 로직과 UI
- **확장 가능한 아키텍처** - 컴포넌트 조합과 코드 분할

이러한 패턴을 따르면 성능이 뛰어나고 유지보수 가능한 React 애플리케이션을 구축할 수 있습니다.

---

::: tip 다음 단계
- [프로바이더 구성](./provider-composition) - 도메인 경계와 프로바이더 패턴
- [성능 최적화](./performance) - React 성능 최적화 고급 기법
- [모범 사례](./best-practices) - 프로덕션 환경 권장사항
:::

---


# Guide Setup Usage

**Source**: `guide/setup-usage.md`  
**Priority**: 80 (essential)  

# 설정 및 사용법

Context-Action 프레임워크의 상세한 설정 방법과 실제 사용법을 배워보세요. 이 가이드는 프로덕션 환경에서 사용할 수 있는 견고한 애플리케이션을 구축하는 방법을 제공합니다.

## 설치 및 초기 설정

### 패키지 설치

```bash
# 핵심 패키지
npm install @context-action/core @context-action/react

# 선택적 패키지
npm install @context-action/logger  # 로깅 유틸리티
npm install @context-action/jotai   # Jotai 통합 (선택)
```

### TypeScript 설정

```json
// tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "jsx": "react-jsx",
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true
  }
}
```

## 프로젝트 구조 설정

### 권장 폴더 구조

```
src/
├── stores/          # 도메인별 스토어와 액션
│   ├── user/
│   │   ├── user.store.ts
│   │   └── index.ts
│   ├── cart/
│   └── index.ts
├── hooks/           # 비즈니스 로직 훅
│   ├── handlers/    # 액션 핸들러
│   │   ├── useUserHandlers.ts
│   │   └── index.ts
│   ├── logic/       # 복합 비즈니스 로직
│   └── index.ts
├── components/      # UI 컴포넌트
├── providers/       # 프로바이더 구성
└── types/          # 공통 타입 정의
```

## 도메인별 스토어 설정

### 1. 기본 스토어 생성

```typescript
// stores/user/user.store.ts
import { createDeclarativeStores, createActionContext } from '@context-action/react';

// 타입 정의
export interface UserData {
  profile: {
    id: string;
    name: string;
    email: string;
    role: 'admin' | 'user' | 'guest';
  };
  preferences: {
    theme: 'light' | 'dark';
    language: string;
    notifications: boolean;
  };
  session: {
    isLoggedIn: boolean;
    token: string | null;
    expiresAt: number | null;
  };
}

export interface UserActions {
  // 인증 액션
  login: { email: string; password: string };
  logout: void;
  refreshToken: void;
  
  // 프로필 액션
  updateProfile: { data: Partial<UserData['profile']> };
  deleteProfile: { confirmation: string };
  
  // 설정 액션
  updatePreferences: { preferences: Partial<UserData['preferences']> };
}

// 스토어 생성
export const {
  Provider: UserStoreProvider,
  useStore: useUserStore,
  useStores: useUserStores,
  useCreateStore: useCreateUserStore
} = createDeclarativeStores<UserData>('User', {
  profile: {
    initialValue: {
      id: '',
      name: '',
      email: '',
      role: 'guest'
    },
    strategy: 'deep',  // 깊은 비교
    description: '사용자 프로필 정보'
  },
  preferences: {
    initialValue: {
      theme: 'light',
      language: 'ko',
      notifications: true
    },
    strategy: 'shallow', // 얕은 비교
    description: '사용자 환경설정'
  },
  session: {
    initialValue: {
      isLoggedIn: false,
      token: null,
      expiresAt: null
    },
    strategy: 'reference', // 참조 비교 (기본값)
    description: '세션 정보'
  }
});

// 액션 컨텍스트 생성
export const {
  Provider: UserActionProvider,
  useAction: useUserAction,
  useActionHandler: useUserActionHandler,
  useActionDispatchWithResult: useUserActionWithResult
} = createActionContext<UserActions>({
  name: 'UserAction',
  debug: process.env.NODE_ENV === 'development'
});
```

### 2. 인덱스 파일로 내보내기

```typescript
// stores/user/index.ts
export * from './user.store';

// stores/index.ts
export * from './user';
export * from './cart';
export * from './order';
```

## 핸들러 구현

### 1. 기본 핸들러 패턴

```typescript
// hooks/handlers/useUserHandlers.ts
import { useCallback, useEffect } from 'react';
import { useUserActionHandler, useUserStores, UserActions } from '@/stores/user';

export function useUserHandlers() {
  const addHandler = useUserActionHandler();
  const stores = useUserStores();
  
  // 로그인 핸들러
  const loginHandler = useCallback(async (
    payload: UserActions['login'],
    controller
  ) => {
    const sessionStore = stores.getStore('session');
    const profileStore = stores.getStore('profile');
    
    try {
      // API 호출 시뮬레이션
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      
      if (!response.ok) {
        controller.abort('로그인 실패: 잘못된 자격증명');
        return { success: false, error: 'INVALID_CREDENTIALS' };
      }
      
      const data = await response.json();
      
      // 세션 업데이트
      sessionStore.setValue({
        isLoggedIn: true,
        token: data.token,
        expiresAt: Date.now() + (data.expiresIn * 1000)
      });
      
      // 프로필 업데이트
      profileStore.setValue(data.user);
      
      return { success: true, user: data.user };
      
    } catch (error) {
      controller.abort('로그인 중 오류 발생', error);
      return { success: false, error: 'NETWORK_ERROR' };
    }
  }, [stores]);
  
  // 로그아웃 핸들러
  const logoutHandler = useCallback(async (payload, controller) => {
    const sessionStore = stores.getStore('session');
    const profileStore = stores.getStore('profile');
    
    try {
      // 토큰 무효화 (서버)
      const session = sessionStore.getValue();
      if (session.token) {
        await fetch('/api/auth/logout', {
          method: 'POST',
          headers: { 
            'Authorization': `Bearer ${session.token}`,
            'Content-Type': 'application/json'
          }
        });
      }
    } catch (error) {
      // 서버 오류여도 로컬 상태는 정리
      console.warn('서버 로그아웃 실패:', error);
    } finally {
      // 로컬 상태 정리
      sessionStore.setValue({
        isLoggedIn: false,
        token: null,
        expiresAt: null
      });
      
      profileStore.setValue({
        id: '',
        name: '',
        email: '',
        role: 'guest'
      });
    }
    
    return { success: true };
  }, [stores]);
  
  // 프로필 업데이트 핸들러
  const updateProfileHandler = useCallback(async (
    payload: UserActions['updateProfile'],
    controller
  ) => {
    const profileStore = stores.getStore('profile');
    const sessionStore = stores.getStore('session');
    
    const currentProfile = profileStore.getValue();
    const session = sessionStore.getValue();
    
    // 인증 확인
    if (!session.isLoggedIn || !session.token) {
      controller.abort('인증이 필요합니다');
      return { success: false, error: 'UNAUTHORIZED' };
    }
    
    // 데이터 검증
    if (payload.data.email && !payload.data.email.includes('@')) {
      controller.abort('유효하지 않은 이메일 형식');
      return { success: false, error: 'INVALID_EMAIL' };
    }
    
    try {
      const response = await fetch('/api/user/profile', {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${session.token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload.data)
      });
      
      if (!response.ok) {
        const error = await response.json();
        controller.abort('프로필 업데이트 실패', error);
        return { success: false, error: error.code };
      }
      
      const updatedProfile = await response.json();
      
      // 로컬 상태 업데이트
      profileStore.setValue({
        ...currentProfile,
        ...updatedProfile
      });
      
      return { success: true, profile: updatedProfile };
      
    } catch (error) {
      controller.abort('프로필 업데이트 중 오류', error);
      return { success: false, error: 'NETWORK_ERROR' };
    }
  }, [stores]);
  
  // 환경설정 업데이트 핸들러
  const updatePreferencesHandler = useCallback(async (
    payload: UserActions['updatePreferences'],
    controller
  ) => {
    const preferencesStore = stores.getStore('preferences');
    const currentPreferences = preferencesStore.getValue();
    
    // 즉시 로컬 업데이트 (낙관적 업데이트)
    const newPreferences = { ...currentPreferences, ...payload.preferences };
    preferencesStore.setValue(newPreferences);
    
    // 서버에 동기화 (백그라운드)
    try {
      const sessionStore = stores.getStore('session');
      const session = sessionStore.getValue();
      
      if (session.isLoggedIn && session.token) {
        await fetch('/api/user/preferences', {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${session.token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(payload.preferences)
        });
      }
    } catch (error) {
      console.warn('환경설정 동기화 실패:', error);
      // 실패해도 로컬 변경사항 유지
    }
    
    return { success: true, preferences: newPreferences };
  }, [stores]);
  
  // 핸들러 등록
  useEffect(() => {
    if (!addHandler) return;
    
    const unregisterLogin = addHandler('login', loginHandler, {
      priority: 100,
      blocking: true,
      id: 'user-login',
      tags: ['auth', 'critical']
    });
    
    const unregisterLogout = addHandler('logout', logoutHandler, {
      priority: 100,
      blocking: true,
      id: 'user-logout',
      tags: ['auth']
    });
    
    const unregisterUpdateProfile = addHandler('updateProfile', updateProfileHandler, {
      priority: 90,
      blocking: true,
      id: 'profile-update',
      tags: ['profile', 'api']
    });
    
    const unregisterUpdatePreferences = addHandler('updatePreferences', updatePreferencesHandler, {
      priority: 80,
      blocking: false, // 논블로킹 - 빠른 UI 반응
      id: 'preferences-update',
      tags: ['preferences']
    });
    
    return () => {
      unregisterLogin();
      unregisterLogout();
      unregisterUpdateProfile();
      unregisterUpdatePreferences();
    };
  }, [addHandler, loginHandler, logoutHandler, updateProfileHandler, updatePreferencesHandler]);
}
```

### 2. 오류 처리 및 로깅

```typescript
// hooks/handlers/useUserHandlers.ts (오류 처리 예제)
import { createLogger } from '@context-action/logger';

const logger = createLogger('UserHandlers');

export function useUserHandlers() {
  // ... 기존 코드
  
  const loginHandler = useCallback(async (payload, controller) => {
    logger.info('로그인 시도', { email: payload.email });
    
    try {
      // 비즈니스 로직
      const result = await performLogin(payload);
      
      logger.info('로그인 성공', { userId: result.user.id });
      return { success: true, user: result.user };
      
    } catch (error) {
      logger.error('로그인 실패', {
        email: payload.email,
        error: error.message,
        stack: error.stack
      });
      
      controller.abort('로그인 실패', {
        operation: 'login',
        payload: { email: payload.email }, // 민감한 정보 제외
        timestamp: Date.now(),
        error: error.message
      });
      
      return { success: false, error: categorizeError(error) };
    }
  }, [stores]);
  
  // 오류 분류 함수
  function categorizeError(error: any): string {
    if (error.status === 401) return 'UNAUTHORIZED';
    if (error.status === 403) return 'FORBIDDEN';
    if (error.status >= 500) return 'SERVER_ERROR';
    if (error.name === 'NetworkError') return 'NETWORK_ERROR';
    return 'UNKNOWN_ERROR';
  }
}
```

## 프로바이더 구성

### 1. 단일 도메인 프로바이더

```typescript
// providers/UserProvider.tsx
import React from 'react';
import { UserStoreProvider, UserActionProvider } from '@/stores/user';
import { useUserHandlers } from '@/hooks/handlers/useUserHandlers';

function UserHandlersSetup() {
  useUserHandlers();
  return null;
}

export function UserProvider({ children }: { children: React.ReactNode }) {
  return (
    <UserStoreProvider>
      <UserActionProvider>
        <UserHandlersSetup />
        {children}
      </UserActionProvider>
    </UserStoreProvider>
  );
}
```

### 2. 다중 도메인 프로바이더

```typescript
// providers/AppProvider.tsx
import React from 'react';
import { UserProvider } from './UserProvider';
import { CartProvider } from './CartProvider';
import { OrderProvider } from './OrderProvider';

export function AppProvider({ children }: { children: React.ReactNode }) {
  return (
    <UserProvider>
      <CartProvider>
        <OrderProvider>
          {children}
        </OrderProvider>
      </CartProvider>
    </UserProvider>
  );
}
```

### 3. 조건부 프로바이더

```typescript
// providers/ConditionalProvider.tsx
import React from 'react';
import { UserProvider } from './UserProvider';
import { AdminProvider } from './AdminProvider';

interface ConditionalProviderProps {
  children: React.ReactNode;
  userRole?: 'admin' | 'user' | 'guest';
}

export function ConditionalProvider({ 
  children, 
  userRole = 'guest' 
}: ConditionalProviderProps) {
  return (
    <UserProvider>
      {userRole === 'admin' ? (
        <AdminProvider>
          {children}
        </AdminProvider>
      ) : (
        children
      )}
    </UserProvider>
  );
}
```

## 고급 패턴

### 1. 지속성 스토어

```typescript
// hooks/usePersistedUserStore.ts
import { useCallback, useEffect } from 'react';
import { useUserStores } from '@/stores/user';

export function usePersistedUserPreferences() {
  const stores = useUserStores();
  
  // 환경설정 로드
  useEffect(() => {
    const preferencesStore = stores.getStore('preferences');
    
    // 로컬 스토리지에서 로드
    const savedPreferences = localStorage.getItem('user-preferences');
    if (savedPreferences) {
      try {
        const parsed = JSON.parse(savedPreferences);
        preferencesStore.setValue(parsed);
      } catch (error) {
        console.warn('환경설정 로드 실패:', error);
      }
    }
  }, [stores]);
  
  // 환경설정 변경 감지 및 저장
  useEffect(() => {
    const preferencesStore = stores.getStore('preferences');
    
    const unsubscribe = preferencesStore.subscribe((newPreferences) => {
      try {
        localStorage.setItem('user-preferences', JSON.stringify(newPreferences));
      } catch (error) {
        console.warn('환경설정 저장 실패:', error);
      }
    });
    
    return unsubscribe;
  }, [stores]);
}
```

### 2. 크로스 도메인 통합

```typescript
// hooks/logic/useUserCartIntegration.ts
import { useCallback } from 'react';
import { useStoreValue } from '@context-action/react';
import { useUserStore, useUserAction } from '@/stores/user';
import { useCartStore, useCartAction } from '@/stores/cart';

export function useUserCartIntegration() {
  // 다중 도메인 접근
  const profileStore = useUserStore('profile');
  const cartItemsStore = useCartStore('items');
  
  const profile = useStoreValue(profileStore);
  const cartItems = useStoreValue(cartItemsStore);
  
  const userAction = useUserAction();
  const cartAction = useCartAction();
  
  // 크로스 도메인 비즈니스 로직
  const processCheckout = useCallback(async () => {
    // 사용자 검증
    if (!profile.id) {
      await userAction('login', { /* 로그인 프롬프트 */ });
      return { success: false, reason: 'LOGIN_REQUIRED' };
    }
    
    // 장바구니 검증
    if (cartItems.length === 0) {
      return { success: false, reason: 'EMPTY_CART' };
    }
    
    // 결제 처리
    const result = await cartAction('processCheckout', {
      userId: profile.id,
      items: cartItems
    });
    
    return result;
  }, [profile.id, cartItems, userAction, cartAction]);
  
  // 로그인 시 장바구니 동기화
  const syncCartOnLogin = useCallback(async () => {
    if (profile.id) {
      await cartAction('syncWithServer', { userId: profile.id });
    }
  }, [profile.id, cartAction]);
  
  return {
    processCheckout,
    syncCartOnLogin,
    canCheckout: profile.id && cartItems.length > 0
  };
}
```

### 3. 커스텀 훅 조합

```typescript
// hooks/logic/useUserProfile.ts
import { useState, useCallback } from 'react';
import { useStoreValue } from '@context-action/react';
import { useUserStore, useUserAction } from '@/stores/user';

export function useUserProfile() {
  const profileStore = useUserStore('profile');
  const sessionStore = useUserStore('session');
  
  const profile = useStoreValue(profileStore);
  const session = useStoreValue(sessionStore);
  const dispatch = useUserAction();
  
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // 프로필 업데이트
  const updateProfile = useCallback(async (data: Partial<typeof profile>) => {
    setIsLoading(true);
    setError(null);
    
    try {
      const result = await dispatch('updateProfile', { data });
      if (!result?.success) {
        setError(result?.error || '업데이트 실패');
      }
      return result;
    } catch (error) {
      setError('네트워크 오류');
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [dispatch]);
  
  // 로그인 상태 확인
  const isAuthenticated = useCallback(() => {
    return session.isLoggedIn && session.token && 
           (session.expiresAt ? session.expiresAt > Date.now() : true);
  }, [session]);
  
  return {
    profile,
    session,
    isLoading,
    error,
    updateProfile,
    isAuthenticated: isAuthenticated(),
    clearError: () => setError(null)
  };
}
```

## 테스팅 설정

### 1. 테스트 유틸리티

```typescript
// test-utils/providers.tsx
import React from 'react';
import { render, RenderOptions } from '@testing-library/react';
import { UserProvider } from '@/providers/UserProvider';

const AllTheProviders = ({ children }: { children: React.ReactNode }) => {
  return (
    <UserProvider>
      {children}
    </UserProvider>
  );
};

const customRender = (
  ui: React.ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>
) => render(ui, { wrapper: AllTheProviders, ...options });

export * from '@testing-library/react';
export { customRender as render };
```

### 2. 핸들러 테스트

```typescript
// __tests__/handlers/userHandlers.test.ts
import { renderHook } from '@testing-library/react-hooks';
import { useUserHandlers } from '@/hooks/handlers/useUserHandlers';
import { createMockStores, createMockController } from '@/test-utils';

describe('User Handlers', () => {
  let mockStores;
  let mockController;
  
  beforeEach(() => {
    mockStores = createMockStores();
    mockController = createMockController();
  });
  
  it('로그인 성공 시 프로필과 세션 업데이트', async () => {
    const { result } = renderHook(() => useUserHandlers());
    
    // Mock API 응답
    global.fetch = jest.fn().mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({
        token: 'fake-token',
        expiresIn: 3600,
        user: { id: '1', name: '테스트', email: 'test@example.com' }
      })
    });
    
    // 핸들러 실행
    await result.current.loginHandler(
      { email: 'test@example.com', password: 'password' },
      mockController
    );
    
    // 검증
    expect(mockStores.getStore('session').setValue).toHaveBeenCalledWith({
      isLoggedIn: true,
      token: 'fake-token',
      expiresAt: expect.any(Number)
    });
    
    expect(mockStores.getStore('profile').setValue).toHaveBeenCalledWith({
      id: '1',
      name: '테스트',
      email: 'test@example.com'
    });
  });
});
```

---

## 요약

이 설정 가이드는 Context-Action 프레임워크를 사용한 견고한 애플리케이션 구축의 기초를 제공합니다. 주요 포인트:

- **체계적인 프로젝트 구조**로 유지보수성 확보
- **타입 안전한 도메인 정의**로 개발자 경험 향상
- **견고한 오류 처리**로 안정성 확보
- **테스트 가능한 아키텍처**로 품질 보장

---

::: tip 다음 단계
- [도메인 훅 패턴](./domain-hooks-pattern) - 도메인별 훅의 고급 사용법
- [액션 핸들러](./action-handlers) - 비즈니스 로직 구현 심화
- [최선의 실습](./best-practices) - 프로덕션 환경 모범 사례
:::

---


# Guide Store Management

**Source**: `guide/store-management.md`  
**Priority**: 80 (essential)  

# 스토어 관리

Context-Action 프레임워크의 스토어 시스템은 프로바이더 경계 내에서 반응형 상태 관리를 제공합니다. 이 가이드는 효율적이고 안전한 스토어 관리 패턴을 다룹니다.

## 스토어 생명주기

### 생성과 초기화

스토어는 프로바이더 내에서 처음 접근될 때 생성되고 초기화됩니다:

```typescript
// 스토어 정의
export const {
  Provider: UserStoreProvider,
  useStore: useUserStore,
  useStores: useUserStores
} = createDeclarativeStores<UserData>('User', {
  profile: {
    initialValue: {
      id: '',
      name: '',
      email: '',
      status: 'offline'
    },
    strategy: 'deep' // 변경 감지 전략
  },
  settings: {
    initialValue: {
      theme: 'light',
      language: 'ko',
      notifications: true
    },
    strategy: 'shallow'
  }
});

// 사용법
function UserComponent() {
  // 첫 번째 접근 시 스토어가 생성되고 초기화됨
  const profileStore = useUserStore('profile');
  const settingsStore = useUserStore('settings');
  
  // 동일한 이름의 스토어는 동일한 인스턴스를 반환 (싱글톤)
  const sameProfileStore = useUserStore('profile'); // profileStore와 동일
}
```

### 변경 감지 전략

스토어는 세 가지 변경 감지 전략을 제공합니다:

```typescript
// 1. 참조 비교 (기본값) - 빠름, 원시값과 불변 객체에 적합
{
  strategy: 'reference' // Object.is() 사용
}

// 2. 얕은 비교 - 객체의 최상위 속성만 비교
{
  strategy: 'shallow' // 각 속성을 개별적으로 비교
}

// 3. 깊은 비교 - 중첩된 객체까지 재귀적으로 비교
{
  strategy: 'deep' // 모든 중첩 수준에서 비교
}
```

**전략 선택 가이드:**

```typescript
// 원시값 또는 불변 객체 - reference (기본값)
counter: {
  initialValue: 0,
  strategy: 'reference'
}

// 평면 객체 - shallow
userPreferences: {
  initialValue: { theme: 'light', lang: 'ko' },
  strategy: 'shallow'
}

// 중첩 객체 - deep (성능 비용 고려)
complexUserData: {
  initialValue: {
    profile: { name: '', settings: { privacy: true } },
    metadata: { lastLogin: null }
  },
  strategy: 'deep'
}
```

## 스토어 접근 패턴

### 1. 컴포넌트에서의 반응형 접근

```typescript
function UserProfile() {
  // 반응형 스토어 접근
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  // 상태 변경 시 컴포넌트 자동 리렌더링
  return (
    <div>
      <h2>{profile.name}</h2>
      <p>상태: {profile.status}</p>
    </div>
  );
}

// 여러 스토어 구독
function UserDashboard() {
  const profile = useStoreValue(useUserStore('profile'));
  const settings = useStoreValue(useUserStore('settings'));
  
  // 각각 독립적으로 구독됨
  return (
    <div className={`theme-${settings.theme}`}>
      <h1>환영합니다, {profile.name}님</h1>
      <p>언어: {settings.language}</p>
    </div>
  );
}
```

### 2. 핸들러에서의 지연 평가 접근

```typescript
function useUserHandlers() {
  const registry = useUserStores();
  
  const updateProfileHandler = useCallback(async (payload, controller) => {
    // 지연 평가 - 실행 시점의 최신 값
    const profileStore = registry.getStore('profile');
    const currentProfile = profileStore.getValue(); // 현재 값 획득
    
    // 비즈니스 로직
    const updatedProfile = {
      ...currentProfile,
      ...payload.data,
      lastModified: Date.now()
    };
    
    // 스토어 업데이트
    profileStore.setValue(updatedProfile);
    
    return { success: true, profile: updatedProfile };
  }, [registry]);
}
```

### 3. 직접 스토어 조작

```typescript
function UserEditor() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  // 직접 업데이트 (간단한 경우)
  const updateName = useCallback((newName: string) => {
    profileStore.setValue({
      ...profile,
      name: newName,
      lastModified: Date.now()
    });
  }, [profileStore, profile]);
  
  // 부분 업데이트 헬퍼
  const updateProfile = useCallback((updates: Partial<UserProfile>) => {
    profileStore.update(current => ({
      ...current,
      ...updates,
      lastModified: Date.now()
    }));
  }, [profileStore]);
  
  return (
    <div>
      <input 
        value={profile.name}
        onChange={(e) => updateName(e.target.value)}
      />
      <button onClick={() => updateProfile({ status: 'online' })}>
        온라인 상태로 변경
      </button>
    </div>
  );
}
```

## 고급 스토어 패턴

### 1. 동적 스토어 생성

```typescript
function UserCacheManager() {
  const createStore = useCreateUserStore();
  
  // 사용자별 캐시 스토어 동적 생성
  const createUserCache = useCallback((userId: string) => {
    return createStore(`cache-${userId}`, {
      data: null,
      lastFetched: null,
      isLoading: false
    });
  }, [createStore]);
  
  return { createUserCache };
}

// 사용법
function UserDataComponent({ userId }: { userId: string }) {
  const { createUserCache } = useUserCacheManager();
  const userCache = createUserCache(userId);
  const cacheData = useStoreValue(userCache);
  
  return <div>사용자 {userId} 캐시: {cacheData.data?.name}</div>;
}
```

### 2. 스토어 구독 최적화

```typescript
// 선택적 필드 구독
function OptimizedUserDisplay() {
  const profileStore = useUserStore('profile');
  
  // 이름 변경 시만 리렌더링
  const userName = useStoreValue(profileStore, profile => profile.name);
  
  // 상태 변경 시만 리렌더링
  const userStatus = useStoreValue(profileStore, profile => profile.status);
  
  return (
    <div>
      <span>이름: {userName}</span>
      <span>상태: {userStatus}</span>
    </div>
  );
}

// 조건부 구독
function ConditionalSubscription({ showDetails }: { showDetails: boolean }) {
  const profileStore = useUserStore('profile');
  
  // showDetails가 true일 때만 구독
  const profile = useStoreValue(profileStore, 
    showDetails ? undefined : () => null
  );
  
  if (!showDetails || !profile) {
    return <div>간단한 뷰</div>;
  }
  
  return <div>상세 정보: {profile.email}</div>;
}
```

### 3. 스토어 동기화 패턴

```typescript
// 로컬 스토리지와 동기화
function usePersistedStore() {
  const settingsStore = useUserStore('settings');
  const settings = useStoreValue(settingsStore);
  
  // 초기 로드
  useEffect(() => {
    const savedSettings = localStorage.getItem('user-settings');
    if (savedSettings) {
      try {
        const parsed = JSON.parse(savedSettings);
        settingsStore.setValue(parsed);
      } catch (error) {
        console.warn('설정 로드 실패:', error);
      }
    }
  }, [settingsStore]);
  
  // 변경사항 저장
  useEffect(() => {
    const unsubscribe = settingsStore.subscribe((newSettings) => {
      try {
        localStorage.setItem('user-settings', JSON.stringify(newSettings));
      } catch (error) {
        console.warn('설정 저장 실패:', error);
      }
    });
    
    return unsubscribe;
  }, [settingsStore]);
  
  return { settings };
}

// 서버와 동기화
function useServerSync() {
  const profileStore = useUserStore('profile');
  const [lastSync, setLastSync] = useState<number>(0);
  
  // 서버에서 데이터 로드
  const loadFromServer = useCallback(async () => {
    try {
      const response = await fetch('/api/user/profile');
      const serverProfile = await response.json();
      profileStore.setValue(serverProfile);
      setLastSync(Date.now());
    } catch (error) {
      console.error('서버 동기화 실패:', error);
    }
  }, [profileStore]);
  
  // 서버에 데이터 저장
  const syncToServer = useCallback(async (profile: UserProfile) => {
    try {
      await fetch('/api/user/profile', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(profile)
      });
      setLastSync(Date.now());
    } catch (error) {
      console.error('서버 업로드 실패:', error);
    }
  }, []);
  
  return { loadFromServer, syncToServer, lastSync };
}
```

## 메모리 관리

### 1. 스토어 정리

```typescript
// 프로바이더 언마운트 시 자동 정리
function App() {
  const [showUser, setShowUser] = useState(true);
  
  return (
    <div>
      {showUser ? (
        <UserStoreProvider>
          <UserComponents />
        </UserStoreProvider>
      ) : (
        <div>사용자 섹션 숨김</div>
      )}
      <button onClick={() => setShowUser(!showUser)}>
        {showUser ? '숨기기' : '보이기'}
      </button>
    </div>
  );
}
// UserStoreProvider가 언마운트되면 모든 User 스토어가 정리됨
```

### 2. 구독 해제

```typescript
function ManualSubscription() {
  const profileStore = useUserStore('profile');
  const [manualData, setManualData] = useState(null);
  
  useEffect(() => {
    // 수동 구독
    const unsubscribe = profileStore.subscribe((newProfile) => {
      setManualData(processProfile(newProfile));
    });
    
    // 정리 함수에서 구독 해제
    return unsubscribe;
  }, [profileStore]);
  
  return <div>수동 처리된 데이터: {manualData}</div>;
}
```

### 3. 메모리 누수 방지

```typescript
// ❌ 메모리 누수 위험
function BadPattern() {
  const profileStore = useUserStore('profile');
  
  useEffect(() => {
    const subscription = profileStore.subscribe((profile) => {
      // 외부 서비스에 등록
      externalService.updateProfile(profile);
    });
    // 정리 함수 없음 - 메모리 누수!
  }, [profileStore]);
}

// ✅ 적절한 정리
function GoodPattern() {
  const profileStore = useUserStore('profile');
  
  useEffect(() => {
    const subscription = profileStore.subscribe((profile) => {
      externalService.updateProfile(profile);
    });
    
    // 적절한 정리
    return () => {
      subscription(); // 구독 해제
      externalService.cleanup(); // 외부 서비스 정리
    };
  }, [profileStore]);
}
```

## 성능 최적화

### 1. 배치 업데이트

```typescript
function BatchUpdates() {
  const profileStore = useUserStore('profile');
  const settingsStore = useUserStore('settings');
  
  const updateMultiple = useCallback(() => {
    // React의 배치 업데이트를 활용
    profileStore.setValue(prevProfile => ({
      ...prevProfile,
      name: '새 이름',
      lastModified: Date.now()
    }));
    
    settingsStore.setValue(prevSettings => ({
      ...prevSettings,
      theme: 'dark'
    }));
    
    // 두 업데이트가 하나의 렌더링 사이클에서 배치됨
  }, [profileStore, settingsStore]);
}
```

### 2. 지연 초기화

```typescript
// 무거운 계산을 지연 초기화
export const expensiveDataStore = createDeclarativeStores<ExpensiveData>('Expensive', {
  computedData: {
    initialValue: () => {
      // 첫 접근 시에만 실행되는 무거운 계산
      return computeExpensiveInitialValue();
    },
    strategy: 'deep'
  }
});
```

### 3. 선택적 리렌더링

```typescript
function OptimizedComponent() {
  const profileStore = useUserStore('profile');
  
  // 이름이 변경될 때만 리렌더링
  const name = useStoreValue(profileStore, profile => profile.name);
  
  // 상태가 변경될 때만 리렌더링  
  const status = useStoreValue(profileStore, profile => profile.status);
  
  return (
    <div>
      <UserName name={name} />
      <UserStatus status={status} />
    </div>
  );
}

// 메모화로 추가 최적화
const UserName = React.memo(({ name }: { name: string }) => (
  <h2>{name}</h2>
));

const UserStatus = React.memo(({ status }: { status: string }) => (
  <span className={`status-${status}`}>{status}</span>
));
```

## 디버깅과 개발 도구

### 1. 개발 모드 로깅

```typescript
// 개발 환경에서 상태 변경 로깅
export const {
  Provider: UserStoreProvider,
  useStore: useUserStore,
  useStores: useUserStores
} = createDeclarativeStores<UserData>('User', {
  profile: {
    initialValue: defaultProfile,
    strategy: 'deep',
    // 개발 모드에서만 로깅
    onChange: process.env.NODE_ENV === 'development' 
      ? (newValue, oldValue) => {
          console.log('Profile 변경:', { from: oldValue, to: newValue });
        }
      : undefined
  }
});
```

### 2. 스토어 상태 검사

```typescript
function DebugPanel() {
  const registry = useUserStores();
  const [storeStates, setStoreStates] = useState({});
  
  const captureStoreStates = useCallback(() => {
    const states = {
      profile: registry.getStore('profile').getValue(),
      settings: registry.getStore('settings').getValue()
    };
    setStoreStates(states);
  }, [registry]);
  
  return (
    <div>
      <button onClick={captureStoreStates}>스토어 상태 캡처</button>
      <pre>{JSON.stringify(storeStates, null, 2)}</pre>
    </div>
  );
}
```

### 3. 시간 여행 디버깅

```typescript
// 상태 변경 히스토리 추적
function useStoreHistory<T>(store: Store<T>) {
  const [history, setHistory] = useState<T[]>([]);
  
  useEffect(() => {
    const unsubscribe = store.subscribe((newValue) => {
      setHistory(prev => [...prev.slice(-9), newValue]); // 최근 10개 유지
    });
    
    return unsubscribe;
  }, [store]);
  
  return history;
}

// 사용법
function DebugComponent() {
  const profileStore = useUserStore('profile');
  const profileHistory = useStoreHistory(profileStore);
  
  return (
    <div>
      <h3>프로필 변경 히스토리</h3>
      {profileHistory.map((profile, index) => (
        <div key={index}>
          {index}: {profile.name} ({profile.lastModified})
        </div>
      ))}
    </div>
  );
}
```

## 모범 사례

### 1. 적절한 초기값 설정

```typescript
// ✅ 좋음: 완전한 타입 구조
{
  profile: {
    initialValue: {
      id: '',
      name: '',
      email: '',
      avatar: null,
      status: 'offline',
      lastLogin: null
    }
  }
}

// ❌ 피하기: null 또는 undefined
{
  profile: {
    initialValue: null // 타입 안전성 문제
  }
}
```

### 2. 일관된 업데이트 패턴

```typescript
// ✅ 좋음: 불변성 유지
const updateProfile = (updates: Partial<UserProfile>) => {
  profileStore.setValue(current => ({
    ...current,
    ...updates,
    lastModified: Date.now()
  }));
};

// ❌ 피하기: 직접 변경
const badUpdate = (updates: Partial<UserProfile>) => {
  const current = profileStore.getValue();
  Object.assign(current, updates); // 직접 변경은 반응성 문제
  profileStore.setValue(current);
};
```

### 3. 명확한 책임 분리

```typescript
// ✅ 좋음: 관련 데이터 그룹화
interface UserData {
  // 사용자 신원 정보
  identity: {
    id: string;
    name: string;
    email: string;
  };
  
  // 사용자 설정
  preferences: {
    theme: string;
    language: string;
  };
  
  // 세션 정보
  session: {
    isLoggedIn: boolean;
    token: string | null;
  };
}

// ❌ 피하기: 평면적 구조
interface UserDataFlat {
  id: string;
  name: string;
  email: string;
  theme: string;
  language: string;
  isLoggedIn: boolean;
  token: string | null;
  // 모든 것이 한 레벨에 있어 관리 어려움
}
```

---

## 요약

Context-Action의 스토어 관리는 다음 핵심 원칙을 따릅니다:

- **반응형 상태 관리** - 변경사항에 자동 반응
- **프로바이더 범위 싱글톤** - 컨텍스트 경계 내 일관성
- **타입 안전성** - 완전한 TypeScript 지원
- **성능 최적화** - 선택적 구독과 배치 업데이트
- **메모리 안전성** - 자동 정리와 구독 관리

이러한 패턴을 따르면 확장 가능하고 유지보수 가능한 상태 관리를 구현할 수 있습니다.

---

::: tip 다음 단계
- [액션 핸들러](./action-handlers) - 비즈니스 로직 구현
- [React 통합](./react-integration) - React와의 효과적인 통합
- [성능 최적화](./performance) - 고급 성능 최적화 기법
:::

---


# Index

**Source**: `index.md`  
**Priority**: 50 (reference)  

<style>
.VPFeature .icon {
  font-size: 2rem;
  margin-bottom: 1rem;
}

.VPFeatures .VPFeature {
  transition: transform 0.2s, box-shadow 0.2s;
}

.VPFeatures .VPFeature:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
}
</style>

---



---

## Document Collection Summary

This collection includes all original documentation content from the Context-Action framework, preserving the complete information while removing YAML metadata for clean presentation.

**Generation Date**: 2025-08-14
**Content Type**: Original Documentation  
**Processing**: YAML frontmatter removed, content preserved

*Generated automatically from source documentation files*