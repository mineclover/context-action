===================[ DOC: ko/guide/action-handlers.md ]===================
# guide--action-handlers

액션 핸들러

useActionHandler 패턴으로 비즈니스 로직 구현. 순차/병렬 실행, 에러 처리, 메모리 정리 지원.

===================[ DOC: ko/guide/action-handlers.md ]===================
# guide--action-handlers

액션 핸들러

액션 핸들러는 애플리케이션의 비즈니스 로직을 포함합니다. 확장 가능하고 유지보수가 가능한 애플리케이션을 위해 핸들러를 효과적으로 구현, 등록, 관리하는 방법을 알아보세요. 핸들러 구현 패턴

모범 사례: useActionHandler 패턴

핸들러 등록에 권장되는 패턴은 최적의 성능과 적절한 정리를 위해 useActionHandler + useEffect를 사용하는 것입니다:

핸들러 설정 옵션

핸들러 실행 흐름

1. 순차 모드 (기본값): 핸들러가 우선순위 순서로 실행
2. 병렬 모드: 모든 핸들러가 동시에 실행
3. 경쟁 모드: 첫 번째로 완료되는 핸들러가 승리

컨트롤러 메서드

컨트롤러는 핸들러 실행 흐름을 관리하는 메서드를 제공합니다:

고급 핸들러 패턴

에러 핸들링

검증 핸들러

부작용 핸들러

결과 수집

여러 핸들러로부터 결과 수집:

핸들러 조직 패턴

도메인별 핸들러 파일

핸들러 조합

성능 고려사항

핸들러 최적화

지연 로딩

일반적인 핸들러 안티패턴

❌ 정리 누락

❌ 오래된 클로저

❌ 에러 핸들링 누락

요약

효과적인 액션 핸들러 구현에는 다음이 필요합니다:

- 적절한 등록: useActionHandler + useEffect 패턴 사용
- 메모리 관리: 항상 정리 함수 반환
- 에러 핸들링: 의미 있는 메시지와 함께 견고한 에러 핸들링
- 성능: useCallback을 사용한 안정적인 핸들러
- 테스트: 비즈니스 로직에 대한 격리된 단위 테스트
- 조직: 도메인별 핸들러 파일

액션 핸들러는 비즈니스 로직의 핵심입니다 - 유지보수 가능하고 확장 가능한 애플리케이션을 위해 올바르게 구현하세요. ---

::: tip 다음 단계
- 효과적인 상태 처리를 위한 스토어 관리 학습
- 다중 도메인 핸들러를 위한 교차 도메인 통합 탐색
- 종합적인 핸들러 테스트 전략을 위한 테스트 가이드 참조
:::.

===================[ DOC: ko/guide/action-handlers.md ]===================
# guide--action-handlers

액션 핸들러

useActionHandler + useEffect 패턴으로 비즈니스 로직 구현. 우선순위 기반 실행, 컨트롤러 메서드를 통한 에러 처리, 메모리 관리를 위한 적절한 정리 기능 제공.

===================[ DOC: ko/guide/action-handlers.md ]===================
# guide--action-handlers

액션 핸들러

액션 핸들러는 애플리케이션의 비즈니스 로직을 포함합니다. 확장 가능하고 유지보수가 가능한 애플리케이션을 위해 핸들러를 효과적으로 구현, 등록, 관리하는 방법을 알아보세요. 핸들러 구현 패턴

모범 사례: useActionHandler 패턴

핸들러 등록에 권장되는 패턴은 최적의 성능과 적절한 정리를 위해 useActionHandler + useEffect를 사용하는 것입니다:

핸들러 설정 옵션

핸들러 실행 흐름

1. 순차 모드 (기본값): 핸들러가 우선순위 순서로 실행
2. 병렬 모드: 모든 핸들러가 동시에 실행
3. 경쟁 모드: 첫 번째로 완료되는 핸들러가 승리

컨트롤러 메서드

컨트롤러는 핸들러 실행 흐름을 관리하는 메서드를 제공합니다:

고급 핸들러 패턴

에러 핸들링

검증 핸들러

부작용 핸들러

결과 수집

여러 핸들러로부터 결과 수집:

핸들러 조직 패턴

도메인별 핸들러 파일

핸들러 조합

성능 고려사항

핸들러 최적화

지연 로딩

일반적인 핸들러 안티패턴

❌ 정리 누락

❌ 오래된 클로저

❌ 에러 핸들링 누락

요약

효과적인 액션 핸들러 구현에는 다음이 필요합니다:

- 적절한 등록: useActionHandler + useEffect 패턴 사용
- 메모리 관리: 항상 정리 함수 반환
- 에러 핸들링: 의미 있는 메시지와 함께 견고한 에러 핸들링
- 성능: useCallback을 사용한 안정적인 핸들러
- 테스트: 비즈니스 로직에 대한 격리된 단위 테스트
- 조직: 도메인별 핸들러 파일

액션 핸들러는 비즈니스 로직의 핵심입니다 - 유지보수 가능하고 확장 가능한 애플리케이션을 위해 올바르게 구현하세요. ---

::: tip 다음 단계
- 효과적인 상태 처리를 위한 스토어 관리 학습
- 다중 도메인 핸들러를 위한 교차 도메인 통합 탐색
- 종합적인 핸들러 테스트 전략을 위한 테스트 가이드 참조
:::.

===================[ DOC: ko/guide/action-handlers.md ]===================
# guide--action-handlers

액션 핸들러

액션 핸들러는 애플리케이션의 비즈니스 로직을 포함합니다. 확장 가능하고 유지보수가 가능한 애플리케이션을 위해 핸들러를 효과적으로 구현, 등록, 관리하는 방법을 알아보세요. 핸들러 구현 패턴

모범 사례: useActionHandler 패턴

핸들러 등록에 권장되는 패턴은 최적의 성능과 적절한 정리를 위해 useActionHandler + useEffect를 사용하는 것입니다:

핸들러 설정 옵션

핸들러 실행 흐름

1. 순차 모드 (기본값): 핸들러가 우선순위 순서로 실행
2.

===================[ DOC: ko/guide/action-handlers.md ]===================
# guide--action-handlers

액션 핸들러

useActionHandler + useEffect 패턴으로 비즈니스 로직을 구현합니다. 주요 기능:

• 우선순위 기반 실행 (순차/병렬/경합 모드)
• 컨트롤러 메서드로 흐름 제어 (abort, jumpToPriority, setResult)
• 컨텍스트와 의미있는 메시지로 강력한 에러 처리
• unregister 함수로 메모리 정리
• 설정 가능한 전략으로 여러 핸들러에서 결과 수집

모범 사례: useCallback으로 핸들러 감싸기, 지연 스토어 평가 사용, 적절한 검증 구현, 유지보수성을 위해 도메인별로 핸들러 구성.

===================[ DOC: ko/guide/action-handlers.md ]===================
# guide--action-handlers

액션 핸들러

액션 핸들러는 애플리케이션의 비즈니스 로직을 포함합니다. 확장 가능하고 유지보수가 가능한 애플리케이션을 위해 핸들러를 효과적으로 구현, 등록, 관리하는 방법을 알아보세요. 핸들러 구현 패턴

모범 사례: useActionHandler 패턴

핸들러 등록에 권장되는 패턴은 최적의 성능과 적절한 정리를 위해 useActionHandler + useEffect를 사용하는 것입니다:

핸들러 설정 옵션

핸들러 실행 흐름

1. 순차 모드 (기본값): 핸들러가 우선순위 순서로 실행
2. 병렬 모드: 모든 핸들러가 동시에 실행
3. 경쟁 모드: 첫 번째로 완료되는 핸들러가 승리

컨트롤러 메서드

컨트롤러는 핸들러 실행 흐름을 관리하는 메서드를 제공합니다:

고급 핸들러 패턴

에러 핸들링

검증 핸들러

부작용 핸들러

결과 수집

여러 핸들러로부터 결과 수집:

핸들러 조직 패턴

도메인별 핸들러 파일

핸들러 조합

성능 고려사항

핸들러 최적화

지연 로딩

일반적인 핸들러 안티패턴

❌ 정리 누락

❌ 오래된 클로저

❌ 에러 핸들링 누락

요약

효과적인 액션 핸들러 구현에는 다음이 필요합니다:

- 적절한 등록: useActionHandler + useEffect 패턴 사용
- 메모리 관리: 항상 정리 함수 반환
- 에러 핸들링: 의미 있는 메시지와 함께 견고한 에러 핸들링
- 성능: useCallback을 사용한 안정적인 핸들러
- 테스트: 비즈니스 로직에 대한 격리된 단위 테스트
- 조직: 도메인별 핸들러 파일

액션 핸들러는 비즈니스 로직의 핵심입니다 - 유지보수 가능하고 확장 가능한 애플리케이션을 위해 올바르게 구현하세요. ---

::: tip 다음 단계
- 효과적인 상태 처리를 위한 스토어 관리 학습
- 다중 도메인 핸들러를 위한 교차 도메인 통합 탐색
- 종합적인 핸들러 테스트 전략을 위한 테스트 가이드 참조
:::.

===================[ DOC: ko/guide/action-pipeline.md ]===================
# guide--action-pipeline

액션 파이프라인 시스템

액션 파이프라인 시스템은 Context-Action의 ViewModel 레이어의 핵심으로, 우선순위 기반 핸들러 실행과 정교한 파이프라인...

===================[ DOC: ko/guide/action-pipeline.md ]===================
# guide--action-pipeline

액션 파이프라인 시스템

액션 파이프라인 시스템은 Context-Action의 ViewModel 레이어의 핵심으로, 우선순위 기반 핸들러 실행과 정교한 파이프라인 제어를 통한 중앙집중식 액션 처리를 제공합니다. 핵심 개념

ActionRegister

ActionRegister 클래스는 액션 파이프라인 시스템의 핵심입니다:

핸들러 등록

우선순위 기반 실행으로 핸들러를 등록:

파이프라인 컨트롤러

각 핸들러는 고급 파이프라인 관리를 위한 PipelineController를 받습니다:

우선순위 기반 실행

실행 순서

핸들러는 내림차순 우선순위 순서로 실행됩니다 (가장 높은 것부터):

핸들러 설정

파이프라인 제어 메서드

controller.abort()

선택적 이유와 함께 파이프라인 실행 중단:

controller.modifyPayload()

후속 핸들러를 위한 페이로드 변환:

controller.setResult() 및 getResults()

핸들러 간 중간 결과 관리:

실행 모드

순차 모드 (기본값)

핸들러가 차례대로 실행:

병렬 모드

모든 핸들러가 동시에 실행:

경쟁 모드

첫 번째 완료 핸들러가 승리:

결과 수집

기본 디스패치

결과 수집을 통한 디스패치

에러 처리

개별 핸들러가 실패해도 파이프라인은 계속 실행됩니다:

실제 예제: 인증 플로우

React와의 통합

액션 파이프라인은 액션 컨텍스트 패턴을 통해 React와 원활하게 통합됩니다:

다음 단계

- 메인 패턴 - Action Only와 Store Only 패턴 알아보기
- API 참조 - 자세한 ActionRegister API 문서  
- 예제 - 실제 Action Only 패턴 보기.

===================[ DOC: ko/guide/action-pipeline.md ]===================
# guide--action-pipeline

액션 파이프라인 시스템

액션 파이프라인 시스템은 Context-Action의 ViewModel 레이어의 핵심으로, 우선순위 기반 핸들러 실행과 정교한 파이프라인 제어를 통한 중앙집중식 액션 처리를 제공합니다.

===================[ DOC: ko/guide/action-pipeline.md ]===================
# guide--action-pipeline

액션 파이프라인 시스템

액션 파이프라인 시스템은 Context-Action의 ViewModel 레이어의 핵심으로, 우선순위 기반 핸들러 실행과 정교한 파이프라인 제어를 통한 중앙집중식 액션 처리를 제공합니다. 핵심 개념

ActionRegister

ActionRegister 클래스는 액션 파이프라인 시스템의 핵심입니다:

핸들러 등록

우선순위 기반 실행으로 핸들러를 등록:

파이프라인 컨트롤러

각 핸들러는 고급 파이프라인 관리를 위한 PipelineController를 받습니다:

우선순위 기반 실행

실행 순서

핸들러는 내림차순 우선순위 순서로 실행됩니다 (가장 높은 것부터):

핸들러 설정

파이프라인 제어 메서드

controller.abort()

선택적 이유와 함께 파이프라인 실행 중단:

controller.modifyPayload()

후속 핸들러를 위한 페이로드 변환:

controller.setResult() 및 getResults()

핸들러 간 중간 결과 관리:

실행 모드

순차 모드 (기본값)

핸들러가 차례대로 실행:

병렬 모드

모든 핸들러가 동시에 실행:

경쟁 모드

첫 번째 완료 핸들러가 승리:

결과 수집

기본 디스패치

결과 수집을 통한 디스패치

에러 처리

개별 핸들러가 실패해도 파이프라인은 계속 실행됩니다:

실제 예제: 인증 플로우

React와의 통합

액션 파이프라인은 액션 컨텍스트 패턴을 통해 React와 원활하게 통합됩니다:

다음 단계

- 메인 패턴 - Action Only와 Store Only 패턴 알아보기
- API 참조 - 자세한 ActionRegister API 문서  
- 예제 - 실제 Action Only 패턴 보기.

===================[ DOC: ko/guide/action-pipeline.md ]===================
# guide--action-pipeline

액션 파이프라인 시스템

액션 파이프라인 시스템은 Context-Action의 ViewModel 레이어의 핵심으로, 우선순위 기반 핸들러 실행과 정교한 파이프라인 제어를 통한 중앙집중식 액션 처리를 제공합니다.

===================[ DOC: ko/guide/action-pipeline.md ]===================
# guide--action-pipeline

액션 파이프라인 시스템

액션 파이프라인 시스템은 Context-Action의 ViewModel 레이어의 핵심으로, 우선순위 기반 핸들러 실행과 정교한 파이프라인 제어를 통한 중앙집중식 액션 처리를 제공합니다.

===================[ DOC: ko/guide/action-pipeline.md ]===================
# guide--action-pipeline

액션 파이프라인 시스템

액션 파이프라인 시스템은 Context-Action의 ViewModel 레이어의 핵심으로, 우선순위 기반 핸들러 실행과 정교한 파이프라인 제어를 통한 중앙집중식 액션 처리를 제공합니다. 핵심 개념

ActionRegister

ActionRegister 클래스는 액션 파이프라인 시스템의 핵심입니다:

핸들러 등록

우선순위 기반 실행으로 핸들러를 등록:

파이프라인 컨트롤러

각 핸들러는 고급 파이프라인 관리를 위한 PipelineController를 받습니다:

우선순위 기반 실행

실행 순서

핸들러는 내림차순 우선순위 순서로 실행됩니다 (가장 높은 것부터):

핸들러 설정

파이프라인 제어 메서드

controller.abort()

선택적 이유와 함께 파이프라인 실행 중단:

controller.modifyPayload()

후속 핸들러를 위한 페이로드 변환:

controller.setResult() 및 getResults()

핸들러 간 중간 결과 관리:

실행 모드

순차 모드 (기본값)

핸들러가 차례대로 실행:

병렬 모드

모든 핸들러가 동시에 실행:

경쟁 모드

첫 번째 완료 핸들러가 승리:

결과 수집

기본 디스패치

결과 수집을 통한 디스패치

에러 처리

개별 핸들러가 실패해도 파이프라인은 계속 실행됩니다:

실제 예제: 인증 플로우

React와의 통합

액션 파이프라인은 액션 컨텍스트 패턴을 통해 React와 원활하게 통합됩니다:

다음 단계

- 메인 패턴 - Action Only와 Store Only 패턴 알아보기
- API 참조 - 자세한 ActionRegister API 문서  
- 예제 - 실제 Action Only 패턴 보기.

===================[ DOC: ko/guide/architecture.md ]===================
# guide--architecture

아키텍처

Context-Action은 MVVM에서 영감을 받은 패턴을 통해 명확한 관심사 분리를 구현합니다.

===================[ DOC: ko/guide/architecture.md ]===================
# guide--architecture

아키텍처

Context-Action은 MVVM에서 영감을 받은 패턴을 통해 명확한 관심사 분리를 구현합니다. 핵심 아키텍처

프레임워크는 관심사를 세 개의 명확한 레이어로 분리합니다:

레이어

1. View 레이어: UI를 렌더링하고 액션을 디스패치하는 React 컴포넌트
2. ViewModel 레이어: 우선순위 기반 핸들러 실행을 가진 액션 파이프라인  
3.

===================[ DOC: ko/guide/architecture.md ]===================
# guide--architecture

아키텍처

Context-Action은 MVVM에서 영감을 받은 패턴을 통해 명확한 관심사 분리를 구현합니다. 핵심 아키텍처

프레임워크는 관심사를 세 개의 명확한 레이어로 분리합니다:

레이어

1. View 레이어: UI를 렌더링하고 액션을 디스패치하는 React 컴포넌트
2.

===================[ DOC: ko/guide/architecture.md ]===================
# guide--architecture

아키텍처

Context-Action은 MVVM에서 영감을 받은 패턴을 통해 명확한 관심사 분리를 구현합니다. 핵심 아키텍처

프레임워크는 관심사를 세 개의 명확한 레이어로 분리합니다:

레이어

1. View 레이어: UI를 렌더링하고 액션을 디스패치하는 React 컴포넌트
2. ViewModel 레이어: 우선순위 기반 핸들러 실행을 가진 액션 파이프라인  
3. Model 레이어: 반응형 상태 관리를 가진 스토어 시스템

컨텍스트 분리

Context-Action은 코드를 도메인별 컨텍스트로 구성합니다:

도메인 기반 컨텍스트
- 비즈니스 컨텍스트: 비즈니스 로직, 데이터 처리, 도메인 규칙
- UI 컨텍스트: 화면 상태, 사용자 상호작용, 컴포넌트 동작  
- 검증 컨텍스트: 데이터 검증, 폼 처리, 에러 핸들링
- 디자인 컨텍스트: 테마 관리, 스타일링, 레이아웃, 비주얼 상태
- 아키텍처 컨텍스트: 시스템 설정, 인프라스트럭처, 기술적 결정

컨텍스트 장점
- 도메인 격리: 각 컨텍스트는 완전한 독립성을 유지
- 명확한 경계: 구현 결과는 뚜렷하고 잘 정의된 도메인 경계를 유지
- 타입 안전성: 도메인별 훅과 함께 완전한 TypeScript 지원
- 확장성: 기존 도메인에 영향을 주지 않고 새로운 도메인을 쉽게 추가

핸들러 관리

Context-Action은 정교한 핸들러 및 트리거 관리를 제공합니다:

우선순위 기반 실행
- 순차 처리: 적절한 비동기 처리와 함께 우선순위 순서로 핸들러 실행
- 도메인 격리: 각 컨텍스트는 자체 핸들러 레지스트리를 유지
- 교차 컨텍스트 조정: 도메인 컨텍스트 간 제어된 통신
- 결과 수집: 복잡한 워크플로를 위한 여러 핸들러의 결과 집계

트리거 시스템
- 상태 변경 트리거: 스토어 값 변경에 기반한 자동 트리거
- 교차 컨텍스트 트리거: 도메인 경계가 다른 컨텍스트의 액션을 트리거
- 조건부 트리거: 비즈니스 규칙과 조건에 기반한 스마트 트리거
- 트리거 정리: 자동 정리가 메모리 누수와 오래된 참조를 방지

패키지 구조

Context-Action은 TypeScript 모노레포로 구성됩니다:

- @context-action/core - 핵심 액션 파이프라인 관리 (React 종속성 없음)
- @context-action/react - Context API와 훅을 이용한 React 통합

주요 장점

1. 문서-아티팩트 관리: 문서와 구현 간의 직접적인 관계
2. 완벽한 관심사 분리: 서로 다른 도메인 컨텍스트 간의 명확한 경계
3. 고급 핸들러 관리: 정교한 트리거 시스템을 가진 우선순위 기반 핸들러 실행
4. 타입 안전성: 프레임워크 전반에 걸친 완전한 TypeScript 지원
5. 성능: 영향받는 컴포넌트만 다시 렌더링
6. 팀 협업: 서로 다른 팀이 서로 다른 도메인에서 작업 가능.

===================[ DOC: ko/guide/architecture.md ]===================
# guide--architecture

아키텍처

Context-Action은 MVVM에서 영감을 받은 패턴을 통해 명확한 관심사 분리를 구현합니다. 핵심 아키텍처

프레임워크는 관심사를 세 개의 명확한 레이어로 분리합니다:

레이어

1. View 레이어: UI를 렌더링하고 액션을 디스패치하는 React 컴포넌트
2. ViewModel 레이어: 우선순위 기반 핸들러 실행을 가진 액션 파이프라인  
3.

===================[ DOC: ko/guide/architecture.md ]===================
# guide--architecture

아키텍처

Context-Action은 MVVM에서 영감을 받은 패턴을 통해 명확한 관심사 분리를 구현합니다. 핵심 아키텍처

프레임워크는 관심사를 세 개의 명확한 레이어로 분리합니다:

레이어

1. View 레이어: UI를 렌더링하고 액션을 디스패치하는 React 컴포넌트
2. ViewModel 레이어: 우선순위 기반 핸들러 실행을 가진 액션 파이프라인  
3.

===================[ DOC: ko/guide/architecture.md ]===================
# guide--architecture

아키텍처

Context-Action은 MVVM에서 영감을 받은 패턴을 통해 명확한 관심사 분리를 구현합니다. 핵심 아키텍처

프레임워크는 관심사를 세 개의 명확한 레이어로 분리합니다:

레이어

1. View 레이어: UI를 렌더링하고 액션을 디스패치하는 React 컴포넌트
2. ViewModel 레이어: 우선순위 기반 핸들러 실행을 가진 액션 파이프라인  
3. Model 레이어: 반응형 상태 관리를 가진 스토어 시스템

컨텍스트 분리

Context-Action은 코드를 도메인별 컨텍스트로 구성합니다:

도메인 기반 컨텍스트
- 비즈니스 컨텍스트: 비즈니스 로직, 데이터 처리, 도메인 규칙
- UI 컨텍스트: 화면 상태, 사용자 상호작용, 컴포넌트 동작  
- 검증 컨텍스트: 데이터 검증, 폼 처리, 에러 핸들링
- 디자인 컨텍스트: 테마 관리, 스타일링, 레이아웃, 비주얼 상태
- 아키텍처 컨텍스트: 시스템 설정, 인프라스트럭처, 기술적 결정

컨텍스트 장점
- 도메인 격리: 각 컨텍스트는 완전한 독립성을 유지
- 명확한 경계: 구현 결과는 뚜렷하고 잘 정의된 도메인 경계를 유지
- 타입 안전성: 도메인별 훅과 함께 완전한 TypeScript 지원
- 확장성: 기존 도메인에 영향을 주지 않고 새로운 도메인을 쉽게 추가

핸들러 관리

Context-Action은 정교한 핸들러 및 트리거 관리를 제공합니다:

우선순위 기반 실행
- 순차 처리: 적절한 비동기 처리와 함께 우선순위 순서로 핸들러 실행
- 도메인 격리: 각 컨텍스트는 자체 핸들러 레지스트리를 유지
- 교차 컨텍스트 조정: 도메인 컨텍스트 간 제어된 통신
- 결과 수집: 복잡한 워크플로를 위한 여러 핸들러의 결과 집계

트리거 시스템
- 상태 변경 트리거: 스토어 값 변경에 기반한 자동 트리거
- 교차 컨텍스트 트리거: 도메인 경계가 다른 컨텍스트의 액션을 트리거
- 조건부 트리거: 비즈니스 규칙과 조건에 기반한 스마트 트리거
- 트리거 정리: 자동 정리가 메모리 누수와 오래된 참조를 방지

패키지 구조

Context-Action은 TypeScript 모노레포로 구성됩니다:

- @context-action/core - 핵심 액션 파이프라인 관리 (React 종속성 없음)
- @context-action/react - Context API와 훅을 이용한 React 통합

주요 장점

1. 문서-아티팩트 관리: 문서와 구현 간의 직접적인 관계
2. 완벽한 관심사 분리: 서로 다른 도메인 컨텍스트 간의 명확한 경계
3. 고급 핸들러 관리: 정교한 트리거 시스템을 가진 우선순위 기반 핸들러 실행
4. 타입 안전성: 프레임워크 전반에 걸친 완전한 TypeScript 지원
5. 성능: 영향받는 컴포넌트만 다시 렌더링
6. 팀 협업: 서로 다른 팀이 서로 다른 도메인에서 작업 가능.

===================[ DOC: ko/guide/best-practices.md ]===================
# guide--best-practices

모범 사례

Context-Action 프레임워크를 사용할 때 따라야 할 컨벤션과 모범 사례입니다.

===================[ DOC: ko/guide/best-practices.md ]===================
# guide--best-practices

모범 사례

Context-Action 프레임워크를 사용할 때 따라야 할 컨벤션과 모범 사례입니다. 네이밍 컨벤션

도메인 기반 리네이밍 패턴

핵심 컨벤션은 명확한 컨텍스트 분리를 위한 도메인별 리네이밍입니다. 스토어 패턴 리네이밍

액션 패턴 리네이밍

컨텍스트 네이밍 규칙

도메인 기반 네이밍

액션 vs 스토어 구분

파일 구조

권장 디렉토리 구조

컨텍스트 파일 구성

패턴 사용법

액션 패턴 모범 사례

핸들러 등록

에러 핸들링

스토어 패턴 모범 사례

스토어 접근

스토어 업데이트

타입 정의

액션 타입

스토어 타입

성능 가이드라인

핸들러 최적화

스토어 구독 최적화

패턴 조합

Provider 계층구조

교차 패턴 통신

일반적인 함정

이런 패턴은 피하세요

고급 베스트 프랙티스

액션 핸들러 상태 접근

⚠️ 중요: 스토어 값 클로저 함정 피하기

액션 핸들러 내부에서 스토어 값에 접근할 때, 컴포넌트 스코프의 값을 절대 사용하지 마세요. 클로저 함정이 발생합니다:

실시간 상태 접근 패턴

useEffect 의존성 베스트 프랙티스

스토어와 Dispatch 참조는 안정적

Context-Action 프레임워크는 스토어 인스턴스와 dispatch 함수가 안정적인 참조를 갖도록 보장합니다:

의존성 배열 가이드라인

상태 이슈 디버깅

상태 모니터링 기법

일반적인 디버깅 시나리오

프로덕션 디버깅 및 컴포넌트 생명주기 관리

치명적 이슈: 중복 액션 핸들러 등록

문제: 동일한 액션 핸들러를 여러 번 등록하면 예측할 수 없는 동작이 발생합니다. 디버깅 팁: grep -n "useActionHandler.'actionName'" src//.tsx

처리 상태로 경쟁 조건 방지하기

문제: 빠른 버튼 클릭으로 인한 경쟁 조건과 상태 불일치가 발생합니다. RefContext를 사용한 안전한 컴포넌트 언마운트

문제: 컴포넌트 언마운트가 수동 ref 정리와 충돌합니다.

===================[ DOC: ko/guide/best-practices.md ]===================
# guide--best-practices

모범 사례

Context-Action 프레임워크를 사용할 때 따라야 할 컨벤션과 모범 사례입니다. 네이밍 컨벤션

도메인 기반 리네이밍 패턴

핵심 컨벤션은 명확한 컨텍스트 분리를 위한 도메인별 리네이밍입니다.

===================[ DOC: ko/guide/best-practices.md ]===================
# guide--best-practices

모범 사례

Context-Action 프레임워크를 사용할 때 따라야 할 컨벤션과 모범 사례입니다. 네이밍 컨벤션

도메인 기반 리네이밍 패턴

핵심 컨벤션은 명확한 컨텍스트 분리를 위한 도메인별 리네이밍입니다. 스토어 패턴 리네이밍

액션 패턴 리네이밍

컨텍스트 네이밍 규칙

도메인 기반 네이밍

액션 vs 스토어 구분

파일 구조

권장 디렉토리 구조

컨텍스트 파일 구성

패턴 사용법

액션 패턴 모범 사례

핸들러 등록

에러 핸들링

스토어 패턴 모범 사례

스토어 접근

스토어 업데이트

타입 정의

액션 타입

스토어 타입

성능 가이드라인

핸들러 최적화

스토어 구독 최적화

패턴 조합

Provider 계층구조

교차 패턴 통신

일반적인 함정

이런 패턴은 피하세요

고급 베스트 프랙티스

액션 핸들러 상태 접근

⚠️ 중요: 스토어 값 클로저 함정 피하기

액션 핸들러 내부에서 스토어 값에 접근할 때, 컴포넌트 스코프의 값을 절대 사용하지 마세요. 클로저 함정이 발생합니다:

실시간 상태 접근 패턴

useEffect 의존성 베스트 프랙티스

스토어와 Dispatch 참조는 안정적

Context-Action 프레임워크는 스토어 인스턴스와 dispatch 함수가 안정적인 참조를 갖도록 보장합니다:

의존성 배열 가이드라인

상태 이슈 디버깅

상태 모니터링 기법

일반적인 디버깅 시나리오

프로덕션 디버깅 및 컴포넌트 생명주기 관리

치명적 이슈: 중복 액션 핸들러 등록

문제: 동일한 액션 핸들러를 여러 번 등록하면 예측할 수 없는 동작이 발생합니다. 디버깅 팁: grep -n "useActionHandler.'actionName'" src//.tsx

처리 상태로 경쟁 조건 방지하기

문제: 빠른 버튼 클릭으로 인한 경쟁 조건과 상태 불일치가 발생합니다. RefContext를 사용한 안전한 컴포넌트 언마운트

문제: 컴포넌트 언마운트가 수동 ref 정리와 충돌합니다. 프로덕션 디버깅 기법

상태 모니터링: 프로덕션 이슈 진단을 위한 포괄적 상태 모니터링:

에러 복구: 자동 재시도 로직으로 우아한 에러 복구:

스트레스 테스트: 간헐적 이슈를 재현하기 위해 프로덕션 조건을 시뮬레이션:.

===================[ DOC: ko/guide/best-practices.md ]===================
# guide--best-practices

모범 사례

Context-Action 프레임워크를 사용할 때 따라야 할 컨벤션과 모범 사례입니다. 네이밍 컨벤션

도메인 기반 리네이밍 패턴

핵심 컨벤션은 명확한 컨텍스트 분리를 위한 도메인별 리네이밍입니다.

===================[ DOC: ko/guide/best-practices.md ]===================
# guide--best-practices

모범 사례

Context-Action 프레임워크를 사용할 때 따라야 할 컨벤션과 모범 사례입니다. 네이밍 컨벤션

도메인 기반 리네이밍 패턴

핵심 컨벤션은 명확한 컨텍스트 분리를 위한 도메인별 리네이밍입니다.

===================[ DOC: ko/guide/best-practices.md ]===================
# guide--best-practices

모범 사례

Context-Action 프레임워크를 사용할 때 따라야 할 컨벤션과 모범 사례입니다. 네이밍 컨벤션

도메인 기반 리네이밍 패턴

핵심 컨벤션은 명확한 컨텍스트 분리를 위한 도메인별 리네이밍입니다. 스토어 패턴 리네이밍

액션 패턴 리네이밍

컨텍스트 네이밍 규칙

도메인 기반 네이밍

액션 vs 스토어 구분

파일 구조

권장 디렉토리 구조

컨텍스트 파일 구성

패턴 사용법

액션 패턴 모범 사례

핸들러 등록

에러 핸들링

스토어 패턴 모범 사례

스토어 접근

스토어 업데이트

타입 정의

액션 타입

스토어 타입

성능 가이드라인

핸들러 최적화

스토어 구독 최적화

패턴 조합

Provider 계층구조

교차 패턴 통신

일반적인 함정

이런 패턴은 피하세요

고급 베스트 프랙티스

액션 핸들러 상태 접근

⚠️ 중요: 스토어 값 클로저 함정 피하기

액션 핸들러 내부에서 스토어 값에 접근할 때, 컴포넌트 스코프의 값을 절대 사용하지 마세요. 클로저 함정이 발생합니다:

실시간 상태 접근 패턴

useEffect 의존성 베스트 프랙티스

스토어와 Dispatch 참조는 안정적

Context-Action 프레임워크는 스토어 인스턴스와 dispatch 함수가 안정적인 참조를 갖도록 보장합니다:

의존성 배열 가이드라인

상태 이슈 디버깅

상태 모니터링 기법

일반적인 디버깅 시나리오

프로덕션 디버깅 및 컴포넌트 생명주기 관리

치명적 이슈: 중복 액션 핸들러 등록

문제: 동일한 액션 핸들러를 여러 번 등록하면 예측할 수 없는 동작이 발생합니다. 디버깅 팁: grep -n "useActionHandler.'actionName'" src//.tsx

처리 상태로 경쟁 조건 방지하기

문제: 빠른 버튼 클릭으로 인한 경쟁 조건과 상태 불일치가 발생합니다. RefContext를 사용한 안전한 컴포넌트 언마운트

문제: 컴포넌트 언마운트가 수동 ref 정리와 충돌합니다. 프로덕션 디버깅 기법

상태 모니터링: 프로덕션 이슈 진단을 위한 포괄적 상태 모니터링:

에러 복구: 자동 재시도 로직으로 우아한 에러 복구:

스트레스 테스트: 간헐적 이슈를 재현하기 위해 프로덕션 조건을 시뮬레이션:.

===================[ DOC: ko/guide/code-patterns.md ]===================
# guide--code-patterns

코드 패턴

Context-Action 프레임워크의 RefContext와 useWaitForRefs 핵심 기능 패턴입니다.

===================[ DOC: ko/guide/code-patterns.md ]===================
# guide--code-patterns

코드 패턴

Context-Action 프레임워크의 RefContext와 useWaitForRefs 핵심 기능 패턴입니다. 자세한 예제와 구현 가이드라인은 정리된 패턴 모음을 참조하세요:

📁 패턴 모음

핵심 패턴
- RefContext 설정 - TypeScript 타입을 포함한 기본 설정
- 조건부 대기 - 핵심 useWaitForRefs 동작
- 대기 후 실행 - 안전한 DOM 조작
- 실시간 상태 접근 - 클로저 함정 방지
- 타임아웃 보호 - 무한 대기 방지

빠른 참조

필수 규칙

✅ 해야 할 것
- useWaitForRefs가 포함된 핸들러에서 useCallback 사용
- store.getValue()로 실시간 상태 접근
- try-catch로 에러 처리
- 마운트/언마운트 시나리오 모두 테스트

❌ 하지 말 것
- 직접 DOM 쿼리 사용 (document.getElementById)
- 핸들러에서 컴포넌트 스코프 값에 의존
- 에러 처리 무시
- 중요한 경로에서 타임아웃 보호 생략.

===================[ DOC: ko/guide/code-patterns.md ]===================
# guide--code-patterns

코드 패턴

Context-Action 프레임워크의 RefContext와 useWaitForRefs 핵심 기능 패턴입니다.

===================[ DOC: ko/guide/code-patterns.md ]===================
# guide--code-patterns

코드 패턴

Context-Action 프레임워크의 RefContext와 useWaitForRefs 핵심 기능 패턴입니다. 자세한 예제와 구현 가이드라인은 정리된 패턴 모음을 참조하세요:

📁 패턴 모음

핵심 패턴
- RefContext 설정 - TypeScript 타입을 포함한 기본 설정
- 조건부 대기 - 핵심 useWaitForRefs 동작
- 대기 후 실행 - 안전한 DOM 조작
- 실시간 상태 접근 - 클로저 함정 방지
- 타임아웃 보호 - 무한 대기 방지

빠른 참조

필수 규칙

✅ 해야 할 것
- useWaitForRefs가 포함된 핸들러에서 useCallback 사용
- store.getValue()로 실시간 상태 접근
- try-catch로 에러 처리
- 마운트/언마운트 시나리오 모두 테스트

❌ 하지 말 것
- 직접 DOM 쿼리 사용 (document.getElementById)
- 핸들러에서 컴포넌트 스코프 값에 의존
- 에러 처리 무시
- 중요한 경로에서 타임아웃 보호 생략.

===================[ DOC: ko/guide/code-patterns.md ]===================
# guide--code-patterns

코드 패턴

Context-Action 프레임워크의 RefContext와 useWaitForRefs 핵심 기능 패턴입니다.

===================[ DOC: ko/guide/code-patterns.md ]===================
# guide--code-patterns

코드 패턴

Context-Action 프레임워크의 RefContext와 useWaitForRefs 핵심 기능 패턴입니다.

===================[ DOC: ko/guide/code-patterns.md ]===================
# guide--code-patterns

코드 패턴

Context-Action 프레임워크의 RefContext와 useWaitForRefs 핵심 기능 패턴입니다. 자세한 예제와 구현 가이드라인은 정리된 패턴 모음을 참조하세요:

📁 패턴 모음

핵심 패턴
- RefContext 설정 - TypeScript 타입을 포함한 기본 설정
- 조건부 대기 - 핵심 useWaitForRefs 동작
- 대기 후 실행 - 안전한 DOM 조작
- 실시간 상태 접근 - 클로저 함정 방지
- 타임아웃 보호 - 무한 대기 방지

빠른 참조

필수 규칙

✅ 해야 할 것
- useWaitForRefs가 포함된 핸들러에서 useCallback 사용
- store.getValue()로 실시간 상태 접근
- try-catch로 에러 처리
- 마운트/언마운트 시나리오 모두 테스트

❌ 하지 말 것
- 직접 DOM 쿼리 사용 (document.getElementById)
- 핸들러에서 컴포넌트 스코프 값에 의존
- 에러 처리 무시
- 중요한 경로에서 타임아웃 보호 생략.

===================[ DOC: ko/guide/conditional-await.md ]===================
# guide--conditional-await

조건부 대기 패턴

useWaitForRefs의 핵심 동작으로 조건부로 대기하거나 즉시 반환하는 패턴입니다.

===================[ DOC: ko/guide/conditional-await.md ]===================
# guide--conditional-await

조건부 대기 패턴

useWaitForRefs의 핵심 동작으로 조건부로 대기하거나 즉시 반환하는 패턴입니다. 기본 패턴

사용 사례

단순 대기

조건부 로직

주요 이점

- 자동 감지: 수동 확인 불필요
- 성능: 요소가 이미 마운트된 경우 지연 없음
- 안정성: await 후 요소 가용성 보장.

===================[ DOC: ko/guide/conditional-await.md ]===================
# guide--conditional-await

조건부 대기 패턴

useWaitForRefs의 핵심 동작으로 조건부로 대기하거나 즉시 반환하는 패턴입니다. 기본 패턴

사용 사례

단순 대기

조건부 로직

주요 이점

- 자동 감지: 수동 확인 불필요
- 성능: 요소가 이미 마운트된 경우 지연 없음
- 안정성: await 후 요소 가용성 보장.

===================[ DOC: ko/guide/conditional-await.md ]===================
# guide--conditional-await

조건부 대기 패턴

useWaitForRefs의 핵심 동작으로 조건부로 대기하거나 즉시 반환하는 패턴입니다. 기본 패턴

사용 사례

단순 대기

조건부 로직

주요 이점

- 자동 감지: 수동 확인 불필요
- 성능: 요소가 이미 마운트된 경우 지연 없음
- 안정성: await 후 요소 가용성 보장.

===================[ DOC: ko/guide/conditional-await.md ]===================
# guide--conditional-await

조건부 대기 패턴

useWaitForRefs의 핵심 동작으로 조건부로 대기하거나 즉시 반환하는 패턴입니다. 기본 패턴

사용 사례

단순 대기

조건부 로직

주요 이점

- 자동 감지: 수동 확인 불필요
- 성능: 요소가 이미 마운트된 경우 지연 없음
- 안정성: await 후 요소 가용성 보장.

===================[ DOC: ko/guide/conditional-await.md ]===================
# guide--conditional-await

조건부 대기 패턴

useWaitForRefs의 핵심 동작으로 조건부로 대기하거나 즉시 반환하는 패턴입니다. 기본 패턴

사용 사례

단순 대기

조건부 로직

주요 이점

- 자동 감지: 수동 확인 불필요
- 성능: 요소가 이미 마운트된 경우 지연 없음
- 안정성: await 후 요소 가용성 보장.

===================[ DOC: ko/guide/conditional-await.md ]===================
# guide--conditional-await

조건부 대기 패턴

useWaitForRefs의 핵심 동작으로 조건부로 대기하거나 즉시 반환하는 패턴입니다. 기본 패턴

사용 사례

단순 대기

조건부 로직

주요 이점

- 자동 감지: 수동 확인 불필요
- 성능: 요소가 이미 마운트된 경우 지연 없음
- 안정성: await 후 요소 가용성 보장.

===================[ DOC: ko/guide/getting-started.md ]===================
# guide--getting-started

시작하기

Context-Action은 완벽한 관심사 분리를 통한 확장 가능한 React 애플리케이션 구축을 위한 세 가지 주요 패턴을 제공합니다.

===================[ DOC: ko/guide/getting-started.md ]===================
# guide--getting-started

시작하기

Context-Action은 완벽한 관심사 분리를 통한 확장 가능한 React 애플리케이션 구축을 위한 세 가지 주요 패턴을 제공합니다. 빠른 시작

사용 사례에 맞는 적합한 패턴을 선택하세요:

| 패턴 | 사용 사례 | 임포트 | 최적용도 |
|---------|----------|--------|----------|
| 🎯 Action Only | 스토어 없이 액션 디스패칭 | createActionContext | 이벤트 시스템, 커맨드 패턴 |
| 🏪 Store Only | 액션 없이 상태 관리 | createDeclarativeStorePattern | 순수 상태 관리, 데이터 레이어 |
| 🔧 Ref Context | 제로 리렌더링 직접 DOM 조작 | createRefContext | 고성능 UI, 애니메이션, 실시간 인터랙션 |

🎯 Action Only 패턴

상태 관리 없이 순수 액션 디스패칭. 기본 사용법

🏪 Store Only 패턴

액션 디스패칭 없이 타입 안전한 상태 관리. 기본 사용법

🔧 Ref Context 패턴

제로 React 리렌더링으로 고성능 직접 DOM 조작. 기본 사용법

비즈니스 로직을 포함한 고급 RefContext

패턴 조합

복잡한 애플리케이션의 경우, 세 패턴을 모두 조합하여 사용:

다음 단계

- React Refs 가이드 - RefContext 패턴 심화 학습
- 패턴 가이드 - 세 패턴의 예시와 함께 비교 분석
- 액션 파이프라인 - 액션 처리에 대해 알아보기
- 아키텍처 - 전체 아키텍처 이해하기
- 훅 - 사용 가능한 React 훅 살펴보기
- 모범 사례 - 권장 패턴 따르기

실제 예시

- RefContext를 사용한 마우스 이벤트: 예시 앱에서 RefContext 마우스 이벤트 데모 확인하기
- 스토어 통합: 액션 핸들러와 스토어를 결합하는 방법 학습하기
- 성능 최적화: 직접 DOM 조작으로 제로 리렌더링 패턴 확인하기.

===================[ DOC: ko/guide/getting-started.md ]===================
# guide--getting-started

시작하기

Context-Action은 완벽한 관심사 분리를 통한 확장 가능한 React 애플리케이션 구축을 위한 세 가지 주요 패턴을 제공합니다.

===================[ DOC: ko/guide/getting-started.md ]===================
# guide--getting-started

시작하기

Context-Action은 완벽한 관심사 분리를 통한 확장 가능한 React 애플리케이션 구축을 위한 세 가지 주요 패턴을 제공합니다. 빠른 시작

사용 사례에 맞는 적합한 패턴을 선택하세요:

| 패턴 | 사용 사례 | 임포트 | 최적용도 |
|---------|----------|--------|----------|
| 🎯 Action Only | 스토어 없이 액션 디스패칭 | createActionContext | 이벤트 시스템, 커맨드 패턴 |
| 🏪 Store Only | 액션 없이 상태 관리 | createDeclarativeStorePattern | 순수 상태 관리, 데이터 레이어 |
| 🔧 Ref Context | 제로 리렌더링 직접 DOM 조작 | createRefContext | 고성능 UI, 애니메이션, 실시간 인터랙션 |

🎯 Action Only 패턴

상태 관리 없이 순수 액션 디스패칭. 기본 사용법

🏪 Store Only 패턴

액션 디스패칭 없이 타입 안전한 상태 관리. 기본 사용법

🔧 Ref Context 패턴

제로 React 리렌더링으로 고성능 직접 DOM 조작. 기본 사용법

비즈니스 로직을 포함한 고급 RefContext

패턴 조합

복잡한 애플리케이션의 경우, 세 패턴을 모두 조합하여 사용:

다음 단계

- React Refs 가이드 - RefContext 패턴 심화 학습
- 패턴 가이드 - 세 패턴의 예시와 함께 비교 분석
- 액션 파이프라인 - 액션 처리에 대해 알아보기
- 아키텍처 - 전체 아키텍처 이해하기
- 훅 - 사용 가능한 React 훅 살펴보기
- 모범 사례 - 권장 패턴 따르기

실제 예시

- RefContext를 사용한 마우스 이벤트: 예시 앱에서 RefContext 마우스 이벤트 데모 확인하기
- 스토어 통합: 액션 핸들러와 스토어를 결합하는 방법 학습하기
- 성능 최적화: 직접 DOM 조작으로 제로 리렌더링 패턴 확인하기.

===================[ DOC: ko/guide/getting-started.md ]===================
# guide--getting-started

시작하기

Context-Action은 완벽한 관심사 분리를 통한 확장 가능한 React 애플리케이션 구축을 위한 세 가지 주요 패턴을 제공합니다.

===================[ DOC: ko/guide/getting-started.md ]===================
# guide--getting-started

시작하기

Context-Action은 완벽한 관심사 분리를 통한 확장 가능한 React 애플리케이션 구축을 위한 세 가지 주요 패턴을 제공합니다. 빠른 시작

사용 사례에 맞는 적합한 패턴을 선택하세요:

| 패턴 | 사용 사례 | 임포트 | 최적용도 |
|---------|----------|--------|----------|
| 🎯 Action Only | 스토어 없이 액션 디스패칭 | createActionContext | 이벤트 시스템, 커맨드 패턴 |
| 🏪 Store Only | 액션 없이 상태 관리 | createDeclarativeStorePattern | 순수 상태 관리, 데이터 레이어 |
| 🔧 Ref Context | 제로 리렌더링 직접 DOM 조작 | createRefContext | 고성능 UI, 애니메이션, 실시간 인터랙션 |

🎯 Action Only 패턴

상태 관리 없이 순수 액션 디스패칭.

===================[ DOC: ko/guide/getting-started.md ]===================
# guide--getting-started

시작하기

Context-Action은 완벽한 관심사 분리를 통한 확장 가능한 React 애플리케이션 구축을 위한 세 가지 주요 패턴을 제공합니다. 빠른 시작

사용 사례에 맞는 적합한 패턴을 선택하세요:

| 패턴 | 사용 사례 | 임포트 | 최적용도 |
|---------|----------|--------|----------|
| 🎯 Action Only | 스토어 없이 액션 디스패칭 | createActionContext | 이벤트 시스템, 커맨드 패턴 |
| 🏪 Store Only | 액션 없이 상태 관리 | createDeclarativeStorePattern | 순수 상태 관리, 데이터 레이어 |
| 🔧 Ref Context | 제로 리렌더링 직접 DOM 조작 | createRefContext | 고성능 UI, 애니메이션, 실시간 인터랙션 |

🎯 Action Only 패턴

상태 관리 없이 순수 액션 디스패칭. 기본 사용법

🏪 Store Only 패턴

액션 디스패칭 없이 타입 안전한 상태 관리. 기본 사용법

🔧 Ref Context 패턴

제로 React 리렌더링으로 고성능 직접 DOM 조작. 기본 사용법

비즈니스 로직을 포함한 고급 RefContext

패턴 조합

복잡한 애플리케이션의 경우, 세 패턴을 모두 조합하여 사용:

다음 단계

- React Refs 가이드 - RefContext 패턴 심화 학습
- 패턴 가이드 - 세 패턴의 예시와 함께 비교 분석
- 액션 파이프라인 - 액션 처리에 대해 알아보기
- 아키텍처 - 전체 아키텍처 이해하기
- 훅 - 사용 가능한 React 훅 살펴보기
- 모범 사례 - 권장 패턴 따르기

실제 예시

- RefContext를 사용한 마우스 이벤트: 예시 앱에서 RefContext 마우스 이벤트 데모 확인하기
- 스토어 통합: 액션 핸들러와 스토어를 결합하는 방법 학습하기
- 성능 최적화: 직접 DOM 조작으로 제로 리렌더링 패턴 확인하기.

===================[ DOC: ko/guide/hooks.md ]===================
# guide--hooks

React 훅

Context-Action은 액션 디스패칭과 스토어 관리를 위한 React 훅을 제공합니다. 필수 훅

가장 자주 사용할 핵심 훅들입니다.

===================[ DOC: ko/guide/hooks.md ]===================
# guide--hooks

React 훅

Context-Action은 액션 디스패칭과 스토어 관리를 위한 React 훅을 제공합니다. 필수 훅

가장 자주 사용할 핵심 훅들입니다. 액션 훅

createActionContext<T>()
모든 액션 관련 훅을 생성하는 팩토리 함수. useActionDispatch()
핸들러에 액션을 디스패치하는 주요 훅. useActionHandler()
액션 핸들러를 등록하는 주요 훅. 스토어 훅

createDeclarativeStorePattern<T>()
모든 스토어 관련 훅을 생성하는 팩토리 함수. useStoreValue<T>(store)
스토어 변경 사항을 구독하는 주요 훅. useStore(name)
이름으로 스토어에 접근하는 주요 훅. 유틸리티 훅

고급 시나리오를 위한 추가 훅들. 스토어 관리

useStoreManager()
프로그래밍 방식으로 스토어를 업데이트하는 훅. 고급 액션 훅

useActionDispatchWithResult()
디스패치와 결과 수집 기능을 모두 제공하는 훅. 사용 가이드라인

모범 사례

1. 핸들러에 useCallback 사용:

2. 필요할 때 패턴 조합:

3. 타입 안전한 스토어 접근:

성능 팁

- 스토어 구독은 실제 값 변경 시에만 다시 렌더링됩니다
- 전체 상태를 구독하는 대신 특정 스토어 구독을 사용하세요
- 핸들러 등록은 최소한의 다시 렌더링에 최적화되어 있습니다
- 액션 디스패칭은 자동으로 메모이제이션됩니다.

===================[ DOC: ko/guide/hooks.md ]===================
# guide--hooks

React 훅

Context-Action은 액션 디스패칭과 스토어 관리를 위한 React 훅을 제공합니다. 필수 훅

가장 자주 사용할 핵심 훅들입니다. 액션 훅

createActionContext<T>()
모든 액션 관련 훅을 생성하는 팩토리 함수. useActionDispatch()
핸들러에 액션을 디스패치하는 주요 훅.

===================[ DOC: ko/guide/hooks.md ]===================
# guide--hooks

React 훅

Context-Action은 액션 디스패칭과 스토어 관리를 위한 React 훅을 제공합니다. 필수 훅

가장 자주 사용할 핵심 훅들입니다. 액션 훅

createActionContext<T>()
모든 액션 관련 훅을 생성하는 팩토리 함수. useActionDispatch()
핸들러에 액션을 디스패치하는 주요 훅. useActionHandler()
액션 핸들러를 등록하는 주요 훅. 스토어 훅

createDeclarativeStorePattern<T>()
모든 스토어 관련 훅을 생성하는 팩토리 함수. useStoreValue<T>(store)
스토어 변경 사항을 구독하는 주요 훅. useStore(name)
이름으로 스토어에 접근하는 주요 훅. 유틸리티 훅

고급 시나리오를 위한 추가 훅들. 스토어 관리

useStoreManager()
프로그래밍 방식으로 스토어를 업데이트하는 훅. 고급 액션 훅

useActionDispatchWithResult()
디스패치와 결과 수집 기능을 모두 제공하는 훅. 사용 가이드라인

모범 사례

1. 핸들러에 useCallback 사용:

2. 필요할 때 패턴 조합:

3. 타입 안전한 스토어 접근:

성능 팁

- 스토어 구독은 실제 값 변경 시에만 다시 렌더링됩니다
- 전체 상태를 구독하는 대신 특정 스토어 구독을 사용하세요
- 핸들러 등록은 최소한의 다시 렌더링에 최적화되어 있습니다
- 액션 디스패칭은 자동으로 메모이제이션됩니다.

===================[ DOC: ko/guide/hooks.md ]===================
# guide--hooks

React 훅

Context-Action은 액션 디스패칭과 스토어 관리를 위한 React 훅을 제공합니다. 필수 훅

가장 자주 사용할 핵심 훅들입니다. 액션 훅

createActionContext<T>()
모든 액션 관련 훅을 생성하는 팩토리 함수. useActionDispatch()
핸들러에 액션을 디스패치하는 주요 훅. useActionHandler()
액션 핸들러를 등록하는 주요 훅. 스토어 훅

createDeclarativeStorePattern<T>()
모든 스토어 관련 훅을 생성하는 팩토리 함수.

===================[ DOC: ko/guide/hooks.md ]===================
# guide--hooks

React 훅

Context-Action은 액션 디스패칭과 스토어 관리를 위한 React 훅을 제공합니다. 필수 훅

가장 자주 사용할 핵심 훅들입니다. 액션 훅

createActionContext<T>()
모든 액션 관련 훅을 생성하는 팩토리 함수. useActionDispatch()
핸들러에 액션을 디스패치하는 주요 훅. useActionHandler()
액션 핸들러를 등록하는 주요 훅. 스토어 훅

createDeclarativeStorePattern<T>()
모든 스토어 관련 훅을 생성하는 팩토리 함수. useStoreValue<T>(store)
스토어 변경 사항을 구독하는 주요 훅. useStore(name)
이름으로 스토어에 접근하는 주요 훅. 유틸리티 훅

고급 시나리오를 위한 추가 훅들. 스토어 관리

useStoreManager()
프로그래밍 방식으로 스토어를 업데이트하는 훅.

===================[ DOC: ko/guide/hooks.md ]===================
# guide--hooks

React 훅

Context-Action은 액션 디스패칭과 스토어 관리를 위한 React 훅을 제공합니다. 필수 훅

가장 자주 사용할 핵심 훅들입니다. 액션 훅

createActionContext<T>()
모든 액션 관련 훅을 생성하는 팩토리 함수. useActionDispatch()
핸들러에 액션을 디스패치하는 주요 훅. useActionHandler()
액션 핸들러를 등록하는 주요 훅. 스토어 훅

createDeclarativeStorePattern<T>()
모든 스토어 관련 훅을 생성하는 팩토리 함수. useStoreValue<T>(store)
스토어 변경 사항을 구독하는 주요 훅. useStore(name)
이름으로 스토어에 접근하는 주요 훅. 유틸리티 훅

고급 시나리오를 위한 추가 훅들. 스토어 관리

useStoreManager()
프로그래밍 방식으로 스토어를 업데이트하는 훅. 고급 액션 훅

useActionDispatchWithResult()
디스패치와 결과 수집 기능을 모두 제공하는 훅. 사용 가이드라인

모범 사례

1. 핸들러에 useCallback 사용:

2. 필요할 때 패턴 조합:

3. 타입 안전한 스토어 접근:

성능 팁

- 스토어 구독은 실제 값 변경 시에만 다시 렌더링됩니다
- 전체 상태를 구독하는 대신 특정 스토어 구독을 사용하세요
- 핸들러 등록은 최소한의 다시 렌더링에 최적화되어 있습니다
- 액션 디스패칭은 자동으로 메모이제이션됩니다.

===================[ DOC: ko/guide/index.md ]===================
# guide--index

코드 패턴

Context-Action 프레임워크의 RefContext와 useWaitForRefs 기능에 중점을 둔 필수 패턴 모음입니다.

===================[ DOC: ko/guide/index.md ]===================
# guide--index

코드 패턴

Context-Action 프레임워크의 RefContext와 useWaitForRefs 기능에 중점을 둔 필수 패턴 모음입니다. 핵심 패턴

RefContext 설정
적절한 TypeScript 타입과 provider 통합을 위한 RefContext의 기본 설정 패턴입니다. 조건부 대기
요소 마운트 상태에 따라 조건부로 대기하거나 즉시 반환하는 useWaitForRefs의 핵심 동작입니다. 대기 후 실행
요소 가용성을 보장한 후 안전하게 DOM 조작을 실행하는 패턴입니다. 실시간 상태 접근
store.getValue()를 사용하여 현재 상태에 실시간으로 접근하여 클로저 함정을 방지하는 패턴입니다. 타임아웃 보호
타임아웃 메커니즘과 재시도 로직으로 무한 대기를 방지하는 패턴입니다. 사용 가이드라인

각 패턴에는 다음이 포함됩니다:
- ✅ 모범 사례 작동하는 예제와 함께
- ❌ 일반적인 함정 피해야 할 것들
- 🎯 사용 사례 패턴을 적용할 시기
- ⚡ 성능 고려사항 및 최적화 팁

패턴 조합

이러한 패턴들은 복잡한 시나리오를 위해 조합할 수 있습니다:
- RefContext 설정 + 조건부 대기 기본 요소 대기용
- 실시간 상태 접근 + 대기 후 실행 경쟁 조건 방지용
- 타임아웃 보호 + 모든 패턴 견고한 에러 처리용.

===================[ DOC: ko/guide/index.md ]===================
# guide--index

코드 패턴

Context-Action 프레임워크의 RefContext와 useWaitForRefs 기능에 중점을 둔 필수 패턴 모음입니다. 핵심 패턴

RefContext 설정
적절한 TypeScript 타입과 provider 통합을 위한 RefContext의 기본 설정 패턴입니다.

===================[ DOC: ko/guide/index.md ]===================
# guide--index

코드 패턴

Context-Action 프레임워크의 RefContext와 useWaitForRefs 기능에 중점을 둔 필수 패턴 모음입니다. 핵심 패턴

RefContext 설정
적절한 TypeScript 타입과 provider 통합을 위한 RefContext의 기본 설정 패턴입니다. 조건부 대기
요소 마운트 상태에 따라 조건부로 대기하거나 즉시 반환하는 useWaitForRefs의 핵심 동작입니다. 대기 후 실행
요소 가용성을 보장한 후 안전하게 DOM 조작을 실행하는 패턴입니다. 실시간 상태 접근
store.getValue()를 사용하여 현재 상태에 실시간으로 접근하여 클로저 함정을 방지하는 패턴입니다. 타임아웃 보호
타임아웃 메커니즘과 재시도 로직으로 무한 대기를 방지하는 패턴입니다. 사용 가이드라인

각 패턴에는 다음이 포함됩니다:
- ✅ 모범 사례 작동하는 예제와 함께
- ❌ 일반적인 함정 피해야 할 것들
- 🎯 사용 사례 패턴을 적용할 시기
- ⚡ 성능 고려사항 및 최적화 팁

패턴 조합

이러한 패턴들은 복잡한 시나리오를 위해 조합할 수 있습니다:
- RefContext 설정 + 조건부 대기 기본 요소 대기용
- 실시간 상태 접근 + 대기 후 실행 경쟁 조건 방지용
- 타임아웃 보호 + 모든 패턴 견고한 에러 처리용.

===================[ DOC: ko/guide/index.md ]===================
# guide--index

코드 패턴

Context-Action 프레임워크의 RefContext와 useWaitForRefs 기능에 중점을 둔 필수 패턴 모음입니다. 핵심 패턴

RefContext 설정
적절한 TypeScript 타입과 provider 통합을 위한 RefContext의 기본 설정 패턴입니다. 조건부 대기
요소 마운트 상태에 따라 조건부로 대기하거나 즉시 반환하는 useWaitForRefs의 핵심 동작입니다. 대기 후 실행
요소 가용성을 보장한 후 안전하게 DOM 조작을 실행하는 패턴입니다.

===================[ DOC: ko/guide/index.md ]===================
# guide--index

코드 패턴

Context-Action 프레임워크의 RefContext와 useWaitForRefs 기능에 중점을 둔 필수 패턴 모음입니다. 핵심 패턴

RefContext 설정
적절한 TypeScript 타입과 provider 통합을 위한 RefContext의 기본 설정 패턴입니다. 조건부 대기
요소 마운트 상태에 따라 조건부로 대기하거나 즉시 반환하는 useWaitForRefs의 핵심 동작입니다. 대기 후 실행
요소 가용성을 보장한 후 안전하게 DOM 조작을 실행하는 패턴입니다. 실시간 상태 접근
store.getValue()를 사용하여 현재 상태에 실시간으로 접근하여 클로저 함정을 방지하는 패턴입니다. 타임아웃 보호
타임아웃 메커니즘과 재시도 로직으로 무한 대기를 방지하는 패턴입니다.

===================[ DOC: ko/guide/index.md ]===================
# guide--index

코드 패턴

Context-Action 프레임워크의 RefContext와 useWaitForRefs 기능에 중점을 둔 필수 패턴 모음입니다. 핵심 패턴

RefContext 설정
적절한 TypeScript 타입과 provider 통합을 위한 RefContext의 기본 설정 패턴입니다. 조건부 대기
요소 마운트 상태에 따라 조건부로 대기하거나 즉시 반환하는 useWaitForRefs의 핵심 동작입니다. 대기 후 실행
요소 가용성을 보장한 후 안전하게 DOM 조작을 실행하는 패턴입니다. 실시간 상태 접근
store.getValue()를 사용하여 현재 상태에 실시간으로 접근하여 클로저 함정을 방지하는 패턴입니다. 타임아웃 보호
타임아웃 메커니즘과 재시도 로직으로 무한 대기를 방지하는 패턴입니다. 사용 가이드라인

각 패턴에는 다음이 포함됩니다:
- ✅ 모범 사례 작동하는 예제와 함께
- ❌ 일반적인 함정 피해야 할 것들
- 🎯 사용 사례 패턴을 적용할 시기
- ⚡ 성능 고려사항 및 최적화 팁

패턴 조합

이러한 패턴들은 복잡한 시나리오를 위해 조합할 수 있습니다:
- RefContext 설정 + 조건부 대기 기본 요소 대기용
- 실시간 상태 접근 + 대기 후 실행 경쟁 조건 방지용
- 타임아웃 보호 + 모든 패턴 견고한 에러 처리용.

===================[ DOC: ko/guide/llms-cli-comprehensive-reference.md ]===================
# guide--llms-cli-comprehensive-reference

LLMS Generator CLI - 종합 구현 참조서

LLMS Generator 시스템의 모든 구현된 CLI 명령어와 기능에 대한 완전한 문서입니다.

===================[ DOC: ko/guide/llms-cli-comprehensive-reference.md ]===================
# guide--llms-cli-comprehensive-reference

LLMS Generator CLI - 종합 구현 참조서

LLMS Generator 시스템의 모든 구현된 CLI 명령어와 기능에 대한 완전한 문서입니다. 개요

LLMS Generator CLI는 다국어 문서 관리, 우선순위 시스템, 자동화된 템플릿 생성을 위한 종합적인 도구 모음을 제공합니다. 이 문서는 구현된 모든 기능, 명령어, 워크플로우를 다룹니다. 아키텍처

핵심 구성 요소
- Command Router: 중앙 명령 디스패치 시스템 (/src/cli/index.ts)
- Command Implementations: /src/cli/commands/의 개별 명령 클래스들
- Configuration Management: EnhancedLLMSConfig를 사용한 향상된 설정 시스템
- Help System: 대화형 도움말 표시 (HelpDisplay.ts)
- Error Handling: 중앙화된 오류 관리 (ErrorHandler.ts)
- Argument Parsing: 통합 인수 처리 (ArgumentParser.ts)

구현 통계
- 총 명령어 수: 13개 핵심 명령어
- NPM 스크립트: 25+ 편의 스크립트
- 지원 언어: 영어, 한국어
- 파일 처리: Markdown → Priority JSON → Templates → LLMS
- 코드 축소: 2000줄에서 200줄 핵심 구현으로 최적화

전체 명령어 참조

프로젝트 초기화

init - 완전한 프로젝트 설정
전체 발견 및 설정과 함께 새 프로젝트에서 LLMS Generator를 초기화합니다.

===================[ DOC: ko/guide/llms-cli-comprehensive-reference.md ]===================
# guide--llms-cli-comprehensive-reference

LLMS Generator CLI - 종합 구현 참조서

LLMS Generator 시스템의 모든 구현된 CLI 명령어와 기능에 대한 완전한 문서입니다. 개요

LLMS Generator CLI는 다국어 문서 관리, 우선순위 시스템, 자동화된 템플릿 생성을 위한 종합적인 도구 모음을 제공합니다.

===================[ DOC: ko/guide/llms-cli-comprehensive-reference.md ]===================
# guide--llms-cli-comprehensive-reference

LLMS Generator CLI - 종합 구현 참조서

LLMS Generator 시스템의 모든 구현된 CLI 명령어와 기능에 대한 완전한 문서입니다. 개요

LLMS Generator CLI는 다국어 문서 관리, 우선순위 시스템, 자동화된 템플릿 생성을 위한 종합적인 도구 모음을 제공합니다. 이 문서는 구현된 모든 기능, 명령어, 워크플로우를 다룹니다. 아키텍처

핵심 구성 요소
- Command Router: 중앙 명령 디스패치 시스템 (/src/cli/index.ts)
- Command Implementations: /src/cli/commands/의 개별 명령 클래스들
- Configuration Management: EnhancedLLMSConfig를 사용한 향상된 설정 시스템
- Help System: 대화형 도움말 표시 (HelpDisplay.ts)
- Error Handling: 중앙화된 오류 관리 (ErrorHandler.ts)
- Argument Parsing: 통합 인수 처리 (ArgumentParser.ts)

구현 통계
- 총 명령어 수: 13개 핵심 명령어
- NPM 스크립트: 25+ 편의 스크립트
- 지원 언어: 영어, 한국어
- 파일 처리: Markdown → Priority JSON → Templates → LLMS
- 코드 축소: 2000줄에서 200줄 핵심 구현으로 최적화

전체 명령어 참조

프로젝트 초기화

init - 완전한 프로젝트 설정
전체 발견 및 설정과 함께 새 프로젝트에서 LLMS Generator를 초기화합니다. 구현: InitCommand.ts
NPM 스크립트: pnpm llms:init

옵션:
- --dry-run: 변경사항을 만들지 않고 초기화 미리보기
- --overwrite: 기존 설정 및 우선순위 파일 덮어쓰기
- --quiet: 상세 출력 억제
- --skip-priority: priority.json 파일 생성 건너뛰기
- --skip-templates: 템플릿 파일 생성 건너뛰기
- -l, --language <lang>: 기본 언어 설정 (en, ko)

처리 단계:
1. 문서 발견: docs/ 디렉토리에서 모든 .md 파일 스캔
2. 우선순위 생성: 메타데이터 분석으로 priority.json 파일 생성
3. 템플릿 생성: 모든 글자 수 제한에 대한 템플릿 파일 생성
4. 설정 구성: llms-generator.config.json 생성 또는 업데이트

출력 예시:

워크플로우 관리

work-next - 우선순위 기반 작업 큐
다음에 작업할 문서 항목을 찾거나 상위 N개 우선순위 문서를 표시합니다. 구현: WorkNextCommand.ts
NPM 스크립트: 
- pnpm llms:work-next
- pnpm llms:work-top10
- pnpm llms:work-top20

옵션:
- -l, --language <lang>: 언어별 필터링 (en, ko)
- --show-completed: 결과에 완료된 항목 포함
- -v, --verbose: 우선순위 점수를 포함한 상세 정보 표시
- -n, --limit <number> / --top <number>: 상위 N개 우선순위 문서 표시
- --sort-by <field>: priority (기본값), category, status, modified로 정렬
- --category <cat>: 특정 카테고리별 필터링
- -c, --character-limit <num>: 글자 수 제한별 필터링

출력 형식:

우선순위 관리 시스템

priority-stats - 우선순위 분포 분석
모든 문서에 걸친 종합적인 우선순위 분포 통계를 표시합니다.

===================[ DOC: ko/guide/llms-cli-comprehensive-reference.md ]===================
# guide--llms-cli-comprehensive-reference

LLMS Generator CLI - 종합 구현 참조서

LLMS Generator 시스템의 모든 구현된 CLI 명령어와 기능에 대한 완전한 문서입니다. 개요

LLMS Generator CLI는 다국어 문서 관리, 우선순위 시스템, 자동화된 템플릿 생성을 위한 종합적인 도구 모음을 제공합니다. 이 문서는 구현된 모든 기능, 명령어, 워크플로우를 다룹니다.

===================[ DOC: ko/guide/llms-cli-comprehensive-reference.md ]===================
# guide--llms-cli-comprehensive-reference

LLMS Generator CLI - 종합 구현 참조서

LLMS Generator 시스템의 모든 구현된 CLI 명령어와 기능에 대한 완전한 문서입니다. 개요

LLMS Generator CLI는 다국어 문서 관리, 우선순위 시스템, 자동화된 템플릿 생성을 위한 종합적인 도구 모음을 제공합니다. 이 문서는 구현된 모든 기능, 명령어, 워크플로우를 다룹니다.

===================[ DOC: ko/guide/llms-cli-comprehensive-reference.md ]===================
# guide--llms-cli-comprehensive-reference

LLMS Generator CLI - 종합 구현 참조서

LLMS Generator 시스템의 모든 구현된 CLI 명령어와 기능에 대한 완전한 문서입니다. 개요

LLMS Generator CLI는 다국어 문서 관리, 우선순위 시스템, 자동화된 템플릿 생성을 위한 종합적인 도구 모음을 제공합니다. 이 문서는 구현된 모든 기능, 명령어, 워크플로우를 다룹니다. 아키텍처

핵심 구성 요소
- Command Router: 중앙 명령 디스패치 시스템 (/src/cli/index.ts)
- Command Implementations: /src/cli/commands/의 개별 명령 클래스들
- Configuration Management: EnhancedLLMSConfig를 사용한 향상된 설정 시스템
- Help System: 대화형 도움말 표시 (HelpDisplay.ts)
- Error Handling: 중앙화된 오류 관리 (ErrorHandler.ts)
- Argument Parsing: 통합 인수 처리 (ArgumentParser.ts)

구현 통계
- 총 명령어 수: 13개 핵심 명령어
- NPM 스크립트: 25+ 편의 스크립트
- 지원 언어: 영어, 한국어
- 파일 처리: Markdown → Priority JSON → Templates → LLMS
- 코드 축소: 2000줄에서 200줄 핵심 구현으로 최적화

전체 명령어 참조

프로젝트 초기화

init - 완전한 프로젝트 설정
전체 발견 및 설정과 함께 새 프로젝트에서 LLMS Generator를 초기화합니다. 구현: InitCommand.ts
NPM 스크립트: pnpm llms:init

옵션:
- --dry-run: 변경사항을 만들지 않고 초기화 미리보기
- --overwrite: 기존 설정 및 우선순위 파일 덮어쓰기
- --quiet: 상세 출력 억제
- --skip-priority: priority.json 파일 생성 건너뛰기
- --skip-templates: 템플릿 파일 생성 건너뛰기
- -l, --language <lang>: 기본 언어 설정 (en, ko)

처리 단계:
1. 문서 발견: docs/ 디렉토리에서 모든 .md 파일 스캔
2. 우선순위 생성: 메타데이터 분석으로 priority.json 파일 생성
3. 템플릿 생성: 모든 글자 수 제한에 대한 템플릿 파일 생성
4. 설정 구성: llms-generator.config.json 생성 또는 업데이트

출력 예시:

워크플로우 관리

work-next - 우선순위 기반 작업 큐
다음에 작업할 문서 항목을 찾거나 상위 N개 우선순위 문서를 표시합니다. 구현: WorkNextCommand.ts
NPM 스크립트: 
- pnpm llms:work-next
- pnpm llms:work-top10
- pnpm llms:work-top20

옵션:
- -l, --language <lang>: 언어별 필터링 (en, ko)
- --show-completed: 결과에 완료된 항목 포함
- -v, --verbose: 우선순위 점수를 포함한 상세 정보 표시
- -n, --limit <number> / --top <number>: 상위 N개 우선순위 문서 표시
- --sort-by <field>: priority (기본값), category, status, modified로 정렬
- --category <cat>: 특정 카테고리별 필터링
- -c, --character-limit <num>: 글자 수 제한별 필터링

출력 형식:

우선순위 관리 시스템

priority-stats - 우선순위 분포 분석
모든 문서에 걸친 종합적인 우선순위 분포 통계를 표시합니다. 구현: PriorityManagerCommand.ts
NPM 스크립트: pnpm priority

출력 포함 사항:
- 총 문서 수 및 평균 우선순위 점수
- 우선순위 등급별 분포 (Critical: 90-100, High: 75-89, Medium: 50-74, Low: 0-49)
- 카테고리 및 언어별 분석
- 통계적 지표 (범위, 표준편차, 사분위수)
- 건강 지표 및 추세 분석

샘플 출력:

priority-health - 우선순위 시스템 건강 점검
우선순위 일관성을 평가하고 시스템적 문제를 식별합니다. 구현: PriorityManagerCommand.ts
NPM 스크립트: pnpm llms:priority-health

건강 점수 시스템:
- 우수 (85-100): 균형 잡히고 일관된 우선순위
- 양호 (70-84): 경미한 불일치, 쉽게 해결 가능  
- 보통 (50-69): 주목할 만한 문제, 주의 필요
- 불량 (0-49): 즉시 조치가 필요한 심각한 문제

평가 요소:
- 우선순위 분포 균형
- 카테고리 일관성
- 언어 균등성
- 이상치 탐지
- 시간적 일관성
- 콘텐츠-우선순위 정렬

priority-suggest - 지능형 권장사항
우선순위 시스템 개선을 위한 실행 가능한 권장사항을 제공합니다. 구현: PriorityManagerCommand.ts
NPM 스크립트: pnpm llms:priority-suggest

제안 카테고리:
- 우선순위 재조정 권장사항
- 콘텐츠 격차 식별
- 카테고리 표준화 제안
- 언어 균등성 개선사항
- 템플릿 완료 우선순위

priority-auto - 자동화된 우선순위 재계산
설정 가능한 기준에 따라 우선순위를 자동으로 재계산합니다. 구현: PriorityManagerCommand.ts
NPM 스크립트: pnpm llms:priority-auto

기본 기준 가중치:
- 문서 크기: 40%
- 카테고리 중요도: 30%
- 키워드 밀도: 20%
- 관계 복잡성: 10%

priority-tasks - 우선순위 파일 관리
priority.json 파일 자체를 관리하고 분석 - 누락되거나 오래되거나 잘못된 우선순위 파일을 찾습니다. 구현: PriorityTasksCommand.ts
NPM 스크립트: 
- pnpm llms:priority-tasks
- pnpm llms:priority-tasks:fix

작업 유형:
- 🔴 missing: 문서에 대한 priority.json 파일이 누락됨
- ❌ invalid: JSON 구문 오류 또는 필수 필드 누락
- 🟡 outdated: priority.json 이후에 소스 문서가 수정됨
- 🟠 needsreview: 우선순위 점수가 카테고리 기준과 맞지 않음  
- 🔵 needsupdate: 메타데이터가 불완전하거나 개선이 필요함

옵션:
- -l, --language <lang>: 언어별 필터링
- --category <cat>: 카테고리별 필터링
- --task-type <type>: 특정 작업 유형별 필터링
- -n, --limit <num>: 결과 수 제한
- -v, --verbose: 상세 정보 표시
- --fix: 감지된 문제 자동 수정
- --dry-run: 변경사항을 만들지 않고 미리보기

자동 수정 기능:
- 누락된 파일: 계산된 점수로 priority.json 생성
- 잘못된 JSON: 구문 오류 수정, 누락된 필수 필드 추가
- 오래된 파일: 타임스탬프 및 메타데이터 업데이트
- 검토 문제: 우선순위 점수 조정 제안
- 업데이트 작업: 메타데이터 완성도 향상

문서 처리

sync-docs - 문서 동기화
변경된 문서 파일을 자동으로 처리하고 우선순위 메타데이터와 함께 템플릿을 생성합니다. 구현: SyncDocsCommand.ts
NPM 스크립트: 
- pnpm llms:sync-docs
- pnpm llms:sync-docs:ko
- pnpm llms:sync-docs:en  
- pnpm llms:sync-docs:dry

옵션:
- --changed-files <files>: 쉼표로 구분된 변경된 마크다운 파일 목록
- --only-korean: 한국어 문서만 처리 🇰🇷
- --only-english: 영어 문서만 처리 🇺🇸
- --languages <langs>: 특정 쉼표로 구분된 언어 처리
- --include-korean / --no-korean: 한국어 문서 처리 제어
- --dry-run: 수정하지 않고 변경사항 미리보기
- --force: 최소 변경사항이 감지되어도 강제 업데이트
- --quiet: 자동화를 위한 상세 출력 억제

처리 워크플로우:
1. 파일 분석: 파일 경로 패턴에서 언어 감지
2. 변경 감지: 기존 priority.json 타임스탬프와 비교
3. 우선순위 계산: 우선순위 점수를 위한 콘텐츠 분석
4. 템플릿 생성: 글자 수 제한 템플릿 생성
5. 메타데이터 업데이트: 새로운 정보로 priority.json 업데이트

generate-templates - 템플릿 생성 시스템
기존 문서에 대한 글자 수 제한 템플릿을 생성합니다. 구현: GenerateTemplatesCommand.ts
NPM 스크립트: pnpm llms:generate-templates

옵션:
- -l, --language <lang>: 대상 언어 (en, ko)
- --category <category>: 특정 문서 카테고리
- --character-limits <limits>: 쉼표로 구분된 글자 수 제한
- --overwrite: 기존 템플릿 덮어쓰기
- --dry-run: 파일 생성 없이 미리보기
- -v, --verbose: 파일 경로가 포함된 상세 출력

템플릿 유형:
- 표준 템플릿: 100, 200, 300, 500, 1000, 2000, 5000 글자 수 제한
- 사용자 정의 제한: 사용자 구성 가능한 글자 수 제한
- 콘텐츠 보존: 소스 형식 및 구조 유지
- 메타데이터 통합: 우선순위 및 카테고리 정보 포함

LLMS 생성

llms-generate - 표준 LLMS 파일 생성
학습 목적을 위해 메타데이터가 포함된 표준 LLMS 파일을 생성합니다.

===================[ DOC: ko/guide/llms-cli-reference.md ]===================
# guide--llms-cli-reference

LLMS Generator CLI 명령어 참조

다국어 문서 처리 기능을 포함한 LLMS Generator CLI 시스템의 완전한 명령어 참조서입니다.

===================[ DOC: ko/guide/llms-cli-reference.md ]===================
# guide--llms-cli-reference

LLMS Generator CLI 명령어 참조

다국어 문서 처리 기능을 포함한 LLMS Generator CLI 시스템의 완전한 명령어 참조서입니다. ::: tip 📖 종합 구현 참조서
모든 CLI 기능, 아키텍처 세부사항, 고급 워크플로우를 다루는 상세한 구현 문서는 종합 구현 참조서를 참조하세요. :::

핵심 명령어

문서 처리

sync-docs

변경된 문서 파일을 자동으로 처리하고 우선순위 메타데이터와 함께 템플릿을 생성합니다. 옵션:
- --changed-files <files>: 쉼표로 구분된 변경된 마크다운 파일 목록
- --only-korean: 한국어 문서만 처리 🇰🇷
- --only-english: 영어 문서만 처리 🇺🇸
- --languages <langs>: 쉼표로 구분된 특정 언어들 처리
- --include-korean / --no-korean: 한국어 문서 처리 제어
- --dry-run: 수정 없이 변경사항 미리보기
- --force: 최소 변경사항이라도 강제 업데이트
- --quiet: 상세 출력 억제

generate-templates

기존 문서에 대한 글자 수 제한 템플릿을 생성합니다. 옵션:
- -l, --language <lang>: 대상 언어 (en, ko)
- --category <category>: 특정 문서 카테고리
- --character-limits <limits>: 쉼표로 구분된 글자 수 제한
- --overwrite: 기존 템플릿 덮어쓰기
- --dry-run: 파일 생성 없이 미리보기
- -v, --verbose: 상세 출력

우선순위 관리

priority-stats

포괄적인 우선순위 분포 통계를 표시합니다.

===================[ DOC: ko/guide/llms-cli-reference.md ]===================
# guide--llms-cli-reference

LLMS Generator CLI 명령어 참조

다국어 문서 처리 기능을 포함한 LLMS Generator CLI 시스템의 완전한 명령어 참조서입니다. ::: tip 📖 종합 구현 참조서
모든 CLI 기능, 아키텍처 세부사항, 고급 워크플로우를 다루는 상세한 구현 문서는 종합 구현 참조서를 참조하세요.

===================[ DOC: ko/guide/llms-cli-reference.md ]===================
# guide--llms-cli-reference

LLMS Generator CLI 명령어 참조

다국어 문서 처리 기능을 포함한 LLMS Generator CLI 시스템의 완전한 명령어 참조서입니다. ::: tip 📖 종합 구현 참조서
모든 CLI 기능, 아키텍처 세부사항, 고급 워크플로우를 다루는 상세한 구현 문서는 종합 구현 참조서를 참조하세요. :::

핵심 명령어

문서 처리

sync-docs

변경된 문서 파일을 자동으로 처리하고 우선순위 메타데이터와 함께 템플릿을 생성합니다. 옵션:
- --changed-files <files>: 쉼표로 구분된 변경된 마크다운 파일 목록
- --only-korean: 한국어 문서만 처리 🇰🇷
- --only-english: 영어 문서만 처리 🇺🇸
- --languages <langs>: 쉼표로 구분된 특정 언어들 처리
- --include-korean / --no-korean: 한국어 문서 처리 제어
- --dry-run: 수정 없이 변경사항 미리보기
- --force: 최소 변경사항이라도 강제 업데이트
- --quiet: 상세 출력 억제

generate-templates

기존 문서에 대한 글자 수 제한 템플릿을 생성합니다. 옵션:
- -l, --language <lang>: 대상 언어 (en, ko)
- --category <category>: 특정 문서 카테고리
- --character-limits <limits>: 쉼표로 구분된 글자 수 제한
- --overwrite: 기존 템플릿 덮어쓰기
- --dry-run: 파일 생성 없이 미리보기
- -v, --verbose: 상세 출력

우선순위 관리

priority-stats

포괄적인 우선순위 분포 통계를 표시합니다. 출력 내용:
- 총 문서 수 및 평균 우선순위 점수
- 우선순위 등급별 분포 (critical, high, medium, low)
- 카테고리 및 언어별 세분화
- 통계적 지표 (범위, 표준편차)

priority-health

우선순위 일관성을 평가하고 문제점을 식별합니다. 건강도 점수:
- 우수 (85-100): 균형 잡히고 일관된 우선순위
- 양호 (70-84): 경미한 불일치, 쉽게 해결 가능
- 보통 (50-69): 주목할 만한 문제, 개선 필요
- 불량 (0-49): 심각한 문제, 즉시 조치 필요

priority-suggest

현재 상태를 기반으로 실행 가능한 권고사항을 제공합니다. priority-auto

정의된 기준에 따라 우선순위를 자동으로 재계산합니다. 프로젝트 관리

init

새 프로젝트에서 LLMS Generator를 초기화합니다. 옵션:
- --dry-run: 변경 없이 초기화 미리보기
- --overwrite: 기존 설정 덮어쓰기
- --quiet: 출력 억제
- --skip-priority: 우선순위 파일 생성 건너뛰기
- --skip-templates: 템플릿 생성 건너뛰기
- -l, --language <lang>: 기본 언어 설정

work-next

우선순위를 기반으로 다음에 작업할 문서 항목을 찾거나 상위 N개 우선순위 문서를 표시합니다.

===================[ DOC: ko/guide/llms-cli-reference.md ]===================
# guide--llms-cli-reference

LLMS Generator CLI 명령어 참조

다국어 문서 처리 기능을 포함한 LLMS Generator CLI 시스템의 완전한 명령어 참조서입니다. ::: tip 📖 종합 구현 참조서
모든 CLI 기능, 아키텍처 세부사항, 고급 워크플로우를 다루는 상세한 구현 문서는 종합 구현 참조서를 참조하세요. :::

핵심 명령어

문서 처리

sync-docs

변경된 문서 파일을 자동으로 처리하고 우선순위 메타데이터와 함께 템플릿을 생성합니다.

===================[ DOC: ko/guide/llms-cli-reference.md ]===================
# guide--llms-cli-reference

LLMS Generator CLI 명령어 참조

다국어 문서 처리 기능을 포함한 LLMS Generator CLI 시스템의 완전한 명령어 참조서입니다. ::: tip 📖 종합 구현 참조서
모든 CLI 기능, 아키텍처 세부사항, 고급 워크플로우를 다루는 상세한 구현 문서는 종합 구현 참조서를 참조하세요. :::

핵심 명령어

문서 처리

sync-docs

변경된 문서 파일을 자동으로 처리하고 우선순위 메타데이터와 함께 템플릿을 생성합니다.

===================[ DOC: ko/guide/llms-cli-reference.md ]===================
# guide--llms-cli-reference

LLMS Generator CLI 명령어 참조

다국어 문서 처리 기능을 포함한 LLMS Generator CLI 시스템의 완전한 명령어 참조서입니다. ::: tip 📖 종합 구현 참조서
모든 CLI 기능, 아키텍처 세부사항, 고급 워크플로우를 다루는 상세한 구현 문서는 종합 구현 참조서를 참조하세요. :::

핵심 명령어

문서 처리

sync-docs

변경된 문서 파일을 자동으로 처리하고 우선순위 메타데이터와 함께 템플릿을 생성합니다. 옵션:
- --changed-files <files>: 쉼표로 구분된 변경된 마크다운 파일 목록
- --only-korean: 한국어 문서만 처리 🇰🇷
- --only-english: 영어 문서만 처리 🇺🇸
- --languages <langs>: 쉼표로 구분된 특정 언어들 처리
- --include-korean / --no-korean: 한국어 문서 처리 제어
- --dry-run: 수정 없이 변경사항 미리보기
- --force: 최소 변경사항이라도 강제 업데이트
- --quiet: 상세 출력 억제

generate-templates

기존 문서에 대한 글자 수 제한 템플릿을 생성합니다. 옵션:
- -l, --language <lang>: 대상 언어 (en, ko)
- --category <category>: 특정 문서 카테고리
- --character-limits <limits>: 쉼표로 구분된 글자 수 제한
- --overwrite: 기존 템플릿 덮어쓰기
- --dry-run: 파일 생성 없이 미리보기
- -v, --verbose: 상세 출력

우선순위 관리

priority-stats

포괄적인 우선순위 분포 통계를 표시합니다. 출력 내용:
- 총 문서 수 및 평균 우선순위 점수
- 우선순위 등급별 분포 (critical, high, medium, low)
- 카테고리 및 언어별 세분화
- 통계적 지표 (범위, 표준편차)

priority-health

우선순위 일관성을 평가하고 문제점을 식별합니다. 건강도 점수:
- 우수 (85-100): 균형 잡히고 일관된 우선순위
- 양호 (70-84): 경미한 불일치, 쉽게 해결 가능
- 보통 (50-69): 주목할 만한 문제, 개선 필요
- 불량 (0-49): 심각한 문제, 즉시 조치 필요

priority-suggest

현재 상태를 기반으로 실행 가능한 권고사항을 제공합니다. priority-auto

정의된 기준에 따라 우선순위를 자동으로 재계산합니다. 프로젝트 관리

init

새 프로젝트에서 LLMS Generator를 초기화합니다. 옵션:
- --dry-run: 변경 없이 초기화 미리보기
- --overwrite: 기존 설정 덮어쓰기
- --quiet: 출력 억제
- --skip-priority: 우선순위 파일 생성 건너뛰기
- --skip-templates: 템플릿 생성 건너뛰기
- -l, --language <lang>: 기본 언어 설정

work-next

우선순위를 기반으로 다음에 작업할 문서 항목을 찾거나 상위 N개 우선순위 문서를 표시합니다. 옵션:
- -l, --language <lang>: 언어별 필터링
- --show-completed: 완료된 항목 포함
- -v, --verbose: 상세 정보 표시
- -n, --limit <number> / --top <number>: 상위 N개 우선순위 문서 표시
- --sort-by <field>: 정렬 기준 (priority 기본값, category, status, modified)
- --category <cat>: 카테고리별 필터링
- -c, --character-limit <num>: 글자 수 제한별 필터링

예시:

우선순위 관리 명령어

priority-tasks

priority.json 파일 자체를 관리하고 분석 - 누락되거나 오래되거나 잘못된 우선순위 파일 찾기

옵션:
- -l, --language <lang>: 언어별 필터링
- --category <cat>: 카테고리별 필터링
- --task-type <type>: 작업 유형별 필터링 (missing, invalid, outdated, needsreview, needsupdate)
- -n, --limit <num>: 결과 수 제한
- -v, --verbose: 상세 정보 표시
- --fix: 감지된 문제 자동 수정
- --dry-run: 변경사항 미리보기 (실제 수정하지 않음)

작업 유형:
- 🔴 missing: priority.json 파일이 없음
- ❌ invalid: JSON 구문 오류 또는 필수 필드 누락
- 🟡 outdated: priority.json 이후에 소스 문서가 수정됨
- 🟠 needsreview: 우선순위 점수가 카테고리 기준과 맞지 않음
- 🔵 needsupdate: 메타데이터가 불완전하거나 개선이 필요함

예시:

추가 우선순위 명령어

- priority-stats: 우선순위 분포 통계 표시
- priority-health: 우선순위 일관성 및 건강도 확인 (0-100 점수)
- priority-suggest: 개선 권고사항 제공
- priority-auto: 사용자 정의 기준으로 우선순위 자동 재계산

고급 기능

언어 처리 매트릭스

| 명령어 | 한국어 지원 | 영어 지원 | 다중언어 | 필터링 |
|---------|-------------|-----------|----------|--------|
| sync-docs | ✅ | ✅ | ✅ | ✅ |
| generate-templates | ✅ | ✅ | ✅ | ✅ |
| priority- | ✅ | ✅ | ✅ | ❌ |
| work-next | ✅ | ✅ | ❌ | ✅ |

자동화 워크플로우

Post-commit 훅

문서 파일 변경 시 자동으로 실행됩니다:

기능:
- docs/(en|ko)//.md 패턴의 변경사항 감지
- 7개 글자 수 제한 템플릿 생성 (100, 200, 300, 500, 1000, 2000, 5000)
- 메타데이터가 포함된 priority.json 생성
- 소스 변경사항과 별도로 LLMS 파일 커밋
- 향상된 디버깅 및 오류 처리

NPM 스크립트

설정

환경 설정

시스템은 사용자 정의 동작을 위한 설정 파일을 준수합니다:

사용자 정의 우선순위 기준

자동 우선순위 계산을 위한 사용자 정의 기준 파일 생성:

모범 사례

언어별 워크플로우

한국어 문서:

영어 문서:

팀 협업

일일 워크플로우:

주간 유지보수:

오류 처리

일반적인 문제

언어 처리 오류:
- 파일 경로가 docs/(en|ko)//.md 패턴과 일치하는지 확인
- 언어 필터링 옵션이 올바르게 지정되었는지 확인
- pnpm build:llms-generator로 LLMS Generator가 빌드되었는지 확인

우선순위 불일치:
- pnpm llms:priority-health를 실행하여 문제 식별
- 대량 재계산을 위해 pnpm llms:priority-auto --force 사용
- 사용자 정의 기준 파일의 올바른 JSON 형식 검토

템플릿 생성 실패:
- 소스 문서 형식 및 구조 확인
- 글자 수 제한에 충분한 내용 확인
- llmsData/ 생성을 위한 디렉토리 권한 확인

디버그 모드

상세한 디버깅 출력 활성화:

::: tip 다음 단계
- post-commit 훅으로 자동화 워크플로우 설정
- 팀을 위한 언어별 처리 구성
- 정기적인 우선순위 건강도 모니터링 수립
- 문서 품질 게이트를 위한 CI/CD 파이프라인 통합
:::

::: warning 중요 사항
- 언어 필터링은 항상 --dry-run으로 먼저 테스트
- 대량 변경 후 우선순위 건강도 점수 모니터링
- 팀 구성원과 언어 처리 설정 조율
- 최신 기능을 위해 LLMS Generator 빌드를 최신 상태로 유지
:::.

===================[ DOC: ko/guide/priority-management.md ]===================
# guide--priority-management

우선순위 관리 시스템

우선순위 관리 시스템은 LLMS Generator 프레임워크에서 문서 우선순위를 자동으로 분석, 유지 및 최적화하는 도구를 제공합니다.

===================[ DOC: ko/guide/priority-management.md ]===================
# guide--priority-management

우선순위 관리 시스템

우선순위 관리 시스템은 LLMS Generator 프레임워크에서 문서 우선순위를 자동으로 분석, 유지 및 최적화하는 도구를 제공합니다. 개요

문제 정의

기존 문서 관리 방식의 한계점:
- 수동 우선순위 할당: 주관적 평가로 인한 일관성 부족
- 팀 협업 어려움: 누가 무엇을 작업 중인지 파악 곤란
- 우선순위 표류: 체계적 검토 없이 우선순위가 구식화
- 확장성 문제: 수동 관리는 문서 증가에 대응 불가

솔루션 아키텍처

우선순위 관리 시스템이 제공하는 기능:
- 자동화된 분석: 우선순위 분포에 대한 통계적 인사이트
- 건강도 모니터링: 일관성 확인 및 편차 감지
- 스마트 제안: 데이터 기반 개선 권고사항
- 팀 협업: 외부 서버 연동을 위한 기반 구조

빠른 시작

기본 명령어

예시 출력

명령어 참조

priority-stats

문서의 우선순위 분포를 분석합니다. 출력 내용:
- 총 문서 수 및 평균 우선순위 점수
- 우선순위 등급별 분포 (critical, high, medium, low)
- 카테고리 및 언어별 세분화
- 통계적 지표 (범위, 표준편차)

priority-health

우선순위 일관성을 평가하고 문제점을 식별합니다. 건강도 점수:
- 우수 (85-100): 균형 잡히고 일관된 우선순위
- 양호 (70-84): 경미한 불일치, 쉽게 해결 가능
- 보통 (50-69): 주목할 만한 문제, 개선 필요
- 불량 (0-49): 심각한 문제, 즉시 조치 필요

감지되는 일반적 문제:
- 높은 우선순위 편차 (표준편차 > 25)
- 모든 문서의 점수가 유사 (범위 < 20)
- 불균등한 카테고리 분포 (편차 > 50)
- 언어간 불일치 (편차 > 30)

priority-suggest

현재 상태를 기반으로 실행 가능한 권고사항을 제공합니다.

===================[ DOC: ko/guide/priority-management.md ]===================
# guide--priority-management

우선순위 관리 시스템

우선순위 관리 시스템은 LLMS Generator 프레임워크에서 문서 우선순위를 자동으로 분석, 유지 및 최적화하는 도구를 제공합니다.

===================[ DOC: ko/guide/priority-management.md ]===================
# guide--priority-management

우선순위 관리 시스템

우선순위 관리 시스템은 LLMS Generator 프레임워크에서 문서 우선순위를 자동으로 분석, 유지 및 최적화하는 도구를 제공합니다. 개요

문제 정의

기존 문서 관리 방식의 한계점:
- 수동 우선순위 할당: 주관적 평가로 인한 일관성 부족
- 팀 협업 어려움: 누가 무엇을 작업 중인지 파악 곤란
- 우선순위 표류: 체계적 검토 없이 우선순위가 구식화
- 확장성 문제: 수동 관리는 문서 증가에 대응 불가

솔루션 아키텍처

우선순위 관리 시스템이 제공하는 기능:
- 자동화된 분석: 우선순위 분포에 대한 통계적 인사이트
- 건강도 모니터링: 일관성 확인 및 편차 감지
- 스마트 제안: 데이터 기반 개선 권고사항
- 팀 협업: 외부 서버 연동을 위한 기반 구조

빠른 시작

기본 명령어

예시 출력

명령어 참조

priority-stats

문서의 우선순위 분포를 분석합니다. 출력 내용:
- 총 문서 수 및 평균 우선순위 점수
- 우선순위 등급별 분포 (critical, high, medium, low)
- 카테고리 및 언어별 세분화
- 통계적 지표 (범위, 표준편차)

priority-health

우선순위 일관성을 평가하고 문제점을 식별합니다. 건강도 점수:
- 우수 (85-100): 균형 잡히고 일관된 우선순위
- 양호 (70-84): 경미한 불일치, 쉽게 해결 가능
- 보통 (50-69): 주목할 만한 문제, 개선 필요
- 불량 (0-49): 심각한 문제, 즉시 조치 필요

감지되는 일반적 문제:
- 높은 우선순위 편차 (표준편차 > 25)
- 모든 문서의 점수가 유사 (범위 < 20)
- 불균등한 카테고리 분포 (편차 > 50)
- 언어간 불일치 (편차 > 30)

priority-suggest

현재 상태를 기반으로 실행 가능한 권고사항을 제공합니다. 제안 내용:
- 불량 건강도 점수에 대한 즉시 조치
- 표준화 권고사항
- 문서별 구체적 가이드
- 개선을 위한 다음 단계

priority-auto

정의된 기준에 따라 우선순위를 자동으로 재계산합니다.

===================[ DOC: ko/guide/priority-management.md ]===================
# guide--priority-management

우선순위 관리 시스템

우선순위 관리 시스템은 LLMS Generator 프레임워크에서 문서 우선순위를 자동으로 분석, 유지 및 최적화하는 도구를 제공합니다.

===================[ DOC: ko/guide/priority-management.md ]===================
# guide--priority-management

우선순위 관리 시스템

우선순위 관리 시스템은 LLMS Generator 프레임워크에서 문서 우선순위를 자동으로 분석, 유지 및 최적화하는 도구를 제공합니다. 개요

문제 정의

기존 문서 관리 방식의 한계점:
- 수동 우선순위 할당: 주관적 평가로 인한 일관성 부족
- 팀 협업 어려움: 누가 무엇을 작업 중인지 파악 곤란
- 우선순위 표류: 체계적 검토 없이 우선순위가 구식화
- 확장성 문제: 수동 관리는 문서 증가에 대응 불가

솔루션 아키텍처

우선순위 관리 시스템이 제공하는 기능:
- 자동화된 분석: 우선순위 분포에 대한 통계적 인사이트
- 건강도 모니터링: 일관성 확인 및 편차 감지
- 스마트 제안: 데이터 기반 개선 권고사항
- 팀 협업: 외부 서버 연동을 위한 기반 구조

빠른 시작

기본 명령어

예시 출력

명령어 참조

priority-stats

문서의 우선순위 분포를 분석합니다.

===================[ DOC: ko/guide/priority-management.md ]===================
# guide--priority-management

우선순위 관리 시스템

우선순위 관리 시스템은 LLMS Generator 프레임워크에서 문서 우선순위를 자동으로 분석, 유지 및 최적화하는 도구를 제공합니다. 개요

문제 정의

기존 문서 관리 방식의 한계점:
- 수동 우선순위 할당: 주관적 평가로 인한 일관성 부족
- 팀 협업 어려움: 누가 무엇을 작업 중인지 파악 곤란
- 우선순위 표류: 체계적 검토 없이 우선순위가 구식화
- 확장성 문제: 수동 관리는 문서 증가에 대응 불가

솔루션 아키텍처

우선순위 관리 시스템이 제공하는 기능:
- 자동화된 분석: 우선순위 분포에 대한 통계적 인사이트
- 건강도 모니터링: 일관성 확인 및 편차 감지
- 스마트 제안: 데이터 기반 개선 권고사항
- 팀 협업: 외부 서버 연동을 위한 기반 구조

빠른 시작

기본 명령어

예시 출력

명령어 참조

priority-stats

문서의 우선순위 분포를 분석합니다. 출력 내용:
- 총 문서 수 및 평균 우선순위 점수
- 우선순위 등급별 분포 (critical, high, medium, low)
- 카테고리 및 언어별 세분화
- 통계적 지표 (범위, 표준편차)

priority-health

우선순위 일관성을 평가하고 문제점을 식별합니다. 건강도 점수:
- 우수 (85-100): 균형 잡히고 일관된 우선순위
- 양호 (70-84): 경미한 불일치, 쉽게 해결 가능
- 보통 (50-69): 주목할 만한 문제, 개선 필요
- 불량 (0-49): 심각한 문제, 즉시 조치 필요

감지되는 일반적 문제:
- 높은 우선순위 편차 (표준편차 > 25)
- 모든 문서의 점수가 유사 (범위 < 20)
- 불균등한 카테고리 분포 (편차 > 50)
- 언어간 불일치 (편차 > 30)

priority-suggest

현재 상태를 기반으로 실행 가능한 권고사항을 제공합니다. 제안 내용:
- 불량 건강도 점수에 대한 즉시 조치
- 표준화 권고사항
- 문서별 구체적 가이드
- 개선을 위한 다음 단계

priority-auto

정의된 기준에 따라 우선순위를 자동으로 재계산합니다. 옵션:
- --criteria <file>: 사용자 정의 기준 JSON 파일 경로
- --force: 최소 변경사항이라도 모든 우선순위 업데이트
- --quiet: 상세 출력 억제

기본 기준:
- 문서 크기 (40% 가중치)
- 카테고리 중요도 (30% 가중치)
- 키워드 밀도 (20% 가중치)
- 상호 참조 (10% 가중치)

다국어 문서 처리

시스템에서 고급 언어 필터링을 통한 문서 처리를 지원합니다:

언어 필터링 옵션:
- --only-korean: 한국어 문서만 처리 🇰🇷
- --only-english: 영어 문서만 처리 🇺🇸
- --languages ko,en: 쉼표로 구분된 특정 언어들 처리
- --include-korean / --no-korean: 한국어 문서 처리 제어
- --quiet: 상세한 언어 처리 출력 억제

우선순위 건강도 지표

분포 분석

편차 지표:
- 표준편차: 우선순위 점수 분산 측정
- 카테고리 균형: 문서 유형별 균등 분포
- 언어 일관성: 언어 버전 간 유사한 우선순위

건강도 기준:

일관성 확인

자동 감지:
- 우선순위 점수가 너무 유사 (차별화 < 20점)
- 극단적 편차 (표준편차 > 25)
- 카테고리 불균형 (한 카테고리가 전체의 60% 초과)
- 언어간 차이 (EN/KO 버전 간 30% 초과 편차)

워크플로우 통합

일일 워크플로우

주간 유지보수

팀 협업

현재 상태 (로컬):
- 개인별 우선순위 분석
- 로컬 일관성 확인
- 개인 워크플로우 최적화
- 언어별 필터링을 통한 다국어 문서 처리

향후 상태 (팀 통합):
- 공유 우선순위 서버
- 실시간 작업 상태 추적
- 팀 전체 일관성 강제
- 중앙화된 다국어 문서 협업

설정

사용자 정의 우선순위 기준

자동 계산 사용자 정의를 위한 기준 파일 생성:

사용법:

환경 설정

우선순위 관리는 LLMS Generator 설정을 준수합니다:

모범 사례

우선순위 할당 가이드라인

점수 범위:
- 90-100 (Critical): 핵심 프레임워크 개념, 시작 가이드
- 80-89 (High): 중요한 기능, 일반적 사용 사례
- 60-79 (Medium): 고급 기능, 특정 시나리오
- 40-59 (Low): 경계 사례, 실험적 기능
- 0-39 (Minimal): 폐기 예정 또는 드물게 사용되는 내용

카테고리 우선순위:
- Guides: 일반적으로 높은 우선순위 (80-95)
- Concepts: 중간에서 높은 우선순위 (70-90)
- Examples: 중간 우선순위 (60-80)
- Reference: 사용량에 따라 가변 (40-90)

일관성 유지

정기 검토:
- 주간 건강도 확인
- 표준편차 추세 모니터링
- 카테고리 불균형 즉시 해결
- 언어 버전 동기화 유지

품질 지표:
- 표준편차 < 20 (우수한 분포)
- 어떤 카테고리도 전체의 50% 미만
- 언어 버전 간 10% 이내 편차
- 우선순위 등급 간 명확한 차별화

팀 협업

협업 전략:
- 팀 우선순위 가이드라인 수립
- 정기 우선순위 검토 미팅
- 자동 계산을 기준선으로 활용
- 우선순위 결정 근거 문서화

의사소통:
- 우선순위 건강도 리포트 공유
- 팀 미팅에서 편차 문제 논의
- 카테고리 중요도 가중치 합의
- 주요 우선순위 조정 조율

고급 기능

향후 개선사항

2단계: 팀 협업
- 작업 상태 추적 (work-claim, work-status, work-release)
- 실시간 협업 충돌 방지
- 팀 작업량 균형 조정
- 진행상황 대시보드

3단계: 외부 통합
- 우선순위 서버 동기화
- 웹 기반 관리 인터페이스
- GitHub Issues 통합
- 분석 기반 자동 우선순위 업데이트

4단계: AI 기반 최적화
- 머신러닝 우선순위 제안
- 사용자 행동 패턴 분석
- 계절적 트렌드 적응
- 자동 카테고리 재균형

통합 지점

현재 통합:
- LLMS Generator work-next 명령어
- Priority.json 메타데이터 시스템
- 템플릿 생성 워크플로우

계획된 통합:
- GitHub Issues 우선순위 동기화
- 문서 분석 시스템
- 사용자 피드백 시스템
- CI/CD 파이프라인 통합

트러블슈팅

일반적인 문제

높은 표준편차 (> 25)

카테고리 불균형

언어간 불일치

성능 최적화

대용량 문서 세트:
- 자동화 스크립트에 --quiet 플래그 사용
- 피크 시간 외 분석 실행
- 배치 우선순위 업데이트 고려
- 자동 계산 중 시스템 리소스 모니터링

오류 복구:
- 업데이트 전 우선순위 파일 검증
- 자동 계산 전 원본 백업
- Git 히스토리를 통한 롤백 기능
- 누락된 파일에 대한 우아한 처리

기존 워크플로우와의 통합

Git 훅 통합

post-commit 훅이 문서 변경사항을 자동으로 처리합니다:

수동 처리

CI/CD 통합

::: tip 다음 단계
- pnpm llms:priority-health로 정기 우선순위 건강도 모니터링 설정
- pnpm llms:priority-auto --dry-run으로 자동 계산 탐색
- 우선순위 일관성을 위한 팀 협업 전략 고려
- 외부 우선순위 관리 시스템과의 통합 계획
:::

::: warning 중요 사항
- 대량 업데이트 전 항상 우선순위 파일 백업
- 먼저 --dry-run으로 자동 계산 테스트
- 변경 후 건강도 점수 모니터링
- 팀 구성원과 우선순위 변경 조율
:::.

===================[ DOC: ko/guide/real-time-state-access.md ]===================
# guide--real-time-state-access

실시간 상태 접근 패턴

현재 상태에 실시간으로 접근하여 클로저 함정을 방지하는 패턴입니다.

===================[ DOC: ko/guide/real-time-state-access.md ]===================
# guide--real-time-state-access

실시간 상태 접근 패턴

현재 상태에 실시간으로 접근하여 클로저 함정을 방지하는 패턴입니다. 문제: 클로저 함정

해결책: 실시간 접근

완전한 예제

주요 이점

- 오래된 클로저 없음: 항상 현재 상태에 접근
- 경쟁 조건 방지: 실시간 검사로 충돌 방지
- 성능: 의존성으로 인한 불필요한 리렌더링 방지.

===================[ DOC: ko/guide/real-time-state-access.md ]===================
# guide--real-time-state-access

실시간 상태 접근 패턴

현재 상태에 실시간으로 접근하여 클로저 함정을 방지하는 패턴입니다. 문제: 클로저 함정

해결책: 실시간 접근

완전한 예제

주요 이점

- 오래된 클로저 없음: 항상 현재 상태에 접근
- 경쟁 조건 방지: 실시간 검사로 충돌 방지
- 성능: 의존성으로 인한 불필요한 리렌더링 방지.

===================[ DOC: ko/guide/real-time-state-access.md ]===================
# guide--real-time-state-access

실시간 상태 접근 패턴

현재 상태에 실시간으로 접근하여 클로저 함정을 방지하는 패턴입니다. 문제: 클로저 함정

해결책: 실시간 접근

완전한 예제

주요 이점

- 오래된 클로저 없음: 항상 현재 상태에 접근
- 경쟁 조건 방지: 실시간 검사로 충돌 방지
- 성능: 의존성으로 인한 불필요한 리렌더링 방지.

===================[ DOC: ko/guide/real-time-state-access.md ]===================
# guide--real-time-state-access

실시간 상태 접근 패턴

현재 상태에 실시간으로 접근하여 클로저 함정을 방지하는 패턴입니다. 문제: 클로저 함정

해결책: 실시간 접근

완전한 예제

주요 이점

- 오래된 클로저 없음: 항상 현재 상태에 접근
- 경쟁 조건 방지: 실시간 검사로 충돌 방지
- 성능: 의존성으로 인한 불필요한 리렌더링 방지.

===================[ DOC: ko/guide/real-time-state-access.md ]===================
# guide--real-time-state-access

실시간 상태 접근 패턴

현재 상태에 실시간으로 접근하여 클로저 함정을 방지하는 패턴입니다. 문제: 클로저 함정

해결책: 실시간 접근

완전한 예제

주요 이점

- 오래된 클로저 없음: 항상 현재 상태에 접근
- 경쟁 조건 방지: 실시간 검사로 충돌 방지
- 성능: 의존성으로 인한 불필요한 리렌더링 방지.

===================[ DOC: ko/guide/real-time-state-access.md ]===================
# guide--real-time-state-access

실시간 상태 접근 패턴

현재 상태에 실시간으로 접근하여 클로저 함정을 방지하는 패턴입니다. 문제: 클로저 함정

해결책: 실시간 접근

완전한 예제

주요 이점

- 오래된 클로저 없음: 항상 현재 상태에 접근
- 경쟁 조건 방지: 실시간 검사로 충돌 방지
- 성능: 의존성으로 인한 불필요한 리렌더링 방지.

===================[ DOC: ko/guide/ref-context-setup.md ]===================
# guide--ref-context-setup

RefContext 설정 패턴

적절한 TypeScript 타입으로 RefContext를 설정하는 핵심 패턴입니다.

===================[ DOC: ko/guide/ref-context-setup.md ]===================
# guide--ref-context-setup

RefContext 설정 패턴

적절한 TypeScript 타입으로 RefContext를 설정하는 핵심 패턴입니다. 기본 설정

Provider 통합

Ref 등록.

===================[ DOC: ko/guide/ref-context-setup.md ]===================
# guide--ref-context-setup

RefContext 설정 패턴

적절한 TypeScript 타입으로 RefContext를 설정하는 핵심 패턴입니다. 기본 설정

Provider 통합

Ref 등록.

===================[ DOC: ko/guide/ref-context-setup.md ]===================
# guide--ref-context-setup

RefContext 설정 패턴

적절한 TypeScript 타입으로 RefContext를 설정하는 핵심 패턴입니다. 기본 설정

Provider 통합

Ref 등록.

===================[ DOC: ko/guide/ref-context-setup.md ]===================
# guide--ref-context-setup

RefContext 설정 패턴

적절한 TypeScript 타입으로 RefContext를 설정하는 핵심 패턴입니다. 기본 설정

Provider 통합

Ref 등록.

===================[ DOC: ko/guide/ref-context-setup.md ]===================
# guide--ref-context-setup

RefContext 설정 패턴

적절한 TypeScript 타입으로 RefContext를 설정하는 핵심 패턴입니다. 기본 설정

Provider 통합

Ref 등록.

===================[ DOC: ko/guide/ref-context-setup.md ]===================
# guide--ref-context-setup

RefContext 설정 패턴

적절한 TypeScript 타입으로 RefContext를 설정하는 핵심 패턴입니다. 기본 설정

Provider 통합

Ref 등록.

===================[ DOC: ko/guide/timeout-protection.md ]===================
# guide--timeout-protection

타임아웃 보호 패턴

타임아웃 메커니즘으로 무한 대기를 방지하는 패턴입니다.

===================[ DOC: ko/guide/timeout-protection.md ]===================
# guide--timeout-protection

타임아웃 보호 패턴

타임아웃 메커니즘으로 무한 대기를 방지하는 패턴입니다. 기본 타임아웃 패턴

재시도가 포함된 고급 타임아웃

액션 핸들러에서 사용

에러 복구 패턴.

===================[ DOC: ko/guide/timeout-protection.md ]===================
# guide--timeout-protection

타임아웃 보호 패턴

타임아웃 메커니즘으로 무한 대기를 방지하는 패턴입니다. 기본 타임아웃 패턴

재시도가 포함된 고급 타임아웃

액션 핸들러에서 사용

에러 복구 패턴.

===================[ DOC: ko/guide/timeout-protection.md ]===================
# guide--timeout-protection

타임아웃 보호 패턴

타임아웃 메커니즘으로 무한 대기를 방지하는 패턴입니다. 기본 타임아웃 패턴

재시도가 포함된 고급 타임아웃

액션 핸들러에서 사용

에러 복구 패턴.

===================[ DOC: ko/guide/timeout-protection.md ]===================
# guide--timeout-protection

타임아웃 보호 패턴

타임아웃 메커니즘으로 무한 대기를 방지하는 패턴입니다. 기본 타임아웃 패턴

재시도가 포함된 고급 타임아웃

액션 핸들러에서 사용

에러 복구 패턴.

===================[ DOC: ko/guide/timeout-protection.md ]===================
# guide--timeout-protection

타임아웃 보호 패턴

타임아웃 메커니즘으로 무한 대기를 방지하는 패턴입니다. 기본 타임아웃 패턴

재시도가 포함된 고급 타임아웃

액션 핸들러에서 사용

에러 복구 패턴.

===================[ DOC: ko/guide/timeout-protection.md ]===================
# guide--timeout-protection

타임아웃 보호 패턴

타임아웃 메커니즘으로 무한 대기를 방지하는 패턴입니다. 기본 타임아웃 패턴

재시도가 포함된 고급 타임아웃

액션 핸들러에서 사용

에러 복구 패턴.

===================[ DOC: ko/guide/wait-then-execute.md ]===================
# guide--wait-then-execute

대기 후 실행 패턴

요소 가용성을 보장한 후 안전하게 DOM 조작을 실행하는 패턴입니다. 기본 패턴

고급 예제

액션 핸들러와 함께.

===================[ DOC: ko/guide/wait-then-execute.md ]===================
# guide--wait-then-execute

대기 후 실행 패턴

요소 가용성을 보장한 후 안전하게 DOM 조작을 실행하는 패턴입니다. 기본 패턴

고급 예제

액션 핸들러와 함께.

===================[ DOC: ko/guide/wait-then-execute.md ]===================
# guide--wait-then-execute

대기 후 실행 패턴

요소 가용성을 보장한 후 안전하게 DOM 조작을 실행하는 패턴입니다. 기본 패턴

고급 예제

액션 핸들러와 함께.

===================[ DOC: ko/guide/wait-then-execute.md ]===================
# guide--wait-then-execute

대기 후 실행 패턴

요소 가용성을 보장한 후 안전하게 DOM 조작을 실행하는 패턴입니다. 기본 패턴

고급 예제

액션 핸들러와 함께.

===================[ DOC: ko/guide/wait-then-execute.md ]===================
# guide--wait-then-execute

대기 후 실행 패턴

요소 가용성을 보장한 후 안전하게 DOM 조작을 실행하는 패턴입니다. 기본 패턴

고급 예제

액션 핸들러와 함께.

===================[ DOC: ko/guide/wait-then-execute.md ]===================
# guide--wait-then-execute

대기 후 실행 패턴

요소 가용성을 보장한 후 안전하게 DOM 조작을 실행하는 패턴입니다. 기본 패턴

고급 예제

액션 핸들러와 함께.

===================[ DOC: ko/guide/wait-then-execute.md ]===================
# guide--wait-then-execute

대기 후 실행 패턴

요소 가용성을 보장한 후 안전하게 DOM 조작을 실행하는 패턴입니다. 기본 패턴

고급 예제

액션 핸들러와 함께.

===================[ DOC: llmsData/Users/junwoobang/project/context-action/llmsData/ko/guide/priority-management-100.md ]===================
# Untitled

우선순위 관리 시스템 - 우선순위 관리 시스템 우선순위 관리 시스템은 LLMS Generator 프레임워크에서 문서 우선순위를 자동으로 분석, 유지 및 최적화하는 도구를...

===================[ DOC: llmsData/Users/junwoobang/project/context-action/llmsData/ko/guide/priority-management-1000.md ]===================
# Untitled

우선순위 관리 시스템

우선순위 관리 시스템 우선순위 관리 시스템은 LLMS Generator 프레임워크에서 문서 우선순위를 자동으로 분석, 유지 및 최적화하는 도구를 제공합니다. 개요 문제 정의 기존 문서 관리 방식의 한계점: - 수동 우선순위 할당: 주관적 평가로 인한 일관성 부족 - 팀 협업 어려움: 누가 무엇을 작업 중인지 파악 곤란 - 우선순위 표류: 체계적 검토 없이 우선순위가 구식화 - 확장성 문제: 수동 관리는 문서 증가에 대응 불가 솔루션 아키텍처 우선순위 관리 시스템이 제공하는 기능: - 자동화된 분석: 우선순위 분포에 대한 통계적 인사이트 - 건강도 모니터링: 일관성 확인 및 편차 감지 - 스마트 제안: 데이터 기반 개선 권고사항 - 팀 협업: 외부 서버 연동을 위한 기반 구조 빠른 시작 기본 명령어 예시 출력 명령어 참조 priority-stats 문서의 우선순위 분포를 분석합니다. 출력 내용: - 총 문서 수 및 평균 우선순위 점수 - 우선순위 등급별 분포 (critical, high, medium, low) - 카테고리 및 언어별 세분화 - 통계적 지표 (범위, 표준편차) priority-health 우선순위 일관성을 평가하고 문제점을 식별합니다. 건강도 

Key points:
• **수동 우선순위 할당**: 주관적 평가로 인한 일관성 부족
• **팀 협업 어려움**: 누가 무엇을 작업 중인지 파악 곤란
• **우선순위 표류**: 체계적 검토 없이 우선순위가 구식화
• **확장성 문제**: 수동 관리는 문서 증가에 대응 불가
• **자동화된 분석**: 우선순위 분포에 대한 통계적 인사이트
• **건강도 모니터링**: 일관성 확인 및 편차 감지
• **스마트 제안**: 데이터 기반 개선 권고사항
• **팀 협업**: 외부 서버 연동을 위한 기반 구조
• 총 문서 수 및 평균 우선순위 점수
• 우선순위 등급별 분포 (critical, high, medium, low)

===================[ DOC: llmsData/Users/junwoobang/project/context-action/llmsData/ko/guide/priority-management-200.md ]===================
# Untitled

우선순위 관리 시스템

우선순위 관리 시스템 우선순위 관리 시스템은 LLMS Generator 프레임워크에서 문서 우선순위를 자동으로 분석, 유지 및 최적화하는 도구를 제공합니다. 개요 문제 정의 기존 문서 관리 방식의 한계점: - 수동 우선순위 할당: 주관적 평가로 인한 일관성 부족 - 팀

Key points:
• **수동 우선순위 할당**:...

===================[ DOC: llmsData/Users/junwoobang/project/context-action/llmsData/ko/guide/priority-management-2000.md ]===================
# Untitled

우선순위 관리 시스템

우선순위 관리 시스템 우선순위 관리 시스템은 LLMS Generator 프레임워크에서 문서 우선순위를 자동으로 분석, 유지 및 최적화하는 도구를 제공합니다. 개요 문제 정의 기존 문서 관리 방식의 한계점: - 수동 우선순위 할당: 주관적 평가로 인한 일관성 부족 - 팀 협업 어려움: 누가 무엇을 작업 중인지 파악 곤란 - 우선순위 표류: 체계적 검토 없이 우선순위가 구식화 - 확장성 문제: 수동 관리는 문서 증가에 대응 불가 솔루션 아키텍처 우선순위 관리 시스템이 제공하는 기능: - 자동화된 분석: 우선순위 분포에 대한 통계적 인사이트 - 건강도 모니터링: 일관성 확인 및 편차 감지 - 스마트 제안: 데이터 기반 개선 권고사항 - 팀 협업: 외부 서버 연동을 위한 기반 구조 빠른 시작 기본 명령어 예시 출력 명령어 참조 priority-stats 문서의 우선순위 분포를 분석합니다. 출력 내용: - 총 문서 수 및 평균 우선순위 점수 - 우선순위 등급별 분포 (critical, high, medium, low) - 카테고리 및 언어별 세분화 - 통계적 지표 (범위, 표준편차) priority-health 우선순위 일관성을 평가하고 문제점을 식별합니다. 건강도 점수: - 우수 (85-100): 균형 잡히고 일관된 우선순위 - 양호 (70-84): 경미한 불일치, 쉽게 해결 가능 - 보통 (50-69): 주목할 만한 문제, 개선 필요 - 불량 (0-49): 심각한 문제, 즉시 조치 필요 감지되는 일반적 문제: - 높은 우선순위 편차 (표준편차 > 25) - 모든 문서의 점수가 유사 (범위 < 20) - 불균등한 카테고리 분포 (편차 > 50) - 언어간 불일치 (편차 > 30) priority-suggest 현재 상태를 기반으로 실행 가능한 권고사항을 제공합니다. 제안 내용: - 불량 건강도 점수에 대한 즉시 조치 - 표준화 권고사항 - 문서별 구체적 가이드 - 개선을 위한 다음 단계 priority-auto 정의된 기준에 따라 우선순위를 자동으로 재계산합니다. 옵션: - --criteria <file>: 사용자 정의 기준 JSON 파일 경로 - --force: 최소 변경사항이라도 모든 우선순위 업데이트 - --quiet: 상세 출력 억제 기본 기준: - 문서 크기 (40% 가중치) - 카테고리 중요도 (30% 가중치) - 키워드 밀도 (20% 가중치) - 상호 참조 (10% 가중치) 우선순위 건강도 지표 분포 분석

Key points:
• **수동 우선순위 할당**: 주관적 평가로 인한 일관성 부족
• **팀 협업 어려움**: 누가 무엇을 작업 중인지 파악 곤란
• **우선순위 표류**: 체계적 검토 없이 우선순위가 구식화
• **확장성 문제**: 수동 관리는 문서 증가에 대응 불가
• **자동화된 분석**: 우선순위 분포에 대한 통계적 인사이트
• **건강도 모니터링**: 일관성 확인 및 편차 감지
• **스마트 제안**: 데이터 기반 개선 권고사항
• **팀 협업**: 외부 서버 연동을 위한 기반 구조
• 총 문서 수 및 평균 우선순위 점수
• 우선순위 등급별 분포 (critical, high, medium, low)
• 카테고리 및 언어별 세분화
• 통계적 지표 (범위, 표준편차)
• **우수 (85-100)**: 균형 잡히고 일관된 우선순위
• **양호 (70-84)**: 경미한 불일치, 쉽게 해결 가능
• **보통 (50-69)**: 주목할 만한 문제, 개선 필요
• **불량 (0-49)**: 심각한 문제, 즉시 조치 필요
• 높은 우선순위 편차 (표준편차 > 25)
• 모든 문서의 점수가 유사 (범위 < 20)
• 불균등한 카테고리 분포 (편차 > 50)
• 언어간 불일치 (편차 > 30)

===================[ DOC: llmsData/Users/junwoobang/project/context-action/llmsData/ko/guide/priority-management-300.md ]===================
# Untitled

우선순위 관리 시스템

우선순위 관리 시스템 우선순위 관리 시스템은 LLMS Generator 프레임워크에서 문서 우선순위를 자동으로 분석, 유지 및 최적화하는 도구를 제공합니다. 개요 문제 정의 기존 문서 관리 방식의 한계점: - 수동 우선순위 할당: 주관적 평가로 인한 일관성 부족 - 팀

Key points:
• **수동 우선순위 할당**: 주관적 평가로 인한 일관성 부족
• **팀 협업 어려움**: 누가 무엇을 작업 중인지 파악 곤란

===================[ DOC: llmsData/Users/junwoobang/project/context-action/llmsData/ko/guide/priority-management-500.md ]===================
# Untitled

우선순위 관리 시스템

우선순위 관리 시스템 우선순위 관리 시스템은 LLMS Generator 프레임워크에서 문서 우선순위를 자동으로 분석, 유지 및 최적화하는 도구를 제공합니다. 개요 문제 정의 기존 문서 관리 방식의 한계점: - 수동 우선순위 할당: 주관적 평가로 인한 일관성 부족 - 팀 협업 어려움: 누가 무엇을 작업 중인지 파악 곤란 - 우선순위 표류: 체계적 검토 없이 우선순위가 구식화 - 확장성 문제: 수동 관리는 문서 증가에 대응 불가 솔루션 아키텍처 우선순위 관리 시스템이 제공하는 기능: - 자동화된 분석: 우선순위 분포에 대한 통계적 인사

Key points:
• **수동 우선순위 할당**: 주관적 평가로 인한 일관성 부족
• **팀 협업 어려움**: 누가 무엇을 작업 중인지 파악 곤란
• **우선순위 표류**: 체계적 검토 없이 우선순위가 구식화
• **확장성 문제**: 수동 관리는 문서 증가에 대응 불가
• **자동화된 분석**: 우선순위 분포에 대한...

===================[ DOC: llmsData/Users/junwoobang/project/context-action/llmsData/ko/guide/priority-management-5000.md ]===================
# Untitled

우선순위 관리 시스템

우선순위 관리 시스템 우선순위 관리 시스템은 LLMS Generator 프레임워크에서 문서 우선순위를 자동으로 분석, 유지 및 최적화하는 도구를 제공합니다. 개요 문제 정의 기존 문서 관리 방식의 한계점: - 수동 우선순위 할당: 주관적 평가로 인한 일관성 부족 - 팀 협업 어려움: 누가 무엇을 작업 중인지 파악 곤란 - 우선순위 표류: 체계적 검토 없이 우선순위가 구식화 - 확장성 문제: 수동 관리는 문서 증가에 대응 불가 솔루션 아키텍처 우선순위 관리 시스템이 제공하는 기능: - 자동화된 분석: 우선순위 분포에 대한 통계적 인사이트 - 건강도 모니터링: 일관성 확인 및 편차 감지 - 스마트 제안: 데이터 기반 개선 권고사항 - 팀 협업: 외부 서버 연동을 위한 기반 구조 빠른 시작 기본 명령어 예시 출력 명령어 참조 priority-stats 문서의 우선순위 분포를 분석합니다. 출력 내용: - 총 문서 수 및 평균 우선순위 점수 - 우선순위 등급별 분포 (critical, high, medium, low) - 카테고리 및 언어별 세분화 - 통계적 지표 (범위, 표준편차) priority-health 우선순위 일관성을 평가하고 문제점을 식별합니다. 건강도 점수: - 우수 (85-100): 균형 잡히고 일관된 우선순위 - 양호 (70-84): 경미한 불일치, 쉽게 해결 가능 - 보통 (50-69): 주목할 만한 문제, 개선 필요 - 불량 (0-49): 심각한 문제, 즉시 조치 필요 감지되는 일반적 문제: - 높은 우선순위 편차 (표준편차 > 25) - 모든 문서의 점수가 유사 (범위 < 20) - 불균등한 카테고리 분포 (편차 > 50) - 언어간 불일치 (편차 > 30) priority-suggest 현재 상태를 기반으로 실행 가능한 권고사항을 제공합니다. 제안 내용: - 불량 건강도 점수에 대한 즉시 조치 - 표준화 권고사항 - 문서별 구체적 가이드 - 개선을 위한 다음 단계 priority-auto 정의된 기준에 따라 우선순위를 자동으로 재계산합니다. 옵션: - --criteria <file>: 사용자 정의 기준 JSON 파일 경로 - --force: 최소 변경사항이라도 모든 우선순위 업데이트 - --quiet: 상세 출력 억제 기본 기준: - 문서 크기 (40% 가중치) - 카테고리 중요도 (30% 가중치) - 키워드 밀도 (20% 가중치) - 상호 참조 (10% 가중치) 우선순위 건강도 지표 분포 분석 편차 지표: - 표준편차: 우선순위 점수 분산 측정 - 카테고리 균형: 문서 유형별 균등 분포 - 언어 일관성: 언어 버전 간 유사한 우선순위 건강도 기준: 일관성 확인 자동 감지: - 우선순위 점수가 너무 유사 (차별화 < 20점) - 극단적 편차 (표준편차 > 25) - 카테고리 불균형 (한 카테고리가 전체의 60% 초과) - 언어간 차이 (EN/KO 버전 간 30% 초과 편차) 워크플로우 통합 일일 워크플로우 주간 유지보수 팀 협업 현재 상태 (로컬): - 개인별 우선순위 분석 - 로컬 일관성 확인 - 개인 워크플로우 최적화 향후 상태 (팀 통합): - 공유 우선순위 서버 - 실시간 작업 상태 추적 - 팀 전체 일관성 강제 설정 사용자 정의 우선순위 기준 자동 계산 사용자 정의를 위한 기준 파일 생성: 사용법: 환경 설정 우선순위 관리는 LLMS Generator 설정을 준수합니다: 모범 사례 우선순위 할당 가이드라인 점수 범위: - 90-100 (Critical): 핵심 프레임워크 개념, 시작 가이드 - 80-89 (High): 중요한 기능, 일반적 사용 사례 - 60-79 (Medium): 고급 기능, 특정 시나리오 - 40-59 (Low): 경계 사례, 실험적 기능 - 0-39 (Minimal): 폐기 예정 또는 드물게 사용되는 내용 카테고리 우선순위: - Guides: 일반적으로 높은 우선순위 (80-95) - Concepts: 중간에서 높은 우선순위 (70-90) - Examples: 중간 우선순위 (60-80) - Reference: 사용량에 따라 가변 (40-90) 일관성 유지 정기 검토: - 주간 건강도 확인 - 표준편차 추세 모니터링 - 카테고리 불균형 즉시 해결 - 언어 버전 동기화 유지 품질 지표: - 표준편차 < 20 (우수한 분포) - 어떤 카테고리도 전체의 50% 미만 - 언어 버전 간 10% 이내 편차 - 우선순위 등급 간 명확한 차별화 팀 협업 협업 전략: - 팀 우선순위 가이드라인 수립 - 정기 우선순위 검토 미팅 - 자동 계산을 기준선으로 활용 - 우선순위 결정 근거 문서화 의사소통: - 우선순위 건강도 리포트 공유 - 팀 미팅에서 편차 문제 논의 - 카테고리 중요도 가중치 합의 - 주요 우선순위 조정 조율 고급 기능 향후 개선사항 2단계: 팀 협업 - 작업 상태 추적 (work-claim, work-status, work-release) - 실시간 협업 충돌 방지 - 팀 작업량 균형 조정 - 진행상황 대시보드 3단계: 외부 통합 - 우선순위 서버 동기화 - 웹 기반 관리 인터페이스 - GitHub Issues 통합 - 분석 기반 자동 우선순위 업데이트 4단계: AI 기반 최적화 - 머신러닝 우선순위 제안 - 사용자 행동 패턴 분석 - 계절적 트렌드 적응 - 자동 카테고리 재균형 통합 지점 현재 통합: - LLMS Generator work-next 명령어 - Priority.json 메타데이터 시스템 - 템플릿 생성 워크플로우 계획된 통합: - GitHub Issues 우선순위 동기화 - 문서 분석 시스템 - 사용자 피드백 시스템 - CI/CD 파이프라인 통합 트러블슈팅 일반적인 문제 높은 표준편차 (> 25) 카테고리 불균형 언어간 불일치 성능 최적화 대용량 문서 세트: - 자동화 스크립트에 --quiet 플래그 사용 - 피크 시간 외 분석 실행 - 배치 우선순위 업데이트 고려 - 자동 계산 중 시스템 리소스 모니터링 오류 복구: - 업데이트 전 우선순위 파일 검증 - 자동 계산 전 원본 백업 - Git 히스토리를 통한 롤백 기능 - 누락된 파일에 대한 우아한 처리 --- ::: tip 다음 단계 - pnpm llms:p

Key points:
• **수동 우선순위 할당**: 주관적 평가로 인한 일관성 부족
• **팀 협업 어려움**: 누가 무엇을 작업 중인지 파악 곤란
• **우선순위 표류**: 체계적 검토 없이 우선순위가 구식화
• **확장성 문제**: 수동 관리는 문서 증가에 대응 불가
• **자동화된 분석**: 우선순위 분포에 대한 통계적 인사이트
• **건강도 모니터링**: 일관성 확인 및 편차 감지
• **스마트 제안**: 데이터 기반 개선 권고사항
• **팀 협업**: 외부 서버 연동을 위한 기반 구조
• 총 문서 수 및 평균 우선순위 점수
• 우선순위 등급별 분포 (critical, high, medium, low)
• 카테고리 및 언어별 세분화
• 통계적 지표 (범위, 표준편차)
• **우수 (85-100)**: 균형 잡히고 일관된 우선순위
• **양호 (70-84)**: 경미한 불일치, 쉽게 해결 가능
• **보통 (50-69)**: 주목할 만한 문제, 개선 필요
• **불량 (0-49)**: 심각한 문제, 즉시 조치 필요
• 높은 우선순위 편차 (표준편차 > 25)
• 모든 문서의 점수가 유사 (범위 < 20)
• 불균등한 카테고리 분포 (편차 > 50)
• 언어간 불일치 (편차 > 30)
• 불량 건강도 점수에 대한 즉시 조치
• 표준화 권고사항
• 문서별 구체적 가이드
• 개선을 위한 다음 단계
• `--criteria <file>`: 사용자 정의 기준 JSON 파일 경로
• `--force`: 최소 변경사항이라도 모든 우선순위 업데이트
• `--quiet`: 상세 출력 억제
• 문서 크기 (40% 가중치)
• 카테고리 중요도 (30% 가중치)
• 키워드 밀도 (20% 가중치)
• 상호 참조 (10% 가중치)
• **표준편차**: 우선순위 점수 분산 측정
• **카테고리 균형**: 문서 유형별 균등 분포
• **언어 일관성**: 언어 버전 간 유사한 우선순위
• 우선순위 점수가 너무 유사 (차별화 < 20점)
• 극단적 편차 (표준편차 > 25)
• 카테고리 불균형 (한 카테고리가 전체의 60% 초과)
• 언어간 차이 (EN/KO 버전 간 30% 초과 편차)
• 개인별 우선순위 분석
• 로컬 일관성 확인
• 개인 워크플로우 최적화
• 공유 우선순위 서버
• 실시간 작업 상태 추적
• 팀 전체 일관성 강제
• **90-100 (Critical)**: 핵심 프레임워크 개념, 시작 가이드
• **80-89 (High)**: 중요한 기능, 일반적 사용 사례
• **60-79 (Medium)**: 고급 기능, 특정 시나리오
• **40-59 (Low)**: 경계 사례, 실험적 기능
• **0-39 (Minimal)**: 폐기 예정 또는 드물게 사용되는 내용
• **Guides**: 일반적으로 높은 우선순위 (80-95)

===================[ DOC: llmsData/Users/junwoobang/project/context-action/llmsData/ko/guide/test-multilingual-sync-100.md ]===================
# Untitled

다국어 동기화 테스트 - 다국어 동기화 테스트 이 문서는 다국어 문서 처리 옵션을 테스트하기 위한 테스트 문서입니다.

===================[ DOC: llmsData/Users/junwoobang/project/context-action/llmsData/ko/guide/test-multilingual-sync-1000.md ]===================
# Untitled

다국어 동기화 테스트

다국어 동기화 테스트 이 문서는 다국어 문서 처리 옵션을 테스트하기 위한 테스트 문서입니다. 주요 기능 - 한국어 문서 자동 처리 - 언어별 필터링 - 우선순위 자동 생성 사용법 이 기능을 통해 다국어 문서를 효율적으로 관리할 수 있습니다.

Key points:
• 한국어 문서 자동 처리
• 언어별 필터링
• 우선순위 자동 생성

===================[ DOC: llmsData/Users/junwoobang/project/context-action/llmsData/ko/guide/test-multilingual-sync-200.md ]===================
# Untitled

다국어 동기화 테스트

다국어 동기화 테스트 이 문서는 다국어 문서 처리 옵션을 테스트하기 위한 테스트 문서입니다. 주요 기능 - 한국어 문서 자동 처리 - 언어별 필터링 - 우선순위 자동 생성 사용법 이 기능을 통해 다국어 문서를 효율적으로 관리할 수 있습니다.

Key points:
• 한국어 문서 자동 처리
• 언어별 필터링

===================[ DOC: llmsData/Users/junwoobang/project/context-action/llmsData/ko/guide/test-multilingual-sync-2000.md ]===================
# Untitled

다국어 동기화 테스트

다국어 동기화 테스트 이 문서는 다국어 문서 처리 옵션을 테스트하기 위한 테스트 문서입니다. 주요 기능 - 한국어 문서 자동 처리 - 언어별 필터링 - 우선순위 자동 생성 사용법 이 기능을 통해 다국어 문서를 효율적으로 관리할 수 있습니다.

Key points:
• 한국어 문서 자동 처리
• 언어별 필터링
• 우선순위 자동 생성

===================[ DOC: llmsData/Users/junwoobang/project/context-action/llmsData/ko/guide/test-multilingual-sync-300.md ]===================
# Untitled

다국어 동기화 테스트

다국어 동기화 테스트 이 문서는 다국어 문서 처리 옵션을 테스트하기 위한 테스트 문서입니다. 주요 기능 - 한국어 문서 자동 처리 - 언어별 필터링 - 우선순위 자동 생성 사용법 이 기능을 통해 다국어 문서를 효율적으로 관리할 수 있습니다.

Key points:
• 한국어 문서 자동 처리
• 언어별 필터링

===================[ DOC: llmsData/Users/junwoobang/project/context-action/llmsData/ko/guide/test-multilingual-sync-500.md ]===================
# Untitled

다국어 동기화 테스트

다국어 동기화 테스트 이 문서는 다국어 문서 처리 옵션을 테스트하기 위한 테스트 문서입니다. 주요 기능 - 한국어 문서 자동 처리 - 언어별 필터링 - 우선순위 자동 생성 사용법 이 기능을 통해 다국어 문서를 효율적으로 관리할 수 있습니다.

Key points:
• 한국어 문서 자동 처리
• 언어별 필터링
• 우선순위 자동 생성

===================[ DOC: llmsData/Users/junwoobang/project/context-action/llmsData/ko/guide/test-multilingual-sync-5000.md ]===================
# Untitled

다국어 동기화 테스트

다국어 동기화 테스트 이 문서는 다국어 문서 처리 옵션을 테스트하기 위한 테스트 문서입니다. 주요 기능 - 한국어 문서 자동 처리 - 언어별 필터링 - 우선순위 자동 생성 사용법 이 기능을 통해 다국어 문서를 효율적으로 관리할 수 있습니다.

Key points:
• 한국어 문서 자동 처리
• 언어별 필터링
• 우선순위 자동 생성

===================[ DOC: ko/concept/action-pipeline-guide.md ]===================
# concept--action-pipeline-guide

Context-Action 액션 파이프라인 시스템 가이드

Context-Action 프레임워크의 핵심인 액션 파이프라인 시스템에 대한 포괄적인 가이드입니다.

===================[ DOC: ko/concept/action-pipeline-guide.md ]===================
# concept--action-pipeline-guide

Context-Action 액션 파이프라인 시스템 가이드

Context-Action 프레임워크의 핵심인 액션 파이프라인 시스템에 대한 포괄적인 가이드입니다. 개요

액션 파이프라인 시스템은 Context-Action의 ViewModel 레이어의 핵심으로, 우선순위 기반 핸들러 실행과 정교한 파이프라인 제어를 통한 중앙집중식 액션 처리를 제공합니다. 핵심 구성 요소

ActionRegister

ActionRegister 클래스는 액션 파이프라인 시스템의 핵심입니다:

핸들러 등록

우선순위 기반 실행으로 핸들러를 등록합니다:

파이프라인 컨트롤러

각 핸들러는 고급 파이프라인 관리를 위한 PipelineController를 받습니다:

우선순위 기반 실행

실행 순서

핸들러는 내림차순 우선순위 순서로 실행됩니다 (가장 높은 것부터):

핸들러 설정

파이프라인 제어 메서드

controller.abort()

선택적 이유와 함께 파이프라인 실행 중단:

controller.modifyPayload()

후속 핸들러를 위한 페이로드 변환:

controller.setResult() 및 getResults()

핸들러 간 중간 결과 관리:

실행 모드

순차 모드 (기본값)

핸들러가 차례대로 실행:

병렬 모드

모든 핸들러가 동시에 실행:

경쟁 모드

첫 번째 완료 핸들러가 승리:

결과 수집

기본 디스패치

결과 수집을 통한 디스패치

에러 처리

개별 핸들러가 실패해도 파이프라인은 계속 실행됩니다:

실제 예제: 인증 플로우

React와의 통합

액션 파이프라인은 액션 컨텍스트 패턴을 통해 React와 원활하게 통합됩니다:

모범 사례

1. 우선순위 설계: 논리적 실행 순서에 따라 우선순위 할당
2. 에러 처리: 적절한 에러 처리와 복구 메커니즘 구현
3. 결과 수집: 복잡한 워크플로에 대해 결과 수집 사용
4. 성능 최적화: 적절한 실행 모드 선택
5. 타입 안전성: TypeScript와 함께 사용하여 타입 안전성 확보.

===================[ DOC: ko/concept/action-pipeline-guide.md ]===================
# concept--action-pipeline-guide

Context-Action 액션 파이프라인 시스템 가이드

Context-Action 프레임워크의 핵심인 액션 파이프라인 시스템에 대한 포괄적인 가이드입니다.

===================[ DOC: ko/concept/action-pipeline-guide.md ]===================
# concept--action-pipeline-guide

Context-Action 액션 파이프라인 시스템 가이드

Context-Action 프레임워크의 핵심인 액션 파이프라인 시스템에 대한 포괄적인 가이드입니다. 개요

액션 파이프라인 시스템은 Context-Action의 ViewModel 레이어의 핵심으로, 우선순위 기반 핸들러 실행과 정교한 파이프라인 제어를 통한 중앙집중식 액션 처리를 제공합니다. 핵심 구성 요소

ActionRegister

ActionRegister 클래스는 액션 파이프라인 시스템의 핵심입니다:

핸들러 등록

우선순위 기반 실행으로 핸들러를 등록합니다:

파이프라인 컨트롤러

각 핸들러는 고급 파이프라인 관리를 위한 PipelineController를 받습니다:

우선순위 기반 실행

실행 순서

핸들러는 내림차순 우선순위 순서로 실행됩니다 (가장 높은 것부터):

핸들러 설정

파이프라인 제어 메서드

controller.abort()

선택적 이유와 함께 파이프라인 실행 중단:

controller.modifyPayload()

후속 핸들러를 위한 페이로드 변환:

controller.setResult() 및 getResults()

핸들러 간 중간 결과 관리:

실행 모드

순차 모드 (기본값)

핸들러가 차례대로 실행:

병렬 모드

모든 핸들러가 동시에 실행:

경쟁 모드

첫 번째 완료 핸들러가 승리:

결과 수집

기본 디스패치

결과 수집을 통한 디스패치

에러 처리

개별 핸들러가 실패해도 파이프라인은 계속 실행됩니다:

실제 예제: 인증 플로우

React와의 통합

액션 파이프라인은 액션 컨텍스트 패턴을 통해 React와 원활하게 통합됩니다:

모범 사례

1. 우선순위 설계: 논리적 실행 순서에 따라 우선순위 할당
2. 에러 처리: 적절한 에러 처리와 복구 메커니즘 구현
3. 결과 수집: 복잡한 워크플로에 대해 결과 수집 사용
4. 성능 최적화: 적절한 실행 모드 선택
5. 타입 안전성: TypeScript와 함께 사용하여 타입 안전성 확보.

===================[ DOC: ko/concept/action-pipeline-guide.md ]===================
# concept--action-pipeline-guide

Context-Action 액션 파이프라인 시스템 가이드

Context-Action 프레임워크의 핵심인 액션 파이프라인 시스템에 대한 포괄적인 가이드입니다. 개요

액션 파이프라인 시스템은 Context-Action의 ViewModel 레이어의 핵심으로, 우선순위 기반 핸들러 실행과 정교한 파이프라인 제어를 통한 중앙집중식 액션 처리를 제공합니다.

===================[ DOC: ko/concept/action-pipeline-guide.md ]===================
# concept--action-pipeline-guide

Context-Action 액션 파이프라인 시스템 가이드

Context-Action 프레임워크의 핵심인 액션 파이프라인 시스템에 대한 포괄적인 가이드입니다. 개요

액션 파이프라인 시스템은 Context-Action의 ViewModel 레이어의 핵심으로, 우선순위 기반 핸들러 실행과 정교한 파이프라인 제어를 통한 중앙집중식 액션 처리를 제공합니다.

===================[ DOC: ko/concept/action-pipeline-guide.md ]===================
# concept--action-pipeline-guide

Context-Action 액션 파이프라인 시스템 가이드

Context-Action 프레임워크의 핵심인 액션 파이프라인 시스템에 대한 포괄적인 가이드입니다. 개요

액션 파이프라인 시스템은 Context-Action의 ViewModel 레이어의 핵심으로, 우선순위 기반 핸들러 실행과 정교한 파이프라인 제어를 통한 중앙집중식 액션 처리를 제공합니다. 핵심 구성 요소

ActionRegister

ActionRegister 클래스는 액션 파이프라인 시스템의 핵심입니다:

핸들러 등록

우선순위 기반 실행으로 핸들러를 등록합니다:

파이프라인 컨트롤러

각 핸들러는 고급 파이프라인 관리를 위한 PipelineController를 받습니다:

우선순위 기반 실행

실행 순서

핸들러는 내림차순 우선순위 순서로 실행됩니다 (가장 높은 것부터):

핸들러 설정

파이프라인 제어 메서드

controller.abort()

선택적 이유와 함께 파이프라인 실행 중단:

controller.modifyPayload()

후속 핸들러를 위한 페이로드 변환:

controller.setResult() 및 getResults()

핸들러 간 중간 결과 관리:

실행 모드

순차 모드 (기본값)

핸들러가 차례대로 실행:

병렬 모드

모든 핸들러가 동시에 실행:

경쟁 모드

첫 번째 완료 핸들러가 승리:

결과 수집

기본 디스패치

결과 수집을 통한 디스패치

에러 처리

개별 핸들러가 실패해도 파이프라인은 계속 실행됩니다:

실제 예제: 인증 플로우

React와의 통합

액션 파이프라인은 액션 컨텍스트 패턴을 통해 React와 원활하게 통합됩니다:

모범 사례

1. 우선순위 설계: 논리적 실행 순서에 따라 우선순위 할당
2. 에러 처리: 적절한 에러 처리와 복구 메커니즘 구현
3. 결과 수집: 복잡한 워크플로에 대해 결과 수집 사용
4. 성능 최적화: 적절한 실행 모드 선택
5. 타입 안전성: TypeScript와 함께 사용하여 타입 안전성 확보.

===================[ DOC: ko/concept/architecture-guide.md ]===================
# concept--architecture-guide

Context-Action 스토어 통합 아키텍처

1. 개요 및 핵심 개념

Context-Action 아키텍처란.

===================[ DOC: ko/concept/architecture-guide.md ]===================
# concept--architecture-guide

Context-Action 스토어 통합 아키텍처

1. 개요 및 핵심 개념

Context-Action 아키텍처란. Context-Action 프레임워크는 문서 중심의 컨텍스트 분리와 효과적인 아티팩트 관리를 통해 기존 라이브러리의 근본적인 한계를 극복하도록 설계된 혁신적인 상태 관리 시스템입니다.

===================[ DOC: ko/concept/architecture-guide.md ]===================
# concept--architecture-guide

Context-Action 스토어 통합 아키텍처

1. 개요 및 핵심 개념

Context-Action 아키텍처란. Context-Action 프레임워크는 문서 중심의 컨텍스트 분리와 효과적인 아티팩트 관리를 통해 기존 라이브러리의 근본적인 한계를 극복하도록 설계된 혁신적인 상태 관리 시스템입니다.

===================[ DOC: ko/concept/architecture-guide.md ]===================
# concept--architecture-guide

Context-Action 스토어 통합 아키텍처

1. 개요 및 핵심 개념

Context-Action 아키텍처란. Context-Action 프레임워크는 문서 중심의 컨텍스트 분리와 효과적인 아티팩트 관리를 통해 기존 라이브러리의 근본적인 한계를 극복하도록 설계된 혁신적인 상태 관리 시스템입니다.

===================[ DOC: ko/concept/architecture-guide.md ]===================
# concept--architecture-guide

Context-Action 스토어 통합 아키텍처

1. 개요 및 핵심 개념

Context-Action 아키텍처란. Context-Action 프레임워크는 문서 중심의 컨텍스트 분리와 효과적인 아티팩트 관리를 통해 기존 라이브러리의 근본적인 한계를 극복하도록 설계된 혁신적인 상태 관리 시스템입니다.

===================[ DOC: ko/concept/architecture-guide.md ]===================
# concept--architecture-guide

Context-Action 스토어 통합 아키텍처

1. 개요 및 핵심 개념

Context-Action 아키텍처란. Context-Action 프레임워크는 문서 중심의 컨텍스트 분리와 효과적인 아티팩트 관리를 통해 기존 라이브러리의 근본적인 한계를 극복하도록 설계된 혁신적인 상태 관리 시스템입니다.

===================[ DOC: ko/concept/architecture-guide.md ]===================
# concept--architecture-guide

Context-Action 스토어 통합 아키텍처

1. 개요 및 핵심 개념

Context-Action 아키텍처란. Context-Action 프레임워크는 문서 중심의 컨텍스트 분리와 효과적인 아티팩트 관리를 통해 기존 라이브러리의 근본적인 한계를 극복하도록 설계된 혁신적인 상태 관리 시스템입니다. 프로젝트 철학

Context-Action 프레임워크는 현대 상태 관리의 중요한 문제들을 해결합니다:

기존 라이브러리의 문제점:
- 높은 React 결합도: 강한 통합으로 컴포넌트 모듈화와 props 처리가 어려움
- 이진 상태 접근법: 단순한 전역/로컬 상태 이분법으로는 특정 범위 기반 분리를 처리하기 어려움  
- 부적절한 핸들러/트리거 관리: 복잡한 상호작용과 비즈니스 로직 처리에 대한 부족한 지원

Context-Action의 솔루션:
- 문서-아티팩트 중심 설계: 문서 테마와 결과물 관리를 기반으로 한 컨텍스트 분리
- 완벽한 관심사 분리: 
  - 뷰 디자인 격리 → 디자인 컨텍스트
  - 개발 아키텍처 격리 → 아키텍처 컨텍스트
  - 비즈니스 로직 격리 → 비즈니스 컨텍스트  
  - 데이터 검증 격리 → 검증 컨텍스트
- 명확한 경계: 구현 결과가 뚜렷하고 잘 정의된 도메인 경계를 유지
- 효과적인 문서-아티팩트 관리: 문서와 결과물 간의 관계를 적극적으로 지원하는 상태 관리 라이브러리

아키텍처 구현

프레임워크는 완전한 도메인 격리를 위한 세 가지 핵심 패턴을 통해 MVVM에서 영감을 받은 패턴으로 깔끔한 관심사 분리를 구현합니다:

- 액션은 createActionContext를 통해 비즈니스 로직과 조정을 처리 (ViewModel 레이어)
- 선언적 스토어 패턴은 createDeclarativeStorePattern을 통해 도메인 격리로 상태를 관리 (Model 레이어)
- RefContext는 createRefContext를 통해 제로 리렌더링으로 직접 DOM 조작 제공 (Performance 레이어)
- 컴포넌트는 UI를 렌더링 (View 레이어)
- 컨텍스트 경계는 기능 도메인을 격리
- 타입 안전한 통합은 도메인별 훅을 통해 구현

핵심 아키텍처 흐름

컨텍스트 분리 전략

도메인 기반 컨텍스트 아키텍처
- 비즈니스 컨텍스트: 비즈니스 로직, 데이터 처리, 도메인 규칙 (액션 + 스토어)
- UI 컨텍스트: 화면 상태, 사용자 상호작용, 컴포넌트 동작 (스토어 + RefContext)
- 성능 컨텍스트: 고성능 DOM 조작과 애니메이션 (RefContext)
- 검증 컨텍스트: 데이터 검증, 폼 처리, 오류 처리 (액션 + 스토어)
- 디자인 컨텍스트: 테마 관리, 스타일링, 레이아웃, 시각적 상태 (스토어 + RefContext)
- 아키텍처 컨텍스트: 시스템 구성, 인프라, 기술적 결정 (액션 + 스토어)

문서 기반 컨텍스트 설계
각 컨텍스트는 해당 문서와 결과물을 관리하도록 설계됩니다:
- 디자인 문서 → Design Context (테마, 컴포넌트 사양, 스타일 가이드) → 스토어 + RefContext
- 비즈니스 요구사항 → Business Context (워크플로, 규칙, 도메인 로직) → 액션 + 스토어
- 성능 사양 → Performance Context (애니메이션, 상호작용) → RefContext
- 아키텍처 문서 → Architecture Context (시스템 설계, 기술적 결정) → 액션 + 스토어
- 검증 사양 → Validation Context (규칙, 스키마, 오류 처리) → 액션 + 스토어
- UI 사양 → UI Context (상호작용, 상태 관리, 사용자 플로우) → 세 패턴 모두

고급 핸들러 및 트리거 관리

Context-Action은 기존 라이브러리에서 부족한 정교한 핸들러 및 트리거 관리를 제공합니다:

우선순위 기반 핸들러 실행
- 순차 처리: 적절한 비동기 처리와 함께 우선순위 순서로 핸들러 실행
- 도메인 격리: 각 컨텍스트가 자체 핸들러 레지스트리를 유지
- 교차 컨텍스트 조정: 도메인 컨텍스트 간 제어된 통신
- 결과 수집: 복잡한 워크플로를 위한 여러 핸들러의 결과 집계

지능형 트리거 시스템
- 상태 변경 트리거: 스토어 값 변경에 기반한 자동 트리거
- 교차 컨텍스트 트리거: 도메인 경계가 다른 컨텍스트의 액션을 트리거
- 조건부 트리거: 비즈니스 규칙과 조건에 기반한 스마트 트리거
- 트리거 정리: 자동 정리가 메모리 누수와 오래된 참조를 방지

주요 이점

1. 문서-아티팩트 관리: 문서와 구현 간의 직접적 관계
2. 도메인 격리: 각 컨텍스트가 완전한 독립성을 유지
3. 타입 안전성: 도메인별 훅으로 완전한 TypeScript 지원
4. 성능: RefContext로 제로 React 리렌더링, 스토어로 선택적 업데이트
5. 확장성: 기존 도메인에 영향을 주지 않고 새 도메인을 쉽게 추가
6. 팀 협업: 다양한 팀이 충돌 없이 서로 다른 도메인에서 작업
7. 명확한 경계: 문서 도메인을 기반으로 한 완벽한 관심사 분리
8. 하드웨어 가속: 60fps 성능을 위한 translate3d()로 직접 DOM 조작

1.1. RefContext 성능 아키텍처

제로 리렌더 철학

RefContext 패턴은 DOM 조작을 위해 React의 렌더링 사이클을 완전히 우회하는 성능 우선 레이어를 도입합니다:

핵심 성능 원칙

1. 직접 DOM 액세스: React 재조정을 트리거하지 않고 DOM 요소를 직접 조작
2. 하드웨어 가속: GPU 가속 애니메이션을 위한 transform3d() 사용
3. 관심사 분리: 시각적 업데이트를 비즈니스 로직 업데이트와 분리
4. 메모리 효율성: 자동 정리 및 생명주기 관리
5. 타입 안전성: DOM 요소 타입에 대한 완전한 TypeScript 지원

아키텍처 레이어

성능 비교

| 접근법 | React 리렌더링 | 성능 | 메모리 | 복잡성 |
|-------|----------------|------|-------|--------|
| useState | 모든 업데이트 | 30fps | 높은 GC | 단순 |
| useRef | 수동 확인 | 45fps | 중간 | 중간 |
| RefContext | 제로 | 60fps+ | 낮음 | 최적화됨 |

RefContext 통합 패턴

패턴 1: 순수 성능 (RefContext만 사용)

패턴 2: 하이브리드 성능 (RefContext + 스토어)

2. MVVM 패턴 통합

선언적 스토어 패턴 (주요)

도메인 격리를 통한 타입 안전한 상태 관리:
- 액션이 비즈니스 로직을 처리 (ViewModel 레이어) via createActionContext
- 선언적 스토어 패턴이 타입 안전성으로 상태를 관리 (Model 레이어)
- 컴포넌트가 UI를 렌더링 (View 레이어)
- 패턴 조합이 유연한 아키텍처를 허용
- 타입 안전한 통합 패턴별 훅을 통해

스토어 통합 3단계 프로세스
1. 현재 상태 읽기 store.getValue()를 사용하여 스토어에서
2. 비즈니스 로직 실행 페이로드와 현재 상태를 사용하여  
3. 스토어 업데이트 store.setValue() 또는 store.update() 사용

핸들러 등록 모범 사례
최적의 성능과 적절한 정리를 위해 useActionHandler + useEffect 패턴 사용:
- 재등록을 방지하기 위해 useCallback으로 핸들러 감싸기
- 현재 상태를 위해 stores.getStore()로 지연 평가 사용
- 등록 해제 함수를 사용하여 정리와 함께 핸들러 등록

3. 아키텍처 패턴

- Action Only 패턴: createActionContext()로 순수 액션 디스패칭
- 선언적 스토어 패턴: createDeclarativeStorePattern()으로 타입 안전한 상태 관리
- RefContext 패턴: createRefContext()로 제로 리렌더링 DOM 조작
- 스토어 통합 패턴: 핸들러 구현을 위한 3단계 프로세스
- HOC 패턴: 자동 컴포넌트 감싸기를 위한 withProvider() (Store Pattern)
- 패턴 조합: 복잡한 애플리케이션을 위한 세 패턴 모두 결합
- Provider 격리: 패턴별 독립적인 컨텍스트 관리

도메인별 훅 패턴 (핵심)

철학: 이름 변경 훅 패턴

프레임워크의 핵심 철학은 구조분해 할당을 통해 도메인별 훅을 만드는 것으로, 개발자 경험을 향상시키는 직관적이고 타입 안전한 API를 제공합니다. 도메인별 명명의 이점

1. 타입 안전성: 도메인별 타입으로 완전한 TypeScript 추론
2. 개발자 경험: 명확하고 자동 완성 친화적인 API
3. 유지보수성: 훅이 어느 도메인에 속하는지 쉽게 식별
4. 리팩토링 안전성: 타입 오류가 즉시 주요 변경사항을 강조
5. 팀 확장성: 다양한 팀이 충돌 없이 서로 다른 도메인에서 작업

패턴 액세스 전략

각각 특정 사용 사례가 있는 패턴 액세스를 위한 전략:.

===================[ DOC: ko/concept/conventions.md ]===================
# concept--conventions

Context-Action Framework Conventions

이 문서는 Context-Action 프레임워크의 세 가지 핵심 패턴(Actions, Stor...

===================[ DOC: ko/concept/conventions.md ]===================
# concept--conventions

Context-Action Framework Conventions

이 문서는 Context-Action 프레임워크의 세 가지 핵심 패턴(Actions, Stores, RefContext)을 사용할 때 따라야 할 코딩 컨벤션과 베스트 프랙티스를 정의합니다. 📋 목차

1. 네이밍 컨벤션
2. 파일 구조
3. 패턴 사용법
4. 타입 정의
5. 코드 스타일
6. 성능 가이드라인
7. 에러 핸들링
8. RefContext 컨벤션

네이밍 컨벤션

🏷️ 리네이밍 패턴 (Renaming Pattern)

Context-Action 프레임워크의 핵심 컨벤션은 세 가지 패턴 모두에 대한 도메인별 리네이밍 패턴입니다.

===================[ DOC: ko/concept/conventions.md ]===================
# concept--conventions

Context-Action Framework Conventions

이 문서는 Context-Action 프레임워크의 세 가지 핵심 패턴(Actions, Stores, RefContext)을 사용할 때 따라야 할 코딩 컨벤션과 베스트 프랙티스를 정의합니다. 📋 목차

1. 네이밍 컨벤션
2. 파일 구조
3. 패턴 사용법
4.

===================[ DOC: ko/concept/conventions.md ]===================
# concept--conventions

Context-Action Framework Conventions

이 문서는 Context-Action 프레임워크의 세 가지 핵심 패턴(Actions, Stores, RefContext)을 사용할 때 따라야 할 코딩 컨벤션과 베스트 프랙티스를 정의합니다. 📋 목차

1. 네이밍 컨벤션
2. 파일 구조
3. 패턴 사용법
4. 타입 정의
5. 코드 스타일
6. 성능 가이드라인
7. 에러 핸들링
8. RefContext 컨벤션

네이밍 컨벤션

🏷️ 리네이밍 패턴 (Renaming Pattern)

Context-Action 프레임워크의 핵심 컨벤션은 세 가지 패턴 모두에 대한 도메인별 리네이밍 패턴입니다. ✅ Store Pattern 리네이밍

✅ Action Pattern 리네이밍

✅ RefContext Pattern 리네이밍

🎯 컨텍스트 이름 규칙

도메인 기반 네이밍

Action vs Store vs RefContext 구분

🔤 Hook 네이밍 패턴

Store Hook 네이밍

Action Hook 네이밍

RefContext Hook 네이밍

파일 구조

📁 권장 디렉토리 구조

📄 파일명 컨벤션

Context 파일명

Provider 파일명

패턴 사용법

🎯 패턴 선택 가이드

Store Only Pattern

Action Only Pattern  

Pattern Composition

🔄 Provider 조합 패턴

HOC 패턴 (권장)

Manual Provider 조합

타입 정의

🏷️ Interface 네이밍

Action Payload Map

Store Data Interface

🎯 제네릭 타입 사용

코드 스타일

✨ 컴포넌트 패턴

Store 사용 패턴

Action Handler 패턴

🎨 Import 정리

성능 가이드라인

⚡ Store 최적화

Comparison Strategy 선택

메모이제이션 패턴

🔄 Action 최적화

Debounce/Throttle 설정

🧪 타입 테스트 및 검증

✅ 타입 안전성 검증

컴파일 타임 타입 테스트

런타임 에러 처리 개선

🔍 디버깅 도구

개발 모드 로깅

에러 핸들링

🚨 Error Boundary 패턴

🛡️ Action Error 처리

RefContext 컨벤션

🔧 RefContext 전용 가이드라인

Ref 타입 정의

성능 중심 패턴

RefContext 에러 처리

⚡ RefContext 성능 최적화

제로 리렌더링 DOM 조작

📚 추가 리소스

관련 문서
- Pattern Guide - 상세한 패턴 사용법
- Full Architecture Guide - 완전한 아키텍처 가이드
- Hooks Reference - Hooks 참조 문서
- API Reference - API 문서

예제 프로젝트
- Basic Example - 기본 사용 예제
- Advanced Patterns - 고급 패턴 예제

마이그레이션 가이드
- Legacy Pattern Migration - 레거시 패턴에서 마이그레이션

❓ FAQ

Q: 언제 Store Only vs Action Only vs RefContext vs Composition을 사용해야 하나요. - Store Only: 순수 상태 관리 (폼, 설정, 캐시)
- Action Only: 순수 이벤트 처리 (로깅, 트래킹, 알림)  
- RefContext Only: 고성능 DOM 조작 (애니메이션, 실시간 상호작용)
- Composition: 여러 패턴이 필요한 복잡한 비즈니스 로직 (사용자 관리, 상호작용형 쇼핑카트)

Q: 리네이밍 패턴을 꼭 사용해야 하나요. 네, 리네이밍 패턴은 Context-Action 프레임워크의 핵심 컨벤션입니다. 타입 안전성과 개발자 경험을 크게 향상시킵니다. Q: 성능 최적화는 어떻게 해야 하나요. 1. 적절한 comparison strategy 선택
2.

===================[ DOC: ko/concept/conventions.md ]===================
# concept--conventions

Context-Action Framework Conventions

이 문서는 Context-Action 프레임워크의 세 가지 핵심 패턴(Actions, Stores, RefContext)을 사용할 때 따라야 할 코딩 컨벤션과 베스트 프랙티스를 정의합니다. 📋 목차

1. 네이밍 컨벤션
2. 파일 구조
3. 패턴 사용법
4. 타입 정의
5. 코드 스타일
6. 성능 가이드라인
7. 에러 핸들링
8.

===================[ DOC: ko/concept/conventions.md ]===================
# concept--conventions

Context-Action Framework Conventions

이 문서는 Context-Action 프레임워크의 세 가지 핵심 패턴(Actions, Stores, RefContext)을 사용할 때 따라야 할 코딩 컨벤션과 베스트 프랙티스를 정의합니다. 📋 목차

1. 네이밍 컨벤션
2. 파일 구조
3. 패턴 사용법
4. 타입 정의
5. 코드 스타일
6. 성능 가이드라인
7. 에러 핸들링
8. RefContext 컨벤션

네이밍 컨벤션

🏷️ 리네이밍 패턴 (Renaming Pattern)

Context-Action 프레임워크의 핵심 컨벤션은 세 가지 패턴 모두에 대한 도메인별 리네이밍 패턴입니다.

===================[ DOC: ko/concept/conventions.md ]===================
# concept--conventions

Context-Action Framework Conventions

이 문서는 Context-Action 프레임워크의 세 가지 핵심 패턴(Actions, Stores, RefContext)을 사용할 때 따라야 할 코딩 컨벤션과 베스트 프랙티스를 정의합니다. 📋 목차

1. 네이밍 컨벤션
2. 파일 구조
3. 패턴 사용법
4. 타입 정의
5. 코드 스타일
6. 성능 가이드라인
7. 에러 핸들링
8. RefContext 컨벤션

네이밍 컨벤션

🏷️ 리네이밍 패턴 (Renaming Pattern)

Context-Action 프레임워크의 핵심 컨벤션은 세 가지 패턴 모두에 대한 도메인별 리네이밍 패턴입니다. ✅ Store Pattern 리네이밍

✅ Action Pattern 리네이밍

✅ RefContext Pattern 리네이밍

🎯 컨텍스트 이름 규칙

도메인 기반 네이밍

Action vs Store vs RefContext 구분

🔤 Hook 네이밍 패턴

Store Hook 네이밍

Action Hook 네이밍

RefContext Hook 네이밍

파일 구조

📁 권장 디렉토리 구조

📄 파일명 컨벤션

Context 파일명

Provider 파일명

패턴 사용법

🎯 패턴 선택 가이드

Store Only Pattern

Action Only Pattern  

Pattern Composition

🔄 Provider 조합 패턴

HOC 패턴 (권장)

Manual Provider 조합

타입 정의

🏷️ Interface 네이밍

Action Payload Map

Store Data Interface

🎯 제네릭 타입 사용

코드 스타일

✨ 컴포넌트 패턴

Store 사용 패턴

Action Handler 패턴

🎨 Import 정리

성능 가이드라인

⚡ Store 최적화

Comparison Strategy 선택

메모이제이션 패턴

🔄 Action 최적화

Debounce/Throttle 설정

🧪 타입 테스트 및 검증

✅ 타입 안전성 검증

컴파일 타임 타입 테스트

런타임 에러 처리 개선

🔍 디버깅 도구

개발 모드 로깅

에러 핸들링

🚨 Error Boundary 패턴

🛡️ Action Error 처리

RefContext 컨벤션

🔧 RefContext 전용 가이드라인

Ref 타입 정의

성능 중심 패턴

RefContext 에러 처리

⚡ RefContext 성능 최적화

제로 리렌더링 DOM 조작

📚 추가 리소스

관련 문서
- Pattern Guide - 상세한 패턴 사용법
- Full Architecture Guide - 완전한 아키텍처 가이드
- Hooks Reference - Hooks 참조 문서
- API Reference - API 문서

예제 프로젝트
- Basic Example - 기본 사용 예제
- Advanced Patterns - 고급 패턴 예제

마이그레이션 가이드
- Legacy Pattern Migration - 레거시 패턴에서 마이그레이션

❓ FAQ

Q: 언제 Store Only vs Action Only vs RefContext vs Composition을 사용해야 하나요. - Store Only: 순수 상태 관리 (폼, 설정, 캐시)
- Action Only: 순수 이벤트 처리 (로깅, 트래킹, 알림)  
- RefContext Only: 고성능 DOM 조작 (애니메이션, 실시간 상호작용)
- Composition: 여러 패턴이 필요한 복잡한 비즈니스 로직 (사용자 관리, 상호작용형 쇼핑카트)

Q: 리네이밍 패턴을 꼭 사용해야 하나요. 네, 리네이밍 패턴은 Context-Action 프레임워크의 핵심 컨벤션입니다. 타입 안전성과 개발자 경험을 크게 향상시킵니다. Q: 성능 최적화는 어떻게 해야 하나요. 1. 적절한 comparison strategy 선택
2. useCallback으로 핸들러 메모이제이션  
3. 큰 데이터는 reference strategy 사용
4. 필요시 debounce/throttle 적용
5. 성능 중요한 DOM 조작에 RefContext 사용

Q: 에러 처리는 어떻게 해야 하나요. 1. Pipeline Controller의 abort() 메서드 사용
2. 도메인별 Error Boundary 설정
3. 적절한 에러 타입별 처리
4. 사용자 친화적 에러 메시지 제공
5. DOM 조작 전 항상 ref.target 존재 여부 확인

Q: 명시적 제네릭과 타입 추론 중 어떤 것을 사용해야 하나요. - 타입 추론 (권장): 대부분의 경우, 코드가 간결하고 타입 안전성 보장
- 명시적 제네릭: 복잡한 타입 구조나 엄격한 타입 제약이 필요한 경우

Q: comparisonOptions는 언제 사용해야 하나요. 1. ignoreKeys: 타임스탬프 등 특정 필드 변경을 무시하고 싶을 때
2. customComparator: 비즈니스 로직에 맞는 특별한 비교가 필요할 때
3. maxDepth: 성능 최적화를 위해 깊은 비교의 깊이를 제한하고 싶을 때
4. enableCircularCheck: 순환 참조 가능성이 있는 객체를 다룰 때

Q: 타입 테스트는 어떻게 작성해야 하나요. 1. 명시적 제네릭과 타입 추론 모두 테스트
2. 컴파일 타임에 타입 안전성 검증
3. 에러 케이스도 주석으로 문서화
4. 실제 사용 패턴을 반영한 테스트 컴포넌트 작성
5. 컴포넌트 테스트에 RefContext 타입 검증 포함

Q: 언제 RefContext를 일반 state 대신 사용해야 하나요. - RefContext 사용 시: 직접 DOM 조작 필요, 60fps 성능 필요, 제로 리렌더링이 중요
- 일반 state 사용 시: 데이터를 UI에 표시해야 함, 컴포넌트 리렌더링이 허용됨
- 둘 다 사용 시: 데이터 표시와 성능 중요 작업이 함께 필요 (예: 실시간 차트)

Q: RefContext 안전성은 어떻게 보장하나요. 1. DOM 작업 전 항상 ref.target 존재 여부 확인
   

2. 여러 ref가 필요한 작업에는 useWaitForRefs 사용
   

3. 애니메이션과 이벤트 리스너의 적절한 정리 구현
   

4. 에러 경계 처리 및 경고 메시지
   

Q: RefContext 성능 최적화는 어떻게 하나요. 1. 하드웨어 가속을 위한 translate3d() 사용
   

2. 애니메이션을 위한 will-change 속성 관리
   

3. requestAnimationFrame을 사용한 부드러운 애니메이션.

===================[ DOC: ko/concept/hooks-reference.md ]===================
# concept--hooks-reference

Context-Action React 훅 참조

이 문서는 Context-Action 프레임워크에서 사용 가능한 모든 React 훅을 필수 훅 (핵심 기능)과 유...

===================[ DOC: ko/concept/hooks-reference.md ]===================
# concept--hooks-reference

Context-Action React 훅 참조

이 문서는 Context-Action 프레임워크에서 사용 가능한 모든 React 훅을 필수 훅 (핵심 기능)과 유틸리티 훅 (편의 및 최적화)으로 분류합니다. 📋 목차

1. 필수 훅
2. 유틸리티 훅
3. 훅 분류
4. 사용 가이드라인

필수 훅

이 훅들은 Context-Action 프레임워크를 사용하는 데 필수적입니다. 대부분의 애플리케이션에서 이러한 훅이 필요합니다. 🔧 RefContext 훅 (성능)

createRefContext<T>()
고성능 DOM 조작을 위한 모든 ref 관련 훅을 생성하는 팩토리 함수. - 목적: 제로 React 리렌더링으로 타입 안전한 직접 DOM 조작 시스템 생성
- 반환: { Provider, useRefHandler, useWaitForRefs, useGetAllRefs }
- 필수 용도: 성능 중요 UI, 애니메이션, 실시간 상호작용

useRefHandler()
타입 안전한 직접 DOM 조작이 가능한 ref 핸들러에 액세스하는 주요 훅. - 목적: 타입 안전성을 갖춘 특정 DOM 요소의 ref 핸들러 가져오기
- 필수 용도: React 리렌더링 없는 직접 DOM 업데이트
- 패턴: React 재조정을 우회하는 성능 레이어

useWaitForRefs()
작업을 실행하기 전에 여러 ref가 마운트될 때까지 대기하는 유틸리티 훅. - 목적: 여러 DOM 요소가 필요한 작업 조정
- 필수 용도: 복잡한 DOM 초기화 시퀀스
- 패턴: 비동기 ref 조정

🎯 Action 훅 (핵심)

createActionContext<T>()
특정 액션 컨텍스트를 위한 모든 액션 관련 훅을 생성하는 팩토리 함수.

===================[ DOC: ko/concept/hooks-reference.md ]===================
# concept--hooks-reference

Context-Action React 훅 참조

이 문서는 Context-Action 프레임워크에서 사용 가능한 모든 React 훅을 필수 훅 (핵심 기능)과 유틸리티 훅 (편의 및 최적화)으로 분류합니다. 📋 목차

1. 필수 훅
2. 유틸리티 훅
3. 훅 분류
4.

===================[ DOC: ko/concept/hooks-reference.md ]===================
# concept--hooks-reference

Context-Action React 훅 참조

이 문서는 Context-Action 프레임워크에서 사용 가능한 모든 React 훅을 필수 훅 (핵심 기능)과 유틸리티 훅 (편의 및 최적화)으로 분류합니다. 📋 목차

1. 필수 훅
2. 유틸리티 훅
3. 훅 분류
4. 사용 가이드라인

필수 훅

이 훅들은 Context-Action 프레임워크를 사용하는 데 필수적입니다. 대부분의 애플리케이션에서 이러한 훅이 필요합니다. 🔧 RefContext 훅 (성능)

createRefContext<T>()
고성능 DOM 조작을 위한 모든 ref 관련 훅을 생성하는 팩토리 함수. - 목적: 제로 React 리렌더링으로 타입 안전한 직접 DOM 조작 시스템 생성
- 반환: { Provider, useRefHandler, useWaitForRefs, useGetAllRefs }
- 필수 용도: 성능 중요 UI, 애니메이션, 실시간 상호작용

useRefHandler()
타입 안전한 직접 DOM 조작이 가능한 ref 핸들러에 액세스하는 주요 훅. - 목적: 타입 안전성을 갖춘 특정 DOM 요소의 ref 핸들러 가져오기
- 필수 용도: React 리렌더링 없는 직접 DOM 업데이트
- 패턴: React 재조정을 우회하는 성능 레이어

useWaitForRefs()
작업을 실행하기 전에 여러 ref가 마운트될 때까지 대기하는 유틸리티 훅. - 목적: 여러 DOM 요소가 필요한 작업 조정
- 필수 용도: 복잡한 DOM 초기화 시퀀스
- 패턴: 비동기 ref 조정

🎯 Action 훅 (핵심)

createActionContext<T>()
특정 액션 컨텍스트를 위한 모든 액션 관련 훅을 생성하는 팩토리 함수. - 목적: 타입 안전한 액션 디스패치 및 핸들러 시스템 생성
- 반환: { Provider, useActionDispatch, useActionHandler, useActionRegister }
- 필수 용도: 모든 액션 기반 로직

useActionDispatch()
핸들러로 액션을 디스패치하는 주요 훅. - 목적: 액션을 트리거하는 디스패치 함수 가져오기
- 필수 용도: 비즈니스 로직과의 컴포넌트 상호작용
- 패턴: MVVM 아키텍처의 ViewModel 레이어

useActionHandler()
액션 핸들러를 등록하는 주요 훅. - 목적: 특정 액션에 대한 비즈니스 로직 등록
- 필수 용도: 비즈니스 로직 구현
- 모범 사례: 최적화를 위해 useCallback과 함께 사용

🏪 Store 훅 (핵심)

createDeclarativeStorePattern<T>()
타입 안전성을 갖춘 모든 스토어 관련 훅을 생성하는 팩토리 함수. - 목적: 타입 안전한 스토어 관리 시스템 생성
- 반환: { Provider, useStore, useStoreManager, withProvider }
- 필수 용도: 모든 상태 관리

useStoreValue<T>(store)
스토어 변경사항을 구독하는 주요 훅. - 목적: 스토어에서 반응형 값 가져오기
- 필수 용도: 컴포넌트에서 상태 읽기
- 성능: 실제 값 변경 시에만 리렌더링

useStore(name) (패턴에서)
이름으로 스토어에 액세스하는 주요 훅. - 목적: 컨텍스트에서 스토어 인스턴스 가져오기
- 필수 용도: 컴포넌트에서 스토어 액세스
- 타입 안전: 적절히 타입이 지정된 스토어 반환

유틸리티 훅

이 훅들은 추가 기능, 최적화, 편의 기능을 제공합니다. 🎯 Action 유틸리티 훅

useActionDispatchWithResult()
결과 수집이 필요한 액션을 위한 유틸리티 훅. - 목적: 액션을 디스패치하고 핸들러 결과 수집
- 사용 사례: 핸들러로부터 반환 값이 필요한 경우
- 고급: 핸들러 응답이 필요한 복잡한 워크플로우용

useActionRegister()
ActionRegister 인스턴스에 직접 액세스하는 유틸리티 훅.

===================[ DOC: ko/concept/hooks-reference.md ]===================
# concept--hooks-reference

Context-Action React 훅 참조

이 문서는 Context-Action 프레임워크에서 사용 가능한 모든 React 훅을 필수 훅 (핵심 기능)과 유틸리티 훅 (편의 및 최적화)으로 분류합니다. 📋 목차

1. 필수 훅
2. 유틸리티 훅
3. 훅 분류
4. 사용 가이드라인

필수 훅

이 훅들은 Context-Action 프레임워크를 사용하는 데 필수적입니다. 대부분의 애플리케이션에서 이러한 훅이 필요합니다.

===================[ DOC: ko/concept/hooks-reference.md ]===================
# concept--hooks-reference

Context-Action React 훅 참조

이 문서는 Context-Action 프레임워크에서 사용 가능한 모든 React 훅을 필수 훅 (핵심 기능)과 유틸리티 훅 (편의 및 최적화)으로 분류합니다. 📋 목차

1. 필수 훅
2. 유틸리티 훅
3. 훅 분류
4. 사용 가이드라인

필수 훅

이 훅들은 Context-Action 프레임워크를 사용하는 데 필수적입니다. 대부분의 애플리케이션에서 이러한 훅이 필요합니다. 🔧 RefContext 훅 (성능)

createRefContext<T>()
고성능 DOM 조작을 위한 모든 ref 관련 훅을 생성하는 팩토리 함수.

===================[ DOC: ko/concept/hooks-reference.md ]===================
# concept--hooks-reference

Context-Action React 훅 참조

이 문서는 Context-Action 프레임워크에서 사용 가능한 모든 React 훅을 필수 훅 (핵심 기능)과 유틸리티 훅 (편의 및 최적화)으로 분류합니다. 📋 목차

1. 필수 훅
2. 유틸리티 훅
3. 훅 분류
4. 사용 가이드라인

필수 훅

이 훅들은 Context-Action 프레임워크를 사용하는 데 필수적입니다. 대부분의 애플리케이션에서 이러한 훅이 필요합니다. 🔧 RefContext 훅 (성능)

createRefContext<T>()
고성능 DOM 조작을 위한 모든 ref 관련 훅을 생성하는 팩토리 함수. - 목적: 제로 React 리렌더링으로 타입 안전한 직접 DOM 조작 시스템 생성
- 반환: { Provider, useRefHandler, useWaitForRefs, useGetAllRefs }
- 필수 용도: 성능 중요 UI, 애니메이션, 실시간 상호작용

useRefHandler()
타입 안전한 직접 DOM 조작이 가능한 ref 핸들러에 액세스하는 주요 훅. - 목적: 타입 안전성을 갖춘 특정 DOM 요소의 ref 핸들러 가져오기
- 필수 용도: React 리렌더링 없는 직접 DOM 업데이트
- 패턴: React 재조정을 우회하는 성능 레이어

useWaitForRefs()
작업을 실행하기 전에 여러 ref가 마운트될 때까지 대기하는 유틸리티 훅. - 목적: 여러 DOM 요소가 필요한 작업 조정
- 필수 용도: 복잡한 DOM 초기화 시퀀스
- 패턴: 비동기 ref 조정

🎯 Action 훅 (핵심)

createActionContext<T>()
특정 액션 컨텍스트를 위한 모든 액션 관련 훅을 생성하는 팩토리 함수. - 목적: 타입 안전한 액션 디스패치 및 핸들러 시스템 생성
- 반환: { Provider, useActionDispatch, useActionHandler, useActionRegister }
- 필수 용도: 모든 액션 기반 로직

useActionDispatch()
핸들러로 액션을 디스패치하는 주요 훅. - 목적: 액션을 트리거하는 디스패치 함수 가져오기
- 필수 용도: 비즈니스 로직과의 컴포넌트 상호작용
- 패턴: MVVM 아키텍처의 ViewModel 레이어

useActionHandler()
액션 핸들러를 등록하는 주요 훅. - 목적: 특정 액션에 대한 비즈니스 로직 등록
- 필수 용도: 비즈니스 로직 구현
- 모범 사례: 최적화를 위해 useCallback과 함께 사용

🏪 Store 훅 (핵심)

createDeclarativeStorePattern<T>()
타입 안전성을 갖춘 모든 스토어 관련 훅을 생성하는 팩토리 함수. - 목적: 타입 안전한 스토어 관리 시스템 생성
- 반환: { Provider, useStore, useStoreManager, withProvider }
- 필수 용도: 모든 상태 관리

useStoreValue<T>(store)
스토어 변경사항을 구독하는 주요 훅. - 목적: 스토어에서 반응형 값 가져오기
- 필수 용도: 컴포넌트에서 상태 읽기
- 성능: 실제 값 변경 시에만 리렌더링

useStore(name) (패턴에서)
이름으로 스토어에 액세스하는 주요 훅. - 목적: 컨텍스트에서 스토어 인스턴스 가져오기
- 필수 용도: 컴포넌트에서 스토어 액세스
- 타입 안전: 적절히 타입이 지정된 스토어 반환

유틸리티 훅

이 훅들은 추가 기능, 최적화, 편의 기능을 제공합니다. 🎯 Action 유틸리티 훅

useActionDispatchWithResult()
결과 수집이 필요한 액션을 위한 유틸리티 훅. - 목적: 액션을 디스패치하고 핸들러 결과 수집
- 사용 사례: 핸들러로부터 반환 값이 필요한 경우
- 고급: 핸들러 응답이 필요한 복잡한 워크플로우용

useActionRegister()
ActionRegister 인스턴스에 직접 액세스하는 유틸리티 훅. - 목적: 액션 레지스트리에 대한 고급 제어
- 사용 사례: 동적 핸들러 관리, 디버깅
- 고급: 일반적인 애플리케이션에서는 거의 필요하지 않음

🏪 Store 유틸리티 훅

useStoreSelector<T, R>(store, selector, equalityFn?)
선택적 구독을 위한 성능 훅. - 목적: 스토어의 특정 부분만 구독
- 최적화: 불필요한 리렌더링 방지
- 사용 사례: 일부만 변경되는 큰 객체

useComputedStore<T, R>(store, compute, config?)
계산된 값을 위한 파생 상태 훅. - 목적: 스토어에서 파생 상태 생성
- 최적화: 의존성이 변경될 때만 재계산
- 사용 사례: 계산된 값, 집계

useLocalStore<T>(initialValue, name?)
컴포넌트 로컬 스토어 훅. - 목적: 컴포넌트 라이프사이클에 범위가 지정된 스토어 생성
- 사용 사례: 복잡한 컴포넌트 상태
- 장점: 전역 상태 없이 스토어 API 사용

usePersistedStore<T>(key, initialValue, options?)
브라우저 저장소를 위한 지속성 훅. - 목적: localStorage/sessionStorage와 스토어 자동 동기화
- 사용 사례: 설정, 사용자 기본 설정, 임시 데이터
- 기능: 탭 간 동기화

assertStoreValue<T>(value, storeName)
스토어 값을 위한 타입 어설션 유틸리티. - 목적: undefined가 아닌 값에 대한 런타임 어설션
- 타입 안전: undefined인 경우 오류 발생
- 사용 사례: 스토어에 값이 반드시 있어야 하는 경우

🔧 성능 최적화 훅

useMultiStoreSelector(stores, selector, equalityFn?)
스토어를 결합하는 다중 스토어 선택자. - 목적: 여러 스토어에서 효율적으로 선택
- 최적화: 여러 스토어에 대한 단일 구독
- 사용 사례: 스토어 간 계산된 값

useStorePathSelector(store, path, equalityFn?)
중첩된 객체를 위한 경로 기반 선택자. - 목적: 경로로 중첩된 값 선택
- 편의성: 깊은 선택을 위한 점 표기법
- 사용 사례: 복잡한 중첩 상태

useAsyncComputedStore(asyncCompute, deps, config?)
비동기 계산된 값 훅. - 목적: 비동기적으로 값 계산
- 기능: 로딩 상태, 오류 처리
- 사용 사례: API 파생 상태

훅 분류

도메인별 분류

상태 관리
- 필수: useStoreValue, useStore (패턴에서)
- 유틸리티: useStoreSelector, useComputedStore, useLocalStore

액션 처리
- 필수: useActionDispatch, useActionHandler
- 유틸리티: useActionDispatchWithResult, useActionRegister

DOM 조작 및 성능
- 필수: useRefHandler (RefContext에서)
- 유틸리티: useWaitForRefs, useGetAllRefs

지속성
- 유틸리티: usePersistedStore

고급/메타
- 유틸리티: useActionRegister

사용 빈도별 분류

높은 빈도 (컴포넌트의 80% 이상)
- useStoreValue
- useActionDispatch
- useStore (패턴에서)

중간 빈도 (컴포넌트의 20-80%)
- useActionHandler
- useStoreSelector
- useLocalStore

낮은 빈도 (컴포넌트의 20% 미만)
- useComputedStore
- usePersistedStore
- useActionDispatchWithResult

사용 가이드라인

필수 훅을 사용해야 하는 경우

1. 새로운 기능 시작: 항상 필수 훅부터 시작
2. 기본 CRUD 작업: 필수 훅으로 충분
3. 단순한 상태 관리: useStoreValue + useActionDispatch
4. 표준 비즈니스 로직: 로직 구현을 위한 useActionHandler

유틸리티 훅을 사용해야 하는 경우

1. 성능 문제: 최적화를 위한 선택자 훅 사용
2. 복잡한 상태 파생: useComputedStore 사용
3. 브라우저 저장소 필요: usePersistedStore 사용
4. 컴포넌트 로컬 복잡 상태: useLocalStore 사용
5. 고급 워크플로우: 결과 수집 훅 사용
6. 메타 프로그래밍: 레지스트리 훅 사용

모범 사례

필수 훅 패턴

유틸리티 훅 패턴

마이그레이션 경로

새로운 프로젝트의 경우:
1. 필수 훅만으로 시작
2. 필요에 따라 유틸리티 훅 추가
3. 최적화를 위해 유틸리티 훅으로 리팩터링

기존 프로젝트의 경우:
1. 기존 패턴 유지
2. 새로운 기능에 점진적으로 유틸리티 훅 채택
3. 성능이 중요한 영역을 선택자 훅으로 리팩터링

추가 훅 및 유틸리티

🔍 컨텍스트 훅

useStoreContext()
스토어 컨텍스트에 직접 액세스하는 저수준 컨텍스트 훅. - 목적: 스토어 컨텍스트 내부에 직접 액세스
- 사용 사례: 커스텀 스토어 패턴, 디버깅
- 고급: 애플리케이션에서는 거의 필요하지 않음

📊 다중 스토어 훅

useStoreValues<T, S>(store, selectors)
한 번에 여러 값을 추출하는 다중 선택자 훅. - 목적: 단일 구독으로 여러 값 추출
- 성능: 여러 useStoreValue 호출보다 효율적
- 사용 사례: 여러 파생 값이 필요한 컴포넌트

useMultiStoreSelector<R>(stores, selector, equalityFn?)
여러 스토어를 결합하는 스토어 간 선택자. - 목적: 여러 스토어에서 값 계산
- 성능: 모든 스토어에 대한 단일 구독
- 사용 사례: 스토어 간 계산된 값

useMultiComputedStore<R>(stores, compute, config?)
복잡한 파생을 위한 다중 스토어 계산 훅.

===================[ DOC: ko/concept/pattern-guide.md ]===================
# concept--pattern-guide

@context-action/react 패턴 가이드

@context-action/react 프레임워크에서 사용 가능한 세 가지 주요 패턴의 완전한 가이드입니다.

===================[ DOC: ko/concept/pattern-guide.md ]===================
# concept--pattern-guide

@context-action/react 패턴 가이드

@context-action/react 프레임워크에서 사용 가능한 세 가지 주요 패턴의 완전한 가이드입니다. 📋 빠른 시작 가이드

사용 사례에 맞는 적합한 패턴을 선택하세요:

| 패턴 | 사용 사례 | 임포트 | 최적용도 |
|---------|----------|--------|----------|
| 🎯 Action Only | 스토어 없이 액션 디스패칭 | createActionContext | 이벤트 시스템, 커맨드 패턴 |
| 🏪 Store Only | 액션 없이 상태 관리 | createDeclarativeStorePattern | 순수 상태 관리, 데이터 레이어 |
| 🔧 Ref Context | 제로 리렌더링 직접 DOM 조작 | createRefContext | 고성능 UI, 애니메이션, 실시간 인터랙션 |

참고: 복잡한 애플리케이션의 경우, 최대한의 유연성과 관심사 분리를 위해 패턴들을 조합하여 사용하세요. ---

🎯 Action Only 패턴

언제 사용: 상태 관리 없이 순수 액션 디스패칭 (이벤트 시스템, 커맨드 패턴). 임포트

기능
- ✅ 타입 안전한 액션 디스패칭
- ✅ 액션 핸들러 등록
- ✅ 중단 지원
- ✅ 결과 처리
- ✅ 경량 (스토어 오버헤드 없음)

기본 사용법

🏪 Store Only 패턴

언제 사용: 액션 디스패칭 없이 순수 상태 관리 (데이터 레이어, 단순 상태).

===================[ DOC: ko/concept/pattern-guide.md ]===================
# concept--pattern-guide

@context-action/react 패턴 가이드

@context-action/react 프레임워크에서 사용 가능한 세 가지 주요 패턴의 완전한 가이드입니다.

===================[ DOC: ko/concept/pattern-guide.md ]===================
# concept--pattern-guide

@context-action/react 패턴 가이드

@context-action/react 프레임워크에서 사용 가능한 세 가지 주요 패턴의 완전한 가이드입니다. 📋 빠른 시작 가이드

사용 사례에 맞는 적합한 패턴을 선택하세요:

| 패턴 | 사용 사례 | 임포트 | 최적용도 |
|---------|----------|--------|----------|
| 🎯 Action Only | 스토어 없이 액션 디스패칭 | createActionContext | 이벤트 시스템, 커맨드 패턴 |
| 🏪 Store Only | 액션 없이 상태 관리 | createDeclarativeStorePattern | 순수 상태 관리, 데이터 레이어 |
| 🔧 Ref Context | 제로 리렌더링 직접 DOM 조작 | createRefContext | 고성능 UI, 애니메이션, 실시간 인터랙션 |

참고: 복잡한 애플리케이션의 경우, 최대한의 유연성과 관심사 분리를 위해 패턴들을 조합하여 사용하세요. ---

🎯 Action Only 패턴

언제 사용: 상태 관리 없이 순수 액션 디스패칭 (이벤트 시스템, 커맨드 패턴). 임포트

기능
- ✅ 타입 안전한 액션 디스패칭
- ✅ 액션 핸들러 등록
- ✅ 중단 지원
- ✅ 결과 처리
- ✅ 경량 (스토어 오버헤드 없음)

기본 사용법

🏪 Store Only 패턴

언제 사용: 액션 디스패칭 없이 순수 상태 관리 (데이터 레이어, 단순 상태). 임포트

기능
- ✅ 뛰어난 타입 추론 (수동 타입 어노테이션 불필요)
- ✅ 스토어 관리에 집중된 단순화된 API
- ✅ 직접 값 또는 설정 객체 지원
- ✅ HOC 패턴 지원

기본 사용법

사용 가능한 훅
- useStore(name) - 이름으로 타입화된 스토어 가져오기 (주 API)
- useStoreManager() - 스토어 관리자 액세스 (고급 사용)
- useStoreInfo() - 레지스트리 정보 가져오기
- useStoreClear() - 모든 스토어 지우기

🔧 Ref Context 패턴

언제 사용하나요: 제로 React 리렌더링으로 직접 DOM 조작 (고성능 UI, 애니메이션, 실시간 인터랙션). 임포트

특징
- ✅ DOM 조작을 위한 제로 React 리렌더링
- ✅ 하드웨어 가속 변환
- ✅ 타입 안전한 ref 관리
- ✅ 자동 생명주기 관리
- ✅ 완벽한 관심사 분리
- ✅ 자동 정리를 통한 메모리 효율성

기본 사용법

커스텀 훅을 사용한 고급 RefContext

사용 가능한 훅
- useRefHandler(name) - 이름으로 타입화된 ref 핸들러 가져오기
- useWaitForRefs() - 여러 ref가 마운트될 때까지 대기
- useGetAllRefs() - 마운트된 모든 ref 액세스
- refHandler.setRef - ref 콜백 설정
- refHandler.target - 현재 ref 값 액세스
- refHandler.isMounted - 마운트 상태 확인
- refHandler.waitForMount() - 비동기 ref 대기
- refHandler.withTarget() - 안전한 작업

🔧 패턴 조합

복잡한 애플리케이션의 경우, 최대한의 유연성을 위해 세 패턴을 모두 조합하세요:

마이그레이션 가이드

기존 패턴에서 새로운 패턴으로

기존의 복잡한 패턴들을 새로운 단순한 두 패턴으로 마이그레이션하는 방법:

1. Action Only로 마이그레이션: 상태가 없는 이벤트/커맨드 처리
2. Store Only로 마이그레이션: 순수 상태 관리
3. 패턴 조합: 복잡한 비즈니스 로직

📚 모범 사례

1. 패턴 선택
- 간단한 상태 관리는 Store Only로 시작
- 부수 효과나 복잡한 워크플로가 필요하면 Action Only 추가
- 고성능 DOM 조작이 필요하면 RefContext 추가
- 완전한 기능의 애플리케이션은 세 패턴 모두 조합

2.

===================[ DOC: ko/concept/pattern-guide.md ]===================
# concept--pattern-guide

@context-action/react 패턴 가이드

@context-action/react 프레임워크에서 사용 가능한 세 가지 주요 패턴의 완전한 가이드입니다.

===================[ DOC: ko/concept/pattern-guide.md ]===================
# concept--pattern-guide

@context-action/react 패턴 가이드

@context-action/react 프레임워크에서 사용 가능한 세 가지 주요 패턴의 완전한 가이드입니다.

===================[ DOC: ko/concept/pattern-guide.md ]===================
# concept--pattern-guide

@context-action/react 패턴 가이드

@context-action/react 프레임워크에서 사용 가능한 세 가지 주요 패턴의 완전한 가이드입니다. 📋 빠른 시작 가이드

사용 사례에 맞는 적합한 패턴을 선택하세요:

| 패턴 | 사용 사례 | 임포트 | 최적용도 |
|---------|----------|--------|----------|
| 🎯 Action Only | 스토어 없이 액션 디스패칭 | createActionContext | 이벤트 시스템, 커맨드 패턴 |
| 🏪 Store Only | 액션 없이 상태 관리 | createDeclarativeStorePattern | 순수 상태 관리, 데이터 레이어 |
| 🔧 Ref Context | 제로 리렌더링 직접 DOM 조작 | createRefContext | 고성능 UI, 애니메이션, 실시간 인터랙션 |

참고: 복잡한 애플리케이션의 경우, 최대한의 유연성과 관심사 분리를 위해 패턴들을 조합하여 사용하세요. ---

🎯 Action Only 패턴

언제 사용: 상태 관리 없이 순수 액션 디스패칭 (이벤트 시스템, 커맨드 패턴). 임포트

기능
- ✅ 타입 안전한 액션 디스패칭
- ✅ 액션 핸들러 등록
- ✅ 중단 지원
- ✅ 결과 처리
- ✅ 경량 (스토어 오버헤드 없음)

기본 사용법

🏪 Store Only 패턴

언제 사용: 액션 디스패칭 없이 순수 상태 관리 (데이터 레이어, 단순 상태). 임포트

기능
- ✅ 뛰어난 타입 추론 (수동 타입 어노테이션 불필요)
- ✅ 스토어 관리에 집중된 단순화된 API
- ✅ 직접 값 또는 설정 객체 지원
- ✅ HOC 패턴 지원

기본 사용법

사용 가능한 훅
- useStore(name) - 이름으로 타입화된 스토어 가져오기 (주 API)
- useStoreManager() - 스토어 관리자 액세스 (고급 사용)
- useStoreInfo() - 레지스트리 정보 가져오기
- useStoreClear() - 모든 스토어 지우기

🔧 Ref Context 패턴

언제 사용하나요: 제로 React 리렌더링으로 직접 DOM 조작 (고성능 UI, 애니메이션, 실시간 인터랙션). 임포트

특징
- ✅ DOM 조작을 위한 제로 React 리렌더링
- ✅ 하드웨어 가속 변환
- ✅ 타입 안전한 ref 관리
- ✅ 자동 생명주기 관리
- ✅ 완벽한 관심사 분리
- ✅ 자동 정리를 통한 메모리 효율성

기본 사용법

커스텀 훅을 사용한 고급 RefContext

사용 가능한 훅
- useRefHandler(name) - 이름으로 타입화된 ref 핸들러 가져오기
- useWaitForRefs() - 여러 ref가 마운트될 때까지 대기
- useGetAllRefs() - 마운트된 모든 ref 액세스
- refHandler.setRef - ref 콜백 설정
- refHandler.target - 현재 ref 값 액세스
- refHandler.isMounted - 마운트 상태 확인
- refHandler.waitForMount() - 비동기 ref 대기
- refHandler.withTarget() - 안전한 작업

🔧 패턴 조합

복잡한 애플리케이션의 경우, 최대한의 유연성을 위해 세 패턴을 모두 조합하세요:

마이그레이션 가이드

기존 패턴에서 새로운 패턴으로

기존의 복잡한 패턴들을 새로운 단순한 두 패턴으로 마이그레이션하는 방법:

1. Action Only로 마이그레이션: 상태가 없는 이벤트/커맨드 처리
2. Store Only로 마이그레이션: 순수 상태 관리
3. 패턴 조합: 복잡한 비즈니스 로직

📚 모범 사례

1. 패턴 선택
- 간단한 상태 관리는 Store Only로 시작
- 부수 효과나 복잡한 워크플로가 필요하면 Action Only 추가
- 고성능 DOM 조작이 필요하면 RefContext 추가
- 완전한 기능의 애플리케이션은 세 패턴 모두 조합

2. 명명 규칙
- 설명적인 컨텍스트 이름 사용: UserActions, AppStores, MouseRefs
- 명확성을 위해 내보낸 훅 이름 변경: useUserAction, useAppStore, useMouseRef
- 스토어 이름은 간단하게 유지: user, counter, settings
- 도메인별 ref 이름 사용: cursor, modal, canvas

3. 성능
- Store 패턴: 대용량 데이터셋에는 strategy: 'reference', 객체에는 'shallow', 필요할 때만 'deep' 사용
- RefContext 패턴: 하드웨어 가속을 위해 translate3d() 사용, DOM 업데이트 배치, React 리렌더링 방지
- Action 패턴: 핸들러를 가볍게 유지, 무거운 작업에는 async 사용

4. 타입 안전성
- 액션: 액션에 명시적 인터페이스 사용 (ActionPayloadMap 선택사항)
- 스토어: TypeScript가 스토어 타입을 추론하게 하거나 명시적 제네릭 사용
- Refs: 적절한 HTML 요소 타입으로 명확한 ref 타입 인터페이스 정의
- 모든 패턴에서 리터럴 타입에 as const 사용

5. 관심사 분리
- 액션: 부수 효과, 비즈니스 로직, 조정 처리
- 스토어: 애플리케이션 상태와 데이터 관리
- RefContext: DOM 조작과 성능 중요 UI 처리
- 각 패턴을 특정 책임에 집중시키기

🔍 예시

각 패턴의 완전한 작업 예시는 examples/ 디렉토리를 참조하세요.

===================[ DOC: ko/concept/react-refs-guide.md ]===================
# concept--react-refs-guide

React Refs 가이드

Context-Action의 RefContext는 제로 React 리렌더링으로 고성능 DOM 조작을 위한 현대적 접근법을 제공합니다.

===================[ DOC: ko/concept/react-refs-guide.md ]===================
# concept--react-refs-guide

React Refs 가이드

Context-Action의 RefContext는 제로 React 리렌더링으로 고성능 DOM 조작을 위한 현대적 접근법을 제공합니다. RefContext란 무엇인가요. RefContext는 React 상태 업데이트를 거치지 않고 DOM 요소에 직접 접근하고 조작할 수 있게 해주는 고성능 패턴입니다. 이는 실시간 인터랙션, 애니메이션, 캔버스 작업과 같이 60fps 성능이 중요한 시나리오에서 완벽합니다. 주요 특징

- 제로 리렌더링: DOM 업데이트가 React 리렌더링을 발생시키지 않음
- 타입 안전성: 완전한 TypeScript 지원으로 엄격한 타입 검사
- 하드웨어 가속: GPU 가속을 위한 translate3d() 변환 내장
- 분리된 비즈니스 로직: DOM 조작과 비즈니스 로직의 깔끔한 분리

기본 사용법

간단한 RefContext 생성

컴포넌트에서 사용

실제 예시: 마우스 이벤트 처리

다음은 관심사 분리를 보여주는 완전한 마우스 추적 시스템입니다:

고급 패턴

Ref 대기 및 검증

성능 최적화 패턴

패턴 통합

Actions + Stores + RefContext

모범 사례

1. 항상 Ref 존재 확인

2. GPU 가속 사용

3. 메모리 정리

4. 비즈니스 로직과 DOM 조작 분리

언제 RefContext를 사용할까요. ✅ 적합한 경우:
- 실시간 마우스/터치 인터랙션
- 60fps 애니메이션
- 캔버스 조작
- 드래그 앤 드롭
- 게임 UI 요소
- 미디어 플레이어 컨트롤

❌ 부적합한 경우:
- 간단한 상태 표시
- 폼 입력 처리
- 목록 렌더링
- 일반적인 UI 상태 관리

RefContext는 성능이 중요한 특정 사용 사례를 위한 강력한 도구입니다. 일반적인 React 상태 관리와 결합하면 고성능과 개발자 경험 모두를 달성할 수 있습니다.

===================[ DOC: ko/concept/react-refs-guide.md ]===================
# concept--react-refs-guide

React Refs 가이드

Context-Action의 RefContext는 제로 React 리렌더링으로 고성능 DOM 조작을 위한 현대적 접근법을 제공합니다. RefContext란 무엇인가요. RefContext는 React 상태 업데이트를 거치지 않고 DOM 요소에 직접 접근하고 조작할 수 있게 해주는 고성능 패턴입니다.

===================[ DOC: ko/concept/react-refs-guide.md ]===================
# concept--react-refs-guide

React Refs 가이드

Context-Action의 RefContext는 제로 React 리렌더링으로 고성능 DOM 조작을 위한 현대적 접근법을 제공합니다. RefContext란 무엇인가요. RefContext는 React 상태 업데이트를 거치지 않고 DOM 요소에 직접 접근하고 조작할 수 있게 해주는 고성능 패턴입니다. 이는 실시간 인터랙션, 애니메이션, 캔버스 작업과 같이 60fps 성능이 중요한 시나리오에서 완벽합니다. 주요 특징

- 제로 리렌더링: DOM 업데이트가 React 리렌더링을 발생시키지 않음
- 타입 안전성: 완전한 TypeScript 지원으로 엄격한 타입 검사
- 하드웨어 가속: GPU 가속을 위한 translate3d() 변환 내장
- 분리된 비즈니스 로직: DOM 조작과 비즈니스 로직의 깔끔한 분리

기본 사용법

간단한 RefContext 생성

컴포넌트에서 사용

실제 예시: 마우스 이벤트 처리

다음은 관심사 분리를 보여주는 완전한 마우스 추적 시스템입니다:

고급 패턴

Ref 대기 및 검증

성능 최적화 패턴

패턴 통합

Actions + Stores + RefContext

모범 사례

1. 항상 Ref 존재 확인

2. GPU 가속 사용

3. 메모리 정리

4. 비즈니스 로직과 DOM 조작 분리

언제 RefContext를 사용할까요. ✅ 적합한 경우:
- 실시간 마우스/터치 인터랙션
- 60fps 애니메이션
- 캔버스 조작
- 드래그 앤 드롭
- 게임 UI 요소
- 미디어 플레이어 컨트롤

❌ 부적합한 경우:
- 간단한 상태 표시
- 폼 입력 처리
- 목록 렌더링
- 일반적인 UI 상태 관리

RefContext는 성능이 중요한 특정 사용 사례를 위한 강력한 도구입니다. 일반적인 React 상태 관리와 결합하면 고성능과 개발자 경험 모두를 달성할 수 있습니다.

===================[ DOC: ko/concept/react-refs-guide.md ]===================
# concept--react-refs-guide

React Refs 가이드

Context-Action의 RefContext는 제로 React 리렌더링으로 고성능 DOM 조작을 위한 현대적 접근법을 제공합니다. RefContext란 무엇인가요. RefContext는 React 상태 업데이트를 거치지 않고 DOM 요소에 직접 접근하고 조작할 수 있게 해주는 고성능 패턴입니다. 이는 실시간 인터랙션, 애니메이션, 캔버스 작업과 같이 60fps 성능이 중요한 시나리오에서 완벽합니다.

===================[ DOC: ko/concept/react-refs-guide.md ]===================
# concept--react-refs-guide

React Refs 가이드

Context-Action의 RefContext는 제로 React 리렌더링으로 고성능 DOM 조작을 위한 현대적 접근법을 제공합니다. RefContext란 무엇인가요. RefContext는 React 상태 업데이트를 거치지 않고 DOM 요소에 직접 접근하고 조작할 수 있게 해주는 고성능 패턴입니다. 이는 실시간 인터랙션, 애니메이션, 캔버스 작업과 같이 60fps 성능이 중요한 시나리오에서 완벽합니다.

===================[ DOC: ko/concept/react-refs-guide.md ]===================
# concept--react-refs-guide

React Refs 가이드

Context-Action의 RefContext는 제로 React 리렌더링으로 고성능 DOM 조작을 위한 현대적 접근법을 제공합니다. RefContext란 무엇인가요. RefContext는 React 상태 업데이트를 거치지 않고 DOM 요소에 직접 접근하고 조작할 수 있게 해주는 고성능 패턴입니다. 이는 실시간 인터랙션, 애니메이션, 캔버스 작업과 같이 60fps 성능이 중요한 시나리오에서 완벽합니다. 주요 특징

- 제로 리렌더링: DOM 업데이트가 React 리렌더링을 발생시키지 않음
- 타입 안전성: 완전한 TypeScript 지원으로 엄격한 타입 검사
- 하드웨어 가속: GPU 가속을 위한 translate3d() 변환 내장
- 분리된 비즈니스 로직: DOM 조작과 비즈니스 로직의 깔끔한 분리

기본 사용법

간단한 RefContext 생성

컴포넌트에서 사용

실제 예시: 마우스 이벤트 처리

다음은 관심사 분리를 보여주는 완전한 마우스 추적 시스템입니다:

고급 패턴

Ref 대기 및 검증

성능 최적화 패턴

패턴 통합

Actions + Stores + RefContext

모범 사례

1. 항상 Ref 존재 확인

2. GPU 가속 사용

3. 메모리 정리

4. 비즈니스 로직과 DOM 조작 분리

언제 RefContext를 사용할까요. ✅ 적합한 경우:
- 실시간 마우스/터치 인터랙션
- 60fps 애니메이션
- 캔버스 조작
- 드래그 앤 드롭
- 게임 UI 요소
- 미디어 플레이어 컨트롤

❌ 부적합한 경우:
- 간단한 상태 표시
- 폼 입력 처리
- 목록 렌더링
- 일반적인 UI 상태 관리

RefContext는 성능이 중요한 특정 사용 사례를 위한 강력한 도구입니다. 일반적인 React 상태 관리와 결합하면 고성능과 개발자 경험 모두를 달성할 수 있습니다.

===================[ DOC: ko/example/action-only.md ]===================
# examples--action-only

Action Only 패턴 예제

상태 관리 없이 순수 액션 디스패칭을 위한 Action Only 패턴의 실제 사용 예제입니다.

===================[ DOC: ko/example/action-only.md ]===================
# examples--action-only

Action Only 패턴 예제

상태 관리 없이 순수 액션 디스패칭을 위한 Action Only 패턴의 실제 사용 예제입니다. 사용 사례

Action Only 패턴은 다음과 같은 경우에 적합합니다:
- 이벤트 추적 및 분석
- 로깅 시스템
- API 호출 (상태 변경 없이)
- 알림 시스템
- 커맨드 패턴 구현

기본 설정

이벤트 추적 시스템

알림 시스템

API 호출 시스템

컴포넌트에서 사용

앱 설정

결과 수집 사용

주요 특징

1. 상태 없음: 순수 사이드 이펙트만 처리
2. 이벤트 기반: 액션 디스패치를 통한 이벤트 처리
3. 분리된 관심사: 각 액션 컨텍스트가 특정 도메인 담당
4. 비동기 지원: async/await를 통한 비동기 작업 처리
5. 에러 처리: 적절한 에러 처리 및 복구

Action Only 패턴은 상태 관리 없이 비즈니스 로직을 깔끔하게 분리하는 강력한 도구입니다.

===================[ DOC: ko/example/action-only.md ]===================
# examples--action-only

Action Only 패턴 예제

상태 관리 없이 순수 액션 디스패칭을 위한 Action Only 패턴의 실제 사용 예제입니다.

===================[ DOC: ko/example/action-only.md ]===================
# examples--action-only

Action Only 패턴 예제

상태 관리 없이 순수 액션 디스패칭을 위한 Action Only 패턴의 실제 사용 예제입니다. 사용 사례

Action Only 패턴은 다음과 같은 경우에 적합합니다:
- 이벤트 추적 및 분석
- 로깅 시스템
- API 호출 (상태 변경 없이)
- 알림 시스템
- 커맨드 패턴 구현

기본 설정

이벤트 추적 시스템

알림 시스템

API 호출 시스템

컴포넌트에서 사용

앱 설정

결과 수집 사용

주요 특징

1. 상태 없음: 순수 사이드 이펙트만 처리
2. 이벤트 기반: 액션 디스패치를 통한 이벤트 처리
3. 분리된 관심사: 각 액션 컨텍스트가 특정 도메인 담당
4. 비동기 지원: async/await를 통한 비동기 작업 처리
5. 에러 처리: 적절한 에러 처리 및 복구

Action Only 패턴은 상태 관리 없이 비즈니스 로직을 깔끔하게 분리하는 강력한 도구입니다.

===================[ DOC: ko/example/action-only.md ]===================
# examples--action-only

Action Only 패턴 예제

상태 관리 없이 순수 액션 디스패칭을 위한 Action Only 패턴의 실제 사용 예제입니다. 사용 사례

Action Only 패턴은 다음과 같은 경우에 적합합니다:
- 이벤트 추적 및 분석
- 로깅 시스템
- API 호출 (상태 변경 없이)
- 알림 시스템
- 커맨드 패턴 구현

기본 설정

이벤트 추적 시스템

알림 시스템

API 호출 시스템

컴포넌트에서 사용

앱 설정

결과 수집 사용

주요 특징

1. 상태 없음: 순수 사이드 이펙트만 처리
2.

===================[ DOC: ko/example/action-only.md ]===================
# examples--action-only

Action Only 패턴 예제

상태 관리 없이 순수 액션 디스패칭을 위한 Action Only 패턴의 실제 사용 예제입니다. 사용 사례

Action Only 패턴은 다음과 같은 경우에 적합합니다:
- 이벤트 추적 및 분석
- 로깅 시스템
- API 호출 (상태 변경 없이)
- 알림 시스템
- 커맨드 패턴 구현

기본 설정

이벤트 추적 시스템

알림 시스템

API 호출 시스템

컴포넌트에서 사용

앱 설정

결과 수집 사용

주요 특징

1. 상태 없음: 순수 사이드 이펙트만 처리
2. 이벤트 기반: 액션 디스패치를 통한 이벤트 처리
3. 분리된 관심사: 각 액션 컨텍스트가 특정 도메인 담당
4. 비동기 지원: async/await를 통한 비동기 작업 처리
5. 에러 처리: 적절한 에러 처리 및 복구

Action Only 패턴은 상태 관리 없이 비즈니스 로직을 깔끔하게 분리하는 강력한 도구입니다.

===================[ DOC: ko/example/action-only.md ]===================
# examples--action-only

Action Only 패턴 예제

상태 관리 없이 순수 액션 디스패칭을 위한 Action Only 패턴의 실제 사용 예제입니다. 사용 사례

Action Only 패턴은 다음과 같은 경우에 적합합니다:
- 이벤트 추적 및 분석
- 로깅 시스템
- API 호출 (상태 변경 없이)
- 알림 시스템
- 커맨드 패턴 구현

기본 설정

이벤트 추적 시스템

알림 시스템

API 호출 시스템

컴포넌트에서 사용

앱 설정

결과 수집 사용

주요 특징

1. 상태 없음: 순수 사이드 이펙트만 처리
2. 이벤트 기반: 액션 디스패치를 통한 이벤트 처리
3. 분리된 관심사: 각 액션 컨텍스트가 특정 도메인 담당
4. 비동기 지원: async/await를 통한 비동기 작업 처리
5. 에러 처리: 적절한 에러 처리 및 복구

Action Only 패턴은 상태 관리 없이 비즈니스 로직을 깔끔하게 분리하는 강력한 도구입니다.

===================[ DOC: ko/example/basic-setup.md ]===================
# examples--basic-setup

기본 설정

이 예제는 Action Only와 Store Only 패턴을 모두 사용한 Context-Action 프레임워크의 기본 설정을 보여줍니다.

===================[ DOC: ko/example/basic-setup.md ]===================
# examples--basic-setup

기본 설정

이 예제는 Action Only와 Store Only 패턴을 모두 사용한 Context-Action 프레임워크의 기본 설정을 보여줍니다. 설치

먼저 필요한 패키지를 설치하세요:

프로젝트 구조

단계 1: 액션 타입 정의

액션을 위한 타입 정의를 생성하세요:

단계 2: 액션 컨텍스트 생성

비즈니스 로직을 위한 Action Only 패턴을 설정하세요:

단계 3: 스토어 패턴 생성

상태 관리를 위한 Store Only 패턴을 설정하세요:

단계 4: 메인 앱 컴포넌트

Provider들을 조합하여 메인 앱을 생성하세요:

단계 5: 사용자 프로필 컴포넌트

액션과 스토어를 모두 사용하는 컴포넌트:

단계 6: 이벤트 로거 컴포넌트

이벤트 추적을 위한 Action Only 패턴 사용:

주요 포인트

1. 패턴 분리: Action Only는 비즈니스 로직, Store Only는 상태 관리
2. 타입 안전성: TypeScript로 완전한 타입 안전성 확보
3. 도메인별 리네이밍: 명확한 컨텍스트 분리를 위한 훅 리네이밍
4. 패턴 조합: 복잡한 애플리케이션을 위한 패턴 조합
5. 최적화: useCallback을 사용한 핸들러 최적화

이 기본 설정을 바탕으로 더 복잡한 애플리케이션을 구축할 수 있습니다.

===================[ DOC: ko/example/basic-setup.md ]===================
# examples--basic-setup

기본 설정

이 예제는 Action Only와 Store Only 패턴을 모두 사용한 Context-Action 프레임워크의 기본 설정을 보여줍니다.

===================[ DOC: ko/example/basic-setup.md ]===================
# examples--basic-setup

기본 설정

이 예제는 Action Only와 Store Only 패턴을 모두 사용한 Context-Action 프레임워크의 기본 설정을 보여줍니다. 설치

먼저 필요한 패키지를 설치하세요:

프로젝트 구조

단계 1: 액션 타입 정의

액션을 위한 타입 정의를 생성하세요:

단계 2: 액션 컨텍스트 생성

비즈니스 로직을 위한 Action Only 패턴을 설정하세요:

단계 3: 스토어 패턴 생성

상태 관리를 위한 Store Only 패턴을 설정하세요:

단계 4: 메인 앱 컴포넌트

Provider들을 조합하여 메인 앱을 생성하세요:

단계 5: 사용자 프로필 컴포넌트

액션과 스토어를 모두 사용하는 컴포넌트:

단계 6: 이벤트 로거 컴포넌트

이벤트 추적을 위한 Action Only 패턴 사용:

주요 포인트

1. 패턴 분리: Action Only는 비즈니스 로직, Store Only는 상태 관리
2. 타입 안전성: TypeScript로 완전한 타입 안전성 확보
3. 도메인별 리네이밍: 명확한 컨텍스트 분리를 위한 훅 리네이밍
4. 패턴 조합: 복잡한 애플리케이션을 위한 패턴 조합
5. 최적화: useCallback을 사용한 핸들러 최적화

이 기본 설정을 바탕으로 더 복잡한 애플리케이션을 구축할 수 있습니다.

===================[ DOC: ko/example/basic-setup.md ]===================
# examples--basic-setup

기본 설정

이 예제는 Action Only와 Store Only 패턴을 모두 사용한 Context-Action 프레임워크의 기본 설정을 보여줍니다.

===================[ DOC: ko/example/basic-setup.md ]===================
# examples--basic-setup

기본 설정

이 예제는 Action Only와 Store Only 패턴을 모두 사용한 Context-Action 프레임워크의 기본 설정을 보여줍니다. 설치

먼저 필요한 패키지를 설치하세요:

프로젝트 구조

단계 1: 액션 타입 정의

액션을 위한 타입 정의를 생성하세요:

단계 2: 액션 컨텍스트 생성

비즈니스 로직을 위한 Action Only 패턴을 설정하세요:

단계 3: 스토어 패턴 생성

상태 관리를 위한 Store Only 패턴을 설정하세요:

단계 4: 메인 앱 컴포넌트

Provider들을 조합하여 메인 앱을 생성하세요:

단계 5: 사용자 프로필 컴포넌트

액션과 스토어를 모두 사용하는 컴포넌트:

단계 6: 이벤트 로거 컴포넌트

이벤트 추적을 위한 Action Only 패턴 사용:

주요 포인트

1. 패턴 분리: Action Only는 비즈니스 로직, Store Only는 상태 관리
2.

===================[ DOC: ko/example/basic-setup.md ]===================
# examples--basic-setup

기본 설정

이 예제는 Action Only와 Store Only 패턴을 모두 사용한 Context-Action 프레임워크의 기본 설정을 보여줍니다. 설치

먼저 필요한 패키지를 설치하세요:

프로젝트 구조

단계 1: 액션 타입 정의

액션을 위한 타입 정의를 생성하세요:

단계 2: 액션 컨텍스트 생성

비즈니스 로직을 위한 Action Only 패턴을 설정하세요:

단계 3: 스토어 패턴 생성

상태 관리를 위한 Store Only 패턴을 설정하세요:

단계 4: 메인 앱 컴포넌트

Provider들을 조합하여 메인 앱을 생성하세요:

단계 5: 사용자 프로필 컴포넌트

액션과 스토어를 모두 사용하는 컴포넌트:

단계 6: 이벤트 로거 컴포넌트

이벤트 추적을 위한 Action Only 패턴 사용:

주요 포인트

1. 패턴 분리: Action Only는 비즈니스 로직, Store Only는 상태 관리
2. 타입 안전성: TypeScript로 완전한 타입 안전성 확보
3. 도메인별 리네이밍: 명확한 컨텍스트 분리를 위한 훅 리네이밍
4. 패턴 조합: 복잡한 애플리케이션을 위한 패턴 조합
5. 최적화: useCallback을 사용한 핸들러 최적화

이 기본 설정을 바탕으로 더 복잡한 애플리케이션을 구축할 수 있습니다.

===================[ DOC: ko/example/element-management.md ]===================
# examples--element-management

DOM Element 관리

Context-Action 프레임워크를 사용한 포괄적인 DOM element 관리 고급 예제입니다.

===================[ DOC: ko/example/element-management.md ]===================
# examples--element-management

DOM Element 관리

Context-Action 프레임워크를 사용한 포괄적인 DOM element 관리 고급 예제입니다. 개요

이 예제는 Context-Action의 Action Pipeline과 Store Pattern을 활용하여 React와 Core 패키지에서 DOM element를 효과적으로 관리하는 방법을 보여줍니다:

- 중앙화된 Element Registry: 모든 DOM element를 중앙에서 관리
- Type-safe Element Management: TypeScript를 활용한 타입 안전성
- Reactive State Management: Element 상태 변경에 대한 실시간 반응
- Lifecycle Management: Element 등록/해제의 자동화
- Focus & Selection Management: 포커스와 선택 상태 관리

주요 기능

Core 패키지 기능
- ElementManager 클래스: 중앙화된 DOM element 생명주기 관리
- Action 기반 API: 모든 element 작업이 action pipeline을 통해 수행
- 자동 정리: DOM에서 제거된 element들의 주기적 정리
- Type-safe 관리: TypeScript를 활용한 완전한 타입 안전성

React 패키지 기능
- useElementRef Hook: Element 자동 등록을 위한 hook
- Focus 관리: useFocusedElement hook으로 포커스 상태 관리
- Selection 관리: useElementSelection hook으로 다중 선택 지원
- Type별 조회: useElementsByType으로 타입별 element 조회
- Managed Components: 자동으로 등록되는 ManagedInput, ManagedButton 컴포넌트

기본 사용법

1. 설정

2. Element 등록 및 관리

3. Focus 관리

4.

===================[ DOC: ko/example/element-management.md ]===================
# examples--element-management

DOM Element 관리

Context-Action 프레임워크를 사용한 포괄적인 DOM element 관리 고급 예제입니다.

===================[ DOC: ko/example/element-management.md ]===================
# examples--element-management

DOM Element 관리

Context-Action 프레임워크를 사용한 포괄적인 DOM element 관리 고급 예제입니다. 개요

이 예제는 Context-Action의 Action Pipeline과 Store Pattern을 활용하여 React와 Core 패키지에서 DOM element를 효과적으로 관리하는 방법을 보여줍니다:

- 중앙화된 Element Registry: 모든 DOM element를 중앙에서 관리
- Type-safe Element Management: TypeScript를 활용한 타입 안전성
- Reactive State Management: Element 상태 변경에 대한 실시간 반응
- Lifecycle Management: Element 등록/해제의 자동화
- Focus & Selection Management: 포커스와 선택 상태 관리

주요 기능

Core 패키지 기능
- ElementManager 클래스: 중앙화된 DOM element 생명주기 관리
- Action 기반 API: 모든 element 작업이 action pipeline을 통해 수행
- 자동 정리: DOM에서 제거된 element들의 주기적 정리
- Type-safe 관리: TypeScript를 활용한 완전한 타입 안전성

React 패키지 기능
- useElementRef Hook: Element 자동 등록을 위한 hook
- Focus 관리: useFocusedElement hook으로 포커스 상태 관리
- Selection 관리: useElementSelection hook으로 다중 선택 지원
- Type별 조회: useElementsByType으로 타입별 element 조회
- Managed Components: 자동으로 등록되는 ManagedInput, ManagedButton 컴포넌트

기본 사용법

1. 설정

2. Element 등록 및 관리

3. Focus 관리

4. Selection 관리

실제 사용 시나리오

Form Builder 애플리케이션

Element 관리를 포함한 동적 폼 빌더:

기능:
- 동적 폼 필드 추가/제거
- 클릭으로 필드 선택, Cmd/Ctrl+클릭으로 다중 선택
- 선택된 필드들 일괄 삭제
- 실시간 element 상태 모니터링
- 키보드 단축키 지원

Canvas 관리

Canvas 기반 그래픽 에디터의 element 관리:

기능:
- Canvas element 등록 및 상태 관리
- Canvas 내 그래픽 객체들과의 연동
- 선택 상태에 따른 도구 패널 표시
- Canvas 메타데이터 관리

API 참조

Core API

ElementManager

React Hooks

useElementRef
Element 자동 등록을 위한 hook

useElementManager
Element 관리를 위한 종합 hook

useFocusedElement
포커스 관리 hook

useElementSelection
선택 관리 hook

주요 이점

1. 중앙화된 관리
- 모든 DOM element가 중앙에서 관리되어 일관성 보장
- Element 생명주기의 예측 가능한 관리

2. 타입 안전성
- TypeScript를 통한 완전한 타입 안전성
- Element 타입별 특화된 기능 제공

3. 메모리 최적화
- 자동 정리로 메모리 누수 방지
- Stale element 자동 탐지 및 제거

4. React 통합
- React의 선언적 패턴과 완벽한 통합
- Hook 기반 API로 재사용성 극대화

5.

===================[ DOC: ko/example/element-management.md ]===================
# examples--element-management

DOM Element 관리

Context-Action 프레임워크를 사용한 포괄적인 DOM element 관리 고급 예제입니다.

===================[ DOC: ko/example/element-management.md ]===================
# examples--element-management

DOM Element 관리

Context-Action 프레임워크를 사용한 포괄적인 DOM element 관리 고급 예제입니다.

===================[ DOC: ko/example/element-management.md ]===================
# examples--element-management

DOM Element 관리

Context-Action 프레임워크를 사용한 포괄적인 DOM element 관리 고급 예제입니다. 개요

이 예제는 Context-Action의 Action Pipeline과 Store Pattern을 활용하여 React와 Core 패키지에서 DOM element를 효과적으로 관리하는 방법을 보여줍니다:

- 중앙화된 Element Registry: 모든 DOM element를 중앙에서 관리
- Type-safe Element Management: TypeScript를 활용한 타입 안전성
- Reactive State Management: Element 상태 변경에 대한 실시간 반응
- Lifecycle Management: Element 등록/해제의 자동화
- Focus & Selection Management: 포커스와 선택 상태 관리

주요 기능

Core 패키지 기능
- ElementManager 클래스: 중앙화된 DOM element 생명주기 관리
- Action 기반 API: 모든 element 작업이 action pipeline을 통해 수행
- 자동 정리: DOM에서 제거된 element들의 주기적 정리
- Type-safe 관리: TypeScript를 활용한 완전한 타입 안전성

React 패키지 기능
- useElementRef Hook: Element 자동 등록을 위한 hook
- Focus 관리: useFocusedElement hook으로 포커스 상태 관리
- Selection 관리: useElementSelection hook으로 다중 선택 지원
- Type별 조회: useElementsByType으로 타입별 element 조회
- Managed Components: 자동으로 등록되는 ManagedInput, ManagedButton 컴포넌트

기본 사용법

1. 설정

2. Element 등록 및 관리

3. Focus 관리

4. Selection 관리

실제 사용 시나리오

Form Builder 애플리케이션

Element 관리를 포함한 동적 폼 빌더:

기능:
- 동적 폼 필드 추가/제거
- 클릭으로 필드 선택, Cmd/Ctrl+클릭으로 다중 선택
- 선택된 필드들 일괄 삭제
- 실시간 element 상태 모니터링
- 키보드 단축키 지원

Canvas 관리

Canvas 기반 그래픽 에디터의 element 관리:

기능:
- Canvas element 등록 및 상태 관리
- Canvas 내 그래픽 객체들과의 연동
- 선택 상태에 따른 도구 패널 표시
- Canvas 메타데이터 관리

API 참조

Core API

ElementManager

React Hooks

useElementRef
Element 자동 등록을 위한 hook

useElementManager
Element 관리를 위한 종합 hook

useFocusedElement
포커스 관리 hook

useElementSelection
선택 관리 hook

주요 이점

1. 중앙화된 관리
- 모든 DOM element가 중앙에서 관리되어 일관성 보장
- Element 생명주기의 예측 가능한 관리

2. 타입 안전성
- TypeScript를 통한 완전한 타입 안전성
- Element 타입별 특화된 기능 제공

3. 메모리 최적화
- 자동 정리로 메모리 누수 방지
- Stale element 자동 탐지 및 제거

4. React 통합
- React의 선언적 패턴과 완벽한 통합
- Hook 기반 API로 재사용성 극대화

5. 디버깅 지원
- 개발 도구로 element 상태 실시간 모니터링
- Element 메타데이터 및 생명주기 추적

소스 코드

이 예제의 완전한 소스 코드는 /examples/element-management/ 디렉터리에서 확인할 수 있습니다:

- core-element-registry.ts - Core element 관리 시스템
- react-element-hooks.tsx - React 통합 hooks 및 컴포넌트
- integration-example.tsx - 실제 사용 예제
- README.md - 종합적인 문서화

이 예제는 Context-Action 프레임워크가 복잡한 DOM element 관리 시나리오를 어떻게 우아하게 해결하는지 보여주며, Form builder, Canvas editor, 복잡한 UI 등 다양한 실제 사용 사례에 적용할 수 있습니다.

===================[ DOC: ko/example/pattern-composition.md ]===================
# examples--pattern-composition

패턴 조합 예제

복잡한 애플리케이션을 위해 Action Only와 Store Only 패턴을 결합하는 방법을 보여줍니다.

===================[ DOC: ko/example/pattern-composition.md ]===================
# examples--pattern-composition

패턴 조합 예제

복잡한 애플리케이션을 위해 Action Only와 Store Only 패턴을 결합하는 방법을 보여줍니다. MVVM 아키텍처에 따라 완전한 관심사 분리를 구현합니다. 아키텍처 개요

완전한 애플리케이션 예제

1. 액션 타입 정의

2. 스토어 설정

3. 컨텍스트 생성

4. 액션 핸들러 컴포넌트

5. 시스템 액션 핸들러

6. 메인 애플리케이션 컴포넌트

7. 대시보드 컴포넌트

8. 모달 시스템

9. 성능 모니터

10. 네비게이션 컴포넌트

주요 아키텍처 이점

완벽한 관심사 분리

1. View Layer: 컴포넌트는 순수하게 UI 렌더링과 사용자 상호작용에 집중
2. ViewModel Layer: 액션 핸들러는 모든 비즈니스 로직과 조정을 담당
3. Model Layer: 스토어는 반응형 업데이트와 계산된 상태로 데이터 관리

패턴 조합의 이점

- Action 패턴: 복잡한 비즈니스 로직, API 호출, 횡단 관심사 처리
- Store 패턴: 타입 안전성과 계산된 값으로 반응형 상태 관리  
- 깔끔한 통합: 두 패턴이 충돌이나 결합 없이 함께 작동

전체적인 타입 안전성

실증된 베스트 프랙티스

1. 핸들러 조직화: 다른 도메인에 대한 분리된 핸들러 컴포넌트
2. 에러 경계: 사용자 피드백을 포함한 포괄적인 에러 처리
3. 성능 모니터링: 내장된 성능 추적 및 최적화
4. 상태 지속성: 애플리케이션 상태의 자동 저장 및 로딩
5. 모달 관리: 타입 안전한 데이터 전달을 가진 중앙화된 모달 시스템
6. 로딩 상태: 다른 작업에 대한 세분화된 로딩 표시기

관련 자료

- Action Only 패턴 - 순수 액션 디스패치 예제
- Store Only 패턴 - 순수 상태 관리 예제
- 기본 설정 - 두 패턴을 모두 사용한 기본 설정
- 아키텍처 가이드 - MVVM 아키텍처 원칙.

===================[ DOC: ko/example/pattern-composition.md ]===================
# examples--pattern-composition

패턴 조합 예제

복잡한 애플리케이션을 위해 Action Only와 Store Only 패턴을 결합하는 방법을 보여줍니다. MVVM 아키텍처에 따라 완전한 관심사 분리를 구현합니다. 아키텍처 개요

완전한 애플리케이션 예제

1. 액션 타입 정의

2. 스토어 설정

3. 컨텍스트 생성

4. 액션 핸들러 컴포넌트

5.

===================[ DOC: ko/example/pattern-composition.md ]===================
# examples--pattern-composition

패턴 조합 예제

복잡한 애플리케이션을 위해 Action Only와 Store Only 패턴을 결합하는 방법을 보여줍니다. MVVM 아키텍처에 따라 완전한 관심사 분리를 구현합니다. 아키텍처 개요

완전한 애플리케이션 예제

1. 액션 타입 정의

2. 스토어 설정

3. 컨텍스트 생성

4. 액션 핸들러 컴포넌트

5. 시스템 액션 핸들러

6. 메인 애플리케이션 컴포넌트

7. 대시보드 컴포넌트

8. 모달 시스템

9. 성능 모니터

10. 네비게이션 컴포넌트

주요 아키텍처 이점

완벽한 관심사 분리

1. View Layer: 컴포넌트는 순수하게 UI 렌더링과 사용자 상호작용에 집중
2. ViewModel Layer: 액션 핸들러는 모든 비즈니스 로직과 조정을 담당
3. Model Layer: 스토어는 반응형 업데이트와 계산된 상태로 데이터 관리

패턴 조합의 이점

- Action 패턴: 복잡한 비즈니스 로직, API 호출, 횡단 관심사 처리
- Store 패턴: 타입 안전성과 계산된 값으로 반응형 상태 관리  
- 깔끔한 통합: 두 패턴이 충돌이나 결합 없이 함께 작동

전체적인 타입 안전성

실증된 베스트 프랙티스

1. 핸들러 조직화: 다른 도메인에 대한 분리된 핸들러 컴포넌트
2. 에러 경계: 사용자 피드백을 포함한 포괄적인 에러 처리
3. 성능 모니터링: 내장된 성능 추적 및 최적화
4. 상태 지속성: 애플리케이션 상태의 자동 저장 및 로딩
5. 모달 관리: 타입 안전한 데이터 전달을 가진 중앙화된 모달 시스템
6. 로딩 상태: 다른 작업에 대한 세분화된 로딩 표시기

관련 자료

- Action Only 패턴 - 순수 액션 디스패치 예제
- Store Only 패턴 - 순수 상태 관리 예제
- 기본 설정 - 두 패턴을 모두 사용한 기본 설정
- 아키텍처 가이드 - MVVM 아키텍처 원칙.

===================[ DOC: ko/example/pattern-composition.md ]===================
# examples--pattern-composition

패턴 조합 예제

복잡한 애플리케이션을 위해 Action Only와 Store Only 패턴을 결합하는 방법을 보여줍니다. MVVM 아키텍처에 따라 완전한 관심사 분리를 구현합니다. 아키텍처 개요

완전한 애플리케이션 예제

1. 액션 타입 정의

2. 스토어 설정

3. 컨텍스트 생성

4. 액션 핸들러 컴포넌트

5. 시스템 액션 핸들러

6. 메인 애플리케이션 컴포넌트

7. 대시보드 컴포넌트

8. 모달 시스템

9. 성능 모니터

10. 네비게이션 컴포넌트

주요 아키텍처 이점

완벽한 관심사 분리

1.

===================[ DOC: ko/example/pattern-composition.md ]===================
# examples--pattern-composition

패턴 조합 예제

복잡한 애플리케이션을 위해 Action Only와 Store Only 패턴을 결합하는 방법을 보여줍니다. MVVM 아키텍처에 따라 완전한 관심사 분리를 구현합니다. 아키텍처 개요

완전한 애플리케이션 예제

1. 액션 타입 정의

2. 스토어 설정

3. 컨텍스트 생성

4. 액션 핸들러 컴포넌트

5. 시스템 액션 핸들러

6. 메인 애플리케이션 컴포넌트

7. 대시보드 컴포넌트

8. 모달 시스템

9. 성능 모니터

10. 네비게이션 컴포넌트

주요 아키텍처 이점

완벽한 관심사 분리

1. View Layer: 컴포넌트는 순수하게 UI 렌더링과 사용자 상호작용에 집중
2. ViewModel Layer: 액션 핸들러는 모든 비즈니스 로직과 조정을 담당
3.

===================[ DOC: ko/example/pattern-composition.md ]===================
# examples--pattern-composition

패턴 조합 예제

복잡한 애플리케이션을 위해 Action Only와 Store Only 패턴을 결합하는 방법을 보여줍니다. MVVM 아키텍처에 따라 완전한 관심사 분리를 구현합니다. 아키텍처 개요

완전한 애플리케이션 예제

1. 액션 타입 정의

2. 스토어 설정

3. 컨텍스트 생성

4. 액션 핸들러 컴포넌트

5. 시스템 액션 핸들러

6. 메인 애플리케이션 컴포넌트

7. 대시보드 컴포넌트

8. 모달 시스템

9. 성능 모니터

10. 네비게이션 컴포넌트

주요 아키텍처 이점

완벽한 관심사 분리

1. View Layer: 컴포넌트는 순수하게 UI 렌더링과 사용자 상호작용에 집중
2. ViewModel Layer: 액션 핸들러는 모든 비즈니스 로직과 조정을 담당
3. Model Layer: 스토어는 반응형 업데이트와 계산된 상태로 데이터 관리

패턴 조합의 이점

- Action 패턴: 복잡한 비즈니스 로직, API 호출, 횡단 관심사 처리
- Store 패턴: 타입 안전성과 계산된 값으로 반응형 상태 관리  
- 깔끔한 통합: 두 패턴이 충돌이나 결합 없이 함께 작동

전체적인 타입 안전성

실증된 베스트 프랙티스

1. 핸들러 조직화: 다른 도메인에 대한 분리된 핸들러 컴포넌트
2. 에러 경계: 사용자 피드백을 포함한 포괄적인 에러 처리
3. 성능 모니터링: 내장된 성능 추적 및 최적화
4. 상태 지속성: 애플리케이션 상태의 자동 저장 및 로딩
5. 모달 관리: 타입 안전한 데이터 전달을 가진 중앙화된 모달 시스템
6. 로딩 상태: 다른 작업에 대한 세분화된 로딩 표시기

관련 자료

- Action Only 패턴 - 순수 액션 디스패치 예제
- Store Only 패턴 - 순수 상태 관리 예제
- 기본 설정 - 두 패턴을 모두 사용한 기본 설정
- 아키텍처 가이드 - MVVM 아키텍처 원칙.

===================[ DOC: ko/example/store-only.md ]===================
# examples--store-only

Store Only 패턴 예제

순수 상태 관리를 위한 Store Only 패턴의 실제 사용 예제입니다.

===================[ DOC: ko/example/store-only.md ]===================
# examples--store-only

Store Only 패턴 예제

순수 상태 관리를 위한 Store Only 패턴의 실제 사용 예제입니다. 액션 디스패치 없이 데이터 레이어, 애플리케이션 상태, 반응형 데이터 플로우에 이상적인 패턴입니다. 사용 사례

- 애플리케이션 상태 관리
- 폼 상태 및 UI 상태
- 데이터 캐싱 및 지속성
- 파생 상태 및 계산된 값
- 컴포넌트 레벨 상태 관리

완전한 예제

1. 스토어 설정 정의

2. 스토어 패턴 생성

3. 프로필 관리 컴포넌트

4. 설정 컴포넌트

5. 애널리틱스 대시보드

6. 연락처 폼 컴포넌트

7. HOC 패턴을 사용한 메인 애플리케이션

고급 스토어 패턴

상태 지속성

계산된 상태 컴포넌트

실제 통합

폼 검증 패턴

서버 동기화

주요 특징

✅ 타입 안전성: 수동 타입 주석 없이 자동 타입 추론  
✅ 반응형 업데이트: 상태 변경 시 컴포넌트 자동 재렌더링  
✅ 파생 상태: 기본 상태가 변경될 때 계산된 속성 자동 업데이트  
✅ 검증: 커스텀 검증 함수가 있는 내장 검증 지원  
✅ HOC 패턴: withProvider()를 사용한 깔끔한 프로바이더 통합  
✅ 스토어 매니저: 재설정, 내보내기, 벌크 작업을 위한 중앙화된 관리

베스트 프랙티스

1. 직접 값: 단순한 타입에는 직접 값 설정 사용
2. 설정 객체: 복잡한 검증과 파생 상태에 사용
3. HOC 패턴: 자동 프로바이더 감싸기를 위해 withProvider() 선호
4. 반응형 구독: 컴포넌트 업데이트를 위해 항상 useStoreValue() 사용
5. 벌크 작업: 재설정과 벌크 작업에 스토어 매니저 사용
6. 상태 구조: 관련된 상태를 논리적 그룹으로 함께 유지

관련 자료

- Action Only 패턴 - 순수 액션 디스패치 패턴
- 패턴 조합 - Action 패턴과 결합하기
- 기본 설정 - 두 패턴을 모두 사용한 기본 설정.

===================[ DOC: ko/example/store-only.md ]===================
# examples--store-only

Store Only 패턴 예제

순수 상태 관리를 위한 Store Only 패턴의 실제 사용 예제입니다. 액션 디스패치 없이 데이터 레이어, 애플리케이션 상태, 반응형 데이터 플로우에 이상적인 패턴입니다.

===================[ DOC: ko/example/store-only.md ]===================
# examples--store-only

Store Only 패턴 예제

순수 상태 관리를 위한 Store Only 패턴의 실제 사용 예제입니다. 액션 디스패치 없이 데이터 레이어, 애플리케이션 상태, 반응형 데이터 플로우에 이상적인 패턴입니다. 사용 사례

- 애플리케이션 상태 관리
- 폼 상태 및 UI 상태
- 데이터 캐싱 및 지속성
- 파생 상태 및 계산된 값
- 컴포넌트 레벨 상태 관리

완전한 예제

1. 스토어 설정 정의

2. 스토어 패턴 생성

3. 프로필 관리 컴포넌트

4. 설정 컴포넌트

5. 애널리틱스 대시보드

6. 연락처 폼 컴포넌트

7. HOC 패턴을 사용한 메인 애플리케이션

고급 스토어 패턴

상태 지속성

계산된 상태 컴포넌트

실제 통합

폼 검증 패턴

서버 동기화

주요 특징

✅ 타입 안전성: 수동 타입 주석 없이 자동 타입 추론  
✅ 반응형 업데이트: 상태 변경 시 컴포넌트 자동 재렌더링  
✅ 파생 상태: 기본 상태가 변경될 때 계산된 속성 자동 업데이트  
✅ 검증: 커스텀 검증 함수가 있는 내장 검증 지원  
✅ HOC 패턴: withProvider()를 사용한 깔끔한 프로바이더 통합  
✅ 스토어 매니저: 재설정, 내보내기, 벌크 작업을 위한 중앙화된 관리

베스트 프랙티스

1. 직접 값: 단순한 타입에는 직접 값 설정 사용
2. 설정 객체: 복잡한 검증과 파생 상태에 사용
3. HOC 패턴: 자동 프로바이더 감싸기를 위해 withProvider() 선호
4. 반응형 구독: 컴포넌트 업데이트를 위해 항상 useStoreValue() 사용
5. 벌크 작업: 재설정과 벌크 작업에 스토어 매니저 사용
6. 상태 구조: 관련된 상태를 논리적 그룹으로 함께 유지

관련 자료

- Action Only 패턴 - 순수 액션 디스패치 패턴
- 패턴 조합 - Action 패턴과 결합하기
- 기본 설정 - 두 패턴을 모두 사용한 기본 설정.

===================[ DOC: ko/example/store-only.md ]===================
# examples--store-only

Store Only 패턴 예제

순수 상태 관리를 위한 Store Only 패턴의 실제 사용 예제입니다. 액션 디스패치 없이 데이터 레이어, 애플리케이션 상태, 반응형 데이터 플로우에 이상적인 패턴입니다. 사용 사례

- 애플리케이션 상태 관리
- 폼 상태 및 UI 상태
- 데이터 캐싱 및 지속성
- 파생 상태 및 계산된 값
- 컴포넌트 레벨 상태 관리

완전한 예제

1. 스토어 설정 정의

2. 스토어 패턴 생성

3. 프로필 관리 컴포넌트

4. 설정 컴포넌트

5. 애널리틱스 대시보드

6.

===================[ DOC: ko/example/store-only.md ]===================
# examples--store-only

Store Only 패턴 예제

순수 상태 관리를 위한 Store Only 패턴의 실제 사용 예제입니다. 액션 디스패치 없이 데이터 레이어, 애플리케이션 상태, 반응형 데이터 플로우에 이상적인 패턴입니다. 사용 사례

- 애플리케이션 상태 관리
- 폼 상태 및 UI 상태
- 데이터 캐싱 및 지속성
- 파생 상태 및 계산된 값
- 컴포넌트 레벨 상태 관리

완전한 예제

1. 스토어 설정 정의

2. 스토어 패턴 생성

3. 프로필 관리 컴포넌트

4. 설정 컴포넌트

5. 애널리틱스 대시보드

6. 연락처 폼 컴포넌트

7.

===================[ DOC: ko/example/store-only.md ]===================
# examples--store-only

Store Only 패턴 예제

순수 상태 관리를 위한 Store Only 패턴의 실제 사용 예제입니다. 액션 디스패치 없이 데이터 레이어, 애플리케이션 상태, 반응형 데이터 플로우에 이상적인 패턴입니다. 사용 사례

- 애플리케이션 상태 관리
- 폼 상태 및 UI 상태
- 데이터 캐싱 및 지속성
- 파생 상태 및 계산된 값
- 컴포넌트 레벨 상태 관리

완전한 예제

1. 스토어 설정 정의

2. 스토어 패턴 생성

3. 프로필 관리 컴포넌트

4. 설정 컴포넌트

5. 애널리틱스 대시보드

6. 연락처 폼 컴포넌트

7. HOC 패턴을 사용한 메인 애플리케이션

고급 스토어 패턴

상태 지속성

계산된 상태 컴포넌트

실제 통합

폼 검증 패턴

서버 동기화

주요 특징

✅ 타입 안전성: 수동 타입 주석 없이 자동 타입 추론  
✅ 반응형 업데이트: 상태 변경 시 컴포넌트 자동 재렌더링  
✅ 파생 상태: 기본 상태가 변경될 때 계산된 속성 자동 업데이트  
✅ 검증: 커스텀 검증 함수가 있는 내장 검증 지원  
✅ HOC 패턴: withProvider()를 사용한 깔끔한 프로바이더 통합  
✅ 스토어 매니저: 재설정, 내보내기, 벌크 작업을 위한 중앙화된 관리

베스트 프랙티스

1. 직접 값: 단순한 타입에는 직접 값 설정 사용
2. 설정 객체: 복잡한 검증과 파생 상태에 사용
3. HOC 패턴: 자동 프로바이더 감싸기를 위해 withProvider() 선호
4. 반응형 구독: 컴포넌트 업데이트를 위해 항상 useStoreValue() 사용
5. 벌크 작업: 재설정과 벌크 작업에 스토어 매니저 사용
6. 상태 구조: 관련된 상태를 논리적 그룹으로 함께 유지

관련 자료

- Action Only 패턴 - 순수 액션 디스패치 패턴
- 패턴 조합 - Action 패턴과 결합하기
- 기본 설정 - 두 패턴을 모두 사용한 기본 설정.