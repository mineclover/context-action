# Context-Action Framework - Complete Documentation

Generated: 2025-08-14
Type: Origin (Full Documents)
Language: EN

This document contains the complete original content of all Context-Action framework documentation files, organized by priority.

---


# Core Concepts

**Source**: `guide/concepts.md`  
**Priority**: 100 (critical)  

# Core Concepts

Understanding the fundamental concepts of the Context-Action framework is essential for effective implementation. This guide covers the key building blocks and their relationships.

## Architecture Overview

The Context-Action framework implements a clean separation of concerns through three main layers:

```mermaid
graph TB
    subgraph "VIEW LAYER"
        A[React Components<br/>UI Presentation]
    end
    
    subgraph "VIEWMODEL LAYER"  
        B[Action Handlers<br/>Business Logic]
    end
    
    subgraph "MODEL LAYER"
        C[Store System<br/>State Management]
    end
    
    A -->|dispatch actions| B
    B -->|update stores| C
    C -->|subscribe/re-render| A
    
    style A fill:#e3f2fd
    style B fill:#fff8e1
    style C fill:#e8f5e8
```

## Core Components

### 1. Domain-Specific Hooks Pattern

The foundation of the framework is creating domain-specific hooks through destructuring assignments:

```typescript
// Define your domain data structure
interface UserData {
  profile: { id: string; name: string; email: string };
  preferences: { theme: 'light' | 'dark'; language: string };
}

// Create domain-specific store hooks
export const {
  Provider: UserProvider,
  useStore: useUserStore,        // Domain-specific store access
  useStores: useUserStores,      // Store registry access
} = createDeclarativeStores<UserData>('User', {
  profile: { initialValue: { id: '', name: '', email: '' } },
  preferences: { initialValue: { theme: 'light', language: 'en' } }
});

// Create domain-specific action hooks
export const {
  Provider: UserActionProvider,
  useAction: useUserAction,      // Domain-specific action dispatcher
  useActionRegister: useUserActionRegister
} = createActionContext<UserActions>({ name: 'UserAction' });
```

**Benefits:**
- Full TypeScript inference
- Clear domain boundaries
- Intuitive, autocomplete-friendly APIs
- Refactoring safety

### 2. Store System

Stores manage state with singleton behavior within provider boundaries:

```typescript
function UserProfile() {
  // Get domain-specific store
  const profileStore = useUserStore('profile');
  
  // Subscribe to changes (reactive)
  const profile = useStoreValue(profileStore);
  
  // Direct store manipulation (when needed)
  const updateName = (name: string) => {
    profileStore.setValue({ ...profile, name });
  };
  
  return <div>Hello, {profile.name}!</div>;
}
```

**Store Patterns:**

1. **Singleton Behavior:** Same store name returns same instance within provider scope
2. **Reactive Subscriptions:** Components automatically re-render on changes
3. **Type Safety:** Full TypeScript support with domain-specific types

### 3. Action Pipeline System

Actions flow through a priority-based handler system:

```typescript
// Define action interface
interface UserActions {
  updateProfile: { data: Partial<UserData['profile']> };
  deleteUser: { userId: string };
  resetUser: void;
}

// Register handlers
function useUserHandlers() {
  const register = useUserActionRegister();
  const registry = useUserRegistry();
  
  const updateProfileHandler = useCallback(async (payload, controller) => {
    // Get current state (lazy evaluation)
    const profileStore = registry.getStore('profile');
    const currentProfile = profileStore.getValue();
    
    // Validation
    if (!payload.data.email?.includes('@')) {
      controller.abort('Invalid email format');
      return;
    }
    
    // Business logic
    const updatedProfile = { ...currentProfile, ...payload.data };
    profileStore.setValue(updatedProfile);
    
    // Return result
    return { success: true, profile: updatedProfile };
  }, [registry]);
  
  // Register with cleanup
  useEffect(() => {
    if (!register) return;
    const unregister = register('updateProfile', updateProfileHandler, {
      priority: 100,
      blocking: true,
      id: 'profile-updater'
    });
    return unregister; // Important: cleanup on unmount
  }, [register, updateProfileHandler]);
}
```

**Handler Features:**

- **Priority-based execution:** Higher priority handlers run first
- **Blocking/Non-blocking:** Control async execution flow
- **Result collection:** Gather results from multiple handlers
- **Error handling:** Built-in error management and abort mechanisms

### 4. Provider Composition

Organize domains with nested providers:

```typescript
// Domain-specific provider composition
function UserProvider({ children }: { children: React.ReactNode }) {
  return (
    <UserStoreProvider>
      <UserActionProvider>
        <UserHandlersSetup />
        {children}
      </UserActionProvider>
    </UserStoreProvider>
  );
}

// Handler setup component
function UserHandlersSetup() {
  useUserHandlers(); // Register all domain handlers
  return null;
}

// Usage
function App() {
  return (
    <UserProvider>
      <UserProfile />
    </UserProvider>
  );
}
```

## Data Flow Patterns

### 1. Component → Action → Store → Component

The standard reactive flow:

```typescript
function UserEditor() {
  // Subscribe to store
  const profile = useStoreValue(useUserStore('profile'));
  const dispatch = useUserAction();
  
  // Trigger action
  const handleSave = () => {
    dispatch('updateProfile', { 
      data: { name: 'Updated Name' } 
    });
  };
  
  // Component re-renders when profile changes
  return (
    <form onSubmit={handleSave}>
      <input defaultValue={profile.name} />
      <button type="submit">Save</button>
    </form>
  );
}
```

### 2. Handler Access Patterns

Three valid patterns for accessing stores:

```typescript
// Pattern 1: Component access (reactive)
const store = useUserStore('profile');
const profile = useStoreValue(store);

// Pattern 2: Handler access (lazy evaluation)
const handler = async (payload, controller) => {
  const profileStore = registry.getStore('profile');
  const currentProfile = profileStore.getValue(); // Fresh value
};

// Pattern 3: Context Store Pattern (isolated)
const store = UserStores.useStore('profile', initialValue);
```

### 3. Cross-Domain Communication

When domains need to interact:

```typescript
function useUserCartIntegration() {
  // Access multiple domains
  const userProfile = useUserStore('profile');
  const cartItems = useCartStore('items');
  const userAction = useUserAction();
  const cartAction = useCartAction();
  
  const profile = useStoreValue(userProfile);
  const items = useStoreValue(cartItems);
  
  const processCheckout = useCallback(async () => {
    // Cross-domain validation
    if (!profile.id) {
      await userAction('requireLogin', {});
      return;
    }
    
    // Cross-domain action
    await cartAction('processCheckout', {
      userId: profile.id,
      items: items
    });
  }, [profile.id, items, userAction, cartAction]);
  
  return { processCheckout };
}
```

## Handler Registration Patterns

### Best Practice Pattern

Always use `useActionRegister` + `useEffect` with cleanup:

```typescript
function useUserHandlers() {
  const register = useUserActionRegister();
  const registry = useUserRegistry();
  
  // Wrap handler with useCallback
  const handler = useCallback(async (payload, controller) => {
    // Handler logic here
  }, [registry]);
  
  // Register with cleanup
  useEffect(() => {
    if (!register) return;
    
    const unregister = register('actionName', handler, {
      priority: 100,
      blocking: true,
      id: 'unique-handler-id'
    });
    
    return unregister; // Critical: cleanup on unmount
  }, [register, handler]);
}
```

### Handler Configuration Options

```typescript
interface HandlerConfig {
  priority?: number;        // Execution order (higher = first)
  blocking?: boolean;       // Wait for async completion
  tags?: string[];         // For filtering
  id?: string;            // Explicit handler ID
  category?: string;      // Handler category
  returnType?: 'value';   // Enable return value collection
}
```

## Context Boundaries & Domain Isolation

### Single Domain Architecture

```typescript
// Domain-specific stores
const UserStores = createContextStorePattern('User');

// Isolated provider boundary
<UserStores.Provider registryId="user-domain">
  <UserComponents />
</UserStores.Provider>

// Domain-specific usage
const userStore = UserStores.useStore('profile', initialData);
```

### Multi-Domain Architecture

```typescript
function App() {
  return (
    <UserProvider>        {/* User domain boundary */}
      <CartProvider>      {/* Cart domain boundary */}
        <OrderProvider>   {/* Order domain boundary */}
          <ApplicationComponents />
        </OrderProvider>
      </CartProvider>
    </UserProvider>
  );
}
```

## Memory Management

### Store Lifecycle

- **Creation:** Stores are created when first accessed within a provider
- **Persistence:** Stores persist for the lifetime of their provider
- **Cleanup:** Stores are cleaned up when provider unmounts

### Handler Cleanup

```typescript
// ❌ Memory leak - no cleanup
useEffect(() => {
  register('action', handler);
}, []);

// ✅ Proper cleanup
useEffect(() => {
  if (!register) return;
  const unregister = register('action', handler);
  return unregister; // Cleanup on unmount
}, [register, handler]);
```

## Type Safety Features

### Automatic Type Inference

```typescript
// Types are automatically inferred
const store = useUserStore('profile'); // Store<UserProfile>
const profile = useStoreValue(store);  // UserProfile
const dispatch = useUserAction();      // Dispatch<UserActions>
```

### Compile-Time Safety

```typescript
// Invalid action name - compile error
dispatch('invalidAction', {}); 
// TS Error: Argument of type '"invalidAction"' is not assignable

// Invalid payload - compile error  
dispatch('updateProfile', { invalid: 'data' });
// TS Error: Object literal may only specify known properties
```

---

## Summary

The Context-Action framework's core concepts work together to provide:

- **Domain Isolation** through context boundaries
- **Type Safety** with automatic inference
- **Reactive State Management** with minimal re-renders
- **Declarative Actions** with centralized business logic
- **Memory Safety** with proper cleanup patterns

Understanding these concepts enables you to build scalable, maintainable applications with clear architectural boundaries.

---

::: tip Next Steps
Ready to implement? Check out the [Full Implementation Guide](./full) for complete patterns and examples, or jump to [Quick Start](./quick-start) for hands-on coding.
:::

---


# Guide Overview

**Source**: `guide/overview.md`  
**Priority**: 100 (critical)  

# Context Action Framework Overview

The Context-Action framework implements a clean separation of concerns through an MVVM-inspired pattern combined with **Context Store Pattern** for complete domain isolation.

## Architecture Overview

```mermaid
graph LR
    A[Component] -->|dispatch| B[Action Pipeline]
    B -->|handlers| C[Store]
    C -->|subscribe| A
    
    style A fill:#e3f2fd
    style B fill:#fff8e1
    style C fill:#e8f5e8
```

## Key Benefits

1. **Domain Isolation** - Each context maintains complete independence
2. **Type Safety** - Full TypeScript support with domain-specific hooks
3. **Performance** - Only affected components re-render
4. **Scalability** - Easy to add new domains without affecting existing ones
5. **Team Collaboration** - Different teams can work on different domains

## Quick Navigation

- [Full Implementation Guide](./full) - Complete implementation guide with all patterns
- [Quick Start](./quick-start) - Get up and running quickly
- [Core Concepts](./concepts) - Understand the fundamental concepts
- [Setup & Usage](./setup-usage) - Detailed setup instructions

## Framework Philosophy

The Context-Action framework follows these core principles:

- **Actions** handle business logic (ViewModel layer)
- **Context Store Pattern** manages state with domain isolation (Model layer)
- **Components** render UI (View layer)
- **Context Boundaries** isolate functional domains
- **Type-Safe Integration** through domain-specific hooks

---

::: tip Next Steps
Start with the [Full Implementation Guide](./full) for a comprehensive understanding, or jump to [Quick Start](./quick-start) if you want to start coding immediately.
:::

---


# Guide Getting Started

**Source**: `guide/getting-started.md`  
**Priority**: 95 (critical)  

# Getting Started

Welcome to **Context-Action framework** - a revolutionary state management system designed to overcome the fundamental limitations of existing libraries through document-centric context separation and effective artifact management.

## What is Context-Action?

Context-Action addresses critical issues in modern state management:

### Problems with Existing Libraries
- **High React Coupling**: Tight integration makes component modularization and props handling difficult
- **Binary State Approach**: Simple global/local state dichotomy fails to handle specific scope-based separation  
- **Inadequate Handler/Trigger Management**: Poor support for complex interactions and business logic processing

### Context-Action's Solution
- **Document-Artifact Centered Design**: Context separation based on document themes and deliverable management
- **Perfect Separation of Concerns**: Clear boundaries between different domain contexts
- **Advanced Handler & Trigger Management**: Priority-based handler execution with sophisticated trigger system

## Core Architecture

Context-Action implements an **MVVM-inspired architecture** with three clear layers:

```mermaid
graph TD
    A[View Layer - React Components] --> B[ViewModel Layer - Action Pipeline]
    B --> C[Model Layer - Store System]
    C --> A
    
    subgraph "Context Separation"
        D[Business Context]
        E[UI Context] 
        F[Validation Context]
        G[Design Context]
        H[Architecture Context]
    end
```

### Key Components

1. **View Layer**: React components that render UI and dispatch actions
2. **ViewModel Layer**: Action pipeline with priority-based handler execution
3. **Model Layer**: Store system with reactive state management

## Package Structure

Context-Action is organized as a TypeScript monorepo:

- **@context-action/core** - Core action pipeline management (no React dependency)
- **@context-action/react** - React integration with Context API and hooks

## Installation

```bash
# Install both packages
npm install @context-action/core @context-action/react

# Or with pnpm
pnpm add @context-action/core @context-action/react

# Or with yarn
yarn add @context-action/core @context-action/react
```

## Two Main Patterns

Context-Action provides two primary patterns that can be used independently or combined:

### 🎯 Action Only Pattern
For pure action dispatching without state management:
- Event systems and command patterns
- Type-safe action dispatching with handler registration
- Lightweight with no store overhead

### 🏪 Store Only Pattern (Recommended)
For pure state management without action dispatching:
- Data layers and simple state management
- Excellent type inference without manual annotations  
- Simplified API focused on store management

## Quick Example

Here's a simple example using both patterns together:

```typescript
// 1. Action Only Pattern for events
const {
  Provider: EventActionProvider,
  useActionDispatch: useEventAction,
  useActionHandler: useEventActionHandler
} = createActionContext<{
  trackEvent: { event: string; data: any }
}>('Events');

// 2. Store Only Pattern for state
const {
  Provider: UserStoreProvider,
  useStore: useUserStore,
  useStoreManager: useUserStoreManager
} = createDeclarativeStorePattern('User', {
  profile: { initialValue: { name: '', email: '' } },
  preferences: { initialValue: { theme: 'light' } }
});

// 3. Compose providers
function App() {
  return (
    <EventActionProvider>
      <UserStoreProvider>
        <UserComponent />
      </UserStoreProvider>
    </EventActionProvider>
  );
}

// 4. Use in components
function UserComponent() {
  const dispatch = useEventAction();
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  useEventActionHandler('trackEvent', async (payload) => {
    console.log('Event tracked:', payload);
  });
  
  return (
    <div>
      <h1>{profile.name}</h1>
      <button onClick={() => dispatch('trackEvent', { 
        event: 'button_click', 
        data: { button: 'profile' } 
      })}>
        Track Event
      </button>
    </div>
  );
}
```

## Next Steps

Now that you understand the basics, explore these topics:

- **[MVVM Architecture](./mvvm-architecture)** - Deep dive into the architectural patterns
- **[Action Pipeline](./action-pipeline)** - Learn about the action processing system  
- **[Main Patterns](./patterns)** - Understand Action Only and Store Only patterns in detail
- **[Examples](../examples/basic-setup)** - See complete working examples

## Key Benefits

✅ **Type Safety**: Full TypeScript support with strict type checking  
✅ **Separation of Concerns**: Clear boundaries between View, ViewModel, and Model  
✅ **Scalable Architecture**: Document-centric context separation  
✅ **Advanced Handler Management**: Priority-based execution with trigger system  
✅ **React Integration**: Clean hooks-based integration  
✅ **Pattern Flexibility**: Use Action Only, Store Only, or both together

---


# Guide Quick Start

**Source**: `guide/quick-start.md`  
**Priority**: 95 (critical)  

# Quick Start Guide

Get up and running with the Context-Action framework in minutes. This guide shows you the essential patterns to start building type-safe, scalable React applications.

## Installation

```bash
npm install @context-action/core @context-action/react
# or
yarn add @context-action/core @context-action/react
# or  
pnpm add @context-action/core @context-action/react
```

## 5-Minute Implementation

### Step 1: Define Your Domain

Create a domain with stores and actions:

```typescript
// stores/user.store.ts
import { createDeclarativeStores, createActionContext } from '@context-action/react';

// Define your data structure
export interface UserData {
  profile: { id: string; name: string; email: string };
  preferences: { theme: 'light' | 'dark'; language: string };
}

// Define your actions
export interface UserActions {
  updateProfile: { name: string; email: string };
  toggleTheme: void;
  login: { email: string; password: string };
}

// Create domain-specific hooks
export const {
  Provider: UserProvider,
  useStore: useUserStore,
  useStores: useUserStores  // New clearer naming
} = createDeclarativeStores<UserData>('User', {
  profile: { initialValue: { id: '', name: '', email: '' } },
  preferences: { initialValue: { theme: 'light', language: 'en' } }
});

export const {
  Provider: UserActionProvider,
  useAction: useUserAction,
  useActionHandler: useUserActionHandler  // New clearer naming
} = createActionContext<UserActions>({ name: 'UserAction' });
```

### Step 2: Create Action Handlers

Define your business logic:

```typescript
// hooks/useUserHandlers.ts
import { useEffect, useCallback } from 'react';
import { useUserActionHandler, useUserStores } from '../stores/user.store';

export function useUserHandlers() {
  const addHandler = useUserActionHandler();
  const stores = useUserStores();
  
  // Update profile handler
  const updateProfileHandler = useCallback(async (payload, controller) => {
    const profileStore = stores.getStore('profile');
    const currentProfile = profileStore.getValue();
    
    // Simple validation
    if (!payload.email.includes('@')) {
      controller.abort('Invalid email format');
      return;
    }
    
    // Update the store
    profileStore.setValue({
      ...currentProfile,
      name: payload.name,
      email: payload.email
    });
    
    return { success: true };
  }, [registry]);
  
  // Toggle theme handler
  const toggleThemeHandler = useCallback(async (payload, controller) => {
    const prefsStore = stores.getStore('preferences');
    const currentPrefs = prefsStore.getValue();
    
    prefsStore.setValue({
      ...currentPrefs,
      theme: currentPrefs.theme === 'light' ? 'dark' : 'light'
    });
  }, [registry]);
  
  // Register handlers with cleanup
  useEffect(() => {
    if (!register) return;
    
    const unaddHandlerUpdate = addHandler('updateProfile', updateProfileHandler, {
      priority: 100,
      blocking: true
    });
    
    const unaddHandlerTheme = addHandler('toggleTheme', toggleThemeHandler, {
      priority: 50,
      blocking: true
    });
    
    // Cleanup on unmount
    return () => {
      unregisterUpdate();
      unregisterTheme();
    };
  }, [register, updateProfileHandler, toggleThemeHandler]);
}
```

### Step 3: Create Your Component

Build a reactive UI component:

```typescript
// components/UserProfile.tsx
import React, { useState } from 'react';
import { useStoreValue } from '@context-action/react';
import { useUserStore, useUserAction } from '../stores/user.store';

export function UserProfile() {
  const profileStore = useUserStore('profile');
  const prefsStore = useUserStore('preferences');
  
  // Reactive subscriptions
  const profile = useStoreValue(profileStore);
  const preferences = useStoreValue(prefsStore);
  const dispatch = useUserAction();
  
  // Local form state
  const [name, setName] = useState(profile.name);
  const [email, setEmail] = useState(profile.email);
  
  const handleSave = () => {
    dispatch('updateProfile', { name, email });
  };
  
  const handleThemeToggle = () => {
    dispatch('toggleTheme');
  };
  
  return (
    <div style={{ 
      backgroundColor: preferences.theme === 'dark' ? '#333' : '#fff',
      color: preferences.theme === 'dark' ? '#fff' : '#333',
      padding: '20px'
    }}>
      <h2>User Profile</h2>
      
      <div>
        <label>Name:</label>
        <input 
          value={name}
          onChange={(e) => setName(e.target.value)}
        />
      </div>
      
      <div>
        <label>Email:</label>
        <input 
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
      </div>
      
      <button onClick={handleSave}>
        Save Profile
      </button>
      
      <button onClick={handleThemeToggle}>
        Toggle Theme ({preferences.theme})
      </button>
      
      <div>
        <p>Current: {profile.name} ({profile.email})</p>
        <p>Theme: {preferences.theme}</p>
      </div>
    </div>
  );
}
```

### Step 4: Setup Your App

Wire everything together:

```typescript
// App.tsx
import React from 'react';
import { 
  UserProvider, 
  UserActionProvider 
} from './stores/user.store';
import { useUserHandlers } from './hooks/useUserHandlers';
import { UserProfile } from './components/UserProfile';

// Handler setup component
function UserHandlersSetup() {
  useUserHandlers();
  return null;
}

// App with proper provider nesting
function App() {
  return (
    <UserProvider>
      <UserActionProvider>
        <UserHandlersSetup />
        <div style={{ padding: '20px' }}>
          <h1>Context-Action Quick Start</h1>
          <UserProfile />
        </div>
      </UserActionProvider>
    </UserProvider>
  );
}

export default App;
```

## What You Just Built

🎉 **Congratulations!** You now have a working Context-Action application with:

- **Type-Safe Actions**: `updateProfile` and `toggleTheme` with full TypeScript support
- **Reactive State**: Components automatically re-render when stores change
- **Domain Isolation**: User domain is completely self-contained
- **Business Logic Separation**: Handlers contain all business logic
- **Memory Safety**: Proper cleanup when components unmount

## Key Patterns You Learned

### 1. Domain-Specific Hooks

```typescript
const profile = useUserStore('profile');     // Typed store access
const dispatch = useUserAction();            // Typed action dispatch
```

### 2. Reactive Subscriptions

```typescript
const profile = useStoreValue(profileStore); // Auto re-render on changes
```

### 3. Handler Registration with Cleanup

```typescript
useEffect(() => {
  const unaddHandler = addHandler('action', handler);
  return unregister; // Important cleanup
}, [register, handler]);
```

### 4. Provider Composition

```typescript
<UserProvider>
  <UserActionProvider>
    <Components />
  </UserActionProvider>
</UserProvider>
```

## Next Steps

### Add More Domains

```typescript
// Add cart functionality
const CartStores = createContextStorePattern('Cart');
const CartActions = createActionContext<CartActions>();

// Add order management
const OrderStores = createContextStorePattern('Order');  
const OrderActions = createActionContext<OrderActions>();
```

### Advanced Patterns

- **[Cross-Domain Integration](./cross-domain-integration)** - Make domains work together
- **[Logic Fit Hooks](./logic-fit-hooks)** - Combine business and UI logic
- **[Performance Optimization](./performance)** - Optimize for large applications

### Testing Your Code

```typescript
// Easy to test handlers in isolation
describe('updateProfile handler', () => {
  it('should update profile data', async () => {
    const mockRegistry = createMockRegistry();
    const handler = createUpdateProfileHandler(mockRegistry);
    
    await handler({ name: 'John', email: 'john@test.com' }, mockController);
    
    expect(mockRegistry.getStore('profile').setValue).toHaveBeenCalledWith({
      name: 'John',
      email: 'john@test.com'
    });
  });
});
```

## Common Patterns

### Loading States

```typescript
const loadingHandler = useCallback(async (payload, controller) => {
  const uiStore = stores.getStore('ui');
  
  // Set loading
  uiStore.setValue({ ...uiStore.getValue(), loading: true });
  
  try {
    // Do work
    await someAsyncOperation();
  } finally {
    // Clear loading
    uiStore.setValue({ ...uiStore.getValue(), loading: false });
  }
}, [registry]);
```

### Error Handling

```typescript
const errorHandler = useCallback(async (payload, controller) => {
  try {
    // Risky operation
    await riskyOperation();
  } catch (error) {
    controller.abort('Operation failed', error);
    return { success: false, error: error.message };
  }
}, []);
```

### Conditional Logic

```typescript
const conditionalHandler = useCallback(async (payload, controller) => {
  const userStore = stores.getStore('profile');
  const user = userStore.getValue();
  
  if (!user.id) {
    controller.abort('User must be logged in');
    return;
  }
  
  // Continue with authenticated user logic
}, [registry]);
```

---

## Summary

You've built a complete Context-Action application in just a few steps! The framework provides:

- **Type Safety** out of the box
- **Reactive State Management** with minimal boilerplate  
- **Clear Architecture** with separated concerns
- **Scalable Patterns** that grow with your application

---

::: tip Ready for More?
- Check out the **[Full Implementation Guide](./full)** for comprehensive patterns
- Explore **[Advanced Patterns](./advanced-patterns)** for complex scenarios
- See **[Real Examples](../examples/)** for production-ready code
:::

::: details Troubleshooting
**Handler not executing?** Make sure you're using `blocking: true` for async handlers.

**Component not re-rendering?** Verify you're using `useStoreValue()` for reactive subscriptions.

**TypeScript errors?** Check that your action payload matches the interface definition.

**Memory issues?** Ensure all handler registrations return cleanup functions.
:::

---


# Action Only Methods

**Source**: `api/action-only.md`  
**Priority**: 85 (essential)  

# Action Only Methods

Complete API reference for Action Only Pattern methods from `createActionContext`.

## Overview

The Action Only Pattern provides type-safe action dispatching without state management. This pattern is ideal for event systems, command patterns, business logic orchestration, and scenarios where you need action processing without local state.

## Core Methods

### `createActionContext<T>(contextName)`

Creates an action context for type-safe action dispatching and handler registration.

**Parameters:**
- `contextName`: Unique identifier for the action context

**Returns:**
```typescript
{
  Provider: React.ComponentType,
  useActionDispatch: () => ActionDispatcher<T>,
  useActionHandler: (actionName, handler, options?) => void
}
```

**Example:**
```typescript
interface AppActions extends ActionPayloadMap {
  updateUser: { id: string; name: string };
  deleteUser: { id: string };
}

const { Provider, useActionDispatch, useActionHandler } = 
  createActionContext<AppActions>('App');
```

## Action Dispatcher Methods

### `dispatch(actionName, payload)`

Dispatches an action with the specified payload to all registered handlers.

**Parameters:**
- `actionName`: Name of the action to dispatch
- `payload`: Action payload data

**Returns:** `Promise<ActionResult[]>` - Results from all handlers

```typescript
function UserComponent() {
  const dispatch = useActionDispatch();
  
  const handleUpdate = async () => {
    try {
      const results = await dispatch('updateUser', {
        id: '123',
        name: 'John Doe'
      });
      console.log('Action results:', results);
    } catch (error) {
      console.error('Action failed:', error);
    }
  };
  
  return <button onClick={handleUpdate}>Update User</button>;
}
```

### `dispatch.async(actionName, payload)`

Alias for the standard dispatch method, explicitly indicating async behavior.

**Parameters:**
- `actionName`: Name of the action to dispatch  
- `payload`: Action payload data

**Returns:** `Promise<ActionResult[]>`

```typescript
const results = await dispatch.async('processData', { data: 'example' });
```

## Handler Registration

### `useActionHandler(actionName, handler, options?)`

Registers an action handler for the specified action.

**Parameters:**
- `actionName`: Name of the action to handle
- `handler`: Handler function `(payload, controller) => Promise<any> | any`
- `options`: Optional configuration object

**Handler Function Signature:**
```typescript
type ActionHandler<TPayload> = (
  payload: TPayload,
  controller: PipelineController
) => Promise<any> | any;
```

**Options:**
```typescript
interface HandlerOptions {
  priority?: number;      // Execution priority (higher = earlier, default: 0)
  id?: string;           // Unique handler identifier
  once?: boolean;        // Execute only once then unregister
}
```

**Example:**
```typescript
function UserHandler() {
  const dispatch = useActionDispatch();
  
  useActionHandler('updateUser', useCallback(async (payload, controller) => {
    try {
      // Validate payload
      if (!payload.id) {
        controller.abort('User ID is required');
        return;
      }
      
      // Business logic
      const result = await userService.updateUser(payload.id, {
        name: payload.name
      });
      
      // Set result for other handlers
      controller.setResult({
        step: 'user-update',
        success: true,
        userId: result.id
      });
      
      return { success: true, user: result };
      
    } catch (error) {
      controller.abort(`User update failed: ${error.message}`);
    }
  }, []), { priority: 100, id: 'user-updater' });
  
  return null;
}
```

## Pipeline Controller Methods

The `controller` parameter in action handlers provides advanced pipeline control.

### `controller.abort(reason, error?)`

Aborts the action pipeline execution.

**Parameters:**
- `reason`: Reason for aborting
- `error?`: Optional error object

```typescript
useActionHandler('validateData', (payload, controller) => {
  if (!payload.data) {
    controller.abort('Data is required');
    return;
  }
  
  if (!isValid(payload.data)) {
    controller.abort('Invalid data format', new ValidationError());
    return;
  }
});
```

### `controller.modifyPayload(modifier)`

Modifies the payload for subsequent handlers in the pipeline.

**Parameters:**
- `modifier`: Function that receives current payload and returns modified payload

```typescript
useActionHandler('enrichData', (payload, controller) => {
  controller.modifyPayload(current => ({
    ...current,
    timestamp: Date.now(),
    userId: getCurrentUserId(),
    sessionId: getSessionId()
  }));
  
  return { enriched: true };
}, { priority: 100 }); // High priority to run first
```

### `controller.setResult(result)`

Sets a result that can be accessed by later handlers.

**Parameters:**
- `result`: Result object to store

```typescript
useActionHandler('processPayment', async (payload, controller) => {
  const transaction = await paymentService.process(payload);
  
  controller.setResult({
    step: 'payment',
    transactionId: transaction.id,
    amount: transaction.amount,
    success: true
  });
  
  return transaction;
}, { priority: 90 });
```

### `controller.getResults()`

Gets all results set by previous handlers.

**Returns:** Array of result objects

```typescript
useActionHandler('sendReceipt', async (payload, controller) => {
  const results = controller.getResults();
  const paymentResult = results.find(r => r.step === 'payment');
  
  if (paymentResult?.success) {
    await emailService.sendReceipt({
      transactionId: paymentResult.transactionId,
      amount: paymentResult.amount,
      email: payload.email
    });
  }
}, { priority: 80 }); // Lower priority to run after payment
```

### `controller.getPayload()`

Gets the current (possibly modified) payload.

**Returns:** Current payload object

```typescript
useActionHandler('logAction', (_, controller) => {
  const currentPayload = controller.getPayload();
  console.log('Final payload:', currentPayload);
  
  return { logged: true };
}, { priority: 10 }); // Low priority to run last
```

## Handler Patterns

### Sequential Processing

Handlers execute in priority order for sequential processing:

```typescript
function SequentialHandlers() {
  // Step 1: Validation (priority 100)
  useActionHandler('processOrder', (payload, controller) => {
    if (!validateOrder(payload)) {
      controller.abort('Invalid order');
    }
    return { step: 'validation', valid: true };
  }, { priority: 100 });
  
  // Step 2: Payment (priority 90)
  useActionHandler('processOrder', async (payload, controller) => {
    const payment = await processPayment(payload.paymentInfo);
    controller.setResult({ step: 'payment', transactionId: payment.id });
    return payment;
  }, { priority: 90 });
  
  // Step 3: Fulfillment (priority 80)
  useActionHandler('processOrder', async (payload, controller) => {
    const results = controller.getResults();
    const paymentResult = results.find(r => r.step === 'payment');
    
    if (paymentResult) {
      const order = await fulfillOrder(payload, paymentResult.transactionId);
      return { step: 'fulfillment', orderId: order.id };
    }
  }, { priority: 80 });
  
  return null;
}
```

### Parallel Processing

Multiple handlers processing the same action independently:

```typescript
function ParallelHandlers() {
  // Analytics tracking (independent)
  useActionHandler('userAction', async (payload) => {
    await analytics.track(payload.action, payload.data);
    return { provider: 'analytics', tracked: true };
  }, { id: 'analytics' });
  
  // Error monitoring (independent)
  useActionHandler('userAction', async (payload) => {
    await errorMonitor.log(payload.action, payload.context);
    return { provider: 'monitor', logged: true };
  }, { id: 'monitor' });
  
  // User feedback (independent)
  useActionHandler('userAction', (payload) => {
    showToast(`Action ${payload.action} completed`);
    return { provider: 'ui', notified: true };
  }, { id: 'ui-feedback' });
  
  return null;
}
```

### Error Recovery

Graceful error handling and recovery:

```typescript
function ErrorRecoveryHandlers() {
  // Primary handler
  useActionHandler('apiCall', async (payload, controller) => {
    try {
      const result = await primaryApi.call(payload.endpoint, payload.data);
      controller.setResult({ provider: 'primary', success: true, data: result });
      return result;
    } catch (error) {
      controller.setResult({ provider: 'primary', success: false, error });
      // Don't abort - let fallback handler try
      return { error: error.message };
    }
  }, { priority: 100, id: 'primary-api' });
  
  // Fallback handler
  useActionHandler('apiCall', async (payload, controller) => {
    const results = controller.getResults();
    const primaryFailed = results.some(r => r.provider === 'primary' && !r.success);
    
    if (primaryFailed) {
      try {
        const result = await fallbackApi.call(payload.endpoint, payload.data);
        return { success: true, data: result, fallback: true };
      } catch (error) {
        controller.abort(`All API providers failed: ${error.message}`);
      }
    }
    
    return { skipped: true, reason: 'primary-succeeded' };
  }, { priority: 90, id: 'fallback-api' });
  
  return null;
}
```

## Advanced Use Cases

### Command Pattern Implementation

```typescript
interface CommandActions extends ActionPayloadMap {
  executeCommand: {
    type: 'create' | 'update' | 'delete';
    entity: string;
    data: any;
  };
}

function CommandProcessor() {
  const dispatch = useActionDispatch();
  
  useActionHandler('executeCommand', async (payload, controller) => {
    const command = createCommand(payload.type, payload.entity, payload.data);
    
    try {
      const result = await command.execute();
      
      // Log command execution
      dispatch('trackEvent', {
        event: 'command_executed',
        data: {
          commandType: payload.type,
          entity: payload.entity,
          success: true
        }
      });
      
      return result;
    } catch (error) {
      // Log command failure
      dispatch('logError', {
        error: error.message,
        context: { command: payload },
        severity: 'high'
      });
      
      controller.abort(`Command execution failed: ${error.message}`);
    }
  }, [dispatch]);
  
  return null;
}
```

### Event Aggregation

```typescript
function EventAggregator() {
  const dispatch = useActionDispatch();
  
  useActionHandler('userInteraction', useCallback((payload, controller) => {
    // Collect interaction data
    const interactionData = {
      type: payload.type,
      element: payload.element,
      timestamp: Date.now(),
      sessionId: getSessionId()
    };
    
    // Store for batching
    addToInteractionBuffer(interactionData);
    
    // Trigger batch processing if buffer is full
    if (isBufferFull()) {
      dispatch('flushInteractions', { interactions: getBufferContents() });
      clearBuffer();
    }
    
    return { buffered: true };
  }, [dispatch]), { id: 'interaction-aggregator' });
  
  useActionHandler('flushInteractions', async (payload) => {
    await analytics.batchTrack(payload.interactions);
    return { flushed: payload.interactions.length };
  }, { id: 'interaction-flusher' });
  
  return null;
}
```

## Best Practices

### 1. Handler Organization
- Create dedicated handler components for related functionality
- Use meaningful handler IDs for debugging
- Group handlers by domain or responsibility

### 2. Priority Management
- Use high priorities (90-100) for critical setup/validation
- Use medium priorities (50-80) for business logic
- Use low priorities (10-40) for cleanup/logging

### 3. Error Handling
- Use `controller.abort()` for critical failures that should stop execution
- Return error objects for non-critical failures
- Implement fallback handlers for resilience

### 4. Performance
- Always wrap handlers with `useCallback` to prevent re-registration
- Use handler IDs to enable debugging and profiling
- Avoid complex computations in handlers - delegate to services

### 5. Testing
- Test handlers in isolation using direct action dispatch
- Mock dependencies and services
- Test error scenarios and edge cases

## Related

- **[Action Registry API](./action-registry)** - Action registration and management
- **[Pipeline Controller API](./pipeline-controller)** - Pipeline control methods
- **[Action Only Example](../examples/action-only)** - Complete usage examples

---


# Guide Action Handlers

**Source**: `guide/action-handlers.md`  
**Priority**: 80 (essential)  

# Action Handlers

Action handlers contain the business logic of your application. Learn how to implement, register, and manage handlers effectively for scalable, maintainable applications.

## Handler Implementation Pattern

### Best Practice: useActionHandler Pattern

The recommended pattern for handler registration uses `useActionHandler` + `useEffect` for optimal performance and proper cleanup:

```typescript
import React, { useEffect, useCallback } from 'react';
import { useUserActionHandler, useUserStores } from '@/stores/user.store';

function useUserHandlers() {
  const addHandler = useUserActionHandler();
  const stores = useUserStores();
  
  // Wrap handler with useCallback to prevent re-registration
  const updateProfileHandler = useCallback(async (payload, controller) => {
    // Lazy evaluation using stores for current state
    const profileStore = stores.getStore('profile');
    const currentProfile = profileStore.getValue();
    
    // Validation
    if (payload.validate && !isValidEmail(payload.data.email)) {
      controller.abort('Invalid email format');
      return;
    }
    
    // Business logic
    const updatedProfile = {
      ...currentProfile,
      ...payload.data,
      updatedAt: Date.now()
    };
    
    // Update store
    profileStore.setValue(updatedProfile);
    
    // Return result for collection
    return { success: true, profile: updatedProfile };
  }, [stores]);
  
  // Register handler with cleanup
  useEffect(() => {
    if (!addHandler) return;
    
    // Register returns unregister function
    const unregister = addHandler('updateProfile', updateProfileHandler, {
      priority: 100,      // Higher priority executes first
      blocking: true,     // Wait for async completion in sequential mode
      tags: ['business'], // For filtering
      id: 'profile-updater' // Explicit ID for debugging
    });
    
    // Critical: Return unregister for memory cleanup on unmount
    return unregister;
  }, [addHandler, updateProfileHandler]);
}
```

## Handler Configuration Options

```typescript
interface HandlerConfig {
  priority?: number;        // Execution order (higher = first)
  blocking?: boolean;       // Wait for async completion
  tags?: string[];         // For filtering and categorization
  id?: string;            // Explicit handler ID
  category?: string;      // Handler category
  returnType?: 'value';   // Enable return value collection
}
```

## Handler Execution Flow

1. **Sequential Mode** (default): Handlers run in priority order
2. **Parallel Mode**: All handlers execute simultaneously
3. **Race Mode**: First handler to complete wins

```typescript
// Sequential with blocking
addHandler('processOrder', handler1, { priority: 100, blocking: true });
addHandler('processOrder', handler2, { priority: 90, blocking: true });
addHandler('processOrder', handler3, { priority: 80, blocking: true });
// Execution: handler1 → waits → handler2 → waits → handler3

// Parallel execution
dispatch('processOrder', payload, { executionMode: 'parallel' });
```

## Controller Methods

The controller provides methods to manage handler execution flow:

```typescript
const handler = async (payload, controller) => {
  // Abort pipeline
  if (error) controller.abort('Error message');
  
  // Jump to specific priority
  if (urgent) controller.jumpToPriority(90);
  
  // Set result for collection
  controller.setResult(computedValue);
  
  // Terminate pipeline with result
  if (canFinishEarly) controller.return(finalResult);
};
```

## Advanced Handler Patterns

### Error Handling

```typescript
const robustHandler = useCallback(async (payload, controller) => {
  const store = stores.getStore('data');
  
  try {
    // Risky operation
    const result = await performRiskyOperation(payload);
    store.setValue(result);
    
    return { success: true, data: result };
  } catch (error) {
    // Proper error handling with context
    controller.abort(`Operation failed: ${error.message}`, {
      operation: 'performRiskyOperation',
      payload,
      timestamp: Date.now(),
      error: error.stack
    });
    
    return { success: false, error: error.message };
  }
}, [stores]);
```

### Validation Handlers

```typescript
const validationHandler = useCallback(async (payload, controller) => {
  // Input validation
  const errors = validatePayload(payload);
  if (errors.length > 0) {
    controller.abort('Validation failed', { errors });
    return { success: false, errors };
  }
  
  // Business rule validation
  const store = stores.getStore('state');
  const currentState = store.getValue();
  
  if (!canPerformAction(currentState, payload)) {
    controller.abort('Action not allowed in current state');
    return { success: false, error: 'INVALID_STATE' };
  }
  
  return { success: true };
}, [stores]);
```

### Side Effects Handlers

```typescript
const sideEffectsHandler = useCallback(async (payload, controller) => {
  const store = stores.getStore('data');
  
  // Main operation
  const result = await mainOperation(payload);
  store.setValue(result);
  
  // Side effects (fire and forget)
  scheduleCleanup(result.id);
  sendAnalytics('operation_completed', { id: result.id });
  logActivity('user_action', { action: 'update', userId: payload.userId });
  
  // Optional: Set result for collection
  controller.setResult(result);
  
  return result;
}, [stores]);
```

## Result Collection

Collect results from multiple handlers:

```typescript
function useOrderProcessing() {
  const dispatchWithResult = useUserActionWithResult();
  
  const processOrder = async (orderData) => {
    const result = await dispatchWithResult('processOrder', orderData, {
      result: {
        collect: true,         // Enable collection
        strategy: 'all',       // Collect all results
        timeout: 5000,         // 5 second timeout
        maxResults: 10         // Limit results
      },
      filter: {
        tags: ['validation', 'business'], // Only these handlers
        excludeTags: ['logging']          // Exclude logging
      }
    });
    
    if (result.success) {
      console.log('Results:', result.results);
      console.log('Duration:', result.execution.duration);
    }
    
    return result.result;
  };
}
```

## Handler Organization Patterns

### Domain-Specific Handler Files

```typescript
// hooks/handlers/useUserBusinessHandlers.ts
export function useUserBusinessHandlers() {
  const addHandler = useUserActionHandler();
  const stores = useUserStores();
  
  // Profile handlers
  const updateProfileHandler = useCallback(/* ... */, [stores]);
  const deleteProfileHandler = useCallback(/* ... */, [stores]);
  
  // Authentication handlers  
  const loginHandler = useCallback(/* ... */, [stores]);
  const logoutHandler = useCallback(/* ... */, [stores]);
  
  // Register all handlers
  useEffect(() => {
    if (!addHandler) return;
    
    const unregisterUpdate = addHandler('updateProfile', updateProfileHandler, {
      priority: 100, blocking: true, id: 'update-profile'
    });
    
    const unregisterDelete = addHandler('deleteProfile', deleteProfileHandler, {
      priority: 100, blocking: true, id: 'delete-profile'
    });
    
    const unregisterLogin = addHandler('login', loginHandler, {
      priority: 100, blocking: true, id: 'user-login'
    });
    
    const unregisterLogout = addHandler('logout', logoutHandler, {
      priority: 100, blocking: true, id: 'user-logout'
    });
    
    return () => {
      unregisterUpdate();
      unregisterDelete();
      unregisterLogin();
      unregisterLogout();
    };
  }, [addHandler, updateProfileHandler, deleteProfileHandler, loginHandler, logoutHandler]);
}
```

### Handler Composition

```typescript
// Compose multiple handler hooks
function useAllHandlers() {
  useUserBusinessHandlers();
  useUserUIHandlers();
  useCartHandlers();
  useOrderHandlers();
  // All handlers registered in one place
}
```

## Testing Handlers

### Unit Testing

```typescript
// __tests__/userHandlers.test.ts
import { renderHook } from '@testing-library/react-hooks';
import { useUserHandlers } from '@/hooks/handlers/useUserHandlers';
import { createMockRegistry, createMockController } from '@/test-utils';

describe('User Handlers', () => {
  let mockRegistry;
  let mockController;
  
  beforeEach(() => {
    mockRegistry = createMockRegistry();
    mockController = createMockController();
  });
  
  it('should validate email in update profile handler', async () => {
    const { result } = renderHook(() => useUserHandlers());
    
    const handler = result.current.updateProfileHandler;
    
    await handler(
      { data: { email: 'invalid-email' }, validate: true },
      mockController
    );
    
    expect(mockController.abort).toHaveBeenCalledWith('Invalid email format');
  });
  
  it('should update profile store on success', async () => {
    const mockProfileStore = {
      getValue: jest.fn(() => ({ id: '1', name: 'John' })),
      setValue: jest.fn()
    };
    
    mockRegistry.getStore.mockReturnValue(mockProfileStore);
    
    const { result } = renderHook(() => useUserHandlers());
    
    await result.current.updateProfileHandler(
      { data: { name: 'Jane' } },
      mockController
    );
    
    expect(mockProfileStore.setValue).toHaveBeenCalledWith(
      expect.objectContaining({
        name: 'Jane',
        updatedAt: expect.any(Number)
      })
    );
  });
});
```

## Performance Considerations

### Handler Optimization

```typescript
// ✅ Good: Stable handler with minimal dependencies
const optimizedHandler = useCallback(async (payload, controller) => {
  const store = registry.getStore('data');
  // Handler logic
}, [registry]); // Only registry dependency

// ❌ Bad: Handler recreated every render
const unoptimizedHandler = async (payload, controller) => {
  // New function every render
};
```

### Lazy Loading

```typescript
// Conditionally register expensive handlers
function useConditionalHandlers(userRole: string) {
  const addHandler = useActionHandler();
  
  useEffect(() => {
    if (!addHandler) return;
    
    const handlers = [];
    
    // Always register basic handlers
    handlers.push(addHandler('basic', basicHandler));
    
    // Only register admin handlers for admins
    if (userRole === 'admin') {
      handlers.push(addHandler('admin', adminHandler));
    }
    
    return () => handlers.forEach(unregister => unregister());
  }, [addHandler, userRole]);
}
```

## Common Handler Anti-Patterns

### ❌ Missing Cleanup

```typescript
// Wrong - Memory leak
useEffect(() => {
  addHandler('action', handler);
}, []); // No cleanup
```

### ❌ Stale Closures

```typescript
// Wrong - Using stale values
const data = store.getValue();
const handler = useCallback(() => {
  console.log(data); // Stale value
}, [data]);
```

### ❌ Missing Error Handling

```typescript
// Wrong - Silent failures
const handler = async (payload, controller) => {
  await riskyOperation(); // No error handling
};
```

## Summary

Effective action handler implementation requires:

- **Proper Registration**: Use `useActionHandler` + `useEffect` pattern
- **Memory Management**: Always return cleanup functions
- **Error Handling**: Robust error handling with meaningful messages
- **Performance**: Stable handlers with `useCallback`
- **Testing**: Isolated unit tests for business logic
- **Organization**: Domain-specific handler files

Action handlers are the heart of your business logic - implement them correctly for maintainable, scalable applications.

---

::: tip Next Steps
- Learn [Store Management](./store-management) for effective state handling
- Explore [Cross-Domain Integration](./cross-domain-integration) for multi-domain handlers
- See [Testing Guide](./testing) for comprehensive handler testing strategies
:::

---


# Guide Action Pipeline

**Source**: `guide/action-pipeline.md`  
**Priority**: 80 (essential)  

# Action Pipeline System

The **Action Pipeline System** is the core of Context-Action's ViewModel layer, providing centralized action processing with priority-based handler execution and sophisticated pipeline control.

## Core Concepts

### ActionRegister

The `ActionRegister` class is the heart of the action pipeline system:

```typescript
import { ActionRegister, type ActionPayloadMap } from '@context-action/core';

interface MyActions extends ActionPayloadMap {
  authenticate: { username: string; password: string };
  processData: { data: any; options?: Record<string, any> };
  uploadFile: { filename: string; content: string };
}

const actionRegister = new ActionRegister<MyActions>({
  name: 'MyAppActions',
  registry: {
    debug: false,
    defaultExecutionMode: 'sequential'
  }
});
```

### Handler Registration

Register handlers with priority-based execution:

```typescript
// Higher priority handlers execute first (priority 100 > 50 > 10)
actionRegister.register('authenticate', validateCredentials, { priority: 100 });
actionRegister.register('authenticate', checkRateLimit, { priority: 90 });
actionRegister.register('authenticate', performAuth, { priority: 80 });
actionRegister.register('authenticate', logAudit, { priority: 70 });
```

### Pipeline Controller

Each handler receives a `PipelineController` for advanced pipeline management:

```typescript
actionRegister.register('authenticate', async (payload, controller) => {
  // 1. Validate input
  if (!payload.username) {
    controller.abort('Username is required');
    return;
  }
  
  // 2. Modify payload for subsequent handlers
  controller.modifyPayload(current => ({
    ...current,
    timestamp: Date.now(),
    validated: true
  }));
  
  // 3. Set intermediate results
  controller.setResult({ step: 'validation', success: true });
  
  // 4. Return final result
  return { validated: true, user: payload.username };
});
```

## Priority-Based Execution

### Execution Order

Handlers execute in **descending priority order** (highest first):

```typescript
const executionOrder: string[] = [];

actionRegister.register('processData', () => {
  executionOrder.push('low');    // Priority: 10
}, { priority: 10 });

actionRegister.register('processData', () => {
  executionOrder.push('high');   // Priority: 100  
}, { priority: 100 });

actionRegister.register('processData', () => {
  executionOrder.push('medium'); // Priority: 50
}, { priority: 50 });

await actionRegister.dispatch('processData', { data: 'test' });
// executionOrder: ['high', 'medium', 'low']
```

### Handler Configuration

```typescript
actionRegister.register('uploadFile', handler, {
  id: 'file-processor',           // Unique identifier
  priority: 50,                   // Execution priority
  once: false,                    // Execute multiple times
  blocking: true,                 // Wait for completion
  condition: (payload) => payload.filename.endsWith('.pdf'), // Conditional execution
  metadata: {                     // Custom metadata
    description: 'PDF file processor',
    version: '1.0.0'
  }
});
```

## Pipeline Control Methods

### controller.abort()

Stop pipeline execution with optional reason:

```typescript
actionRegister.register('authenticate', (payload, controller) => {
  if (!isValidUser(payload.username)) {
    controller.abort('Invalid user credentials');
    return;
  }
  // Subsequent handlers won't execute
});
```

### controller.modifyPayload()

Transform payload for subsequent handlers:

```typescript
actionRegister.register('processData', (payload, controller) => {
  controller.modifyPayload(current => ({
    ...current,
    processed: true,
    timestamp: Date.now(),
    version: '2.0'
  }));
}, { priority: 100 });

actionRegister.register('processData', (payload) => {
  // payload now includes: processed, timestamp, version
  console.log(payload.processed); // true
}, { priority: 50 });
```

### controller.setResult() and getResults()

Manage intermediate results across handlers:

```typescript
actionRegister.register('uploadFile', (payload, controller) => {
  // Set intermediate result
  controller.setResult({ step: 'validation', fileSize: 1024 });
  
  return { step: 'upload', fileId: 'file-123' };
}, { priority: 100 });

actionRegister.register('uploadFile', (payload, controller) => {
  // Access previous results
  const previousResults = controller.getResults();
  console.log(previousResults); 
  // [{ step: 'validation', fileSize: 1024 }, { step: 'upload', fileId: 'file-123' }]
}, { priority: 50 });
```

## Execution Modes

### Sequential Mode (Default)

Handlers execute one after another:

```typescript
actionRegister.setActionExecutionMode('processData', 'sequential');

// Handler 1 completes → Handler 2 starts → Handler 3 starts
```

### Parallel Mode

All handlers execute simultaneously:

```typescript
actionRegister.setActionExecutionMode('processData', 'parallel');

// Handler 1, 2, 3 all start at the same time
```

### Race Mode

First handler to complete wins:

```typescript
actionRegister.setActionExecutionMode('processData', 'race');

// First handler to return stops the rest
```

## Result Collection

### Basic Dispatch

```typescript
const result = await actionRegister.dispatch('authenticate', {
  username: 'john',
  password: 'secret123'
});
```

### Dispatch with Result Collection

```typescript
const result = await actionRegister.dispatchWithResult('uploadFile', 
  { filename: 'document.pdf', content: 'pdf content' },
  { result: { collect: true } }
);

console.log(result);
// {
//   success: true,
//   aborted: false,
//   terminated: false,
//   results: [
//     { step: 'validation', success: true },
//     { step: 'upload', fileId: 'file-123' },
//     { step: 'notification', sent: true }
//   ],
//   execution: {
//     handlersExecuted: 3,
//     startTime: 1640995200000,
//     endTime: 1640995200500,
//     duration: 500
//   }
// }
```

## Error Handling

The pipeline continues execution even when individual handlers fail:

```typescript
actionRegister.register('processData', () => {
  throw new Error('Handler 1 failed');
}, { priority: 100 });

actionRegister.register('processData', () => {
  return { success: true, step: 'recovery' };
}, { priority: 50 });

const result = await actionRegister.dispatchWithResult('processData', 
  { data: 'test' },
  { result: { collect: true } }
);

// result.success: true (pipeline succeeds)
// result.results: [{ success: true, step: 'recovery' }] (only successful results)
```

## Real-World Example: Authentication Flow

```typescript
interface AuthActions extends ActionPayloadMap {
  authenticate: { username: string; password: string };
}

const authRegister = new ActionRegister<AuthActions>();

// 1. Input validation (Priority: 100)
authRegister.register('authenticate', (payload, controller) => {
  if (!payload.username || !payload.password) {
    controller.abort('Missing credentials');
    return;
  }
  return { step: 'validation', valid: true };
}, { priority: 100, id: 'validator' });

// 2. Rate limiting (Priority: 90)
authRegister.register('authenticate', (payload) => {
  // Check rate limiting
  return { step: 'rate-limiting', allowed: true };
}, { priority: 90, id: 'rate-limiter' });

// 3. Authentication (Priority: 80)
authRegister.register('authenticate', async (payload) => {
  const user = await authenticateUser(payload.username, payload.password);
  return { 
    step: 'authentication', 
    user: { id: user.id, username: user.username },
    token: generateJWT(user)
  };
}, { priority: 80, id: 'authenticator' });

// 4. Audit logging (Priority: 70)
authRegister.register('authenticate', (payload) => {
  logAuthAttempt(payload.username, true);
  return { step: 'audit', logged: true, timestamp: Date.now() };
}, { priority: 70, id: 'auditor' });

// Execute the complete authentication pipeline
const result = await authRegister.dispatchWithResult('authenticate', {
  username: 'john',
  password: 'secret123'
}, { result: { collect: true } });

// Result contains all steps: validation → rate-limiting → authentication → audit
```

## Integration with React

The Action Pipeline integrates seamlessly with React through the Action Context pattern:

```typescript
const { Provider, useActionDispatch, useActionHandler } = createActionContext<AuthActions>('Auth');

function AuthComponent() {
  const dispatch = useActionDispatch();
  
  // Register handlers in components
  useActionHandler('authenticate', async (payload) => {
    // Handle authentication
  });
  
  const handleLogin = async () => {
    await dispatch('authenticate', { username: 'john', password: 'secret' });
  };
  
  return <button onClick={handleLogin}>Login</button>;
}
```

## Next Steps

- **[Main Patterns](./patterns)** - Learn about Action Only and Store Only patterns
- **[API Reference](../api/core/action-register)** - Detailed ActionRegister API documentation  
- **[Examples](../examples/action-only)** - See Action Only pattern in practice

---


# Guide Best Practices

**Source**: `guide/best-practices.md`  
**Priority**: 80 (essential)  

# Development Best Practices

Essential best practices for building maintainable, scalable applications with the Context-Action framework. Follow these guidelines to ensure code quality, performance, and team productivity.

## Handler Registration Best Practices

### 1. Always Use `useActionRegister` + `useEffect` Pattern

```typescript
// ✅ Correct: Proper registration with cleanup
function useUserHandlers() {
  const register = useUserActionRegister();
  const registry = useUserRegistry();
  
  const handler = useCallback(async (payload, controller) => {
    // Handler logic
  }, [registry]);
  
  useEffect(() => {
    if (!register) return;
    const unregister = register('action', handler, {
      priority: 100,
      blocking: true
    });
    return unregister; // Critical: cleanup on unmount
  }, [register, handler]);
}

// ❌ Wrong: Missing cleanup
function useUserHandlers() {
  const register = useUserActionRegister();
  
  useEffect(() => {
    register('action', handler); // Memory leak!
  }, []);
}
```

### 2. Use `blocking: true` for Sequential Async Handlers

```typescript
// ✅ Correct: Sequential execution
register('asyncAction', asyncHandler, { 
  priority: 100, 
  blocking: true // Wait for completion
});

// ❌ Wrong: Handlers execute simultaneously
register('asyncAction', asyncHandler, { 
  priority: 100 
  // Missing blocking: true
});
```

### 3. Consider Explicit IDs for Debugging and Critical Handlers

```typescript
// ✅ Good: Explicit IDs for debugging
register('updateProfile', handler, {
  priority: 100,
  blocking: true,
  id: 'profile-updater-main' // Helpful for debugging
});

// ✅ Also good: Auto-generated IDs for simple cases
register('updateProfile', handler, {
  priority: 100,
  blocking: true
  // Framework generates ID automatically
});
```

### 4. Wrap Handlers with `useCallback` to Prevent Re-registration

```typescript
// ✅ Correct: Stable handler reference
const handler = useCallback(async (payload, controller) => {
  // Handler logic
}, [registry]); // Stable dependencies only

// ❌ Wrong: Handler recreated every render
const handler = async (payload, controller) => {
  // This creates new function every render
};
```

## Store Access Best Practices

### 5. Use Domain-Specific Hooks in Components

```typescript
// ✅ Correct: Domain-specific hooks
function UserProfile() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  const dispatch = useUserAction();
  
  return <div>{profile.name}</div>;
}

// ❌ Wrong: Generic hooks (no type safety)
function UserProfile() {
  const store = useStore('user-profile'); // No type information
  const dispatch = useDispatch(); // No action safety
}
```

### 6. Use `registry.getStore()` for Lazy Evaluation in Handlers

```typescript
// ✅ Correct: Lazy evaluation (fresh values)
const handler = useCallback(async (payload, controller) => {
  const profileStore = registry.getStore('profile');
  const currentProfile = profileStore.getValue(); // Current value
  
  // Business logic with fresh data
}, [registry]);

// ❌ Wrong: Stale closure
const profile = profileStore.getValue();
const handler = useCallback(async (payload, controller) => {
  console.log(profile); // Stale value from registration time
}, [profile]);
```

### 7. Provide Proper Initial Values, Not Null

```typescript
// ✅ Correct: Proper initial values
export const userStores = createDeclarativeStores<UserData>('User', {
  profile: {
    initialValue: {
      id: '',
      name: '',
      email: ''
    }
  }
});

// ❌ Wrong: Null values cause type issues
export const userStores = createDeclarativeStores<UserData>('User', {
  profile: {
    initialValue: null // TypeScript errors, runtime issues
  }
});
```

### 8. Keep Store Updates Predictable and Traceable

```typescript
// ✅ Correct: Clear, traceable updates
const updateProfile = useCallback(async (updates: Partial<UserProfile>) => {
  const profileStore = registry.getStore('profile');
  const currentProfile = profileStore.getValue();
  
  const newProfile = {
    ...currentProfile,
    ...updates,
    updatedAt: Date.now() // Add metadata
  };
  
  profileStore.setValue(newProfile);
  
  // Log for debugging
  console.log('Profile updated:', { from: currentProfile, to: newProfile });
}, [registry]);

// ❌ Wrong: Unclear mutations
const updateProfile = useCallback((updates) => {
  // Direct mutation (hard to debug)
  Object.assign(currentProfile, updates);
}, []);
```

## Type Safety (Recommended)

### 9. Define Interfaces for Better Type Safety

```typescript
// ✅ Good: Clear interfaces
export interface UserData {
  profile: {
    id: string;
    name: string;
    email: string;
    role: 'admin' | 'user' | 'guest';
  };
  preferences: {
    theme: 'light' | 'dark';
    language: string;
  };
}

export interface UserActions {
  updateProfile: { data: Partial<UserData['profile']> };
  deleteUser: { userId: string };
  resetUser: void; // Explicit void for actions without payload
}

// ❌ Avoid: Any types (lose safety)
export interface UserActions {
  updateProfile: any;
  deleteUser: any;
}
```

### 10. Use Domain-Specific Hooks for Type Inference

```typescript
// ✅ Correct: Automatic type inference
function UserComponent() {
  const profileStore = useUserStore('profile'); // Store<UserProfile>
  const profile = useStoreValue(profileStore);  // UserProfile
  const dispatch = useUserAction();             // Typed dispatcher
  
  dispatch('updateProfile', { 
    data: { name: 'New Name' } // ✓ Type-checked
  });
}
```

### 11. Avoid `any` Types - Leverage TypeScript

```typescript
// ✅ Correct: Proper typing
const handler = useCallback(async (
  payload: UserActions['updateProfile'],
  controller: ActionController
) => {
  // Fully typed handler
}, []);

// ❌ Wrong: Any types defeat the purpose
const handler = useCallback(async (payload: any, controller: any) => {
  // Lost all type safety
}, []);
```

## Performance Best Practices

### 12. Only Subscribe to Needed Stores

```typescript
// ✅ Correct: Minimal subscriptions
function UserName() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  // Only re-renders when profile changes
  return <span>{profile.name}</span>;
}

// ❌ Wrong: Over-subscription
function UserName() {
  const profileStore = useUserStore('profile');
  const preferencesStore = useUserStore('preferences'); // Unnecessary
  const sessionStore = useUserStore('session'); // Unnecessary
  
  const profile = useStoreValue(profileStore);
  const preferences = useStoreValue(preferencesStore); // Causes extra re-renders
  const session = useStoreValue(sessionStore); // Causes extra re-renders
  
  return <span>{profile.name}</span>; // Only needs profile
}
```

### 13. Use Proper Handler Priorities

```typescript
// ✅ Correct: Logical priority order
register('updateProfile', validationHandler, { 
  priority: 200, // Validation first
  blocking: true 
});

register('updateProfile', updateHandler, { 
  priority: 100, // Main logic second
  blocking: true 
});

register('updateProfile', loggingHandler, { 
  priority: 50,  // Logging last
  blocking: true 
});
```

### 14. Clean Up Handlers on Unmount

```typescript
// ✅ Correct: All handlers cleaned up
useEffect(() => {
  if (!register) return;
  
  const unregisterA = register('actionA', handlerA);
  const unregisterB = register('actionB', handlerB);
  const unregisterC = register('actionC', handlerC);
  
  return () => {
    unregisterA();
    unregisterB();
    unregisterC();
  };
}, [register, handlerA, handlerB, handlerC]);
```

### 15. Use Result Collection Selectively

```typescript
// ✅ Good: Only when you need results
const dispatchWithResult = useUserActionWithResult();

const criticalAction = async () => {
  const result = await dispatchWithResult('importantAction', payload, {
    result: { collect: true, strategy: 'all' }
  });
  
  // Process results
  return result.results;
};

// ✅ Also good: Regular dispatch when results not needed
const dispatch = useUserAction();

const simpleAction = () => {
  dispatch('simpleAction', payload); // No result collection overhead
};
```

## Architecture Best Practices

### 16. One Domain = One Context Boundary

```typescript
// ✅ Correct: Clear domain boundaries
function App() {
  return (
    <UserProvider>        {/* User domain */}
      <CartProvider>      {/* Cart domain */}
        <OrderProvider>   {/* Order domain */}
          <AppContent />
        </OrderProvider>
      </CartProvider>
    </UserProvider>
  );
}
```

### 17. Separate Business and UI Concerns

```typescript
// ✅ Correct: Separated concerns
// Business data
interface UserBusinessData {
  profile: UserProfile;
  session: UserSession;
}

// UI state  
interface UserUIState {
  isEditing: boolean;
  selectedTab: string;
  loadingState: LoadingState;
}

// Separate providers
<UserBusinessProvider>
  <UserUIProvider>
    <UserComponents />
  </UserUIProvider>
</UserBusinessProvider>
```

### 18. Prefer Domain Isolation - Use Cross-Domain Only When Necessary

```typescript
// ✅ Good: Domain isolation (preferred)
function UserProfile() {
  const profileStore = useUserStore('profile');
  const userAction = useUserAction();
  // Self-contained user logic
}

// ✅ Also good: Cross-domain when truly needed
function useCheckoutProcess() {
  const userProfile = useUserStore('profile');
  const cartItems = useCartStore('items');
  const userAction = useUserAction();
  const cartAction = useCartAction();
  
  // Business logic that truly spans domains
}

// ❌ Avoid: Unnecessary coupling
function UserProfile() {
  const cartItems = useCartStore('items'); // Why does user profile need cart?
}
```

### 19. Document Domain Boundaries Clearly

```typescript
// ✅ Good: Clear documentation
/**
 * User Domain
 * 
 * Responsibilities:
 * - User authentication and profile management
 * - User preferences and settings
 * - User session management
 * 
 * Dependencies:
 * - None (self-contained)
 * 
 * Provides to other domains:
 * - User ID for data association
 * - Authentication status
 */
export interface UserData {
  // Domain data definition
}
```

## Development Workflow Best Practices

### 20. Test Handlers in Isolation

```typescript
// ✅ Good: Isolated handler testing
describe('updateProfile handler', () => {
  it('should update profile with valid data', async () => {
    // Arrange
    const mockRegistry = createMockRegistry();
    const mockController = createMockController();
    const handler = createUpdateProfileHandler(mockRegistry);
    
    // Act
    const result = await handler(
      { data: { name: 'John Doe' } },
      mockController
    );
    
    // Assert
    expect(result).toEqual({ success: true });
    expect(mockRegistry.getStore('profile').setValue).toHaveBeenCalledWith({
      name: 'John Doe'
    });
  });
});
```

### 21. Use Consistent Error Handling

```typescript
// ✅ Correct: Consistent error patterns
const handler = useCallback(async (payload, controller) => {
  try {
    // Validation
    if (!isValid(payload)) {
      controller.abort('Validation failed: invalid payload');
      return { success: false, error: 'VALIDATION_ERROR' };
    }
    
    // Business logic
    const result = await performOperation(payload);
    
    return { success: true, data: result };
    
  } catch (error) {
    controller.abort('Operation failed', error);
    return { 
      success: false, 
      error: error.code || 'UNKNOWN_ERROR',
      message: error.message 
    };
  }
}, []);
```

### 22. Implement Progressive Enhancement

```typescript
// ✅ Good: Progressive enhancement
function useUserFeatures() {
  const profile = useStoreValue(useUserStore('profile'));
  const [advancedFeatures, setAdvancedFeatures] = useState(false);
  
  // Enable advanced features progressively
  useEffect(() => {
    if (profile.role === 'premium' && profile.isActive) {
      setAdvancedFeatures(true);
    }
  }, [profile.role, profile.isActive]);
  
  return {
    basicFeatures: true,      // Always available
    advancedFeatures,         // Conditionally available
    adminFeatures: profile.role === 'admin' // Role-based
  };
}
```

## Code Organization Best Practices

### 23. Consistent File Structure

```mermaid
graph TD
    A[src/] --> B[stores/]
    A --> C[hooks/]
    A --> D[components/]
    A --> E[providers/]
    
    B --> B1[user/]
    B --> B2[cart/]
    B --> B3[index.ts]
    
    B1 --> B1a[userBusiness.store.ts]
    B1 --> B1b[userUI.store.ts]
    B1 --> B1c[index.ts]
    
    B2 --> B2a[cart.store.ts]
    B2 --> B2b[index.ts]
    
    C --> C1[handlers/]
    C --> C2[logic/]
    C --> C3[integration/]
    
    C1 --> C1a[useUserHandlers.ts]
    C1 --> C1b[useCartHandlers.ts]
    C1 --> C1c[index.ts]
    
    C2 --> C2a[useUserLogic.ts]
    C2 --> C2b[useCartLogic.ts]
    C2 --> C2c[index.ts]
    
    C3 --> C3a[useUserCartIntegration.ts]
    C3 --> C3b[index.ts]
    
    D --> D1[user/]
    D --> D2[cart/]
    D --> D3[shared/]
    
    E --> E1[UserProvider.tsx]
    E --> E2[CartProvider.tsx]
    E --> E3[AppProvider.tsx]
    
    style A fill:#e3f2fd
    style B fill:#fff8e1
    style C fill:#e8f5e8
    style D fill:#fce4ec
    style E fill:#f3e5f5
```

### 24. Use Barrel Exports

```typescript
// stores/user/index.ts
export * from './userBusiness.store';
export * from './userUI.store';

// stores/index.ts  
export * from './user';
export * from './cart';
export * from './order';

// Usage
import { useUserStore, useCartStore } from '@/stores';
```

### 25. Implement Consistent Naming Conventions

```typescript
// ✅ Consistent naming
// Stores
export const useUserBusinessStore = ...;
export const useUserUIStore = ...;

// Actions
export const useUserBusinessAction = ...;
export const useUserUIAction = ...;

// Handlers
export const useUserBusinessHandlers = ...;
export const useUserUIHandlers = ...;

// Logic hooks
export const useUserProfile = ...;
export const useUserSettings = ...;
```

---

## Summary Checklist

### Handler Registration ✓
- [ ] Always use `useActionRegister` + `useEffect` pattern
- [ ] Return unregister function for cleanup
- [ ] Use `blocking: true` for sequential async handlers
- [ ] Consider explicit IDs for debugging and critical handlers
- [ ] Wrap handlers with `useCallback` to prevent re-registration

### Store Access ✓
- [ ] Use domain-specific hooks in components
- [ ] Use `registry.getStore()` for lazy evaluation in handlers
- [ ] Provide proper initial values, not null
- [ ] Keep store updates predictable and traceable

### Type Safety ✓
- [ ] Define interfaces for better type safety
- [ ] Use domain-specific hooks for type inference
- [ ] Avoid `any` types - leverage TypeScript

### Performance ✓
- [ ] Only subscribe to needed stores
- [ ] Use proper handler priorities
- [ ] Clean up handlers on unmount
- [ ] Use result collection selectively

### Architecture ✓
- [ ] One domain = One context boundary
- [ ] Separate business and UI concerns
- [ ] Prefer domain isolation - use cross-domain only when necessary
- [ ] Document domain boundaries clearly

Following these best practices ensures maintainable, scalable, and performant applications with the Context-Action framework.

---

::: tip Continuous Improvement
Regularly review your codebase against this checklist. Consider setting up ESLint rules and automated checks to enforce these patterns in your development workflow.
:::

---


# Guide Common Pitfalls

**Source**: `guide/common-pitfalls.md`  
**Priority**: 80 (essential)  

# Common Pitfalls

Learn from common mistakes and avoid them in your Context-Action implementations. This guide covers the most frequent issues developers encounter and how to fix them.

## Handler Registration Issues

### ❌ Missing Cleanup

**Problem:** Memory leaks from handlers not being cleaned up on component unmount.

```typescript
// ❌ Wrong - Memory leak
function useUserHandlers() {
  const register = useUserActionRegister();
  
  useEffect(() => {
    register('updateProfile', handler);
  }, []); // No cleanup - handlers accumulate in memory
}
```

**Solution:** Always return the unregister function.

```typescript
// ✅ Correct - Proper cleanup
function useUserHandlers() {
  const register = useUserActionRegister();
  
  const handler = useCallback(async (payload, controller) => {
    // Handler logic
  }, []);
  
  useEffect(() => {
    if (!register) return;
    const unregister = register('updateProfile', handler);
    return unregister; // Critical: cleanup on unmount
  }, [register, handler]);
}
```

**Symptoms:**
- Increasing memory usage over time
- Handlers executing multiple times
- Stale closure errors

### ❌ Missing `blocking` for Async Handlers

**Problem:** Async handlers execute simultaneously instead of sequentially.

```typescript
// ❌ Wrong - Handlers execute simultaneously
register('processOrder', asyncHandler1, { priority: 100 });
register('processOrder', asyncHandler2, { priority: 90 });
register('processOrder', asyncHandler3, { priority: 80 });
// All execute at the same time!
```

**Solution:** Use `blocking: true` for async handlers that should run sequentially.

```typescript
// ✅ Correct - Sequential execution
register('processOrder', asyncHandler1, { 
  priority: 100, 
  blocking: true // Wait for completion
});
register('processOrder', asyncHandler2, { 
  priority: 90, 
  blocking: true // Runs after handler1 completes
});
```

**Symptoms:**
- Race conditions between handlers
- Inconsistent state updates
- Handlers overwriting each other's changes

### ❌ Using Stale Closures

**Problem:** Handlers capture stale values from registration time.

```typescript
// ❌ Wrong - Stale closure
function useUserHandlers() {
  const profileStore = useUserStore('profile');
  const profile = profileStore.getValue(); // Captured at registration time
  
  const handler = useCallback(async (payload, controller) => {
    console.log(profile); // This is stale data!
    // Always shows the profile from when handler was registered
  }, [profile]); // Dependencies include stale value
}
```

**Solution:** Use lazy evaluation with registry.getStore().

```typescript
// ✅ Correct - Lazy evaluation
function useUserHandlers() {
  const register = useUserActionRegister();
  const registry = useUserRegistry();
  
  const handler = useCallback(async (payload, controller) => {
    const profileStore = registry.getStore('profile');
    const profile = profileStore.getValue(); // Fresh value at execution time
    console.log(profile); // Always current data
  }, [registry]); // Only registry in dependencies
}
```

**Symptoms:**
- Handlers working with old data
- State updates based on stale values
- Logic that doesn't reflect current application state

## Store Access Issues

### ❌ Not Using Reactive Subscriptions

**Problem:** Components don't re-render when store data changes.

```typescript
// ❌ Wrong - Not reactive
function UserProfile() {
  const profileStore = useUserStore('profile');
  const profile = profileStore.getValue(); // One-time access, not reactive
  
  // Component never re-renders when profile changes
  return <div>{profile.name}</div>;
}
```

**Solution:** Use `useStoreValue()` for reactive subscriptions.

```typescript
// ✅ Correct - Reactive subscription
function UserProfile() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore); // Reactive subscription
  
  // Component re-renders when profile changes
  return <div>{profile.name}</div>;
}
```

**Symptoms:**
- Components not updating when state changes
- Stale UI that doesn't reflect current data
- Manual refresh needed to see changes

### ❌ Direct Store Mutation

**Problem:** Mutating store objects directly instead of using setValue.

```typescript
// ❌ Wrong - Direct mutation
function updateUserName(newName: string) {
  const profileStore = useUserStore('profile');
  const profile = profileStore.getValue();
  
  profile.name = newName; // Direct mutation - no subscribers notified
  // Components won't re-render!
}
```

**Solution:** Always use setValue for updates.

```typescript
// ✅ Correct - Immutable updates
function updateUserName(newName: string) {
  const profileStore = useUserStore('profile');
  const profile = profileStore.getValue();
  
  profileStore.setValue({
    ...profile,
    name: newName // New object - subscribers notified
  });
}
```

**Symptoms:**
- Changes not reflected in UI
- Inconsistent state across components
- Debugging confusion about when state changes

### ❌ Null/Undefined Initial Values

**Problem:** Using null or undefined as initial values causes TypeScript and runtime issues.

```typescript
// ❌ Wrong - Null initial values
const userStores = createDeclarativeStores<UserData>('User', {
  profile: {
    initialValue: null // TypeScript errors, runtime issues
  }
});

function UserProfile() {
  const profile = useStoreValue(useUserStore('profile'));
  return <div>{profile.name}</div>; // Runtime error if profile is null
}
```

**Solution:** Provide proper default values.

```typescript
// ✅ Correct - Proper initial values
const userStores = createDeclarativeStores<UserData>('User', {
  profile: {
    initialValue: {
      id: '',
      name: '',
      email: ''
    }
  }
});

function UserProfile() {
  const profile = useStoreValue(useUserStore('profile'));
  return <div>{profile.name || 'No name'}</div>; // Safe access
}
```

**Symptoms:**
- TypeScript compilation errors
- Runtime null/undefined errors
- Defensive coding needed everywhere

## Type Safety Issues

### ❌ Using Generic Hooks

**Problem:** Losing type safety by using generic hooks instead of domain-specific ones.

```typescript
// ❌ Wrong - No type safety
function UserProfile() {
  const store = useStore('user-profile'); // any type
  const dispatch = useDispatch(); // any action type
  
  dispatch('updateUser', { anyData: 'here' }); // No compile-time checking
}
```

**Solution:** Use domain-specific hooks for full type safety.

```typescript
// ✅ Correct - Full type safety
function UserProfile() {
  const profileStore = useUserStore('profile'); // Store<UserProfile>
  const dispatch = useUserAction(); // Typed dispatcher
  
  dispatch('updateProfile', { 
    data: { name: 'John' } // Compile-time type checking
  });
}
```

### ❌ Any Types in Interfaces

**Problem:** Using `any` types defeats the purpose of TypeScript.

```typescript
// ❌ Wrong - Lost type safety
interface UserActions {
  updateProfile: any;
  deleteUser: any;
}
```

**Solution:** Define proper, specific types.

```typescript
// ✅ Correct - Specific types
interface UserActions {
  updateProfile: { data: Partial<UserProfile> };
  deleteUser: { userId: string };
  resetProfile: void; // Explicit void for no payload
}
```

## Provider Setup Issues

### ❌ Wrong Provider Order

**Problem:** Incorrect provider nesting causes context errors.

```typescript
// ❌ Wrong - Action provider outside store provider
function App() {
  return (
    <UserActionProvider>  {/* Actions need stores to exist */}
      <UserProvider>      {/* Stores created here */}
        <UserProfile />
      </UserProvider>
    </UserActionProvider>
  );
}
// Error: Actions can't access stores
```

**Solution:** Store providers must wrap action providers.

```typescript
// ✅ Correct - Store provider wraps action provider
function App() {
  return (
    <UserProvider>         {/* Stores created first */}
      <UserActionProvider> {/* Actions can access stores */}
        <UserProfile />
      </UserActionProvider>
    </UserProvider>
  );
}
```

### ❌ Missing Handler Setup

**Problem:** Forgetting to set up handlers in the provider tree.

```typescript
// ❌ Wrong - Handlers never registered
function App() {
  return (
    <UserProvider>
      <UserActionProvider>
        <UserProfile /> {/* Actions dispatch but no handlers respond */}
      </UserActionProvider>
    </UserProvider>
  );
}
```

**Solution:** Include handler setup component.

```typescript
// ✅ Correct - Handlers properly set up
function HandlerSetup() {
  useUserHandlers(); // Register all handlers
  return null;
}

function App() {
  return (
    <UserProvider>
      <UserActionProvider>
        <HandlerSetup />    {/* Handlers registered */}
        <UserProfile />
      </UserActionProvider>
    </UserProvider>
  );
}
```

## Performance Issues

### ❌ Over-Subscription

**Problem:** Components subscribing to more stores than needed.

```typescript
// ❌ Wrong - Unnecessary subscriptions
function UserName() {
  const profile = useStoreValue(useUserStore('profile'));
  const preferences = useStoreValue(useUserStore('preferences')); // Not needed
  const session = useStoreValue(useUserStore('session')); // Not needed
  const history = useStoreValue(useUserStore('history')); // Not needed
  
  // Component re-renders when ANY of these change
  return <span>{profile.name}</span>; // Only needs profile
}
```

**Solution:** Only subscribe to stores you actually use.

```typescript
// ✅ Correct - Minimal subscriptions
function UserName() {
  const profile = useStoreValue(useUserStore('profile'));
  
  // Only re-renders when profile changes
  return <span>{profile.name}</span>;
}
```

### ❌ Handler Re-creation

**Problem:** Creating new handler functions on every render.

```typescript
// ❌ Wrong - Handler recreated every render
function useUserHandlers() {
  const register = useUserActionRegister();
  
  // New function created every render
  const handler = async (payload, controller) => {
    // Handler logic
  };
  
  useEffect(() => {
    const unregister = register('action', handler);
    return unregister;
  }, [register, handler]); // Handler changes every render!
}
```

**Solution:** Use `useCallback` to stabilize handler references.

```typescript
// ✅ Correct - Stable handler reference
function useUserHandlers() {
  const register = useUserActionRegister();
  const registry = useUserRegistry();
  
  // Stable function reference
  const handler = useCallback(async (payload, controller) => {
    // Handler logic
  }, [registry]); // Only changes if registry changes
  
  useEffect(() => {
    const unregister = register('action', handler);
    return unregister;
  }, [register, handler]); // Effect only runs when needed
}
```

## Cross-Domain Issues

### ❌ Tight Coupling Between Domains

**Problem:** Domains directly accessing each other's internals.

```typescript
// ❌ Wrong - Direct domain coupling
function useUserHandlers() {
  const cartStore = useCartStore('items'); // User domain accessing cart internals
  
  const loginHandler = useCallback(async (payload, controller) => {
    // Login logic
    
    // Direct manipulation of other domain
    cartStore.setValue([]); // Tight coupling!
  }, [cartStore]);
}
```

**Solution:** Use integration hooks or events for cross-domain communication.

```typescript
// ✅ Correct - Loose coupling via integration
function useUserCartIntegration() {
  const userAction = useUserAction();
  const cartAction = useCartAction();
  
  const loginWithCartReset = useCallback(async (loginData) => {
    await userAction('login', loginData);
    await cartAction('clearCart'); // Proper domain boundaries
  }, [userAction, cartAction]);
  
  return { loginWithCartReset };
}
```

### ❌ Circular Dependencies

**Problem:** Domains depending on each other creating circular imports.

```typescript
// ❌ Wrong - Circular dependency
// user.store.ts
import { useCartAction } from './cart.store'; // User imports Cart

// cart.store.ts  
import { useUserAction } from './user.store'; // Cart imports User
// Circular dependency!
```

**Solution:** Create separate integration modules.

```typescript
// ✅ Correct - Integration module
// integration/userCartIntegration.ts
import { useUserAction } from '../stores/user.store';
import { useCartAction } from '../stores/cart.store';

export function useUserCartIntegration() {
  const userAction = useUserAction();
  const cartAction = useCartAction();
  
  // Integration logic here
  return { /* integration methods */ };
}
```

## Debugging Issues

### ❌ Poor Error Messages

**Problem:** Handlers failing silently or with unhelpful errors.

```typescript
// ❌ Wrong - Poor error handling
const handler = useCallback(async (payload, controller) => {
  try {
    await riskyOperation();
  } catch (error) {
    controller.abort(); // No context about what failed
  }
}, []);
```

**Solution:** Provide detailed error context.

```typescript
// ✅ Correct - Detailed error handling
const handler = useCallback(async (payload, controller) => {
  try {
    await riskyOperation();
  } catch (error) {
    controller.abort(`Profile update failed: ${error.message}`, {
      operation: 'updateProfile',
      payload,
      timestamp: Date.now(),
      error: error.stack
    });
  }
}, []);
```

### ❌ No Handler IDs

**Problem:** Difficult to debug which handler is causing issues.

```typescript
// ❌ Wrong - No handler identification
register('updateProfile', handler, {
  priority: 100,
  blocking: true
  // No ID - hard to debug
});
```

**Solution:** Use descriptive IDs for debugging.

```typescript
// ✅ Correct - Clear handler identification
register('updateProfile', handler, {
  priority: 100,
  blocking: true,
  id: 'profile-validation-handler' // Clear identification
});
```

---

## Troubleshooting Checklist

When something isn't working, check these common issues:

### Handler Issues ✓
- [ ] Are handlers returning unregister functions?
- [ ] Are async handlers using `blocking: true`?
- [ ] Are handlers using lazy evaluation (`registry.getStore()`)?
- [ ] Are handlers wrapped with `useCallback`?

### Store Issues ✓
- [ ] Are components using `useStoreValue()` for reactivity?
- [ ] Are store updates using `setValue()` instead of direct mutation?
- [ ] Are initial values properly defined (not null)?

### Provider Issues ✓
- [ ] Are store providers wrapping action providers?
- [ ] Are handler setup components included?
- [ ] Are providers in the correct order?

### Type Issues ✓
- [ ] Are you using domain-specific hooks?
- [ ] Are interfaces properly defined without `any` types?
- [ ] Are action payloads matching interface definitions?

### Performance Issues ✓
- [ ] Are components only subscribing to needed stores?
- [ ] Are handlers stable with `useCallback`?
- [ ] Are you avoiding unnecessary re-renders?

---

## Summary

Most Context-Action issues stem from:

1. **Memory Management**: Not cleaning up handlers
2. **Async Coordination**: Missing `blocking: true`  
3. **Reactivity**: Not using reactive subscriptions
4. **Type Safety**: Using generic instead of domain-specific hooks
5. **Provider Setup**: Incorrect provider order or missing handlers

Following the patterns in this guide will help you avoid these common pitfalls and build more robust applications.

---

::: tip Prevention
Set up ESLint rules and code review checklists to catch these issues early. Consider creating custom hooks that enforce correct patterns in your team's codebase.
:::

---


# Guide Cross Domain Integration

**Source**: `guide/cross-domain-integration.md`  
**Priority**: 80 (essential)  

# Cross-Domain Integration (When Needed)

While domain isolation is preferred, sometimes cross-domain interaction is necessary. This guide shows how to safely integrate multiple domains while maintaining clear boundaries and type safety.

## When to Use Cross-Domain Integration

### ✅ Good Use Cases

- **User Authentication + Cart**: User login affects cart persistence
- **Profile + Preferences**: User settings span multiple feature areas  
- **Order + Inventory**: Order placement updates inventory counts
- **Analytics + All Domains**: Tracking events across domains

### ❌ Avoid When

- **Simple Data Sharing**: Use shared utilities instead
- **Tight Coupling**: Consider merging domains
- **Circular Dependencies**: Redesign domain boundaries

## Integration Patterns

### 1. Logic Fit Hooks Pattern (Recommended)

Create integration hooks that combine multiple domains:

```typescript
// hooks/useUserCartIntegration.ts
export function useUserCartIntegration() {
  // Access multiple domains
  const userProfile = useUserStore('profile');
  const cartItems = useCartStore('items');
  const userAction = useUserAction();
  const cartAction = useCartAction();
  
  const profile = useStoreValue(userProfile);
  const items = useStoreValue(cartItems);
  
  // Combined business logic
  const processCheckout = useCallback(async () => {
    // Cross-domain validation
    if (!profile.id) {
      await userAction('requireLogin', {});
      return;
    }
    
    if (items.length === 0) {
      throw new Error('Cart is empty');
    }
    
    // Cross-domain coordination
    try {
      // Start checkout process
      await cartAction('startCheckout', { userId: profile.id });
      
      // Process payment with user info
      await cartAction('processPayment', {
        userId: profile.id,
        email: profile.email,
        items: items
      });
      
      // Update user's order history
      await userAction('addOrderToHistory', {
        orderId: generateOrderId(),
        items: items,
        total: calculateTotal(items)
      });
      
    } catch (error) {
      // Rollback on failure
      await cartAction('cancelCheckout', {});
      throw error;
    }
  }, [profile.id, profile.email, items, userAction, cartAction]);
  
  const canCheckout = useMemo(() => {
    return profile.id && items.length > 0;
  }, [profile.id, items.length]);
  
  return {
    processCheckout,
    canCheckout,
    userProfile: profile,
    cartItems: items
  };
}
```

### 2. Event-Driven Integration

Use actions to communicate between domains:

```typescript
// User domain handlers
function useUserHandlers() {
  const register = useUserActionRegister();
  const registry = useUserRegistry();
  
  const loginHandler = useCallback(async (payload, controller) => {
    const profileStore = registry.getStore('profile');
    
    // Authenticate user
    const user = await authenticateUser(payload);
    profileStore.setValue(user);
    
    // Notify other domains about login
    // This triggers cart domain handlers
    await dispatchGlobalEvent('user:logged_in', {
      userId: user.id,
      email: user.email
    });
    
    return { success: true, user };
  }, [registry]);
  
  // Register handler...
}

// Cart domain handlers
function useCartHandlers() {
  const register = useCartActionRegister();
  const registry = useCartRegistry();
  
  // Listen for user login events
  const handleUserLogin = useCallback(async (payload, controller) => {
    const cartStore = registry.getStore('items');
    
    // Restore user's saved cart
    const savedCart = await loadSavedCart(payload.userId);
    if (savedCart) {
      cartStore.setValue(savedCart.items);
    }
    
    // Merge with current session cart
    const sessionCart = getSessionCart();
    if (sessionCart.length > 0) {
      const mergedCart = mergeCartItems(savedCart?.items || [], sessionCart);
      cartStore.setValue(mergedCart);
    }
  }, [registry]);
  
  // Register for user events
  useEffect(() => {
    if (!register) return;
    
    const unregister = register('user:logged_in', handleUserLogin, {
      priority: 80,
      blocking: true
    });
    
    return unregister;
  }, [register, handleUserLogin]);
}
```

### 3. Shared Service Pattern

Create shared services that multiple domains can use:

```typescript
// services/analyticsService.ts
class AnalyticsService {
  private events: Array<{ domain: string; event: string; data: any; timestamp: number }> = [];
  
  track(domain: string, event: string, data: any = {}) {
    const eventData = {
      domain,
      event,
      data,
      timestamp: Date.now()
    };
    
    this.events.push(eventData);
    
    // Send to analytics provider
    this.sendToProvider(eventData);
  }
  
  private async sendToProvider(eventData: any) {
    // Implementation for external analytics service
    await analyticsProvider.track(eventData);
  }
  
  getEvents(domain?: string) {
    return domain 
      ? this.events.filter(e => e.domain === domain)
      : this.events;
  }
}

export const analyticsService = new AnalyticsService();

// Use in domain handlers
function useUserHandlers() {
  const loginHandler = useCallback(async (payload, controller) => {
    // Business logic
    const result = await performLogin(payload);
    
    // Analytics tracking
    analyticsService.track('user', 'login_success', {
      userId: result.user.id,
      method: payload.method
    });
    
    return result;
  }, []);
}

function useCartHandlers() {
  const addItemHandler = useCallback(async (payload, controller) => {
    // Business logic
    const result = await addItemToCart(payload);
    
    // Analytics tracking
    analyticsService.track('cart', 'item_added', {
      productId: payload.productId,
      quantity: payload.quantity,
      cartTotal: result.cartTotal
    });
    
    return result;
  }, []);
}
```

### 4. Cross-Domain Data Dependencies

Handle data that spans multiple domains:

```typescript
// hooks/useUserPreferences.ts
export function useUserPreferences() {
  // User domain - core profile data
  const userProfile = useUserStore('profile');
  const profile = useStoreValue(userProfile);
  
  // Settings domain - UI preferences  
  const settingsStore = useSettingsStore('ui');
  const uiSettings = useStoreValue(settingsStore);
  
  // Theme domain - appearance settings
  const themeStore = useThemeStore('current');
  const theme = useStoreValue(themeStore);
  
  // Combined preferences object
  const preferences = useMemo(() => ({
    // From user domain
    language: profile.language,
    timezone: profile.timezone,
    
    // From settings domain
    notifications: uiSettings.notifications,
    layout: uiSettings.layout,
    
    // From theme domain
    theme: theme.name,
    colors: theme.colors
  }), [profile, uiSettings, theme]);
  
  // Update preferences across domains
  const updatePreferences = useCallback(async (updates: Partial<typeof preferences>) => {
    const userAction = useUserAction();
    const settingsAction = useSettingsAction();
    const themeAction = useThemeAction();
    
    // Update relevant domains
    if ('language' in updates || 'timezone' in updates) {
      await userAction('updateProfile', {
        data: {
          language: updates.language,
          timezone: updates.timezone
        }
      });
    }
    
    if ('notifications' in updates || 'layout' in updates) {
      await settingsAction('updateUI', {
        notifications: updates.notifications,
        layout: updates.layout
      });
    }
    
    if ('theme' in updates) {
      await themeAction('setTheme', {
        themeName: updates.theme
      });
    }
  }, []);
  
  return {
    preferences,
    updatePreferences
  };
}
```

## Advanced Integration Patterns

### 1. Cross-Domain Transactions

Implement atomic operations across multiple domains:

```typescript
// hooks/useTransactionalOperations.ts
export function useTransactionalOperations() {
  const userRegistry = useUserRegistry();
  const cartRegistry = useCartRegistry();
  const orderRegistry = useOrderRegistry();
  
  const processOrder = useCallback(async (orderData: OrderData) => {
    // Start transaction
    const transaction = createTransaction();
    
    try {
      // Step 1: Validate user
      const userStore = userRegistry.getStore('profile');
      const user = userStore.getValue();
      
      if (!user.id) {
        throw new Error('User not authenticated');
      }
      
      // Step 2: Reserve inventory
      const cartStore = cartRegistry.getStore('items');
      const items = cartStore.getValue();
      
      const reservationResult = await reserveInventory(items);
      transaction.addRollback(() => releaseInventory(reservationResult.reservationId));
      
      // Step 3: Process payment
      const paymentResult = await processPayment({
        userId: user.id,
        amount: orderData.total,
        items: items
      });
      transaction.addRollback(() => refundPayment(paymentResult.transactionId));
      
      // Step 4: Create order
      const orderStore = orderRegistry.getStore('current');
      const order = {
        id: generateOrderId(),
        userId: user.id,
        items: items,
        paymentId: paymentResult.transactionId,
        status: 'completed',
        createdAt: Date.now()
      };
      
      orderStore.setValue(order);
      transaction.addRollback(() => orderStore.setValue(null));
      
      // Step 5: Clear cart
      cartStore.setValue([]);
      transaction.addRollback(() => cartStore.setValue(items));
      
      // Step 6: Update user order history
      const userOrderHistory = userRegistry.getStore('orderHistory');
      const currentHistory = userOrderHistory.getValue();
      userOrderHistory.setValue([...currentHistory, order]);
      
      // Commit transaction
      await transaction.commit();
      
      return { success: true, order };
      
    } catch (error) {
      // Rollback all changes
      await transaction.rollback();
      throw error;
    }
  }, [userRegistry, cartRegistry, orderRegistry]);
  
  return { processOrder };
}

// Simple transaction helper
function createTransaction() {
  const rollbackOperations: Array<() => void | Promise<void>> = [];
  
  return {
    addRollback(operation: () => void | Promise<void>) {
      rollbackOperations.push(operation);
    },
    
    async commit() {
      // Transaction is complete, clear rollback operations
      rollbackOperations.length = 0;
    },
    
    async rollback() {
      // Execute rollback operations in reverse order
      for (const operation of rollbackOperations.reverse()) {
        try {
          await operation();
        } catch (error) {
          console.error('Rollback operation failed:', error);
        }
      }
    }
  };
}
```

### 2. Cross-Domain State Synchronization

Keep related state synchronized across domains:

```typescript
// hooks/useStateSynchronization.ts
export function useStateSynchronization() {
  const userProfile = useUserStore('profile');
  const userPreferences = useUserStore('preferences');
  const themeStore = useThemeStore('current');
  const settingsStore = useSettingsStore('ui');
  
  const profile = useStoreValue(userProfile);
  const preferences = useStoreValue(userPreferences);
  const theme = useStoreValue(themeStore);
  const settings = useStoreValue(settingsStore);
  
  // Sync user language changes to settings
  useEffect(() => {
    if (profile.language && settings.language !== profile.language) {
      const settingsAction = useSettingsAction();
      settingsAction('updateLanguage', { 
        language: profile.language 
      });
    }
  }, [profile.language, settings.language]);
  
  // Sync theme changes to user preferences
  useEffect(() => {
    if (theme.name && preferences.theme !== theme.name) {
      const userAction = useUserAction();
      userAction('updatePreferences', {
        data: { theme: theme.name }
      });
    }
  }, [theme.name, preferences.theme]);
  
  // Sync timezone changes across domains
  useEffect(() => {
    if (profile.timezone) {
      // Update all time-sensitive domains
      const calendarAction = useCalendarAction();
      const notificationAction = useNotificationAction();
      
      calendarAction('setTimezone', { timezone: profile.timezone });
      notificationAction('setTimezone', { timezone: profile.timezone });
    }
  }, [profile.timezone]);
}
```

### 3. Cross-Domain Error Handling

Handle errors that affect multiple domains:

```typescript
// hooks/useGlobalErrorHandling.ts
export function useGlobalErrorHandling() {
  const userAction = useUserAction();
  const cartAction = useCartAction();
  const orderAction = useOrderAction();
  
  const handleAuthenticationError = useCallback(async (error: AuthError) => {
    // Clear user session
    await userAction('logout', {});
    
    // Clear sensitive cart data
    await cartAction('clearSensitiveData', {});
    
    // Cancel pending orders
    await orderAction('cancelPendingOrders', {});
    
    // Redirect to login
    redirectToLogin();
  }, [userAction, cartAction, orderAction]);
  
  const handleNetworkError = useCallback(async (error: NetworkError) => {
    // Put all domains in offline mode
    await userAction('setOfflineMode', { offline: true });
    await cartAction('setOfflineMode', { offline: true });
    await orderAction('setOfflineMode', { offline: true });
    
    // Queue operations for when network returns
    queueOfflineOperations();
  }, [userAction, cartAction, orderAction]);
  
  const handlePaymentError = useCallback(async (error: PaymentError) => {
    // Rollback cart state
    await cartAction('rollbackToCheckout', {});
    
    // Update order status
    await orderAction('markPaymentFailed', {
      orderId: error.orderId,
      reason: error.reason
    });
    
    // Notify user
    await userAction('addNotification', {
      type: 'error',
      message: 'Payment failed. Please try again.',
      actions: ['retry', 'change_method']
    });
  }, [cartAction, orderAction, userAction]);
  
  return {
    handleAuthenticationError,
    handleNetworkError,
    handlePaymentError
  };
}
```

## Best Practices for Cross-Domain Integration

### 1. Keep Integration Logic Separate

```typescript
// ✅ Good: Separate integration logic
function useUserCartIntegration() {
  // Integration-specific logic only
}

// ✅ Good: Domain-specific logic stays in domain
function useUserHandlers() {
  // User domain logic only
}

// ❌ Bad: Mixing integration in domain handlers
function useUserHandlers() {
  // User logic mixed with cart concerns
}
```

### 2. Use Explicit Dependencies

```typescript
// ✅ Good: Explicit dependencies
function useOrderProcessing() {
  const userAction = useUserAction();   // Explicit
  const cartAction = useCartAction();   // Explicit
  const paymentService = usePaymentService(); // Explicit
  
  // Clear dependencies
}

// ❌ Bad: Hidden dependencies
function useOrderProcessing() {
  // Hidden global state access
  const user = getCurrentUser(); // Where does this come from?
}
```

### 3. Minimize Cross-Domain Surface Area

```typescript
// ✅ Good: Minimal interface
interface CrossDomainAPI {
  getUserId(): string | null;
  isAuthenticated(): boolean;
}

// ❌ Bad: Exposing entire domain
interface CrossDomainAPI {
  user: CompleteUserState;      // Too much exposure
  profile: UserProfile;         // Implementation details
  session: SessionState;        // Internal state
}
```

### 4. Handle Failures Gracefully

```typescript
// ✅ Good: Graceful degradation
function useIntegration() {
  const processCheckout = useCallback(async () => {
    try {
      // Attempt cross-domain operation
      return await fullCheckoutProcess();
    } catch (error) {
      // Fallback to single-domain operation
      return await basicCheckoutProcess();
    }
  }, []);
}

// ❌ Bad: All-or-nothing
function useIntegration() {
  const processCheckout = useCallback(async () => {
    // Fails completely if any domain fails
    await updateUser();
    await updateCart(); 
    await updateOrder(); // If this fails, everything fails
  }, []);
}
```

---

## Summary

Cross-domain integration in the Context-Action framework should be:

- **Purposeful**: Only when business logic truly spans domains
- **Explicit**: Clear dependencies and interfaces
- **Resilient**: Graceful error handling and fallbacks  
- **Minimal**: Keep integration surface area small
- **Separated**: Integration logic separate from domain logic

Use Logic Fit Hooks as the primary pattern for cross-domain integration, supplemented by event-driven communication and shared services when appropriate.

---

::: tip Next Steps
- Learn [Logic Fit Hooks](./logic-fit-hooks) for combining business and UI logic
- Explore [Performance Optimization](./performance) for multi-domain applications
- See [Error Handling Patterns](./error-handling) for robust cross-domain error management
:::

---


# Guide Domain Hooks Pattern

**Source**: `guide/domain-hooks-pattern.md`  
**Priority**: 80 (essential)  

# Domain-Specific Hooks Pattern

The Domain-Specific Hooks Pattern is the core philosophy of the Context-Action framework. It transforms generic, untyped APIs into domain-specific, fully-typed interfaces through destructuring assignments.

## The Pattern Philosophy

### Traditional Generic Approach

```typescript
// ❌ Generic, untyped approach
const store = useStore('user-profile');     // any
const dispatch = useDispatch();             // (action: string, payload: any) => void
const register = useActionRegister();       // (name: string, handler: any) => void

// No type safety, no domain clarity
dispatch('updateUser', { anyData: 'here' }); // Runtime errors only
```

### Domain-Specific Approach

```typescript
// ✅ Domain-specific, fully-typed approach
const store = useUserStore('profile');      // Store<UserProfile>
const dispatch = useUserAction();           // (action: keyof UserActions, payload: UserActions[action]) => void
const register = useUserActionRegister();   // Type-safe handler registration

// Full type safety, clear domain boundaries
dispatch('updateProfile', { data: { name: 'John' } }); // Compile-time safety
```

## Creating Domain-Specific Hooks

### Step 1: Define Domain Data Structure

```typescript
// Domain data interface
export interface UserBusinessData {
  profile: {
    id: string;
    name: string;
    email: string;
    role: 'admin' | 'user' | 'guest';
  };
  preferences: {
    theme: 'light' | 'dark';
    language: string;
    notifications: boolean;
  };
  session: {
    lastLogin: number;
    isActive: boolean;
  };
}

// Domain actions interface
export interface UserBusinessActions {
  login: { email: string; password: string };
  logout: void;
  updateProfile: { data: Partial<UserBusinessData['profile']> };
  updatePreferences: { data: Partial<UserBusinessData['preferences']> };
}
```

### Step 2: Create Store Hooks via Destructuring

```typescript
// Transform generic hooks into domain-specific ones
export const {
  Provider: UserBusinessProvider,
  useStore: useUserBusinessStore,          // Domain-specific store hook
  useRegistry: useUserBusinessRegistry,    // Domain-specific registry hook
  useCreateStore: useCreateUserBusinessStore
} = createDeclarativeStores<UserBusinessData>('UserBusiness', {
  profile: {
    initialValue: {
      id: '',
      name: '',
      email: '',
      role: 'guest'
    }
  },
  preferences: {
    initialValue: {
      theme: 'light',
      language: 'en',
      notifications: true
    }
  },
  session: {
    initialValue: {
      lastLogin: 0,
      isActive: false
    }
  }
});
```

### Step 3: Create Action Hooks via Destructuring

```typescript
// Transform generic action hooks into domain-specific ones
export const {
  Provider: UserBusinessActionProvider,
  useAction: useUserBusinessAction,        // Domain-specific action dispatcher
  useActionRegister: useUserBusinessActionRegister,
  useActionWithResult: useUserBusinessActionWithResult
} = createActionContext<UserBusinessActions>({ 
  name: 'UserBusinessAction' 
});
```

## Benefits of Domain-Specific Naming

### 1. Full Type Inference

```typescript
function UserProfile() {
  // Automatic type inference - no manual typing needed
  const profileStore = useUserBusinessStore('profile'); // Store<UserBusinessData['profile']>
  const profile = useStoreValue(profileStore);          // UserBusinessData['profile']
  const dispatch = useUserBusinessAction();             // Typed dispatcher
  
  // TypeScript knows exactly what actions are available
  dispatch('updateProfile', { 
    data: { name: 'New Name' } // ✅ Correct payload structure
  });
  
  // Compile-time error for invalid actions
  dispatch('invalidAction', {}); // ❌ TS Error: 'invalidAction' doesn't exist
}
```

### 2. Clear Domain Boundaries

```typescript
// Each domain has its own isolated hooks
const userProfile = useUserBusinessStore('profile');    // User domain
const cartItems = useCartStore('items');                // Cart domain  
const orderHistory = useOrderStore('history');          // Order domain

// No confusion about which domain you're working with
const userDispatch = useUserBusinessAction();           // User actions only
const cartDispatch = useCartAction();                   // Cart actions only
```

### 3. Refactoring Safety

```typescript
// Rename domain interfaces safely
interface UserBusinessData {
  userProfile: UserProfile; // Renamed from 'profile'
}

// TypeScript will catch ALL references that need updating
const profileStore = useUserBusinessStore('userProfile'); // ✅ Must update
const oldStore = useUserBusinessStore('profile');         // ❌ TS Error
```

### 4. Team Scalability

```typescript
// Different teams can work on different domains without conflicts

// Team A: User Management
export const {
  useStore: useUserStore,
  useAction: useUserAction
} = createUserDomain();

// Team B: E-commerce
export const {
  useStore: useCartStore,
  useAction: useCartAction
} = createCartDomain();

// Team C: Analytics
export const {
  useStore: useAnalyticsStore,
  useAction: useAnalyticsAction
} = createAnalyticsDomain();

// No naming collisions, clear ownership
```

## Pattern Implementation Examples

### Basic Domain Setup

```typescript
// stores/user/userBusiness.store.ts
import { createDeclarativeStores, createActionContext } from '@context-action/react';

// 1. Define your domain
export interface UserData {
  profile: { id: string; name: string };
  settings: { theme: 'light' | 'dark' };
}

export interface UserActions {
  updateProfile: { name: string };
  toggleTheme: void;
}

// 2. Create domain-specific hooks
export const {
  Provider: UserProvider,
  useStore: useUserStore,
  useRegistry: useUserRegistry
} = createDeclarativeStores<UserData>('User', {
  profile: { initialValue: { id: '', name: '' } },
  settings: { initialValue: { theme: 'light' } }
});

export const {
  Provider: UserActionProvider,
  useAction: useUserAction,
  useActionRegister: useUserActionRegister
} = createActionContext<UserActions>({ name: 'UserAction' });
```

### Multi-Layer Domain Pattern

```typescript
// Separate business logic from UI state
export interface UserBusinessData {
  profile: UserProfile;
  session: UserSession;
}

export interface UserUIState {
  isEditing: boolean;
  selectedTab: string;
  loadingState: LoadingState;
}

// Business layer hooks
export const {
  useStore: useUserBusinessStore,
  useAction: useUserBusinessAction
} = createUserBusinessDomain();

// UI layer hooks  
export const {
  useStore: useUserUIStore,
  useAction: useUserUIAction
} = createUserUIDomain();
```

### Cross-Domain Integration Pattern

```typescript
// Logic fit hooks that combine multiple domains
export function useUserCartIntegration() {
  // Access multiple domain-specific hooks
  const userProfile = useUserStore('profile');
  const cartItems = useCartStore('items');
  
  // Domain-specific action dispatchers
  const userAction = useUserAction();
  const cartAction = useCartAction();
  
  const profile = useStoreValue(userProfile);
  const items = useStoreValue(cartItems);
  
  // Combined business logic
  const processCheckout = useCallback(async () => {
    if (!profile.id) {
      await userAction('requireLogin', {});
      return;
    }
    
    await cartAction('processCheckout', {
      userId: profile.id,
      items: items
    });
  }, [profile.id, items, userAction, cartAction]);
  
  return { processCheckout };
}
```

## Advanced Pattern Techniques

### 1. HOC Pattern for Provider Composition

```typescript
// Create self-contained domain components
const UserStores = createContextStorePattern('User');

const withUserProviders = UserStores.withCustomProvider(
  ({ children }) => (
    <UserActionProvider>
      {children}
    </UserActionProvider>
  ),
  'user-with-actions'
);

// Usage - completely isolated
const UserModule = withUserProviders(() => {
  const userStore = UserStores.useStore('profile', initialData);
  const dispatch = useUserAction();
  
  return <UserInterface />;
});

// No manual provider wrapping needed
function App() {
  return <UserModule />; // Fully self-contained
}
```

### 2. Conditional Domain Loading

```typescript
// Lazy load domains based on user permissions
export function useConditionalDomains(userRole: string) {
  // Admin users get admin domain hooks
  const adminHooks = userRole === 'admin' ? {
    useAdminStore: useAdminStore,
    useAdminAction: useAdminAction
  } : null;
  
  // All users get basic hooks
  const basicHooks = {
    useUserStore: useUserStore,
    useUserAction: useUserAction
  };
  
  return { ...basicHooks, ...adminHooks };
}
```

### 3. Testing with Domain Hooks

```typescript
// Easy to mock domain-specific hooks
jest.mock('../stores/user.store', () => ({
  useUserStore: jest.fn(),
  useUserAction: jest.fn()
}));

// Test with typed mocks
const mockUserStore = useUserStore as jest.MockedFunction<typeof useUserStore>;
const mockUserAction = useUserAction as jest.MockedFunction<typeof useUserAction>;

mockUserStore.mockReturnValue(createMockStore({ 
  id: '1', 
  name: 'Test User' 
}));
```

## Common Patterns and Anti-Patterns

### ✅ Good Patterns

```typescript
// Clear domain naming
const useUserStore = userStores.useStore;
const useUserAction = userActions.useAction;

// Consistent interface structure
interface UserActions {
  updateProfile: { data: Partial<UserProfile> };
  deleteProfile: { userId: string };
  resetProfile: void; // For actions without payload
}

// Proper cleanup
useEffect(() => {
  if (!register) return;
  const unregister = register('action', handler);
  return unregister;
}, [register, handler]);
```

### ❌ Anti-Patterns

```typescript
// Generic naming defeats the purpose
const useStore = userStores.useStore; // Lost domain context
const useAction = userActions.useAction; // No type clarity

// Inconsistent interfaces
interface UserActions {
  updateProfile: any;           // Lost type safety
  deleteProfile: string;       // Inconsistent payload pattern
  resetProfile: { empty: {} }; // Unnecessary payload for void actions
}

// Missing cleanup
useEffect(() => {
  register('action', handler); // Memory leak
}, []);
```

---

## Summary

The Domain-Specific Hooks Pattern transforms generic APIs into typed, domain-specific interfaces through strategic destructuring. This approach provides:

- **Full Type Safety**: Automatic TypeScript inference
- **Clear Boundaries**: Domain-specific naming prevents confusion  
- **Refactoring Safety**: Compile-time errors catch breaking changes
- **Team Scalability**: Multiple teams work independently
- **Better DX**: Autocomplete, documentation, and clear APIs

This pattern is fundamental to building maintainable, scalable applications with the Context-Action framework.

---

::: tip Next Steps
Ready to see this pattern in action? Check out the [Full Implementation Guide](./full) for complete examples, or explore [MVVM Architecture](./mvvm-architecture) to understand the broader architectural context.
:::

---


# Guide Error Handling

**Source**: `guide/error-handling.md`  
**Priority**: 80 (essential)  

# Error Handling Patterns

Robust error handling is crucial for reliable Context-Action applications. Learn effective patterns for handling errors in handlers, stores, and components.

## Error Handling Philosophy

Context-Action error handling follows these principles:

1. **Fail Fast**: Detect and report errors immediately
2. **Contextual Information**: Provide meaningful error details
3. **Graceful Degradation**: Maintain application stability
4. **Recovery Options**: Allow users to recover from errors
5. **Monitoring Integration**: Enable error tracking and analysis

## Handler Error Handling

### 1. Controller-Based Error Management

```typescript
// Use controller.abort() for graceful error handling
function useUserHandlers() {
  const addHandler = useUserActionHandler();
  const stores = useUserStores();
  
  const updateProfileHandler = useCallback(async (payload, controller) => {
    try {
      const profileStore = stores.getStore('profile');
      const currentProfile = profileStore.getValue();
      
      // Validation errors
      if (payload.validate && !isValidEmail(payload.data.email)) {
        controller.abort('Invalid email format', {
          field: 'email',
          value: payload.data.email,
          code: 'VALIDATION_ERROR'
        });
        return { success: false, error: 'INVALID_EMAIL' };
      }
      
      // Business logic
      const updatedProfile = {
        ...currentProfile,
        ...payload.data,
        updatedAt: Date.now()
      };
      
      // API call with error handling
      const response = await updateUserProfileAPI(updatedProfile);
      
      if (!response.success) {
        controller.abort('API update failed', {
          apiError: response.error,
          statusCode: response.status,
          retryable: response.retryable
        });
        return { success: false, error: 'API_ERROR', retryable: response.retryable };
      }
      
      // Update store on success
      profileStore.setValue(updatedProfile);
      
      return { success: true, profile: updatedProfile };
      
    } catch (error) {
      // Unexpected errors
      controller.abort(`Profile update failed: ${error.message}`, {
        operation: 'updateProfile',
        payload,
        timestamp: Date.now(),
        error: error.stack,
        recoverable: false
      });
      
      return { success: false, error: 'UNEXPECTED_ERROR' };
    }
  }, [stores]);
  
  useEffect(() => {
    if (!addHandler) return;
    return addHandler('updateProfile', updateProfileHandler, {
      priority: 100,
      blocking: true,
      id: 'profile-updater'
    });
  }, [register, updateProfileHandler]);
}
```

### 2. Layered Error Handling

```typescript
// Create error handling layers for different concerns
function useLayeredErrorHandling() {
  const addHandler = useUserActionHandler();
  const stores = useUserStores();
  
  useEffect(() => {
    if (!addHandler) return;
    
    const unregisterFunctions = [];
    
    // Layer 1: Input validation (highest priority)
    unregisterFunctions.push(
      register('updateProfile', validationHandler, {
        priority: 100,
        blocking: true,
        id: 'validation-layer'
      })
    );
    
    // Layer 2: Business logic
    unregisterFunctions.push(
      register('updateProfile', businessHandler, {
        priority: 90,
        blocking: true,
        id: 'business-layer'
      })
    );
    
    // Layer 3: Persistence
    unregisterFunctions.push(
      register('updateProfile', persistenceHandler, {
        priority: 80,
        blocking: true,
        id: 'persistence-layer'
      })
    );
    
    // Layer 4: Error logging (lowest priority, non-blocking)
    unregisterFunctions.push(
      register('updateProfile', errorLoggingHandler, {
        priority: 70,
        blocking: false,
        id: 'error-logging'
      })
    );
    
    return () => unregisterFunctions.forEach(fn => fn());
  }, [register, registry]);
}

// Validation layer handler
const validationHandler = useCallback(async (payload, controller) => {
  const errors = validateUpdateProfilePayload(payload);
  
  if (errors.length > 0) {
    controller.abort('Validation failed', {
      code: 'VALIDATION_ERROR',
      errors,
      field: errors[0].field
    });
    return { success: false, errors };
  }
}, []);

// Business logic layer handler
const businessHandler = useCallback(async (payload, controller) => {
  try {
    // Business rules validation
    const businessValidation = await validateBusinessRules(payload);
    
    if (!businessValidation.valid) {
      controller.abort('Business rule violation', {
        code: 'BUSINESS_ERROR',
        rule: businessValidation.violatedRule,
        message: businessValidation.message
      });
      return { success: false, error: 'BUSINESS_RULE_VIOLATION' };
    }
    
    // Continue processing...
  } catch (error) {
    controller.abort('Business logic error', {
      code: 'BUSINESS_ERROR',
      error: error.message
    });
    return { success: false, error: 'BUSINESS_ERROR' };
  }
}, []);
```

### 3. Error Recovery Patterns

```typescript
// Implement retry and fallback mechanisms
function useRetryableHandlers() {
  const addHandler = useUserActionHandler();
  const stores = useUserStores();
  
  const createRetryableHandler = useCallback((
    handlerFn: Function,
    maxRetries = 3,
    backoffMs = 1000
  ) => {
    return async (payload, controller) => {
      let lastError;
      
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          const result = await handlerFn(payload, controller);
          
          // Success - return result
          if (result.success) {
            return result;
          }
          
          // Check if error is retryable
          if (!result.retryable || attempt === maxRetries) {
            controller.abort(`Operation failed after ${attempt} attempts`, {
              finalError: result.error,
              attempts: attempt
            });
            return result;
          }
          
          // Wait before retry
          await new Promise(resolve => setTimeout(resolve, backoffMs * attempt));
          
        } catch (error) {
          lastError = error;
          
          if (attempt === maxRetries) {
            controller.abort(`Handler failed after ${maxRetries} attempts`, {
              finalError: error.message,
              attempts: maxRetries
            });
            throw error;
          }
          
          // Wait before retry
          await new Promise(resolve => setTimeout(resolve, backoffMs * attempt));
        }
      }
    };
  }, []);
  
  const apiHandler = useCallback(async (payload, controller) => {
    try {
      const response = await apiCall(payload);
      return { success: true, data: response, retryable: false };
    } catch (error) {
      // Determine if error is retryable
      const isRetryable = error.status >= 500 || error.code === 'NETWORK_ERROR';
      
      return { 
        success: false, 
        error: error.message, 
        retryable: isRetryable 
      };
    }
  }, []);
  
  useEffect(() => {
    if (!addHandler) return;
    
    const retryableApiHandler = createRetryableHandler(apiHandler, 3, 1000);
    
    return addHandler('updateProfile', retryableApiHandler, {
      priority: 80,
      blocking: true,
      id: 'retryable-api-handler'
    });
  }, [register, createRetryableHandler, apiHandler]);
}
```

## Store Error Handling

### 1. Store Operation Error Handling

```typescript
// Handle store operation errors
export function useStoreWithErrorHandling<T>(
  store: Store<T>,
  onError?: (error: Error) => void
) {
  const safeSetValue = useCallback((newValue: T) => {
    try {
      store.setValue(newValue);
    } catch (error) {
      console.error('Store setValue failed:', error);
      onError?.(error);
      
      // Optionally, revert to previous value or handle recovery
      throw new Error(`Failed to update store: ${error.message}`);
    }
  }, [store, onError]);
  
  const safeGetValue = useCallback(() => {
    try {
      return store.getValue();
    } catch (error) {
      console.error('Store getValue failed:', error);
      onError?.(error);
      
      // Return safe default
      return null;
    }
  }, [store, onError]);
  
  return {
    setValue: safeSetValue,
    getValue: safeGetValue,
    subscribe: store.subscribe
  };
}
```

### 2. Store Validation

```typescript
// Validate store updates before applying
export function createValidatedStore<T>(
  initialValue: T,
  validator: (value: T) => { valid: boolean; errors: string[] }
) {
  const baseStore = createStore(initialValue);
  
  const validatedSetValue = (newValue: T) => {
    const validation = validator(newValue);
    
    if (!validation.valid) {
      throw new Error(`Store validation failed: ${validation.errors.join(', ')}`);
    }
    
    return baseStore.setValue(newValue);
  };
  
  return {
    ...baseStore,
    setValue: validatedSetValue
  };
}

// Usage
const profileStore = createValidatedStore(
  { name: '', email: '' },
  (profile) => {
    const errors = [];
    
    if (!profile.name.trim()) errors.push('Name is required');
    if (!profile.email.includes('@')) errors.push('Invalid email format');
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
);
```

## Component Error Handling

### 1. Error Boundaries for Action Handling

```typescript
// Error boundary for action dispatching
class ActionErrorBoundary extends React.Component<
  { children: React.ReactNode; onError?: (error: Error, errorInfo: any) => void },
  { hasError: boolean; error: Error | null }
> {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: any) {
    console.error('Action error caught by boundary:', error, errorInfo);
    this.props.onError?.(error, errorInfo);
    
    // Report to error tracking service
    reportError('ACTION_ERROR', error, {
      componentStack: errorInfo.componentStack,
      errorBoundary: 'ActionErrorBoundary'
    });
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-fallback">
          <h2>Something went wrong</h2>
          <details>
            <summary>Error details</summary>
            <pre>{this.state.error?.message}</pre>
          </details>
          <button onClick={() => this.setState({ hasError: false, error: null })}>
            Try again
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage
function App() {
  return (
    <ActionErrorBoundary onError={(error) => reportError('APP_ERROR', error)}>
      <UserProvider>
        <UserActionProvider>
          <UserProfile />
        </UserActionProvider>
      </UserProvider>
    </ActionErrorBoundary>
  );
}
```

### 2. Hook-Level Error Handling

```typescript
// Custom hook with built-in error handling
export function useUserProfileWithErrorHandling() {
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  const dispatch = useUserAction();
  
  const updateProfile = useCallback(async (data: Partial<UserProfile>) => {
    setLoading(true);
    setError(null);
    
    try {
      await dispatch('updateProfile', { data });
    } catch (actionError) {
      console.error('Profile update failed:', actionError);
      setError(actionError.message || 'Update failed');
      
      // Report error
      reportError('PROFILE_UPDATE_ERROR', actionError, {
        profileData: data,
        currentProfile: profile
      });
    } finally {
      setLoading(false);
    }
  }, [dispatch, profile]);
  
  const clearError = useCallback(() => {
    setError(null);
  }, []);
  
  return {
    profile,
    updateProfile,
    loading,
    error,
    clearError
  };
}
```

### 3. Component Error Recovery

```typescript
// Component with error recovery options
function UserProfileWithRecovery() {
  const {
    profile,
    updateProfile,
    loading,
    error,
    clearError
  } = useUserProfileWithErrorHandling();
  
  const [retryCount, setRetryCount] = useState(0);
  
  const handleRetry = useCallback(() => {
    clearError();
    setRetryCount(prev => prev + 1);
    
    // Retry with exponential backoff
    const delay = Math.min(1000 * Math.pow(2, retryCount), 10000);
    setTimeout(() => {
      updateProfile(profile);
    }, delay);
  }, [clearError, retryCount, updateProfile, profile]);
  
  const handleReset = useCallback(() => {
    clearError();
    setRetryCount(0);
    
    // Reset to last known good state
    window.location.reload();
  }, [clearError]);
  
  if (error) {
    return (
      <div className="error-state">
        <h3>Profile Update Failed</h3>
        <p>{error}</p>
        
        <div className="error-actions">
          {retryCount < 3 && (
            <button onClick={handleRetry} disabled={loading}>
              Retry ({retryCount + 1}/3)
            </button>
          )}
          
          <button onClick={handleReset}>
            Reset
          </button>
          
          <button onClick={clearError}>
            Dismiss
          </button>
        </div>
      </div>
    );
  }
  
  return (
    <div>
      {/* Normal profile UI */}
      <UserProfileForm
        profile={profile}
        onUpdate={updateProfile}
        loading={loading}
      />
    </div>
  );
}
```

## Error Monitoring and Logging

### 1. Centralized Error Reporting

```typescript
// Centralized error reporting service
class ErrorReporter {
  private static instance: ErrorReporter;
  
  static getInstance(): ErrorReporter {
    if (!ErrorReporter.instance) {
      ErrorReporter.instance = new ErrorReporter();
    }
    return ErrorReporter.instance;
  }
  
  reportError(
    category: string,
    error: Error,
    context?: Record<string, any>
  ) {
    const errorReport = {
      category,
      message: error.message,
      stack: error.stack,
      context,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    // Log to console in development
    if (process.env.NODE_ENV === 'development') {
      console.error('Error Report:', errorReport);
    }
    
    // Send to monitoring service in production
    if (process.env.NODE_ENV === 'production') {
      this.sendToMonitoringService(errorReport);
    }
  }
  
  private sendToMonitoringService(errorReport: any) {
    // Send to services like Sentry, LogRocket, etc.
    // Example with fetch:
    fetch('/api/errors', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(errorReport)
    }).catch(sendError => {
      console.error('Failed to send error report:', sendError);
    });
  }
}

// Global error reporting utility
export const reportError = (
  category: string,
  error: Error,
  context?: Record<string, any>
) => {
  ErrorReporter.getInstance().reportError(category, error, context);
};
```

### 2. Handler Error Monitoring

```typescript
// Monitor handler execution and errors
export function createMonitoredHandler<T extends any[], R>(
  handlerId: string,
  handler: (...args: T) => Promise<R>
) {
  return async (...args: T): Promise<R> => {
    const startTime = performance.now();
    
    try {
      const result = await handler(...args);
      
      const duration = performance.now() - startTime;
      
      // Report success metrics
      reportMetric('HANDLER_SUCCESS', {
        handlerId,
        duration,
        args: args.length
      });
      
      return result;
      
    } catch (error) {
      const duration = performance.now() - startTime;
      
      // Report error with context
      reportError('HANDLER_ERROR', error, {
        handlerId,
        duration,
        args,
        timestamp: Date.now()
      });
      
      throw error;
    }
  };
}

// Usage
const monitoredUpdateHandler = createMonitoredHandler(
  'updateProfile',
  async (payload, controller) => {
    // Handler logic
  }
);
```

## Error Handling Best Practices

### ✅ Do

- **Use controller.abort() for graceful error handling**
- **Provide contextual error information**
- **Implement retry mechanisms for transient errors**
- **Use error boundaries to catch unexpected errors**
- **Log errors with sufficient context for debugging**
- **Provide user-friendly error messages**
- **Implement error recovery options**

### ❌ Don't

- **Silently swallow errors without handling**
- **Show technical error messages to users**
- **Retry operations indefinitely**
- **Log sensitive information in error reports**
- **Ignore error cleanup and resource disposal**
- **Use generic error handling for all error types**

---

## Summary

Effective error handling in Context-Action applications includes:

- **Controller-Based Handling**: Use `controller.abort()` for graceful error propagation
- **Layered Error Management**: Handle errors at appropriate layers (validation, business, persistence)
- **Recovery Mechanisms**: Implement retry logic and fallback options
- **Error Boundaries**: Catch and handle React component errors
- **Monitoring Integration**: Report errors for analysis and improvement
- **User Experience**: Provide helpful error messages and recovery options

Robust error handling ensures your applications remain stable and user-friendly even when things go wrong.

---

::: tip Next Steps
- Learn [Testing Strategies](./testing) for testing error scenarios
- Explore [Performance Optimization](./performance) for error handling performance
- See [Troubleshooting Guide](./troubleshooting) for common error resolution patterns
:::

---


# Guide Handler Id Strategies

**Source**: `guide/handler-id-strategies.md`  
**Priority**: 80 (essential)  

# Handler ID Strategies

Handler IDs are crucial for debugging, monitoring, and managing action handlers in complex applications. Learn effective strategies for naming, organizing, and using handler IDs.

## Why Handler IDs Matter

Handler IDs provide several benefits:

- **Debugging**: Quickly identify which handler is causing issues
- **Monitoring**: Track handler performance and execution
- **Testing**: Target specific handlers in tests
- **Documentation**: Self-documenting handler purposes
- **Maintenance**: Easy handler management and updates

## ID Naming Strategies

### 1. Descriptive Action-Based IDs

```typescript
// Pattern: {action}-{purpose}
addHandler('updateProfile', handler, { 
  id: 'updateProfile-validation' 
});

addHandler('updateProfile', handler, { 
  id: 'updateProfile-persistence' 
});

addHandler('updateProfile', handler, { 
  id: 'updateProfile-notification' 
});
```

### 2. Domain-Scoped IDs

```typescript
// Pattern: {domain}-{action}-{purpose}
addHandler('updateProfile', handler, { 
  id: 'user-updateProfile-validator' 
});

addHandler('clearCart', handler, { 
  id: 'cart-clearCart-analytics' 
});

addHandler('processPayment', handler, { 
  id: 'payment-processPayment-gateway' 
});
```

### 3. Priority-Based IDs

```typescript
// Pattern: {priority}-{action}-{description}
addHandler('processOrder', handler, { 
  id: '100-processOrder-validation',
  priority: 100 
});

addHandler('processOrder', handler, { 
  id: '090-processOrder-inventory',
  priority: 90 
});

addHandler('processOrder', handler, { 
  id: '080-processOrder-payment',
  priority: 80 
});
```

### 4. Feature-Based IDs

```typescript
// Pattern: {feature}-{action}-{component}
addHandler('login', handler, { 
  id: 'auth-login-ldap' 
});

addHandler('login', handler, { 
  id: 'auth-login-session' 
});

addHandler('login', handler, { 
  id: 'analytics-login-tracking' 
});
```

## ID Organization Patterns

### 1. Hierarchical ID Structure

```typescript
// Create ID hierarchy for complex domains
const createUserHandlerID = (action: string, purpose: string) => 
  `user.profile.${action}.${purpose}`;

const createCartHandlerID = (action: string, purpose: string) => 
  `cart.items.${action}.${purpose}`;

// Usage
addHandler('updateProfile', handler, { 
  id: createUserHandlerID('update', 'validator') // user.profile.update.validator
});

addHandler('addItem', handler, { 
  id: createCartHandlerID('add', 'inventory') // cart.items.add.inventory
});
```

### 2. Namespace-Based IDs

```typescript
// Define namespaces for different concerns
const HandlerNamespaces = {
  VALIDATION: 'validation',
  BUSINESS: 'business', 
  PERSISTENCE: 'persistence',
  ANALYTICS: 'analytics',
  NOTIFICATION: 'notification'
} as const;

// Usage with namespace
addHandler('updateProfile', validationHandler, {
  id: `${HandlerNamespaces.VALIDATION}.updateProfile.schema`
});

addHandler('updateProfile', businessHandler, {
  id: `${HandlerNamespaces.BUSINESS}.updateProfile.rules`
});

addHandler('updateProfile', persistenceHandler, {
  id: `${HandlerNamespaces.PERSISTENCE}.updateProfile.database`
});
```

### 3. Component-Instance IDs

```typescript
// For component-specific handlers
function TodoItem({ todoId }: { todoId: string }) {
  const componentId = useId(); // React's unique ID
  const addHandler = useTodoActionRegister();
  
  const handler = useCallback(async (payload) => {
    // Handler logic specific to this instance
  }, [todoId]);
  
  useEffect(() => {
    if (!addHandler) return;
    
    // Unique ID per component instance
    const unaddHandler = addHandler('updateTodo', handler, {
      id: `todo-${componentId}-${todoId}`, // Unique per instance
      tags: ['component-instance'],
      cleanup: true
    });
    
    return unaddHandler;
  }, [addHandler, handler, componentId, todoId]);
}
```

## Advanced ID Strategies

### 1. Dynamic ID Generation

```typescript
// Dynamic IDs based on runtime conditions
function useUserHandlers(userRole: 'admin' | 'user' | 'guest') {
  const addHandler = useUserActionRegister();
  
  const generateHandlerID = useCallback((action: string, purpose: string) => {
    return `${userRole}.${action}.${purpose}`;
  }, [userRole]);
  
  useEffect(() => {
    if (!addHandler) return;
    
    const unaddHandlerUpdate = addHandler('updateProfile', handler, {
      id: generateHandlerID('updateProfile', 'authorization'),
      priority: userRole === 'admin' ? 100 : 50 // Different priorities by role
    });
    
    return unaddHandlerUpdate;
  }, [addHandler, userRole, generateHandlerID]);
}
```

### 2. Version-Based IDs

```typescript
// Version handlers for A/B testing or gradual rollouts
const HANDLER_VERSIONS = {
  V1: 'v1',
  V2: 'v2',
  BETA: 'beta'
} as const;

function usePaymentHandlers(version: keyof typeof HANDLER_VERSIONS = 'V1') {
  const addHandler = usePaymentActionRegister();
  
  useEffect(() => {
    if (!addHandler) return;
    
    const handlerVersion = HANDLER_VERSIONS[version];
    
    const unaddHandler = addHandler('processPayment', handler, {
      id: `payment.process.${handlerVersion}`,
      tags: ['versioned', handlerVersion],
      priority: version === 'V2' ? 100 : 90 // Newer version higher priority
    });
    
    return unaddHandler;
  }, [addHandler, version]);
}
```

### 3. Environment-Based IDs

```typescript
// Different handlers for different environments
function useAnalyticsHandlers() {
  const addHandler = useAnalyticsActionRegister();
  const environment = process.env.NODE_ENV;
  
  useEffect(() => {
    if (!addHandler) return;
    
    const handlers = [];
    
    // Production analytics
    if (environment === 'production') {
      handlers.push(addHandler('trackEvent', productionHandler, {
        id: 'analytics.track.production',
        tags: ['production']
      }));
    }
    
    // Development debugging
    if (environment === 'development') {
      handlers.push(addHandler('trackEvent', debugHandler, {
        id: 'analytics.track.debug',
        tags: ['development', 'debug']
      }));
    }
    
    // Test mock handlers
    if (environment === 'test') {
      handlers.push(addHandler('trackEvent', mockHandler, {
        id: 'analytics.track.mock',
        tags: ['test', 'mock']
      }));
    }
    
    return () => handlers.forEach(unaddHandler => unaddHandler?.());
  }, [addHandler, environment]);
}
```

## ID-Based Handler Management

### 1. Handler Registry Pattern

```typescript
// Central handler stores for management
class HandlerRegistry {
  private handlers = new Map<string, {
    id: string;
    action: string;
    priority: number;
    tags: string[];
    addHandleredAt: Date;
  }>();
  
  addHandler(action: string, handler: Function, config: { id: string; priority?: number; tags?: string[] }) {
    this.handlers.set(config.id, {
      id: config.id,
      action,
      priority: config.priority || 0,
      tags: config.tags || [],
      addHandleredAt: new Date()
    });
    
    // Actual registration logic here
    const unaddHandler = actualRegister(action, handler, config);
    
    return () => {
      this.handlers.delete(config.id);
      unaddHandler();
    };
  }
  
  getHandlersByAction(action: string) {
    return Array.from(this.handlers.values())
      .filter(h => h.action === action)
      .sort((a, b) => b.priority - a.priority);
  }
  
  getHandlersByTag(tag: string) {
    return Array.from(this.handlers.values())
      .filter(h => h.tags.includes(tag));
  }
  
  getHandlerInfo(id: string) {
    return this.handlers.get(id);
  }
  
  getAllHandlers() {
    return Array.from(this.handlers.values());
  }
}
```

### 2. Handler Debugging Tools

```typescript
// Debug tools using handler IDs
export function useHandlerDebugger(actionType?: string) {
  const [debugInfo, setDebugInfo] = useState<any[]>([]);
  
  useEffect(() => {
    if (process.env.NODE_ENV !== 'development') return;
    
    // Hook into handler execution to collect debug info
    const debugInterceptor = (handlerId: string, action: string, payload: any, result: any) => {
      setDebugInfo(prev => [...prev, {
        id: handlerId,
        action,
        payload,
        result,
        timestamp: Date.now()
      }]);
    };
    
    // Register debug interceptor
    return addHandlerDebugInterceptor(debugInterceptor, actionType);
  }, [actionType]);
  
  const clearDebugInfo = useCallback(() => {
    setDebugInfo([]);
  }, []);
  
  return { debugInfo, clearDebugInfo };
}

// Usage
function DebugPanel() {
  const { debugInfo, clearDebugInfo } = useHandlerDebugger('updateProfile');
  
  return (
    <div>
      <h3>Handler Debug Info</h3>
      <button onClick={clearDebugInfo}>Clear</button>
      {debugInfo.map(info => (
        <div key={info.timestamp}>
          <strong>{info.id}</strong> - {info.action}
          <pre>{JSON.stringify(info.payload, null, 2)}</pre>
        </div>
      ))}
    </div>
  );
}
```

### 3. Conditional Handler Registration

```typescript
// Register handlers based on feature flags or conditions
function useConditionalHandlers() {
  const addHandler = useUserActionRegister();
  const featureFlags = useFeatureFlags();
  
  useEffect(() => {
    if (!addHandler) return;
    
    const unaddHandlerFunctions: Array<() => void> = [];
    
    // Always addHandler core handlers
    unaddHandlerFunctions.push(
      addHandler('updateProfile', coreHandler, {
        id: 'user.updateProfile.core',
        priority: 100
      })
    );
    
    // Conditionally addHandler advanced features
    if (featureFlags.advancedValidation) {
      unaddHandlerFunctions.push(
        addHandler('updateProfile', advancedValidationHandler, {
          id: 'user.updateProfile.advancedValidation',
          priority: 110, // Higher priority than core
          tags: ['feature-flag', 'advanced-validation']
        })
      );
    }
    
    if (featureFlags.auditLogging) {
      unaddHandlerFunctions.push(
        addHandler('updateProfile', auditHandler, {
          id: 'user.updateProfile.audit',
          priority: 80, // Lower priority, runs after main logic
          tags: ['feature-flag', 'audit']
        })
      );
    }
    
    return () => {
      unaddHandlerFunctions.forEach(unaddHandler => unaddHandler());
    };
  }, [addHandler, featureFlags]);
}
```

## Testing with Handler IDs

### 1. ID-Based Test Utilities

```typescript
// Test utilities that use handler IDs
export function createTestHandlerSpy(handlerIds: string[]) {
  const spies = new Map<string, jest.SpyFunction>();
  
  handlerIds.forEach(id => {
    spies.set(id, jest.fn());
  });
  
  return {
    getSpyForHandler: (id: string) => spies.get(id),
    getAllSpies: () => Array.from(spies.values()),
    verifyHandlerCalled: (id: string, times = 1) => {
      const spy = spies.get(id);
      expect(spy).toHaveBeenCalledTimes(times);
    },
    verifyHandlerNotCalled: (id: string) => {
      const spy = spies.get(id);
      expect(spy).not.toHaveBeenCalled();
    }
  };
}

// Usage in tests
describe('User Profile Handlers', () => {
  it('should execute handlers in correct order', async () => {
    const spy = createTestHandlerSpy([
      'user.updateProfile.validation',
      'user.updateProfile.business',
      'user.updateProfile.persistence'
    ]);
    
    // Execute action
    await dispatch('updateProfile', { name: 'John' });
    
    // Verify execution order and calls
    spy.verifyHandlerCalled('user.updateProfile.validation', 1);
    spy.verifyHandlerCalled('user.updateProfile.business', 1);
    spy.verifyHandlerCalled('user.updateProfile.persistence', 1);
  });
});
```

## Best Practices

### ✅ Do

- **Use consistent naming conventions**: Establish patterns and stick to them
- **Include context in IDs**: Domain, action, and purpose should be clear
- **Use hierarchical structure**: Organize IDs with namespacing
- **Document ID conventions**: Maintain team documentation for ID patterns
- **Consider future maintenance**: Use IDs that will make sense months later

### ❌ Don't

- **Use generic IDs**: Avoid 'handler1', 'temp', or non-descriptive names
- **Make IDs too long**: Balance descriptiveness with readability
- **Hardcode environment-specific IDs**: Use dynamic generation when needed
- **Forget to clean up**: Always provide cleanup for addHandlered handlers
- **Ignore ID collisions**: Ensure IDs are unique within their scope

## Common ID Patterns

### Business Logic Handlers
```typescript
// Pattern: {domain}.{action}.{concern}
'user.login.authentication'
'user.login.session'
'user.login.analytics'

'cart.addItem.inventory'
'cart.addItem.pricing'
'cart.addItem.recommendations'
```

### Validation Handlers
```typescript
// Pattern: validation.{action}.{rule}
'validation.updateProfile.required'
'validation.updateProfile.format'
'validation.updateProfile.business'
```

### Integration Handlers
```typescript
// Pattern: integration.{source}.{target}.{action}
'integration.user.cart.login'
'integration.cart.inventory.addItem'
'integration.payment.order.process'
```

---

## Summary

Effective handler ID strategies provide:

- **Clear Identification**: Easy debugging and maintenance
- **Organized Structure**: Consistent patterns for team development
- **Runtime Management**: Dynamic handler registration and management
- **Testing Support**: Targeted testing and verification
- **Documentation**: Self-documenting handler purposes

Choose ID strategies that fit your team's needs and maintain consistency across your application.

---

::: tip Next Steps
- Learn [Performance Optimization](./performance) for efficient handler execution
- Explore [Error Handling Patterns](./error-handling) for robust handler implementation
- See [Testing Strategies](./testing) for comprehensive handler testing
:::

---


# Guide Logic Fit Hooks

**Source**: `guide/logic-fit-hooks.md`  
**Priority**: 80 (essential)  

# Logic Fit Hooks Pattern

Logic Fit Hooks combine business logic and UI state management in reusable custom hooks, providing a clean abstraction layer that bridges the MVVM architecture layers for specific use cases.

## Pattern Overview

The Logic Fit Hooks pattern allows you to:

- **Combine Layers**: Merge business logic (ViewModel) and UI state (View) in a single hook
- **Encapsulate Complexity**: Hide complex state coordination behind simple interfaces
- **Promote Reusability**: Share common logic patterns across components
- **Maintain Separation**: Keep business and UI concerns identifiable within the hook

## Basic Logic Fit Hook Pattern

### Simple User Editor Hook

```typescript
// hooks/useUserEditor.ts
export function useUserEditor() {
  // Business layer (ViewModel)
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  const dispatch = useUserAction();
  
  // UI state layer (View)
  const [editMode, setEditMode] = useState(false);
  const [formData, setFormData] = useState(profile);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Sync form data with store changes
  useEffect(() => {
    setFormData(profile);
  }, [profile]);
  
  // Combined business + UI logic
  const startEdit = useCallback(() => {
    setEditMode(true);
    setFormData(profile);
    setError(null);
  }, [profile]);
  
  const cancelEdit = useCallback(() => {
    setEditMode(false);
    setFormData(profile); // Reset to original
    setError(null);
  }, [profile]);
  
  const saveChanges = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      // Delegate to business layer
      await dispatch('updateProfile', { data: formData });
      setEditMode(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Save failed');
    } finally {
      setLoading(false);
    }
  }, [dispatch, formData]);
  
  const updateField = useCallback(<K extends keyof typeof formData>(
    field: K, 
    value: typeof formData[K]
  ) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  }, []);
  
  // Computed values
  const hasChanges = useMemo(() => {
    return JSON.stringify(formData) !== JSON.stringify(profile);
  }, [formData, profile]);
  
  const canSave = useMemo(() => {
    return hasChanges && !loading && formData.name.trim() !== '';
  }, [hasChanges, loading, formData.name]);
  
  return {
    // State
    profile,
    formData,
    editMode,
    loading,
    error,
    hasChanges,
    canSave,
    
    // Actions
    startEdit,
    cancelEdit,
    saveChanges,
    updateField
  };
}
```

### Using the Logic Fit Hook

```typescript
// components/UserProfile.tsx
export function UserProfile() {
  const {
    profile,
    formData,
    editMode,
    loading,
    error,
    hasChanges,
    canSave,
    startEdit,
    cancelEdit,
    saveChanges,
    updateField
  } = useUserEditor(); // All complexity hidden in the hook
  
  if (editMode) {
    return (
      <form onSubmit={(e) => { e.preventDefault(); saveChanges(); }}>
        <div>
          <label>Name:</label>
          <input 
            value={formData.name}
            onChange={(e) => updateField('name', e.target.value)}
            disabled={loading}
          />
        </div>
        
        <div>
          <label>Email:</label>
          <input 
            value={formData.email}
            onChange={(e) => updateField('email', e.target.value)}
            disabled={loading}
          />
        </div>
        
        {error && <div className="error">{error}</div>}
        
        <div>
          <button type="submit" disabled={!canSave}>
            {loading ? 'Saving...' : 'Save Changes'}
          </button>
          <button type="button" onClick={cancelEdit} disabled={loading}>
            Cancel
          </button>
        </div>
        
        {hasChanges && <div className="warning">You have unsaved changes</div>}
      </form>
    );
  }
  
  return (
    <div>
      <h2>{profile.name}</h2>
      <p>{profile.email}</p>
      <p>Role: {profile.role}</p>
      <button onClick={startEdit}>Edit Profile</button>
    </div>
  );
}
```

## Advanced Logic Fit Patterns

### 1. Multi-Store Coordination Hook

```typescript
// hooks/useCheckoutProcess.ts
export function useCheckoutProcess() {
  // Multiple business layers
  const cartStore = useCartStore('items');
  const userStore = useUserStore('profile');
  const orderStore = useOrderStore('current');
  
  const cartItems = useStoreValue(cartStore);
  const userProfile = useStoreValue(userStore);
  const currentOrder = useStoreValue(orderStore);
  
  const cartAction = useCartAction();
  const userAction = useUserAction();
  const orderAction = useOrderAction();
  
  // UI state coordination
  const [step, setStep] = useState<'cart' | 'shipping' | 'payment' | 'review'>('cart');
  const [shippingData, setShippingData] = useState(userProfile.address || {});
  const [paymentData, setPaymentData] = useState({});
  const [processing, setProcessing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Computed values across domains
  const total = useMemo(() => {
    return cartItems.reduce((sum, item) => sum + item.price * item.quantity, 0);
  }, [cartItems]);
  
  const canProceedToShipping = useMemo(() => {
    return cartItems.length > 0 && userProfile.id;
  }, [cartItems, userProfile]);
  
  const canProceedToPayment = useMemo(() => {
    return shippingData.address && shippingData.city && shippingData.zipCode;
  }, [shippingData]);
  
  // Complex cross-domain workflow
  const processCheckout = useCallback(async () => {
    setProcessing(true);
    setError(null);
    
    try {
      // Step 1: Validate cart
      await cartAction('validateItems');
      
      // Step 2: Update user shipping address
      if (shippingData.address !== userProfile.address?.address) {
        await userAction('updateAddress', { address: shippingData });
      }
      
      // Step 3: Create order
      const orderResult = await orderAction('createOrder', {
        items: cartItems,
        shipping: shippingData,
        payment: paymentData,
        total
      });
      
      // Step 4: Clear cart on success
      await cartAction('clearCart');
      
      return orderResult;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Checkout failed');
      throw err;
    } finally {
      setProcessing(false);
    }
  }, [cartAction, userAction, orderAction, cartItems, shippingData, paymentData, total, userProfile]);
  
  // Step navigation
  const nextStep = useCallback(() => {
    const steps: typeof step[] = ['cart', 'shipping', 'payment', 'review'];
    const currentIndex = steps.indexOf(step);
    if (currentIndex < steps.length - 1) {
      setStep(steps[currentIndex + 1]);
    }
  }, [step]);
  
  const prevStep = useCallback(() => {
    const steps: typeof step[] = ['cart', 'shipping', 'payment', 'review'];
    const currentIndex = steps.indexOf(step);
    if (currentIndex > 0) {
      setStep(steps[currentIndex - 1]);
    }
  }, [step]);
  
  return {
    // Cross-domain state
    cartItems,
    userProfile,
    currentOrder,
    total,
    
    // UI state
    step,
    shippingData,
    paymentData,
    processing,
    error,
    
    // Computed values
    canProceedToShipping,
    canProceedToPayment,
    
    // Actions
    setShippingData,
    setPaymentData,
    processCheckout,
    nextStep,
    prevStep,
    setStep
  };
}
```

### 2. Real-time Data Synchronization Hook

```typescript
// hooks/useUserActivitySync.ts
export function useUserActivitySync() {
  // Business layer
  const userStore = useUserStore('profile');
  const activityStore = useUserStore('activity');
  const user = useStoreValue(userStore);
  const activity = useStoreValue(activityStore);
  const dispatch = useUserAction();
  
  // UI state for real-time features
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [lastSync, setLastSync] = useState<number>(Date.now());
  const [syncStatus, setSyncStatus] = useState<'idle' | 'syncing' | 'error'>('idle');
  const [pendingUpdates, setPendingUpdates] = useState<any[]>([]);
  
  // Network status monitoring
  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  // Auto-sync when coming back online
  useEffect(() => {
    if (isOnline && pendingUpdates.length > 0) {
      syncPendingUpdates();
    }
  }, [isOnline]);
  
  // Sync pending updates
  const syncPendingUpdates = useCallback(async () => {
    if (!isOnline || pendingUpdates.length === 0) return;
    
    setSyncStatus('syncing');
    
    try {
      for (const update of pendingUpdates) {
        await dispatch('syncActivity', update);
      }
      
      setPendingUpdates([]);
      setLastSync(Date.now());
      setSyncStatus('idle');
    } catch (error) {
      setSyncStatus('error');
      // Keep pending updates for retry
    }
  }, [isOnline, pendingUpdates, dispatch]);
  
  // Track user activity
  const trackActivity = useCallback((activityType: string, data: any) => {
    const activityRecord = {
      type: activityType,
      data,
      timestamp: Date.now(),
      userId: user.id
    };
    
    if (isOnline) {
      // Sync immediately when online
      dispatch('trackActivity', activityRecord);
    } else {
      // Queue for later sync when offline
      setPendingUpdates(prev => [...prev, activityRecord]);
    }
  }, [isOnline, user.id, dispatch]);
  
  // Manual sync trigger
  const forcSync = useCallback(() => {
    if (isOnline) {
      dispatch('forceSync');
      setLastSync(Date.now());
    }
  }, [isOnline, dispatch]);
  
  return {
    // State
    user,
    activity,
    isOnline,
    lastSync,
    syncStatus,
    pendingUpdates: pendingUpdates.length,
    
    // Actions
    trackActivity,
    forcSync,
    syncPendingUpdates
  };
}
```

### 3. Form Validation Logic Fit Hook

```typescript
// hooks/useValidatedForm.ts
export function useValidatedForm<T extends Record<string, any>>(
  initialData: T,
  validationRules: Record<keyof T, (value: any) => string | null>,
  onSubmit: (data: T) => Promise<void>
) {
  // UI state
  const [formData, setFormData] = useState<T>(initialData);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [touched, setTouched] = useState<Partial<Record<keyof T, boolean>>>({});
  const [submitting, setSubmitting] = useState(false);
  const [submitError, setSubmitError] = useState<string | null>(null);
  
  // Validation logic
  const validateField = useCallback((field: keyof T, value: any): string | null => {
    const rule = validationRules[field];
    return rule ? rule(value) : null;
  }, [validationRules]);
  
  const validateAll = useCallback((): boolean => {
    const newErrors: Partial<Record<keyof T, string>> = {};
    let isValid = true;
    
    for (const field in formData) {
      const error = validateField(field, formData[field]);
      if (error) {
        newErrors[field] = error;
        isValid = false;
      }
    }
    
    setErrors(newErrors);
    return isValid;
  }, [formData, validateField]);
  
  // Field update with validation
  const updateField = useCallback(<K extends keyof T>(
    field: K,
    value: T[K]
  ) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    
    // Validate field if it has been touched
    if (touched[field]) {
      const error = validateField(field, value);
      setErrors(prev => ({ ...prev, [field]: error || undefined }));
    }
  }, [touched, validateField]);
  
  // Mark field as touched
  const touchField = useCallback((field: keyof T) => {
    setTouched(prev => ({ ...prev, [field]: true }));
    
    // Validate on touch
    const error = validateField(field, formData[field]);
    setErrors(prev => ({ ...prev, [field]: error || undefined }));
  }, [formData, validateField]);
  
  // Submit handling
  const handleSubmit = useCallback(async () => {
    // Mark all fields as touched
    const allTouched = Object.keys(formData).reduce(
      (acc, key) => ({ ...acc, [key]: true }),
      {} as Record<keyof T, boolean>
    );
    setTouched(allTouched);
    
    // Validate all fields
    if (!validateAll()) {
      return;
    }
    
    setSubmitting(true);
    setSubmitError(null);
    
    try {
      await onSubmit(formData);
    } catch (error) {
      setSubmitError(error instanceof Error ? error.message : 'Submit failed');
    } finally {
      setSubmitting(false);
    }
  }, [formData, validateAll, onSubmit]);
  
  // Reset form
  const resetForm = useCallback(() => {
    setFormData(initialData);
    setErrors({});
    setTouched({});
    setSubmitError(null);
  }, [initialData]);
  
  // Computed values
  const hasErrors = useMemo(() => {
    return Object.values(errors).some(error => error);
  }, [errors]);
  
  const isValid = useMemo(() => {
    return !hasErrors && Object.keys(touched).length > 0;
  }, [hasErrors, touched]);
  
  return {
    // Data
    formData,
    errors,
    touched,
    submitting,
    submitError,
    
    // Computed
    hasErrors,
    isValid,
    
    // Actions
    updateField,
    touchField,
    handleSubmit,
    resetForm,
    validateAll
  };
}

// Usage with business logic integration
export function useUserProfileForm() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  const dispatch = useUserAction();
  
  const validationRules = {
    name: (value: string) => !value.trim() ? 'Name is required' : null,
    email: (value: string) => {
      if (!value.trim()) return 'Email is required';
      if (!value.includes('@')) return 'Invalid email format';
      return null;
    }
  };
  
  const handleProfileUpdate = useCallback(async (data: typeof profile) => {
    await dispatch('updateProfile', { data });
  }, [dispatch]);
  
  const form = useValidatedForm(profile, validationRules, handleProfileUpdate);
  
  // Reset form when profile changes from external updates
  useEffect(() => {
    if (JSON.stringify(form.formData) !== JSON.stringify(profile)) {
      form.resetForm();
    }
  }, [profile]);
  
  return form;
}
```

## Logic Fit Hook Patterns

### 1. State + Actions Pattern

```typescript
// Combine store state with action dispatchers
export function useUserManagement() {
  // State layer
  const users = useStoreValue(useUserStore('list'));
  const selectedUser = useStoreValue(useUserStore('selected'));
  
  // Action layer
  const dispatch = useUserAction();
  
  // UI state
  const [loading, setLoading] = useState(false);
  
  // Combined operations
  const selectUser = useCallback(async (userId: string) => {
    setLoading(true);
    await dispatch('selectUser', { userId });
    setLoading(false);
  }, [dispatch]);
  
  return { users, selectedUser, loading, selectUser };
}
```

### 2. Cross-Domain Integration Pattern

```typescript
// Integrate multiple domains in a single hook
export function useShoppingExperience() {
  // Multiple domain connections
  const userProfile = useStoreValue(useUserStore('profile'));
  const cartItems = useStoreValue(useCartStore('items'));
  const recommendations = useStoreValue(useProductStore('recommended'));
  
  const userAction = useUserAction();
  const cartAction = useCartAction();
  const productAction = useProductAction();
  
  // Cross-domain operations
  const addToCartWithRecommendations = useCallback(async (productId: string) => {
    await cartAction('addItem', { productId });
    await productAction('updateRecommendations', { userId: userProfile.id });
  }, [cartAction, productAction, userProfile.id]);
  
  return {
    userProfile,
    cartItems,
    recommendations,
    addToCartWithRecommendations
  };
}
```

### 3. Async State Management Pattern

```typescript
// Handle async operations with UI state
export function useAsyncOperation<TParams, TResult>(
  operation: (params: TParams) => Promise<TResult>
) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [result, setResult] = useState<TResult | null>(null);
  
  const execute = useCallback(async (params: TParams) => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await operation(params);
      setResult(result);
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Operation failed';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [operation]);
  
  const reset = useCallback(() => {
    setLoading(false);
    setError(null);
    setResult(null);
  }, []);
  
  return { loading, error, result, execute, reset };
}
```

## Best Practices

### ✅ Do

- **Keep business logic identifiable**: Clearly separate business and UI concerns within the hook
- **Use meaningful names**: Hook names should describe what they accomplish
- **Return consistent interfaces**: Provide predictable return shapes
- **Handle loading and error states**: Include UI state for async operations
- **Use useMemo for expensive computations**: Optimize derived values

### ❌ Don't

- **Mix too many concerns**: Keep hooks focused on specific functionality
- **Create overly complex hooks**: Split large hooks into smaller, focused ones
- **Ignore error handling**: Always handle potential errors in async operations
- **Forget cleanup**: Clean up subscriptions and timers in useEffect
- **Bypass the action layer**: Don't directly manipulate stores in logic fit hooks

---

## Summary

Logic Fit Hooks provide:

- **Clean Abstraction**: Hide complex state coordination behind simple interfaces
- **Reusable Logic**: Share common patterns across multiple components
- **Type Safety**: Full TypeScript support with proper inference
- **Testability**: Isolated testing of complex business + UI logic
- **Maintainability**: Centralized logic for specific features

Use Logic Fit Hooks when you need to combine business logic with UI state management in a reusable, testable way.

---

::: tip Next Steps
- Learn [Handler ID Strategies](./handler-id-strategies) for debugging and organization
- Explore [Performance Optimization](./performance) for efficient hook implementations  
- See [Testing Strategies](./testing) for testing custom hooks
:::

---


# Guide Mvvm Architecture

**Source**: `guide/mvvm-architecture.md`  
**Priority**: 80 (essential)  

# MVVM-Inspired Architecture

The Context-Action framework implements a clean separation of concerns through an **MVVM-inspired pattern** combined with **Context Store Pattern** for complete domain isolation.

## Architecture Overview

The MVVM-inspired architecture provides clear separation between different layers of your application:

- **Actions** handle business logic (ViewModel layer)
- **Context Store Pattern** manages state with domain isolation (Model layer)
- **Components** render UI (View layer)
- **Context Boundaries** isolate functional domains
- **Type-Safe Integration** through domain-specific hooks

## Three-Layer Architecture

### Model Layer (Context Store Pattern)

The Model layer manages application state through isolated store contexts:

```typescript
// stores/user.store.ts
export interface UserData {
  profile: {
    id: string;
    name: string;
    email: string;
    role: 'admin' | 'user' | 'guest';
  };
  preferences: {
    theme: 'light' | 'dark';
    language: string;
  };
}

// Create domain-specific stores (Model layer)
export const {
  Provider: UserProvider,
  useStore: useUserStore,
  useStores: useUserStores
} = createDeclarativeStores<UserData>('User', {
  profile: {
    initialValue: {
      id: '',
      name: '',
      email: '',
      role: 'guest'
    }
  },
  preferences: {
    initialValue: {
      theme: 'light',
      language: 'en'
    }
  }
});
```

**Model Layer Responsibilities:**
- State management and persistence
- Data validation and consistency
- Domain boundaries and isolation
- Store lifecycle management

### ViewModel Layer (Actions)

The ViewModel layer handles business logic through action handlers:

```typescript
// Define business operations (ViewModel layer)
export interface UserActions {
  login: { email: string; password: string };
  logout: void;
  updateProfile: { data: Partial<UserData['profile']> };
  deleteUser: { userId: string };
}

// Create action context for business logic
export const {
  Provider: UserActionProvider,
  useAction: useUserAction,
  useActionHandler: useUserActionHandler
} = createActionContext<UserActions>({ name: 'UserAction' });

// Business logic handlers (ViewModel layer)
function useUserHandlers() {
  const addHandler = useUserActionHandler();
  const stores = useUserStores();
  
  const loginHandler = useCallback(async (payload, controller) => {
    const profileStore = stores.getStore('profile');
    
    // Business logic: authentication
    try {
      const response = await authenticateUser(payload);
      
      // Update model
      profileStore.setValue({
        id: response.user.id,
        name: response.user.name,
        email: response.user.email,
        role: response.user.role
      });
    } catch (error) {
      controller.abort('Authentication failed', error);
    }
  }, [stores]);
  
  useEffect(() => {
    if (!addHandler) return;
    return addHandler('login', loginHandler, { priority: 100, blocking: true });
  }, [addHandler, loginHandler]);
}
```

**ViewModel Layer Responsibilities:**
- Business logic implementation
- Data transformation and validation
- External service integration
- State coordination and updates

### View Layer (React Components)

The View layer handles UI rendering and user interactions:

```typescript
// components/UserProfile.tsx (View layer)
export function UserProfile() {
  // Connect to Model layer
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  // Connect to ViewModel layer
  const dispatch = useUserAction();
  
  // Local UI state (View layer only)
  const [editMode, setEditMode] = useState(false);
  const [formData, setFormData] = useState(profile);
  
  // Sync form with model changes
  useEffect(() => {
    setFormData(profile);
  }, [profile]);
  
  // View actions (UI interactions)
  const handleSave = useCallback(async () => {
    try {
      // Delegate to ViewModel layer
      await dispatch('updateProfile', { data: formData });
      setEditMode(false);
    } catch (error) {
      console.error('Update failed:', error);
    }
  }, [dispatch, formData]);
  
  // Pure UI rendering
  if (editMode) {
    return (
      <form onSubmit={(e) => { e.preventDefault(); handleSave(); }}>
        <input 
          value={formData.name}
          onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
        />
        <button type="submit">Save</button>
        <button type="button" onClick={() => setEditMode(false)}>Cancel</button>
      </form>
    );
  }
  
  return (
    <div>
      <h2>{profile.name}</h2>
      <p>{profile.email}</p>
      <p>Role: {profile.role}</p>
      <button onClick={() => setEditMode(true)}>Edit</button>
    </div>
  );
}
```

**View Layer Responsibilities:**
- UI rendering and presentation
- User interaction handling
- Local UI state management
- Event handling and form validation

## MVVM Data Flow

### Unidirectional Data Flow

```mermaid
graph LR
    A[View] -->|dispatch| B[ViewModel]
    B -->|update| C[Model]
    C -->|subscribe| A
    
    style A fill:#e3f2fd
    style B fill:#fff8e1
    style C fill:#e8f5e8
```

1. **View** dispatches actions (user interactions)
2. **ViewModel** processes business logic
3. **Model** updates state
4. **View** re-renders through reactive subscriptions

### Complete Flow Example

```typescript
// 1. View Layer - User clicks save button
function SaveButton() {
  const dispatch = useUserAction();
  
  const handleSave = () => {
    // Dispatch to ViewModel layer
    dispatch('updateProfile', { data: { name: 'New Name' } });
  };
  
  return <button onClick={handleSave}>Save</button>;
}

// 2. ViewModel Layer - Business logic handler
function useUserHandlers() {
  const register = useUserActionRegister();
  const registry = useUserRegistry();
  
  const updateHandler = useCallback(async (payload, controller) => {
    // Business logic: validation
    if (!payload.data.name?.trim()) {
      controller.abort('Name cannot be empty');
      return;
    }
    
    // Business logic: data transformation
    const sanitizedData = {
      ...payload.data,
      name: payload.data.name.trim(),
      updatedAt: Date.now()
    };
    
    // Update Model layer
    const profileStore = registry.getStore('profile');
    const currentProfile = profileStore.getValue();
    
    profileStore.setValue({
      ...currentProfile,
      ...sanitizedData
    });
  }, [registry]);
  
  useEffect(() => {
    if (!register) return;
    return register('updateProfile', updateHandler);
  }, [register, updateHandler]);
}

// 3. Model Layer - State management
const userStore = createDeclarativeStores<UserData>('User', {
  profile: {
    initialValue: { /* initial state */ }
  }
});

// 4. View Layer - Reactive updates
function UserDisplay() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore); // Reactive subscription
  
  // Re-renders when Model updates
  return <div>{profile.name}</div>;
}
```

## Architecture Benefits

### 1. Clear Separation of Concerns

- **View**: Only UI rendering and user interactions
- **ViewModel**: Pure business logic, no UI dependencies
- **Model**: State management, no business logic

### 2. Testability

Each layer can be tested independently:

```typescript
// Test ViewModel layer (business logic)
describe('User Business Logic', () => {
  it('should validate profile updates', async () => {
    const handler = createUpdateProfileHandler(mockRegistry);
    const mockController = { abort: jest.fn() };
    
    await handler({ data: { name: '' } }, mockController);
    
    expect(mockController.abort).toHaveBeenCalledWith('Name cannot be empty');
  });
});

// Test View layer (UI interactions)
describe('UserProfile Component', () => {
  it('should dispatch action on save', () => {
    const mockDispatch = jest.fn();
    render(<UserProfile dispatch={mockDispatch} />);
    
    fireEvent.click(getByText('Save'));
    
    expect(mockDispatch).toHaveBeenCalledWith('updateProfile', { data: expect.any(Object) });
  });
});
```

### 3. Maintainability

- Business logic centralized in ViewModel handlers
- UI logic isolated in View components
- State management isolated in Model stores
- Clear interfaces between layers

### 4. Scalability

- Add new Views without affecting business logic
- Extend business logic without changing UI
- Scale Model independently
- Domain isolation prevents conflicts

## Advanced MVVM Patterns

### 1. Multi-Domain MVVM

```typescript
// Each domain has its own MVVM layers
const UserDomain = {
  Model: createUserStores(),
  ViewModel: createUserActions(),
  View: UserComponents
};

const CartDomain = {
  Model: createCartStores(),
  ViewModel: createCartActions(), 
  View: CartComponents
};

// Cross-domain coordination through integration layer
function useUserCartIntegration() {
  const userAction = useUserAction();   // User ViewModel
  const cartAction = useCartAction();   // Cart ViewModel
  
  const loginWithCartReset = useCallback(async (loginData) => {
    await userAction('login', loginData);        // User domain business logic
    await cartAction('clearCart');               // Cart domain business logic
  }, [userAction, cartAction]);
  
  return { loginWithCartReset };
}
```

### 2. Shared ViewModel Services

```typescript
// Shared business logic across domains
export function useNotificationService() {
  const userAction = useUserAction();
  const cartAction = useCartAction();
  const orderAction = useOrderAction();
  
  const sendNotification = useCallback(async (type: string, data: any) => {
    // Cross-domain business logic
    switch (type) {
      case 'user-update':
        return userAction('notifyUpdate', data);
      case 'cart-change':
        return cartAction('notifyChange', data);
      case 'order-status':
        return orderAction('notifyStatus', data);
    }
  }, [userAction, cartAction, orderAction]);
  
  return { sendNotification };
}
```

### 3. View-ViewModel Composition

```typescript
// Compose multiple ViewModels in a single View
export function DashboardView() {
  // Multiple ViewModel connections
  const userProfile = useUserProfile();       // User ViewModel
  const cartSummary = useCartSummary();       // Cart ViewModel
  const orderHistory = useOrderHistory();     // Order ViewModel
  
  return (
    <div>
      <UserProfileWidget {...userProfile} />
      <CartSummaryWidget {...cartSummary} />
      <OrderHistoryWidget {...orderHistory} />
    </div>
  );
}
```

## Best Practices

### ✅ Do

- **Keep layers pure**: No business logic in View, no UI logic in ViewModel
- **Use reactive subscriptions**: Connect View to Model through `useStoreValue`
- **Centralize business logic**: Put all business logic in ViewModel handlers
- **Test layers independently**: Unit test each layer in isolation
- **Use domain boundaries**: Keep related functionality together

### ❌ Don't

- **Mix layers**: Don't put business logic in components or UI logic in handlers
- **Direct store access**: Don't bypass ViewModel layer for state updates
- **Tight coupling**: Don't create dependencies between domains
- **Stale closures**: Don't capture values at registration time
- **Skip cleanup**: Always clean up handlers and subscriptions

---

## Summary

The MVVM-inspired architecture in Context-Action provides:

- **Clear Separation**: Distinct Model, ViewModel, and View layers
- **Type Safety**: Full TypeScript support across all layers  
- **Testability**: Independent testing of business logic and UI
- **Maintainability**: Centralized concerns with clear boundaries
- **Scalability**: Domain isolation and modular architecture

This architecture enables building complex, maintainable applications with clear responsibilities and strong architectural boundaries.

---

::: tip Next Steps
- Learn [Logic Fit Hooks](./logic-fit-hooks) for combining business and UI logic
- Explore [Cross-Domain Integration](./cross-domain-integration) for multi-domain coordination
- See [Testing Strategies](./testing) for comprehensive testing approaches
:::

---


# Guide Patterns

**Source**: `guide/patterns.md`  
**Priority**: 80 (essential)  

# Main Patterns

Context-Action framework provides **two main patterns** that can be used independently or combined to build scalable React applications with clean separation of concerns.

## Pattern Overview

### 🎯 Action Only Pattern
**Import**: `createActionContext` from `@context-action/react`

**Use Case**: Pure action dispatching without state management
- Event systems and command patterns
- User interaction handling
- Business logic orchestration
- Cross-component communication

**Features**:
- Type-safe action dispatching
- Handler registration with priority
- Pipeline control (abort, modify payload)
- Lightweight (no store overhead)

### 🏪 Store Only Pattern (Recommended)
**Import**: `createDeclarativeStorePattern` from `@context-action/react`

**Use Case**: Pure state management without action dispatching
- Data layers and application state
- Component-level state
- Derived state management
- Reactive data flows

**Features**:
- Excellent type inference without manual annotations
- Simplified API focused on store management
- Direct value or configuration object support
- HOC pattern with `withProvider()`

## Action Only Pattern

### Basic Setup

```typescript
import { createActionContext } from '@context-action/react';

// 1. Define action types
interface EventActions extends ActionPayloadMap {
  trackEvent: { event: string; data: any };
  logError: { error: string; context: any };
  sendAnalytics: { category: string; action: string; value?: number };
}

// 2. Create action context
const {
  Provider: EventActionProvider,
  useActionDispatch: useEventAction,
  useActionHandler: useEventActionHandler
} = createActionContext<EventActions>('Events');
```

### Provider Setup

```typescript
function App() {
  return (
    <EventActionProvider>
      <AnalyticsComponent />
      <UserInteractionComponent />
    </EventActionProvider>
  );
}
```

### Handler Registration

```typescript
function AnalyticsComponent() {
  const dispatch = useEventAction();
  
  // Register event tracking handler
  useEventActionHandler('trackEvent', async (payload) => {
    await analytics.track(payload.event, payload.data);
    console.log(`Event tracked: ${payload.event}`);
  }, { priority: 100 });
  
  // Register error logging handler
  useEventActionHandler('logError', async (payload) => {
    await logger.error(payload.error, payload.context);
    // Send to error reporting service
  }, { priority: 90 });
  
  return null; // This component only handles events
}
```

### Action Dispatching

```typescript
function UserInteractionComponent() {
  const dispatch = useEventAction();
  
  const handleButtonClick = () => {
    dispatch('trackEvent', {
      event: 'button_click',
      data: { button: 'cta', page: 'home' }
    });
  };
  
  const handleError = (error: Error) => {
    dispatch('logError', {
      error: error.message,
      context: { component: 'UserInteraction', timestamp: Date.now() }
    });
  };
  
  return (
    <div>
      <button onClick={handleButtonClick}>
        Click me
      </button>
    </div>
  );
}
```

### Advanced Pipeline Control

```typescript
function AdvancedEventHandler() {
  useEventActionHandler('sendAnalytics', async (payload, controller) => {
    // 1. Validate input
    if (!payload.category || !payload.action) {
      controller.abort('Missing required fields');
      return;
    }
    
    // 2. Modify payload for subsequent handlers
    controller.modifyPayload(current => ({
      ...current,
      timestamp: Date.now(),
      sessionId: getSessionId()
    }));
    
    // 3. Set intermediate result
    controller.setResult({ step: 'validation', success: true });
    
    // 4. Process analytics
    await analytics.send({
      category: payload.category,
      action: payload.action,
      value: payload.value || 0
    });
    
    return { sent: true, provider: 'google-analytics' };
  }, { priority: 100 });
  
  return null;
}
```

## Store Only Pattern

### Basic Setup

```typescript
import { createDeclarativeStorePattern } from '@context-action/react';

// 1. Create store pattern with type inference
const {
  Provider: UserStoreProvider,
  useStore: useUserStore,
  useStoreManager: useUserStoreManager,
  withProvider: withUserStoreProvider
} = createDeclarativeStorePattern('User', {
  // Direct value support
  profile: { name: '', email: '', avatar: '' },
  
  // Configuration object support
  preferences: {
    initialValue: { theme: 'light', language: 'en', notifications: true },
    validator: (value) => typeof value === 'object' && 'theme' in value
  },
  
  // Complex state with derivations
  settings: {
    initialValue: { privacy: 'public', twoFactor: false },
    derived: {
      isSecure: (settings) => settings.twoFactor && settings.privacy === 'private'
    }
  }
});
```

### Provider Setup Options

#### Option 1: Manual Provider
```typescript
function App() {
  return (
    <UserStoreProvider>
      <UserProfileComponent />
      <UserSettingsComponent />
    </UserStoreProvider>
  );
}
```

#### Option 2: HOC Pattern (Recommended)
```typescript
// Automatically wrap component with provider
const App = withUserStoreProvider(() => (
  <div>
    <UserProfileComponent />
    <UserSettingsComponent />
  </div>
));
```

### Store Usage

```typescript
function UserProfileComponent() {
  const profileStore = useUserStore('profile');
  const preferencesStore = useUserStore('preferences');
  
  // Subscribe to store values
  const profile = useStoreValue(profileStore);
  const preferences = useStoreValue(preferencesStore);
  
  const updateProfile = () => {
    // Direct value update
    profileStore.setValue({
      ...profile,
      name: 'John Doe',
      email: 'john@example.com'
    });
  };
  
  const toggleTheme = () => {
    // Update function
    preferencesStore.update(current => ({
      ...current,
      theme: current.theme === 'light' ? 'dark' : 'light'
    }));
  };
  
  return (
    <div>
      <h1>{profile.name}</h1>
      <p>Theme: {preferences.theme}</p>
      <button onClick={updateProfile}>Update Profile</button>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </div>
  );
}
```

### Store Manager

```typescript
function UserManagerComponent() {
  const storeManager = useUserStoreManager();
  
  const resetAllStores = () => {
    // Reset all stores to initial values
    storeManager.resetAll();
  };
  
  const resetSpecificStore = () => {
    // Reset specific store
    storeManager.reset('profile');
  };
  
  const getAllValues = () => {
    // Get all current values
    const values = storeManager.getAllValues();
    console.log(values);
    // {
    //   profile: { name: '', email: '', avatar: '' },
    //   preferences: { theme: 'light', language: 'en', notifications: true },
    //   settings: { privacy: 'public', twoFactor: false }
    // }
  };
  
  return (
    <div>
      <button onClick={resetAllStores}>Reset All</button>
      <button onClick={resetSpecificStore}>Reset Profile</button>
      <button onClick={getAllValues}>Log All Values</button>
    </div>
  );
}
```

## Pattern Composition

Combine both patterns for complex applications:

```typescript
// 1. Create Action Context
const {
  Provider: EventActionProvider,
  useActionDispatch: useEventAction,
  useActionHandler: useEventActionHandler
} = createActionContext<{
  userLogin: { username: string; password: string };
  userLogout: void;
  trackEvent: { event: string; data: any };
}>('UserEvents');

// 2. Create Store Pattern  
const {
  Provider: AppStoreProvider,
  useStore: useAppStore,
  withProvider: withAppStoreProvider
} = createDeclarativeStorePattern('App', {
  user: { id: '', name: '', email: '', isAuthenticated: false },
  ui: { loading: false, error: null },
  analytics: { sessionId: '', events: [] }
});

// 3. Compose Providers
const App = withAppStoreProvider(() => (
  <EventActionProvider>
    <AuthComponent />
    <UserDashboard />
  </EventActionProvider>
));

// 4. Use Both Patterns Together
function AuthComponent() {
  const dispatch = useEventAction();
  const userStore = useAppStore('user');
  const uiStore = useAppStore('ui');
  
  // Action handler that updates stores
  useEventActionHandler('userLogin', async (payload, controller) => {
    try {
      // Set loading state
      uiStore.update(ui => ({ ...ui, loading: true, error: null }));
      
      // Perform authentication
      const user = await authService.login(payload.username, payload.password);
      
      // Update user store
      userStore.setValue({
        id: user.id,
        name: user.name,
        email: user.email,
        isAuthenticated: true
      });
      
      // Track login event
      dispatch('trackEvent', { event: 'user_login', data: { userId: user.id } });
      
    } catch (error) {
      // Handle error
      uiStore.update(ui => ({ 
        ...ui, 
        loading: false, 
        error: (error as Error).message 
      }));
      controller.abort('Login failed');
    } finally {
      uiStore.update(ui => ({ ...ui, loading: false }));
    }
  });
  
  const user = useStoreValue(userStore);
  const ui = useStoreValue(uiStore);
  
  const handleLogin = () => {
    dispatch('userLogin', { username: 'john', password: 'secret' });
  };
  
  return (
    <div>
      {ui.loading && <p>Logging in...</p>}
      {ui.error && <p>Error: {ui.error}</p>}
      {user.isAuthenticated ? (
        <p>Welcome, {user.name}!</p>
      ) : (
        <button onClick={handleLogin}>Login</button>
      )}
    </div>
  );
}
```

## MVVM Architecture Integration

### View Layer (Components)
- React components that render UI
- Dispatch actions for user interactions
- Subscribe to store changes for reactive updates

### ViewModel Layer (Action Handlers)
- Business logic in action handlers
- Coordinate between different stores
- Handle side effects and API calls

### Model Layer (Stores)
- Application state management
- Data persistence and retrieval
- Derived state computations

```typescript
// View Layer - Component
function TodoComponent() {
  const dispatch = useEventAction();           // ViewModel interaction
  const todosStore = useAppStore('todos');     // Model subscription
  const todos = useStoreValue(todosStore);
  
  return (
    <div>
      {todos.map(todo => (
        <div key={todo.id}>
          {todo.text}
          <button onClick={() => dispatch('toggleTodo', { id: todo.id })}>
            Toggle
          </button>
        </div>
      ))}
    </div>
  );
}

// ViewModel Layer - Action Handler
useEventActionHandler('toggleTodo', async (payload) => {
  const todosStore = stores.getStore('todos');
  const currentTodos = todosStore.getValue();
  
  // Business logic
  const updatedTodos = currentTodos.map(todo =>
    todo.id === payload.id 
      ? { ...todo, completed: !todo.completed }
      : todo
  );
  
  // Update model
  todosStore.setValue(updatedTodos);
  
  // Side effects
  await api.updateTodo(payload.id, { completed: !todo.completed });
});
```

## Best Practices

### When to Use Action Only Pattern
- ✅ Event systems and analytics
- ✅ Command patterns and business logic orchestration
- ✅ Cross-component communication
- ✅ Side effects and API calls

### When to Use Store Only Pattern
- ✅ Application state management
- ✅ Form state and UI state
- ✅ Derived state and computed values
- ✅ Data caching and persistence

### Pattern Composition Guidelines
- Use **Action Only** for business logic and side effects
- Use **Store Only** for state management and data
- Combine both for complex applications with clear separation
- Keep actions focused on orchestration, stores focused on data

## Next Steps

- **[Examples](../examples/pattern-composition)** - See complete pattern composition examples
- **[API Reference](../api/react/action-context)** - Detailed API documentation
- **[MVVM Architecture](./mvvm-architecture)** - Deep dive into architectural principles

---


# Guide Performance

**Source**: `guide/performance.md`  
**Priority**: 80 (essential)  

# Performance Optimization

Optimize your Context-Action applications for maximum performance through efficient handler management, smart subscriptions, and memory optimization techniques.

## Performance Principles

The Context-Action framework is designed for performance, but following best practices ensures optimal results:

1. **Lazy Evaluation**: Access stores only when needed in handlers
2. **Minimal Subscriptions**: Subscribe only to stores you actually use
3. **Efficient Handlers**: Use `useCallback` to prevent re-registration
4. **Memory Cleanup**: Always clean up handlers and subscriptions
5. **Selective Updates**: Update only what changes

## Handler Performance Optimization

### 1. Efficient Handler Registration

```typescript
// ✅ Optimal: Stable handler with minimal dependencies
function useUserHandlers() {
  const addHandler = useUserActionHandler();
  const stores = useUserStores(); // Stable reference
  
  // Stable handler - only recreated if registry changes
  const updateHandler = useCallback(async (payload, controller) => {
    // Lazy evaluation - get current state when needed
    const profileStore = stores.getStore('profile');
    const currentProfile = profileStore.getValue();
    
    // Business logic
    const updatedProfile = {
      ...currentProfile,
      ...payload.data,
      updatedAt: Date.now()
    };
    
    profileStore.setValue(updatedProfile);
  }, [registry]); // Only registry dependency
  
  useEffect(() => {
    if (!addHandler) return;
    const unregister = addHandler('updateProfile', updateHandler, {
      priority: 100,
      blocking: true,
      id: 'profile-updater'
    });
    return unregister; // Critical: cleanup prevents memory leaks
  }, [addHandler, updateHandler]);
}
```

```typescript
// ❌ Inefficient: Handler recreated every render
function useUserHandlers() {
  const addHandler = useUserActionHandler();
  const profileStore = useUserStore('profile'); // Store reference changes
  
  // New function every render - causes re-registration
  const updateHandler = async (payload, controller) => {
    const profile = profileStore.getValue(); // Stale closure risk
    // Handler logic
  };
  
  useEffect(() => {
    if (!addHandler) return;
    const unregister = addHandler('updateProfile', updateHandler);
    return unregister;
  }, [addHandler, updateHandler]); // updateHandler changes every render!
}
```

### 2. Handler Priority Optimization

```typescript
// Optimize handler execution order for performance
function useOptimizedHandlers() {
  const addHandler = useUserActionHandler();
  const stores = useUserStores();
  
  useEffect(() => {
    if (!addHandler) return;
    
    const unregisterFunctions = [];
    
    // High priority: Fast validation (runs first)
    unregisterFunctions.push(
      register('updateProfile', fastValidationHandler, {
        priority: 100,
        blocking: true, // Block if validation fails
        id: 'validation-fast'
      })
    );
    
    // Medium priority: Business logic (runs second)
    unregisterFunctions.push(
      register('updateProfile', businessLogicHandler, {
        priority: 90,
        blocking: true, // Block for data consistency
        id: 'business-logic'
      })
    );
    
    // Low priority: Side effects (runs last, can be async)
    unregisterFunctions.push(
      register('updateProfile', analyticsHandler, {
        priority: 80,
        blocking: false, // Don't block for analytics
        id: 'analytics'
      })
    );
    
    return () => unregisterFunctions.forEach(fn => fn());
  }, [addHandler, registry]);
}
```

### 3. Conditional Handler Registration

```typescript
// Register handlers based on conditions to reduce overhead
function useConditionalHandlers(userRole: string, features: string[]) {
  const addHandler = useUserActionHandler();
  
  useEffect(() => {
    if (!addHandler) return;
    
    const unregisterFunctions = [];
    
    // Always register core handlers
    unregisterFunctions.push(
      register('updateProfile', coreHandler, {
        priority: 100,
        id: 'core-handler'
      })
    );
    
    // Conditionally register expensive handlers
    if (userRole === 'admin') {
      unregisterFunctions.push(
        register('updateProfile', adminValidationHandler, {
          priority: 110,
          id: 'admin-validation'
        })
      );
    }
    
    if (features.includes('advanced-analytics')) {
      unregisterFunctions.push(
        register('updateProfile', advancedAnalyticsHandler, {
          priority: 70,
          blocking: false, // Don't block main flow
          id: 'advanced-analytics'
        })
      );
    }
    
    return () => unregisterFunctions.forEach(fn => fn());
  }, [addHandler, userRole, features]); // Re-register when conditions change
}
```

## Store Performance Optimization

### 1. Selective Subscriptions

```typescript
// ✅ Optimal: Only subscribe to stores you use
function UserName() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore); // Only subscribes to profile
  
  // Component only re-renders when profile changes
  return <span>{profile.name}</span>;
}

function UserEmail() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  // Separate component for email - independent re-rendering
  return <span>{profile.email}</span>;
}
```

```typescript
// ❌ Inefficient: Over-subscription
function UserDisplay() {
  const profile = useStoreValue(useUserStore('profile'));
  const preferences = useStoreValue(useUserStore('preferences')); // Not used!
  const session = useStoreValue(useUserStore('session')); // Not used!
  const history = useStoreValue(useUserStore('history')); // Not used!
  
  // Component re-renders when ANY of these stores change
  return <span>{profile.name}</span>; // Only uses profile
}
```

### 2. Field-Level Subscriptions

```typescript
// Custom hook for field-level subscriptions
export function useStoreField<T, K extends keyof T>(
  store: Store<T>,
  field: K
): T[K] {
  const [value, setValue] = useState(() => store.getValue()[field]);
  
  useEffect(() => {
    return store.subscribe((newData) => {
      const newValue = newData[field];
      setValue(prevValue => {
        // Only update if the specific field changed
        return Object.is(prevValue, newValue) ? prevValue : newValue;
      });
    });
  }, [store, field]);
  
  return value;
}

// Usage: Only re-renders when email field changes
function UserEmail() {
  const profileStore = useUserStore('profile');
  const email = useStoreField(profileStore, 'email'); // Field-level subscription
  
  return <span>{email}</span>;
}
```

### 3. Debounced Updates

```typescript
// Debounce rapid store updates
export function useDebouncedStore<T>(
  store: Store<T>,
  delay: number = 300
): T {
  const [debouncedValue, setDebouncedValue] = useState(store.getValue());
  
  useEffect(() => {
    return store.subscribe((newValue) => {
      const timer = setTimeout(() => {
        setDebouncedValue(newValue);
      }, delay);
      
      return () => clearTimeout(timer);
    });
  }, [store, delay]);
  
  return debouncedValue;
}

// Usage: Expensive operations only run after user stops typing
function ExpensiveUserAnalytics() {
  const profileStore = useUserStore('profile');
  const debouncedProfile = useDebouncedStore(profileStore, 500);
  
  const analytics = useMemo(() => {
    // Expensive computation only runs after 500ms of no changes
    return computeExpensiveAnalytics(debouncedProfile);
  }, [debouncedProfile]);
  
  return <div>{analytics.summary}</div>;
}
```

## React Performance Optimization

### 1. Component Memoization

```typescript
// Optimize components with React.memo
const UserName = React.memo(function UserName() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  // Only re-renders when profile changes
  return <span>{profile.name}</span>;
});

const UserAvatar = React.memo(function UserAvatar() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  // Memoize expensive avatar rendering
  return useMemo(() => (
    <img 
      src={profile.avatarUrl || '/default-avatar.png'} 
      alt={profile.name}
      onLoad={handleImageLoad} // Expensive operation
    />
  ), [profile.avatarUrl, profile.name]);
});
```

### 2. Custom Hook Optimization

```typescript
// Optimize custom hooks with proper dependencies
export function useUserProfile() {
  const profileStore = useUserStore('profile');
  const preferencesStore = useUserStore('preferences');
  
  const profile = useStoreValue(profileStore);
  const preferences = useStoreValue(preferencesStore);
  const dispatch = useUserAction();
  
  // Memoize computed values
  const displayName = useMemo(() => {
    return profile.name || profile.email || 'Anonymous User';
  }, [profile.name, profile.email]);
  
  const isComplete = useMemo(() => {
    return Boolean(profile.name && profile.email && profile.phone);
  }, [profile.name, profile.email, profile.phone]);
  
  // Memoize action functions
  const updateProfile = useCallback(async (data: Partial<UserProfile>) => {
    return await dispatch('updateProfile', { data });
  }, [dispatch]);
  
  const updatePreferences = useCallback(async (data: Partial<UserPreferences>) => {
    return await dispatch('updatePreferences', { data });
  }, [dispatch]);
  
  return useMemo(() => ({
    // State
    profile,
    preferences,
    displayName,
    isComplete,
    
    // Actions
    updateProfile,
    updatePreferences
  }), [profile, preferences, displayName, isComplete, updateProfile, updatePreferences]);
}
```

### 3. Lazy Loading and Code Splitting

```typescript
// Lazy load expensive components
const ExpensiveUserDashboard = React.lazy(() => 
  import('./components/ExpensiveUserDashboard')
);

function UserApp() {
  const [showDashboard, setShowDashboard] = useState(false);
  
  return (
    <div>
      <UserProfile />
      
      {showDashboard && (
        <React.Suspense fallback={<div>Loading dashboard...</div>}>
          <ExpensiveUserDashboard />
        </React.Suspense>
      )}
      
      <button onClick={() => setShowDashboard(true)}>
        Load Dashboard
      </button>
    </div>
  );
}

// Lazy load handlers for large applications
const loadUserHandlers = () => import('./handlers/userHandlers');

function useConditionalUserHandlers(shouldLoad: boolean) {
  const [handlersLoaded, setHandlersLoaded] = useState(false);
  
  useEffect(() => {
    if (shouldLoad && !handlersLoaded) {
      loadUserHandlers().then(module => {
        module.setupUserHandlers();
        setHandlersLoaded(true);
      });
    }
  }, [shouldLoad, handlersLoaded]);
}
```

## Memory Management

### 1. Handler Cleanup

```typescript
// Proper cleanup prevents memory leaks
function useUserHandlers() {
  const addHandler = useUserActionHandler();
  
  useEffect(() => {
    if (!addHandler) return;
    
    const unregisterFunctions: Array<() => void> = [];
    
    // Register multiple handlers
    unregisterFunctions.push(
      register('updateProfile', updateHandler, { id: 'update' })
    );
    unregisterFunctions.push(
      register('deleteProfile', deleteHandler, { id: 'delete' })
    );
    unregisterFunctions.push(
      register('validateProfile', validateHandler, { id: 'validate' })
    );
    
    // Critical: Clean up all handlers on unmount
    return () => {
      unregisterFunctions.forEach(unregister => unregister?.());
    };
  }, [register]);
}
```

### 2. Store Cleanup

```typescript
// Clean up store subscriptions
export function useStoreValue<T>(store: Store<T>): T {
  const [value, setValue] = useState(() => store.getValue());
  
  useEffect(() => {
    const unsubscribe = store.subscribe(setValue);
    return unsubscribe; // Cleanup subscription
  }, [store]);
  
  return value;
}

// Cleanup in custom hooks
export function useUserData() {
  const profileStore = useUserStore('profile');
  const [userData, setUserData] = useState(null);
  
  useEffect(() => {
    const unsubscribe = profileStore.subscribe((profile) => {
      setUserData(processUserData(profile)); // Expensive processing
    });
    
    return () => {
      unsubscribe();
      setUserData(null); // Clear processed data
    };
  }, [profileStore]);
  
  return userData;
}
```

### 3. Event Listener Cleanup

```typescript
// Clean up event listeners and timers
function useAutoSave() {
  const dispatch = useUserAction();
  const profileStore = useUserStore('profile');
  
  useEffect(() => {
    let timeoutId: NodeJS.Timeout;
    
    const unsubscribe = profileStore.subscribe((profile) => {
      // Clear previous timeout
      clearTimeout(timeoutId);
      
      // Auto-save after 2 seconds of inactivity
      timeoutId = setTimeout(() => {
        dispatch('autoSave', { data: profile });
      }, 2000);
    });
    
    return () => {
      clearTimeout(timeoutId); // Clear timeout
      unsubscribe(); // Clean up subscription
    };
  }, [dispatch, profileStore]);
}
```

## Bundle Size Optimization

### 1. Tree Shaking

```typescript
// Import only what you need for better tree shaking
import { createDeclarativeStores } from '@context-action/react';
import { useStoreValue } from '@context-action/react';

// ❌ Avoid importing entire modules
// import * as ContextAction from '@context-action/react';

// ✅ Import specific functions
import { 
  createDeclarativeStores,
  createActionContext,
  useStoreValue 
} from '@context-action/react';
```

### 2. Dynamic Imports

```typescript
// Dynamic imports for optional features
async function loadAdvancedFeatures() {
  if (shouldLoadAdvancedFeatures()) {
    const { setupAdvancedHandlers } = await import('./advancedHandlers');
    const { createAdvancedStores } = await import('./advancedStores');
    
    setupAdvancedHandlers();
    return createAdvancedStores();
  }
  
  return null;
}

// Conditional feature loading
function useAdvancedUserFeatures(enabled: boolean) {
  const [features, setFeatures] = useState(null);
  
  useEffect(() => {
    if (enabled) {
      loadAdvancedFeatures().then(setFeatures);
    }
  }, [enabled]);
  
  return features;
}
```

## Performance Monitoring

### 1. Performance Metrics

```typescript
// Monitor handler performance
function createPerformanceHandler<T extends any[], R>(
  name: string,
  handler: (...args: T) => Promise<R>
) {
  return async (...args: T): Promise<R> => {
    const start = performance.now();
    
    try {
      const result = await handler(...args);
      
      const duration = performance.now() - start;
      console.log(`Handler ${name} took ${duration.toFixed(2)}ms`);
      
      // Report to monitoring service
      reportPerformance(name, duration);
      
      return result;
    } catch (error) {
      const duration = performance.now() - start;
      console.error(`Handler ${name} failed after ${duration.toFixed(2)}ms:`, error);
      
      reportError(name, error, duration);
      throw error;
    }
  };
}

// Usage
const monitoredUpdateHandler = createPerformanceHandler(
  'updateProfile',
  async (payload, controller) => {
    // Handler logic
  }
);
```

### 2. Store Performance Tracking

```typescript
// Monitor store update frequency
function createMonitoredStore<T>(name: string, initialValue: T) {
  const store = createStore(initialValue);
  let updateCount = 0;
  let lastUpdate = Date.now();
  
  const originalSetValue = store.setValue;
  store.setValue = (newValue: T) => {
    updateCount++;
    const now = Date.now();
    const timeSinceLastUpdate = now - lastUpdate;
    
    console.log(`Store ${name} update #${updateCount} (${timeSinceLastUpdate}ms since last)`);
    
    if (timeSinceLastUpdate < 100) {
      console.warn(`Store ${name} updating too frequently!`);
    }
    
    lastUpdate = now;
    return originalSetValue(newValue);
  };
  
  return store;
}
```

## Performance Best Practices

### ✅ Do

- **Use `useCallback` for stable handler references**
- **Subscribe only to stores you actually use**
- **Clean up handlers and subscriptions on unmount**
- **Memoize expensive computations with `useMemo`**
- **Use React.memo for pure components**
- **Implement lazy loading for large features**
- **Monitor performance in production**

### ❌ Don't

- **Create new handler functions on every render**
- **Subscribe to unnecessary stores**
- **Forget cleanup functions**
- **Perform expensive operations in render**
- **Use stale closures in handlers**
- **Over-optimize without measuring**

---

## Summary

Context-Action performance optimization focuses on:

- **Efficient Handler Management**: Stable references and proper cleanup
- **Smart Subscriptions**: Only subscribe to what you need
- **Memory Management**: Clean up resources to prevent leaks
- **React Optimization**: Memoization and selective re-rendering
- **Bundle Optimization**: Tree shaking and dynamic imports
- **Performance Monitoring**: Track and improve performance metrics

Follow these patterns to build fast, efficient applications that scale well with complexity.

---

::: tip Next Steps
- Learn [Error Handling Patterns](./error-handling) for robust error management
- Explore [Testing Strategies](./testing) for performance testing approaches
- See [Memory Management](./memory-management) for advanced memory optimization
:::

---


# Guide Philosophy

**Source**: `guide/philosophy.md`  
**Priority**: 80 (essential)  

# Design Philosophy

The Context-Action framework is built on foundational principles that guide every architectural decision and implementation pattern. Understanding these principles is essential for effective usage.

## Core Philosophy

**"Evidence-based architecture with type-safe domain isolation"**

The framework implements a clean separation of concerns through an MVVM-inspired pattern, where:

- **Actions** handle business logic (ViewModel layer)
- **Context Store Pattern** manages state with domain isolation (Model layer)  
- **Components** render UI (View layer)
- **Context Boundaries** isolate functional domains
- **Type-Safe Integration** through domain-specific hooks

## Fundamental Principles

### 1. Domain Isolation First

Each functional domain maintains complete independence through context boundaries:

```typescript
// Each domain has its own isolated context
const UserDomain = createContextStorePattern('User');
const CartDomain = createContextStorePattern('Cart');
const OrderDomain = createContextStorePattern('Order');
```

**Benefits:**
- No accidental state coupling between domains
- Teams can work independently on different domains
- Easier testing and debugging
- Scalable architecture for large applications

### 2. Type Safety at Every Layer

Full TypeScript integration ensures compile-time safety:

```typescript
// Domain-specific interfaces
interface UserData {
  profile: { id: string; name: string; email: string };
  preferences: { theme: 'light' | 'dark' };
}

interface UserActions {
  updateProfile: { data: Partial<UserData['profile']> };
  toggleTheme: void;
}

// Type-safe hooks automatically inferred
const profileStore = useUserStore('profile'); // Typed as Store<UserData['profile']>
const dispatch = useUserAction(); // Typed dispatch for UserActions
```

### 3. Declarative Action Pipeline

Business logic flows through a declarative pipeline system:

```typescript
// Declare what should happen, not how
dispatch('updateProfile', { data: { name: 'New Name' } });

// Framework handles the "how":
// 1. Action validation
// 2. Handler execution by priority
// 3. Store updates
// 4. Component re-renders
```

### 4. Reactive State Management

Components automatically react to relevant state changes:

```typescript
function UserProfile() {
  const profile = useStoreValue(useUserStore('profile'));
  // ↑ Component re-renders only when profile changes
  
  return <div>Welcome, {profile.name}!</div>;
}
```

## Architecture Patterns

### MVVM-Inspired Separation

```mermaid
graph TD
    V[View Layer<br/>React Components] --> VM[ViewModel Layer<br/>Action Handlers]
    VM --> M[Model Layer<br/>Store System]
    M --> V
    
    subgraph "Domain Boundary"
        VM
        M
    end
```

### Context Store Pattern

The core pattern for domain isolation:

```typescript
// 1. Create domain context
const UserStores = createContextStorePattern('User');

// 2. Provide context boundary
<UserStores.Provider registryId="user-app">
  <UserComponents />
</UserStores.Provider>

// 3. Use within boundary
const userStore = UserStores.useStore('profile', initialData);
```

## Design Decisions

### Why Domain-Specific Hooks?

**Traditional Approach (Generic):**
```typescript
const store = useStore('user-profile'); // No type information
const dispatch = useDispatch(); // No action type safety
```

**Context-Action Approach (Domain-Specific):**
```typescript
const store = useUserStore('profile'); // Fully typed
const dispatch = useUserAction(); // Type-safe actions
```

**Benefits:**
- Full TypeScript inference
- Clear domain boundaries
- Refactoring safety
- Better developer experience

### Why Action Pipeline Over Direct State Updates?

**Direct Updates (Anti-Pattern):**
```typescript
// Scattered business logic
function updateUser() {
  setUser(prev => ({ ...prev, name: 'New Name' }));
  logActivity('user_updated');
  validateUser();
  syncToServer();
}
```

**Action Pipeline (Recommended):**
```typescript
// Centralized, testable business logic
dispatch('updateUser', { name: 'New Name' });

// Handlers manage complexity:
register('updateUser', async (payload, controller) => {
  const userStore = registry.getStore('user');
  // Update, log, validate, sync - all in one place
});
```

**Benefits:**
- Centralized business logic
- Testable handlers
- Consistent error handling
- Auditable action flow

## Performance Philosophy

### Minimal Re-renders

Only components using changed data re-render:

```typescript
// Component A uses profile
const profile = useStoreValue(useUserStore('profile'));

// Component B uses preferences  
const prefs = useStoreValue(useUserStore('preferences'));

// Updating profile won't re-render Component B
dispatch('updateProfile', { name: 'New Name' });
```

### Lazy Evaluation in Handlers

Avoid stale closures with lazy store access:

```typescript
const handler = async (payload, controller) => {
  // ❌ Stale: captured at registration time
  const oldValue = profileStore.getValue();
  
  // ✅ Fresh: evaluated at execution time
  const currentValue = registry.getStore('profile').getValue();
};
```

## Developer Experience Priorities

### 1. Type Safety Without Ceremony

```typescript
// Automatic inference, no manual typing needed
const store = useUserStore('profile'); // Store<UserProfile>
const profile = useStoreValue(store); // UserProfile
```

### 2. Intuitive API Design

```typescript
// Natural, React-like patterns
const dispatch = useUserAction();
dispatch('updateProfile', { name: 'New Name' });
```

### 3. Clear Error Messages

```typescript
// Compile-time errors guide correct usage
dispatch('invalidAction', { data: 'wrong' }); 
// TS Error: 'invalidAction' does not exist in UserActions
```

### 4. Flexible Integration

```typescript
// Works with existing React patterns
function useUserProfile() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  const dispatch = useUserAction();
  
  // Compose with other hooks naturally
  const memoizedData = useMemo(() => 
    processProfile(profile), [profile]
  );
  
  return { profile, memoizedData, dispatch };
}
```

## Architectural Benefits

### Scalability

- **Horizontal:** Add new domains without affecting existing ones
- **Vertical:** Add features within domains without cross-contamination
- **Team:** Multiple teams can work on different domains independently

### Maintainability

- **Clear Boundaries:** Domain isolation prevents unexpected dependencies
- **Testability:** Business logic in handlers is easily unit tested
- **Debuggability:** Action flow is auditable and traceable

### Performance

- **Selective Re-renders:** Only affected components update
- **Lazy Loading:** Domains can be loaded on demand
- **Memory Efficiency:** Context boundaries prevent memory leaks

---

## Summary

The Context-Action framework's philosophy centers on **type-safe domain isolation** with **reactive state management**. By following MVVM-inspired patterns and declarative action pipelines, applications become more maintainable, testable, and scalable.

The framework prioritizes developer experience through automatic type inference, intuitive APIs, and clear architectural boundaries that guide correct usage patterns.

---

::: tip Next Steps
Now that you understand the philosophy, explore the [Core Concepts](./concepts) to see how these principles translate into practical implementation patterns.
:::

---


# Guide Provider Composition

**Source**: `guide/provider-composition.md`  
**Priority**: 80 (essential)  

# Provider Composition

Learn how to compose providers effectively for clean architecture, proper context boundaries, and optimal performance in Context-Action applications.

## Provider Architecture Overview

Provider composition creates isolated context boundaries for different domains:

```typescript
// Basic provider structure
<StoreProvider>          {/* State context */}
  <ActionProvider>       {/* Action context */}
    <HandlerSetup />     {/* Handler registration */}
    <Components />       {/* Application components */}
  </ActionProvider>
</StoreProvider>
```

## Single Domain Provider Pattern

### Basic Domain Provider

```typescript
// providers/CounterProvider.tsx
import React from 'react';
import { 
  CounterProvider,
  CounterActionProvider
} from '../stores/counter.store';
import { useCounterHandlers } from '../hooks/useCounterHandlers';

function CounterHandlersSetup() {
  useCounterHandlers();
  return null;
}

export function CounterDomainProvider({ 
  children 
}: { 
  children: React.ReactNode 
}) {
  return (
    <CounterProvider>
      <CounterActionProvider>
        <CounterHandlersSetup />
        {children}
      </CounterActionProvider>
    </CounterProvider>
  );
}

// Usage
function App() {
  return (
    <CounterDomainProvider>
      <CounterApp />
    </CounterDomainProvider>
  );
}
```

## Multi-Domain Provider Composition

### Nested Provider Pattern

```typescript
// providers/AppProvider.tsx
import React from 'react';
import { 
  UserBusinessProvider,
  UserBusinessActionProvider,
  UserUIProvider,
  UserUIActionProvider
} from '../stores/user';
import {
  CartProvider,
  CartActionProvider
} from '../stores/cart';
import {
  OrderProvider,
  OrderActionProvider
} from '../stores/order';

// Individual domain provider
function UserDomainProvider({ children }: { children: React.ReactNode }) {
  return (
    <UserBusinessProvider>
      <UserUIProvider>
        <UserBusinessActionProvider>
          <UserUIActionProvider>
            <UserHandlersSetup />
            {children}
          </UserUIActionProvider>
        </UserBusinessActionProvider>
      </UserUIProvider>
    </UserBusinessProvider>
  );
}

function CartDomainProvider({ children }: { children: React.ReactNode }) {
  return (
    <CartProvider>
      <CartActionProvider>
        <CartHandlersSetup />
        {children}
      </CartActionProvider>
    </CartProvider>
  );
}

function OrderDomainProvider({ children }: { children: React.ReactNode }) {
  return (
    <OrderProvider>
      <OrderActionProvider>
        <OrderHandlersSetup />
        {children}
      </OrderActionProvider>
    </OrderProvider>
  );
}

// Application-wide provider composition
export function AppProvider({ children }: { children: React.ReactNode }) {
  return (
    <UserDomainProvider>
      <CartDomainProvider>
        <OrderDomainProvider>
          {children}
        </OrderDomainProvider>
      </CartDomainProvider>
    </UserDomainProvider>
  );
}
```

### Handler Setup Components

```typescript
// handlers/index.tsx
import { useUserBusinessHandlers } from './useUserBusinessHandlers';
import { useUserUIHandlers } from './useUserUIHandlers';
import { useCartHandlers } from './useCartHandlers';
import { useOrderHandlers } from './useOrderHandlers';

function UserHandlersSetup() {
  useUserBusinessHandlers();
  useUserUIHandlers();
  return null;
}

function CartHandlersSetup() {
  useCartHandlers();
  return null;
}

function OrderHandlersSetup() {
  useOrderHandlers();
  return null;
}

export {
  UserHandlersSetup,
  CartHandlersSetup,
  OrderHandlersSetup
};
```

## HOC Pattern for Self-Contained Components

### Context Store Pattern with HOC

```typescript
// patterns/withUserDomain.tsx
import React from 'react';
import { createContextStorePattern } from '@context-action/react';
import { UserActionProvider } from '../stores/user.store';
import { useUserHandlers } from '../hooks/useUserHandlers';

// Create isolated store pattern
const UserStores = createContextStorePattern('User');

// HOC for complete domain encapsulation
export const withUserDomain = UserStores.withCustomProvider(
  ({ children }) => (
    <UserActionProvider>
      <UserHandlerSetup />
      {children}
    </UserActionProvider>
  ),
  'user-domain'
);

function UserHandlerSetup() {
  useUserHandlers();
  return null;
}

// Usage - completely self-contained
const UserModule = withUserDomain(() => {
  const userStore = UserStores.useStore('profile', {
    id: '',
    name: '',
    email: ''
  });
  
  const profile = useStoreValue(userStore);
  const dispatch = useUserAction();
  
  return (
    <div>
      <h1>User: {profile.name}</h1>
      <button onClick={() => dispatch('updateProfile', { data: { name: 'New Name' } })}>
        Update
      </button>
    </div>
  );
});

// No provider setup needed - completely isolated
function App() {
  return (
    <div>
      <UserModule /> {/* Self-contained with all providers */}
    </div>
  );
}
```

### Multi-Provider HOC

```typescript
// patterns/withMultiDomains.tsx
export function withMultipleDomains<P extends object>(
  Component: React.ComponentType<P>,
  domains: string[]
) {
  return function WrappedComponent(props: P) {
    const providers = domains.map(domain => {
      switch (domain) {
        case 'user':
          return UserDomainProvider;
        case 'cart':
          return CartDomainProvider;
        case 'order':
          return OrderDomainProvider;
        default:
          return React.Fragment;
      }
    });
    
    return providers.reduceRight(
      (acc, Provider) => <Provider>{acc}</Provider>,
      <Component {...props} />
    );
  };
}

// Usage
const ECommerceApp = withMultipleDomains(
  ECommerceContent,
  ['user', 'cart', 'order']
);
```

## Provider Scope and Isolation

### Multiple Provider Instances

```typescript
// Different provider scopes = different store instances
function MultiUserApp() {
  return (
    <div>
      <UserProvider> {/* Scope 1 - Admin User */}
        <h2>Admin Section</h2>
        <AdminUserComponent />
      </UserProvider>
      
      <UserProvider> {/* Scope 2 - Regular User */}
        <h2>User Section</h2>
        <RegularUserComponent />
      </UserProvider>
    </div>
  );
}

function AdminUserComponent() {
  const store = useUserStore('profile'); // Instance A
  // Admin-specific logic
  return null;
}

function RegularUserComponent() {
  const store = useUserStore('profile'); // Instance B (different from A)
  // User-specific logic  
  return null;
}
```

### Context Store Pattern for Complete Isolation

```typescript
// Complete isolation with Context Store Pattern
const AdminStores = createContextStorePattern('Admin');
const UserStores = createContextStorePattern('User');

function IsolatedMultiUserApp() {
  return (
    <div>
      <AdminStores.Provider registryId="admin-section">
        <AdminSection />
      </AdminStores.Provider>
      
      <UserStores.Provider registryId="user-section">
        <UserSection />
      </UserStores.Provider>
    </div>
  );
}

function AdminSection() {
  const adminStore = AdminStores.useStore('profile', adminDefaults);
  // Completely isolated admin logic
  return <div>Admin Interface</div>;
}

function UserSection() {
  const userStore = UserStores.useStore('profile', userDefaults);
  // Completely isolated user logic
  return <div>User Interface</div>;
}
```

## Performance Optimizations

### Lazy Provider Loading

```typescript
// Lazy load providers based on conditions
function ConditionalProviders({ children, userRole }: { 
  children: React.ReactNode;
  userRole: string;
}) {
  // Only load admin provider for admin users
  if (userRole === 'admin') {
    return (
      <AdminProvider>
        <UserProvider>
          {children}
        </UserProvider>
      </AdminProvider>
    );
  }
  
  // Regular user only gets user provider
  return (
    <UserProvider>
      {children}
    </UserProvider>
  );
}
```

### Provider Memoization

```typescript
// Memoize expensive provider setups
const MemoizedUserProvider = React.memo(function UserProvider({ 
  children,
  userId 
}: { 
  children: React.ReactNode;
  userId: string;
}) {
  return (
    <UserBusinessProvider key={userId}>
      <UserUIProvider>
        <UserBusinessActionProvider>
          <UserUIActionProvider>
            <UserHandlersSetup />
            {children}
          </UserUIActionProvider>
        </UserBusinessActionProvider>
      </UserUIProvider>
    </UserBusinessProvider>
  );
});
```

## Testing Provider Compositions

### Test Provider Utilities

```typescript
// test-utils/createTestProvider.tsx
import React from 'react';
import {
  UserProvider,
  UserActionProvider
} from '../stores/user.store';

interface TestProviderProps {
  children: React.ReactNode;
  initialStores?: Record<string, any>;
  enableHandlers?: boolean;
}

export function createTestProvider({
  initialStores = {},
  enableHandlers = false
}: Partial<TestProviderProps> = {}) {
  return function TestProvider({ children }: { children: React.ReactNode }) {
    return (
      <UserProvider>
        <UserActionProvider>
          {enableHandlers && <UserHandlersSetup />}
          <StoreInitializer initialStores={initialStores} />
          {children}
        </UserActionProvider>
      </UserProvider>
    );
  };
}

function StoreInitializer({ initialStores }: { initialStores: Record<string, any> }) {
  const registry = useUserRegistry();
  
  React.useEffect(() => {
    Object.entries(initialStores).forEach(([storeName, initialValue]) => {
      const store = registry.getStore(storeName);
      store.setValue(initialValue);
    });
  }, [registry, initialStores]);
  
  return null;
}

// Usage in tests
const TestProvider = createTestProvider({
  initialStores: {
    profile: { id: '1', name: 'Test User' }
  },
  enableHandlers: true
});

render(
  <TestProvider>
    <ComponentToTest />
  </TestProvider>
);
```

## Common Provider Patterns

### Environment-Based Providers

```typescript
// Different providers for different environments
function EnvironmentProvider({ children }: { children: React.ReactNode }) {
  if (process.env.NODE_ENV === 'test') {
    return <MockProvider>{children}</MockProvider>;
  }
  
  if (process.env.NODE_ENV === 'development') {
    return (
      <DevToolsProvider>
        <AppProvider>
          {children}
        </AppProvider>
      </DevToolsProvider>
    );
  }
  
  return <AppProvider>{children}</AppProvider>;
}
```

### Error Boundary Integration

```typescript
// Provider with error boundaries
function RobustProvider({ children }: { children: React.ReactNode }) {
  return (
    <ErrorBoundary fallback={<ProviderError />}>
      <UserProvider>
        <ErrorBoundary fallback={<ActionError />}>
          <UserActionProvider>
            <ErrorBoundary fallback={<HandlerError />}>
              <UserHandlersSetup />
              {children}
            </ErrorBoundary>
          </UserActionProvider>
        </ErrorBoundary>
      </UserProvider>
    </ErrorBoundary>
  );
}
```

## Best Practices

### ✅ Do

- **Store providers wrap action providers**
- **Include handler setup components**
- **Use domain-specific provider composition**
- **Isolate unrelated domains**
- **Test provider compositions**

### ❌ Don't

- **Action providers outside store providers**
- **Forget handler setup components**
- **Mix unrelated domains in single provider**
- **Create deeply nested provider trees unnecessarily**
- **Skip cleanup in test providers**

## Troubleshooting

### Common Issues

1. **Actions dispatch but no handlers respond**
   - Missing handler setup component
   - Handler registration after action dispatch

2. **Context not found errors**
   - Wrong provider order (action before store)
   - Component outside provider boundary

3. **Stale store data**
   - Multiple provider instances with different scopes
   - Store accessed outside provider boundary

### Debug Provider Trees

```typescript
// Debug provider tree structure
function ProviderDebugger({ children }: { children: React.ReactNode }) {
  if (process.env.NODE_ENV !== 'development') {
    return <>{children}</>;
  }
  
  return (
    <div>
      <div style={{ background: 'yellow', padding: '2px', fontSize: '10px' }}>
        Provider Boundary: User Domain
      </div>
      {children}
    </div>
  );
}
```

---

## Summary

Provider composition in Context-Action framework enables:

- **Clean Domain Boundaries**: Isolated contexts for different domains
- **Flexible Architecture**: HOCs, nested providers, and context patterns
- **Performance Optimization**: Lazy loading and memoization
- **Testability**: Easy provider mocking and testing utilities
- **Error Resilience**: Error boundaries and graceful degradation

Proper provider composition is essential for scalable, maintainable Context-Action applications.

---

::: tip Next Steps
- Learn [Cross-Domain Integration](./cross-domain-integration) for multi-domain provider coordination
- Explore [Testing Guide](./testing) for comprehensive provider testing strategies
- See [Performance Optimization](./performance) for advanced provider optimization techniques
:::

---


# Guide React Integration

**Source**: `guide/react-integration.md`  
**Priority**: 80 (essential)  

# React Integration

The Context-Action framework provides seamless React integration through the `@context-action/react` package. Learn how to integrate with React patterns, hooks, and component lifecycles.

## Integration Overview

Context-Action integrates with React through:

- **Context API**: For provider-based state isolation
- **Custom Hooks**: For reactive store subscriptions and action dispatching
- **Effect Hooks**: For handler registration and cleanup
- **Component Patterns**: HOCs, render props, and hook-based patterns

## Core React Integration Patterns

### 1. Provider-Based Architecture

```typescript
// providers/AppProvider.tsx
import React from 'react';
import { 
  UserProvider,
  UserActionProvider
} from '../stores/user.store';
import { useUserHandlers } from '../hooks/useUserHandlers';

function UserHandlerSetup() {
  useUserHandlers(); // Register handlers using useEffect
  return null;
}

export function AppProvider({ children }: { children: React.ReactNode }) {
  return (
    <UserProvider>           {/* Store context */}
      <UserActionProvider>   {/* Action context */}
        <UserHandlerSetup />  {/* Handler registration */}
        {children}
      </UserActionProvider>
    </UserProvider>
  );
}
```

### 2. Hook-Based Component Integration

```typescript
// components/UserProfile.tsx
import React, { useState, useCallback } from 'react';
import { useStoreValue } from '@context-action/react';
import { useUserStore, useUserAction } from '../stores/user.store';

export function UserProfile() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore); // Reactive subscription
  const dispatch = useUserAction();
  
  const [editMode, setEditMode] = useState(false);
  const [formData, setFormData] = useState(profile);
  
  // Sync form data when profile changes
  React.useEffect(() => {
    setFormData(profile);
  }, [profile]);
  
  const handleSave = useCallback(async () => {
    try {
      await dispatch('updateProfile', { data: formData });
      setEditMode(false);
    } catch (error) {
      console.error('Save failed:', error);
    }
  }, [dispatch, formData]);
  
  if (editMode) {
    return (
      <form onSubmit={(e) => { e.preventDefault(); handleSave(); }}>
        <input 
          value={formData.name}
          onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
        />
        <button type="submit">Save</button>
        <button type="button" onClick={() => setEditMode(false)}>Cancel</button>
      </form>
    );
  }
  
  return (
    <div>
      <h2>{profile.name}</h2>
      <p>{profile.email}</p>
      <button onClick={() => setEditMode(true)}>Edit</button>
    </div>
  );
}
```

### 3. Custom Hook Patterns

```typescript
// hooks/useUserProfile.ts
import { useMemo, useCallback } from 'react';
import { useStoreValue } from '@context-action/react';
import { useUserStore, useUserAction } from '../stores/user.store';

export function useUserProfile() {
  const profileStore = useUserStore('profile');
  const preferencesStore = useUserStore('preferences');
  
  const profile = useStoreValue(profileStore);
  const preferences = useStoreValue(preferencesStore);
  const dispatch = useUserAction();
  
  // Computed values
  const displayName = useMemo(() => {
    return profile.name || profile.email || 'Anonymous User';
  }, [profile.name, profile.email]);
  
  const isComplete = useMemo(() => {
    return Boolean(profile.name && profile.email);
  }, [profile.name, profile.email]);
  
  // Actions
  const updateProfile = useCallback(async (data: Partial<UserProfile>) => {
    return await dispatch('updateProfile', { data });
  }, [dispatch]);
  
  const updatePreferences = useCallback(async (data: Partial<UserPreferences>) => {
    return await dispatch('updatePreferences', { data });
  }, [dispatch]);
  
  return {
    // State
    profile,
    preferences,
    displayName,
    isComplete,
    
    // Actions
    updateProfile,
    updatePreferences
  };
}
```

## Advanced React Integration Patterns

### 1. HOC Pattern for Self-Contained Components

```typescript
// patterns/withUserDomain.tsx
import React from 'react';
import { createContextStorePattern } from '@context-action/react';
import { UserActionProvider } from '../stores/user.store';
import { useUserHandlers } from '../hooks/useUserHandlers';

// Create isolated store pattern
const UserStores = createContextStorePattern('User');

// HOC for complete domain encapsulation
export const withUserDomain = UserStores.withCustomProvider(
  ({ children }) => (
    <UserActionProvider>
      <UserHandlerSetup />
      {children}
    </UserActionProvider>
  ),
  'user-domain'
);

function UserHandlerSetup() {
  useUserHandlers();
  return null;
}

// Usage - completely self-contained
const UserModule = withUserDomain(() => {
  const userStore = UserStores.useStore('profile', {
    id: '',
    name: '',
    email: ''
  });
  
  const profile = useStoreValue(userStore);
  const dispatch = useUserAction();
  
  return (
    <div>
      <h1>User: {profile.name}</h1>
      <button onClick={() => dispatch('updateProfile', { data: { name: 'New Name' } })}>
        Update
      </button>
    </div>
  );
});

// No provider setup needed - completely isolated
function App() {
  return (
    <div>
      <UserModule /> {/* Self-contained with all providers */}
    </div>
  );
}
```

### 2. Render Props Pattern

```typescript
// patterns/UserDataProvider.tsx
interface UserDataProviderProps {
  children: (data: {
    profile: UserProfile;
    preferences: UserPreferences;
    updateProfile: (data: Partial<UserProfile>) => Promise<void>;
    updatePreferences: (data: Partial<UserPreferences>) => Promise<void>;
  }) => React.ReactNode;
}

export function UserDataProvider({ children }: UserDataProviderProps) {
  const {
    profile,
    preferences,
    updateProfile,
    updatePreferences
  } = useUserProfile();
  
  return (
    <>
      {children({
        profile,
        preferences,
        updateProfile,
        updatePreferences
      })}
    </>
  );
}

// Usage
function UserSettings() {
  return (
    <UserDataProvider>
      {({ profile, preferences, updateProfile, updatePreferences }) => (
        <div>
          <h1>{profile.name}</h1>
          <p>Theme: {preferences.theme}</p>
          <button onClick={() => updatePreferences({ theme: 'dark' })}>
            Dark Mode
          </button>
        </div>
      )}
    </UserDataProvider>
  );
}
```

### 3. Context Store Pattern Integration

```typescript
// components/isolated/UserWidget.tsx
import React from 'react';
import { createContextStorePattern } from '@context-action/react';
import { useStoreValue } from '@context-action/react';

const UserWidgetStores = createContextStorePattern('UserWidget');

// Self-contained widget with isolated state
export function UserWidget() {
  return (
    <UserWidgetStores.Provider registryId="user-widget">
      <UserWidgetContent />
    </UserWidgetStores.Provider>
  );
}

function UserWidgetContent() {
  const userStore = UserWidgetStores.useStore('data', {
    name: 'Guest',
    status: 'offline'
  });
  
  const userData = useStoreValue(userStore);
  
  const updateStatus = () => {
    userStore.setValue({
      ...userData,
      status: userData.status === 'online' ? 'offline' : 'online'
    });
  };
  
  return (
    <div className="user-widget">
      <span>{userData.name}</span>
      <span className={`status ${userData.status}`}>
        {userData.status}
      </span>
      <button onClick={updateStatus}>
        Toggle Status
      </button>
    </div>
  );
}
```

## React Performance Optimizations

### 1. Selective Re-rendering

```typescript
// Optimize with React.memo and selective subscriptions
const UserName = React.memo(function UserName() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  // Component only re-renders when profile changes
  return <span>{profile.name}</span>;
});

const UserAvatar = React.memo(function UserAvatar() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  // Only re-renders when avatar URL changes
  return useMemo(() => (
    <img src={profile.avatarUrl || '/default-avatar.png'} alt={profile.name} />
  ), [profile.avatarUrl, profile.name]);
});
```

### 2. Custom Selective Subscription Hook

```typescript
// hooks/useSelectiveSubscription.ts
export function useStoreField<T, K extends keyof T>(
  store: Store<T>,
  field: K
): T[K] {
  const [value, setValue] = React.useState(() => store.getValue()[field]);
  
  React.useEffect(() => {
    return store.subscribe((newData) => {
      const newValue = newData[field];
      setValue(prevValue => {
        // Only update if the specific field changed
        return Object.is(prevValue, newValue) ? prevValue : newValue;
      });
    });
  }, [store, field]);
  
  return value;
}

// Usage - only re-renders when specific field changes
function UserEmail() {
  const profileStore = useUserStore('profile');
  const email = useStoreField(profileStore, 'email'); // Only email changes trigger re-render
  
  return <span>{email}</span>;
}
```

### 3. Debounced Store Updates

```typescript
// hooks/useDebouncedStore.ts
export function useDebouncedStore<T>(
  store: Store<T>,
  delay: number = 300
): T {
  const [debouncedValue, setDebouncedValue] = React.useState(store.getValue());
  
  React.useEffect(() => {
    return store.subscribe((newValue) => {
      const timer = setTimeout(() => {
        setDebouncedValue(newValue);
      }, delay);
      
      return () => clearTimeout(timer);
    });
  }, [store, delay]);
  
  return debouncedValue;
}

// Usage - debounced updates for expensive operations
function ExpensiveUserAnalytics() {
  const profileStore = useUserStore('profile');
  const debouncedProfile = useDebouncedStore(profileStore, 500);
  
  const analytics = useMemo(() => {
    // Expensive computation only runs after 500ms of no changes
    return computeExpensiveAnalytics(debouncedProfile);
  }, [debouncedProfile]);
  
  return <div>{analytics.summary}</div>;
}
```

## React Development Tools Integration

### 1. DevTools Support

```typescript
// Enable React DevTools integration
import { enableDevTools } from '@context-action/react';

if (process.env.NODE_ENV === 'development') {
  enableDevTools({
    logStateChanges: true,
    logActionDispatches: true,
    showComponentUpdates: true
  });
}
```

### 2. Debug Components

```typescript
// components/debug/StoreDebugger.tsx
export function StoreDebugger({ storeName }: { storeName: string }) {
  const registry = useUserRegistry();
  const [debugInfo, setDebugInfo] = React.useState<any>(null);
  
  React.useEffect(() => {
    if (process.env.NODE_ENV !== 'development') return;
    
    const store = registry.getStore(storeName);
    
    const unsubscribe = store.subscribe((newValue) => {
      setDebugInfo({
        storeName,
        value: newValue,
        timestamp: Date.now(),
        subscribers: store.getSubscriberCount?.() || 'unknown'
      });
    });
    
    return unsubscribe;
  }, [registry, storeName]);
  
  if (process.env.NODE_ENV !== 'development') return null;
  
  return (
    <div style={{ 
      position: 'fixed', 
      top: 0, 
      right: 0, 
      background: 'rgba(0,0,0,0.8)', 
      color: 'white',
      padding: '10px',
      fontSize: '12px'
    }}>
      <h4>Store Debug: {storeName}</h4>
      <pre>{JSON.stringify(debugInfo, null, 2)}</pre>
    </div>
  );
}
```

## React 18+ Features

### 1. Concurrent Features Support

```typescript
// Automatic support for React 18 concurrent features
import { startTransition } from 'react';

function useOptimizedUpdates() {
  const dispatch = useUserAction();
  
  const updateWithTransition = useCallback((data: any) => {
    startTransition(() => {
      // Non-urgent update wrapped in transition
      dispatch('updateProfile', { data });
    });
  }, [dispatch]);
  
  return { updateWithTransition };
}
```

### 2. Suspense Integration

```typescript
// Suspense-compatible data fetching
function UserProfileSuspense() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  // Throw promise for Suspense if profile is loading
  if (profile.isLoading) {
    throw profile.loadingPromise;
  }
  
  return <div>{profile.name}</div>;
}

// Usage with Suspense
function App() {
  return (
    <React.Suspense fallback={<div>Loading user...</div>}>
      <UserProfileSuspense />
    </React.Suspense>
  );
}
```

## Testing React Integration

### 1. Component Testing

```typescript
// __tests__/UserProfile.test.tsx
import { render, fireEvent, waitFor } from '@testing-library/react';
import { UserProfile } from '../components/UserProfile';
import { createTestProvider } from '../test-utils';

describe('UserProfile', () => {
  it('should update profile on form submission', async () => {
    const TestProvider = createTestProvider({
      initialStores: {
        profile: { id: '1', name: 'John', email: 'john@test.com' }
      }
    });
    
    const { getByLabelText, getByText } = render(
      <TestProvider>
        <UserProfile />
      </TestProvider>
    );
    
    // Edit mode
    fireEvent.click(getByText('Edit'));
    
    // Update name
    const nameInput = getByLabelText('Name');
    fireEvent.change(nameInput, { target: { value: 'Jane' } });
    
    // Save
    fireEvent.click(getByText('Save'));
    
    // Verify update
    await waitFor(() => {
      expect(getByText('Jane')).toBeInTheDocument();
    });
  });
});
```

### 2. Hook Testing

```typescript
// __tests__/useUserProfile.test.tsx
import { renderHook, act } from '@testing-library/react';
import { useUserProfile } from '../hooks/useUserProfile';
import { createTestProvider } from '../test-utils';

describe('useUserProfile', () => {
  it('should return profile data and update functions', async () => {
    const TestProvider = createTestProvider({
      initialStores: {
        profile: { id: '1', name: 'John', email: 'john@test.com' }
      }
    });
    
    const { result } = renderHook(() => useUserProfile(), {
      wrapper: TestProvider
    });
    
    expect(result.current.profile.name).toBe('John');
    expect(result.current.displayName).toBe('John');
    
    // Test update
    await act(async () => {
      await result.current.updateProfile({ name: 'Jane' });
    });
    
    expect(result.current.profile.name).toBe('Jane');
  });
});
```

---

## Summary

React integration with Context-Action provides:

- **Seamless Hooks Integration**: Native React hooks for stores and actions
- **Provider-Based Architecture**: Clean context boundaries with React Context API
- **Performance Optimizations**: Selective subscriptions and React.memo compatibility
- **Advanced Patterns**: HOCs, render props, and isolated components
- **Development Tools**: DevTools integration and debugging components
- **Modern React Support**: Concurrent features and Suspense compatibility

The framework leverages React's strengths while providing type-safe, scalable state management with clear architectural boundaries.

---

::: tip Next Steps
- Explore [Jotai Integration](./jotai-integration) for atom-based state management
- Learn [Performance Optimization](./performance) for large-scale React applications
- See [Testing Strategies](./testing) for comprehensive testing approaches
:::

---


# Guide Setup Usage

**Source**: `guide/setup-usage.md`  
**Priority**: 80 (essential)  

# Setup & Usage

This guide covers the detailed setup and usage patterns for the Context-Action framework. Learn how to properly configure your domains, providers, and implement best practices.

## Installation & Setup

### Package Installation

```bash
# Core packages (required)
npm install @context-action/core @context-action/react

# Optional integrations
npm install @context-action/jotai  # For Jotai integration
npm install @context-action/logger # For enhanced logging
```

### TypeScript Configuration

Ensure your `tsconfig.json` has strict type checking enabled:

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitReturns": true,
    "noImplicitThis": true
  }
}
```

## Domain Setup Patterns

### 1. Basic Domain Setup

Start with a simple domain structure:

```typescript
// stores/counter.store.ts
import { createDeclarativeStores, createActionContext } from '@context-action/react';

// Define your domain data
export interface CounterData {
  count: { value: number; step: number };
  history: { actions: string[]; timestamps: number[] };
}

// Define your domain actions
export interface CounterActions {
  increment: void;
  decrement: void;
  setStep: { step: number };
  reset: void;
}

// Create domain-specific store hooks
export const {
  Provider: CounterProvider,
  useStore: useCounterStore,
  useRegistry: useCounterRegistry
} = createDeclarativeStores<CounterData>('Counter', {
  count: { 
    initialValue: { value: 0, step: 1 }
  },
  history: { 
    initialValue: { actions: [], timestamps: [] }
  }
});

// Create domain-specific action hooks
export const {
  Provider: CounterActionProvider,
  useAction: useCounterAction,
  useActionRegister: useCounterActionRegister
} = createActionContext<CounterActions>({ 
  name: 'CounterAction' 
});
```

### 2. Multi-Layer Domain Setup

Separate business logic from UI state:

```typescript
// stores/user/userBusiness.store.ts
export interface UserBusinessData {
  profile: { id: string; name: string; email: string };
  session: { token: string; expiresAt: number };
}

export interface UserBusinessActions {
  login: { email: string; password: string };
  logout: void;
  updateProfile: { data: Partial<UserBusinessData['profile']> };
}

export const {
  Provider: UserBusinessProvider,
  useStore: useUserBusinessStore,
  useRegistry: useUserBusinessRegistry
} = createDeclarativeStores<UserBusinessData>('UserBusiness', {
  // ... store definitions
});

// stores/user/userUI.store.ts  
export interface UserUIState {
  view: { isEditing: boolean; selectedTab: string };
  modal: { isOpen: boolean; type: string | null };
  validation: { errors: Record<string, string> };
}

export interface UserUIActions {
  setEditMode: { editing: boolean };
  openModal: { type: string; data?: any };
  closeModal: void;
}

export const {
  Provider: UserUIProvider,
  useStore: useUserUIStore
} = createDeclarativeStores<UserUIState>('UserUI', {
  // ... UI state definitions
});
```

## Provider Composition Patterns

### 1. Single Domain Provider

```typescript
// providers/CounterProvider.tsx
import React from 'react';
import { 
  CounterProvider,
  CounterActionProvider
} from '../stores/counter.store';
import { useCounterHandlers } from '../hooks/useCounterHandlers';

function CounterHandlersSetup() {
  useCounterHandlers();
  return null;
}

export function CounterDomainProvider({ 
  children 
}: { 
  children: React.ReactNode 
}) {
  return (
    <CounterProvider>
      <CounterActionProvider>
        <CounterHandlersSetup />
        {children}
      </CounterActionProvider>
    </CounterProvider>
  );
}
```

### 2. Multi-Domain Provider Composition

```typescript
// providers/AppProvider.tsx
import React from 'react';
import { 
  UserBusinessProvider,
  UserBusinessActionProvider,
  UserUIProvider,
  UserUIActionProvider
} from '../stores/user';
import {
  CartProvider,
  CartActionProvider
} from '../stores/cart';

// Individual domain provider
function UserDomainProvider({ children }: { children: React.ReactNode }) {
  return (
    <UserBusinessProvider>
      <UserUIProvider>
        <UserBusinessActionProvider>
          <UserUIActionProvider>
            <UserHandlersSetup />
            {children}
          </UserUIActionProvider>
        </UserBusinessActionProvider>
      </UserUIProvider>
    </UserBusinessProvider>
  );
}

// Application-wide provider composition
export function AppProvider({ children }: { children: React.ReactNode }) {
  return (
    <UserDomainProvider>
      <CartDomainProvider>
        <OrderDomainProvider>
          {children}
        </OrderDomainProvider>
      </CartDomainProvider>
    </UserDomainProvider>
  );
}
```

### 3. HOC Pattern for Self-Contained Components

```typescript
// Higher-order component approach
const UserStores = createContextStorePattern('User');

export const withUserDomain = UserStores.withCustomProvider(
  ({ children }) => (
    <UserActionProvider>
      <UserHandlersSetup />
      {children}
    </UserActionProvider>
  ),
  'user-domain'
);

// Usage - completely self-contained
const UserModule = withUserDomain(() => {
  const userStore = UserStores.useStore('profile', initialData);
  const dispatch = useUserAction();
  
  return <UserInterface />;
});

// No manual provider setup needed
function App() {
  return (
    <div>
      <UserModule />  {/* Self-contained with providers */}
    </div>
  );
}
```

## Handler Implementation Patterns

### 1. Basic Handler Setup

```typescript
// hooks/useCounterHandlers.ts
import { useEffect, useCallback } from 'react';
import { 
  useCounterActionRegister,
  useCounterRegistry
} from '../stores/counter.store';

export function useCounterHandlers() {
  const register = useCounterActionRegister();
  const registry = useCounterRegistry();
  
  // Increment handler
  const incrementHandler = useCallback(async (payload, controller) => {
    const countStore = registry.getStore('count');
    const historyStore = registry.getStore('history');
    
    const currentCount = countStore.getValue();
    const currentHistory = historyStore.getValue();
    
    // Update count
    countStore.setValue({
      ...currentCount,
      value: currentCount.value + currentCount.step
    });
    
    // Update history
    historyStore.setValue({
      actions: [...currentHistory.actions, 'increment'],
      timestamps: [...currentHistory.timestamps, Date.now()]
    });
    
    return { success: true, newValue: currentCount.value + currentCount.step };
  }, [registry]);
  
  // Register all handlers
  useEffect(() => {
    if (!register) return;
    
    const unregisterIncrement = register('increment', incrementHandler, {
      priority: 100,
      blocking: true,
      id: 'counter-increment'
    });
    
    // Add other handlers...
    
    return () => {
      unregisterIncrement();
      // Cleanup other handlers...
    };
  }, [register, incrementHandler]);
}
```

### 2. Advanced Handler Patterns

```typescript
// hooks/useAdvancedHandlers.ts
export function useAdvancedHandlers() {
  const register = useActionRegister();
  const registry = useRegistry();
  
  // Handler with validation
  const validateAndUpdate = useCallback(async (payload, controller) => {
    // Input validation
    if (!payload.data) {
      controller.abort('Data is required');
      return { success: false, error: 'Missing data' };
    }
    
    // Business rule validation
    const currentState = registry.getStore('state').getValue();
    if (!canPerformAction(currentState, payload)) {
      controller.abort('Action not allowed in current state');
      return { success: false, error: 'Invalid state' };
    }
    
    try {
      // Perform update
      const result = await performUpdate(payload.data);
      
      // Update multiple stores atomically
      const stateStore = registry.getStore('state');
      const historyStore = registry.getStore('history');
      
      stateStore.setValue(result.newState);
      historyStore.setValue({
        ...historyStore.getValue(),
        lastAction: { type: 'update', timestamp: Date.now() }
      });
      
      return { success: true, result };
      
    } catch (error) {
      controller.abort('Update failed', error);
      return { success: false, error: error.message };
    }
  }, [registry]);
  
  // Handler with side effects
  const handlerWithSideEffects = useCallback(async (payload, controller) => {
    const store = registry.getStore('data');
    
    // Main operation
    const result = await mainOperation(payload);
    store.setValue(result);
    
    // Side effects (fire and forget)
    scheduleCleanup(result.id);
    sendAnalytics('operation_completed', { id: result.id });
    
    // Optional: Set result for collection
    controller.setResult(result);
    
    return result;
  }, [registry]);
  
  // Conditional handler execution
  const conditionalHandler = useCallback(async (payload, controller) => {
    const userStore = registry.getStore('user');
    const user = userStore.getValue();
    
    // Skip if user not authenticated
    if (!user.id) {
      return; // Handler completes without error
    }
    
    // Skip if insufficient permissions
    if (!hasPermission(user, payload.requiredPermission)) {
      controller.abort('Insufficient permissions');
      return;
    }
    
    // Continue with authenticated user logic
    await performAuthenticatedAction(payload, user);
  }, [registry]);
  
  // Handler with priority control
  const priorityHandler = useCallback(async (payload, controller) => {
    if (payload.urgent) {
      // Jump to high priority execution
      controller.jumpToPriority(200);
    }
    
    // Regular processing
    await processAction(payload);
  }, []);
}
```

## Component Usage Patterns

### 1. Basic Component Integration

```typescript
// components/Counter.tsx
import React from 'react';
import { useStoreValue } from '@context-action/react';
import { useCounterStore, useCounterAction } from '../stores/counter.store';

export function Counter() {
  const countStore = useCounterStore('count');
  const historyStore = useCounterStore('history');
  
  const count = useStoreValue(countStore);
  const history = useStoreValue(historyStore);
  const dispatch = useCounterAction();
  
  return (
    <div>
      <h2>Count: {count.value}</h2>
      <p>Step: {count.step}</p>
      
      <button onClick={() => dispatch('increment')}>
        +{count.step}
      </button>
      
      <button onClick={() => dispatch('decrement')}>
        -{count.step}
      </button>
      
      <button onClick={() => dispatch('reset')}>
        Reset
      </button>
      
      <div>
        <h3>History</h3>
        {history.actions.map((action, index) => (
          <div key={index}>
            {action} at {new Date(history.timestamps[index]).toLocaleTimeString()}
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 2. Logic Fit Hooks Pattern

```typescript
// hooks/useCounterLogic.ts
export function useCounterLogic() {
  const countStore = useCounterStore('count');
  const historyStore = useCounterStore('history');
  const dispatch = useCounterAction();
  
  const count = useStoreValue(countStore);
  const history = useStoreValue(historyStore);
  
  // Computed values
  const canIncrement = count.value < 100;
  const canDecrement = count.value > 0;
  const totalActions = history.actions.length;
  
  // Methods
  const increment = useCallback(() => {
    if (canIncrement) {
      dispatch('increment');
    }
  }, [canIncrement, dispatch]);
  
  const decrement = useCallback(() => {
    if (canDecrement) {
      dispatch('decrement');
    }
  }, [canDecrement, dispatch]);
  
  const setStep = useCallback((step: number) => {
    if (step > 0 && step <= 10) {
      dispatch('setStep', { step });
    }
  }, [dispatch]);
  
  return {
    // State
    count: count.value,
    step: count.step,
    history: history.actions,
    
    // Computed
    canIncrement,
    canDecrement,
    totalActions,
    
    // Methods
    increment,
    decrement,
    setStep,
    reset: () => dispatch('reset')
  };
}

// Component using logic hook
export function SmartCounter() {
  const {
    count,
    step,
    canIncrement,
    canDecrement,
    increment,
    decrement,
    setStep
  } = useCounterLogic();
  
  return (
    <div>
      <h2>{count}</h2>
      <button onClick={increment} disabled={!canIncrement}>
        +{step}
      </button>
      <button onClick={decrement} disabled={!canDecrement}>
        -{step}
      </button>
    </div>
  );
}
```

### 3. Form Integration Pattern

```typescript
// components/UserForm.tsx
export function UserForm() {
  const profileStore = useUserStore('profile');
  const validationStore = useUserStore('validation');
  const dispatch = useUserAction();
  
  const profile = useStoreValue(profileStore);
  const validation = useStoreValue(validationStore);
  
  const [formData, setFormData] = useState({
    name: profile.name,
    email: profile.email
  });
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    const result = await dispatch('updateProfile', {
      data: formData
    });
    
    if (result?.success) {
      // Handle success
      console.log('Profile updated successfully');
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Name:</label>
        <input
          value={formData.name}
          onChange={(e) => setFormData(prev => ({ 
            ...prev, 
            name: e.target.value 
          }))}
        />
        {validation.errors.name && (
          <span className="error">{validation.errors.name}</span>
        )}
      </div>
      
      <div>
        <label>Email:</label>
        <input
          type="email"
          value={formData.email}
          onChange={(e) => setFormData(prev => ({ 
            ...prev, 
            email: e.target.value 
          }))}
        />
        {validation.errors.email && (
          <span className="error">{validation.errors.email}</span>
        )}
      </div>
      
      <button type="submit">
        Save Profile
      </button>
    </form>
  );
}
```

## Configuration Options

### Store Configuration

```typescript
const {
  Provider,
  useStore,
  useRegistry
} = createDeclarativeStores<MyData>('Domain', {
  storeName: {
    initialValue: defaultValue,
    
    // Optional: Custom store options
    persist: true,           // Persist to localStorage
    serialize: customSerializer,
    deserialize: customDeserializer
  }
});
```

### Action Context Configuration

```typescript
const {
  Provider,
  useAction,
  useActionRegister
} = createActionContext<MyActions>({
  name: 'DomainAction',
  
  // Optional: Default execution options
  defaultOptions: {
    executionMode: 'sequential', // or 'parallel', 'race'
    timeout: 5000,
    retries: 2
  },
  
  // Optional: Custom logging
  logger: customLogger
});
```

---

## Summary

Proper setup and usage of the Context-Action framework involves:

1. **Domain Definition**: Clear interfaces for data and actions
2. **Provider Composition**: Proper nesting and organization
3. **Handler Implementation**: Business logic with proper cleanup
4. **Component Integration**: Reactive subscriptions and type safety
5. **Configuration**: Optional settings for advanced use cases

Following these patterns ensures scalable, maintainable applications with clear architectural boundaries.

---

::: tip Next Steps
- Explore [Store Management](./store-management) for advanced store patterns
- Learn [Action Handlers](./action-handlers) for complex business logic
- See [Full Implementation Guide](./full) for comprehensive examples
:::

---


# Guide Store Management

**Source**: `guide/store-management.md`  
**Priority**: 80 (essential)  

# Store Management

Learn how to effectively manage state in the Context-Action framework. This guide covers store patterns, lifecycle management, and advanced state handling techniques.

## Store System Overview

The Context-Action store system provides type-safe, reactive state management with domain isolation:

```typescript
// Stores are singletons within provider boundaries
const profileStore = useUserStore('profile'); // Always returns same instance
const profile = useStoreValue(profileStore);   // Reactive subscription
```

## Store Creation Patterns

### 1. Basic Store Setup

```typescript
// Define your domain data structure
export interface UserData {
  profile: { 
    id: string; 
    name: string; 
    email: string;
    avatar?: string;
  };
  preferences: { 
    theme: 'light' | 'dark';
    language: string;
    notifications: {
      email: boolean;
      push: boolean;
      sms: boolean;
    };
  };
  session: {
    token: string | null;
    expiresAt: number | null;
    lastActivity: number;
  };
}

// Create domain-specific store hooks
export const {
  Provider: UserProvider,
  useStore: useUserStore,
  useRegistry: useUserRegistry,
  useCreateStore: useCreateUserStore
} = createDeclarativeStores<UserData>('User', {
  profile: {
    initialValue: {
      id: '',
      name: '',
      email: ''
    }
  },
  preferences: {
    initialValue: {
      theme: 'light',
      language: 'en',
      notifications: {
        email: true,
        push: true,
        sms: false
      }
    }
  },
  session: {
    initialValue: {
      token: null,
      expiresAt: null,
      lastActivity: Date.now()
    }
  }
});
```

### 2. Dynamic Store Creation

```typescript
// Create stores dynamically based on runtime conditions
function UserStoreSetup() {
  // Create core stores
  useCreateUserStore('profile', {
    id: '',
    name: '',
    email: ''
  });
  
  useCreateUserStore('preferences', {
    theme: 'light',
    language: navigator.language || 'en'
  });
  
  // Conditionally create admin-specific stores
  const userRole = getUserRole();
  if (userRole === 'admin') {
    useCreateUserStore('adminSettings', {
      canManageUsers: true,
      canModifySystem: false
    });
  }
  
  return null;
}
```

### 3. Computed Store Pattern

```typescript
// Create computed values that update automatically
function useComputedUserData() {
  const profileStore = useUserStore('profile');
  const preferencesStore = useUserStore('preferences');
  
  const profile = useStoreValue(profileStore);
  const preferences = useStoreValue(preferencesStore);
  
  // Computed values (memoized)
  const displayName = useMemo(() => {
    return profile.name || profile.email || 'Guest User';
  }, [profile.name, profile.email]);
  
  const isAuthenticated = useMemo(() => {
    return Boolean(profile.id);
  }, [profile.id]);
  
  const themeConfig = useMemo(() => {
    return {
      isDark: preferences.theme === 'dark',
      cssClass: `theme-${preferences.theme}`,
      colors: getThemeColors(preferences.theme)
    };
  }, [preferences.theme]);
  
  return {
    profile,
    preferences,
    displayName,
    isAuthenticated,
    themeConfig
  };
}
```

## Store Access Patterns

### 1. Component Access (Reactive)

```typescript
function UserProfile() {
  // Get store instance
  const profileStore = useUserStore('profile');
  
  // Subscribe to changes (component re-renders on updates)
  const profile = useStoreValue(profileStore);
  
  // Direct store manipulation (when needed)
  const updateName = (newName: string) => {
    const currentProfile = profileStore.getValue();
    profileStore.setValue({
      ...currentProfile,
      name: newName
    });
  };
  
  return <div>Hello, {profile.name}!</div>;
}
```

### 2. Handler Access (Lazy Evaluation)

```typescript
function useUserHandlers() {
  const register = useUserActionRegister();
  const registry = useUserRegistry();
  
  const updateProfileHandler = useCallback(async (payload, controller) => {
    // Lazy evaluation - gets current value at execution time
    const profileStore = registry.getStore('profile');
    const currentProfile = profileStore.getValue(); // Fresh data
    
    // Validation
    if (!payload.data.email?.includes('@')) {
      controller.abort('Invalid email format');
      return;
    }
    
    // Update store
    profileStore.setValue({
      ...currentProfile,
      ...payload.data,
      updatedAt: Date.now()
    });
    
    return { success: true, profile: profileStore.getValue() };
  }, [registry]);
  
  // Handler registration...
}
```

### 3. Context Store Pattern (Isolated)

```typescript
// Create isolated store context
const UserStores = createContextStorePattern('User');

function UserModule() {
  return (
    <UserStores.Provider registryId="user-module">
      <UserComponents />
    </UserStores.Provider>
  );
}

function UserComponents() {
  // Isolated store within this context
  const userStore = UserStores.useStore('profile', {
    id: '',
    name: '',
    email: ''
  });
  
  const profile = useStoreValue(userStore);
  
  return <div>User: {profile.name}</div>;
}
```

## Store Lifecycle Management

### 1. Store Creation Lifecycle

```typescript
// Stores are created when first accessed
function Component() {
  // This creates the store if it doesn't exist
  const profileStore = useUserStore('profile');
  
  // Subsequent calls return the same instance
  const sameStore = useUserStore('profile'); // profileStore === sameStore
  
  return null;
}
```

### 2. Store Persistence Across Re-renders

```typescript
function Component({ userId }: { userId: string }) {
  // Store persists across re-renders within the same provider scope
  const profileStore = useUserStore('profile');
  
  // Effect to update store when userId changes
  useEffect(() => {
    if (userId) {
      loadUserProfile(userId).then(profile => {
        profileStore.setValue(profile);
      });
    }
  }, [userId, profileStore]);
  
  const profile = useStoreValue(profileStore);
  
  return <div>{profile.name}</div>;
}
```

### 3. Provider Scope and Store Isolation

```typescript
// Different provider scopes = different store instances
function App() {
  return (
    <div>
      <UserProvider> {/* Scope 1 */}
        <ComponentA /> {/* Uses Store Instance A */}
      </UserProvider>
      
      <UserProvider> {/* Scope 2 */}
        <ComponentB /> {/* Uses Store Instance B */}
      </UserProvider>
    </div>
  );
}

function ComponentA() {
  const store = useUserStore('profile'); // Instance A
  return null;
}

function ComponentB() {
  const store = useUserStore('profile'); // Instance B (different from A)
  return null;
}
```

## Advanced Store Patterns

### 1. Store Synchronization

```typescript
// Sync stores across different parts of the application
function useStoreSynchronization() {
  const profileStore = useUserStore('profile');
  const sessionStore = useUserStore('session');
  
  const profile = useStoreValue(profileStore);
  const session = useStoreValue(sessionStore);
  
  // Sync profile updates with session activity
  useEffect(() => {
    if (profile.id) {
      const currentSession = sessionStore.getValue();
      sessionStore.setValue({
        ...currentSession,
        lastActivity: Date.now()
      });
    }
  }, [profile.id, sessionStore]);
  
  // Sync session expiration with profile
  useEffect(() => {
    if (session.expiresAt && session.expiresAt < Date.now()) {
      profileStore.setValue({
        id: '',
        name: '',
        email: ''
      });
    }
  }, [session.expiresAt, profileStore]);
}
```

### 2. Store Caching Pattern

```typescript
// Implement caching for expensive computations
function useCachedUserData() {
  const profileStore = useUserStore('profile');
  const cacheStore = useUserStore('cache');
  
  const profile = useStoreValue(profileStore);
  const cache = useStoreValue(cacheStore);
  
  // Get cached or computed expensive data
  const expensiveData = useMemo(() => {
    const cacheKey = `user-${profile.id}`;
    const cached = cache[cacheKey];
    
    if (cached && cached.timestamp > Date.now() - 60000) { // 1 minute cache
      return cached.data;
    }
    
    // Compute expensive data
    const computedData = computeExpensiveUserData(profile);
    
    // Update cache
    cacheStore.setValue({
      ...cache,
      [cacheKey]: {
        data: computedData,
        timestamp: Date.now()
      }
    });
    
    return computedData;
  }, [profile, cache, cacheStore]);
  
  return expensiveData;
}
```

### 3. Store Validation Pattern

```typescript
// Add validation layer to store updates
function useValidatedUserStore() {
  const profileStore = useUserStore('profile');
  const validationStore = useUserStore('validation');
  
  // Validated update method
  const updateProfile = useCallback((updates: Partial<UserProfile>) => {
    const errors: Record<string, string> = {};
    
    // Validation rules
    if (updates.email && !isValidEmail(updates.email)) {
      errors.email = 'Invalid email format';
    }
    
    if (updates.name && updates.name.length < 2) {
      errors.name = 'Name must be at least 2 characters';
    }
    
    // Update validation store
    validationStore.setValue({
      errors,
      isValid: Object.keys(errors).length === 0
    });
    
    // Only update profile if valid
    if (Object.keys(errors).length === 0) {
      const currentProfile = profileStore.getValue();
      profileStore.setValue({
        ...currentProfile,
        ...updates
      });
      return true;
    }
    
    return false;
  }, [profileStore, validationStore]);
  
  return {
    profile: useStoreValue(profileStore),
    validation: useStoreValue(validationStore),
    updateProfile
  };
}
```

### 4. Store Middleware Pattern

```typescript
// Add middleware for logging, analytics, etc.
function useStoreMiddleware() {
  const registry = useUserRegistry();
  
  // Create middleware wrapper
  const createMiddlewareStore = useCallback(<T>(storeName: string) => {
    const originalStore = registry.getStore<T>(storeName);
    
    return {
      getValue: () => originalStore.getValue(),
      setValue: (value: T) => {
        const oldValue = originalStore.getValue();
        
        // Pre-update middleware
        console.log(`[STORE] Updating ${storeName}:`, { oldValue, newValue: value });
        
        // Analytics
        trackStoreUpdate(storeName, oldValue, value);
        
        // Update store
        originalStore.setValue(value);
        
        // Post-update middleware
        console.log(`[STORE] Updated ${storeName} successfully`);
      },
      subscribe: originalStore.subscribe
    };
  }, [registry]);
  
  return { createMiddlewareStore };
}
```

## Store Performance Optimization

### 1. Selective Subscriptions

```typescript
// Only subscribe to specific parts of the store
function OptimizedComponent() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  // Only re-render when name changes
  const userName = useMemo(() => profile.name, [profile.name]);
  
  // Or use custom hook for specific field subscription
  const userEmail = useStoreField(profileStore, 'email');
  
  return <div>{userName} - {userEmail}</div>;
}

// Custom hook for field-specific subscriptions
function useStoreField<T, K extends keyof T>(
  store: Store<T>, 
  field: K
): T[K] {
  const [fieldValue, setFieldValue] = useState(() => store.getValue()[field]);
  
  useEffect(() => {
    return store.subscribe((newValue) => {
      const newFieldValue = newValue[field];
      if (newFieldValue !== fieldValue) {
        setFieldValue(newFieldValue);
      }
    });
  }, [store, field, fieldValue]);
  
  return fieldValue;
}
```

### 2. Store Batching

```typescript
// Batch multiple store updates
function useBatchedUpdates() {
  const registry = useUserRegistry();
  
  const batchUpdate = useCallback((updates: {
    profile?: Partial<UserData['profile']>;
    preferences?: Partial<UserData['preferences']>;
    session?: Partial<UserData['session']>;
  }) => {
    // Start batch
    const profileStore = registry.getStore('profile');
    const preferencesStore = registry.getStore('preferences');
    const sessionStore = registry.getStore('session');
    
    // Perform all updates
    if (updates.profile) {
      profileStore.setValue({
        ...profileStore.getValue(),
        ...updates.profile
      });
    }
    
    if (updates.preferences) {
      preferencesStore.setValue({
        ...preferencesStore.getValue(),
        ...updates.preferences
      });
    }
    
    if (updates.session) {
      sessionStore.setValue({
        ...sessionStore.getValue(),
        ...updates.session
      });
    }
    
    // All updates are atomic from React's perspective
  }, [registry]);
  
  return { batchUpdate };
}
```

### 3. Store Debouncing

```typescript
// Debounce frequent store updates
function useDebouncedStore() {
  const profileStore = useUserStore('profile');
  const [debouncedProfile, setDebouncedProfile] = useState(profileStore.getValue());
  
  // Debounce store changes
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedProfile(profileStore.getValue());
    }, 300);
    
    return () => clearTimeout(timer);
  }, [profileStore.getValue()]);
  
  return debouncedProfile;
}
```

## Common Store Patterns

### 1. Loading States

```typescript
interface LoadingState {
  isLoading: boolean;
  error: string | null;
  lastUpdated: number | null;
}

function useLoadingStore() {
  const loadingStore = useUserStore('loading');
  const dispatch = useUserAction();
  
  const setLoading = useCallback((loading: boolean, error?: string) => {
    loadingStore.setValue({
      isLoading: loading,
      error: error || null,
      lastUpdated: loading ? null : Date.now()
    });
  }, [loadingStore]);
  
  const handleAsyncAction = useCallback(async (actionType: string, payload: any) => {
    setLoading(true);
    
    try {
      const result = await dispatch(actionType as any, payload);
      setLoading(false);
      return result;
    } catch (error) {
      setLoading(false, error.message);
      throw error;
    }
  }, [dispatch, setLoading]);
  
  return {
    loading: useStoreValue(loadingStore),
    setLoading,
    handleAsyncAction
  };
}
```

### 2. Undo/Redo Pattern

```typescript
interface HistoryState<T> {
  past: T[];
  present: T;
  future: T[];
}

function useUndoableStore<T>(storeName: string, initialValue: T) {
  const historyStore = useUserStore(`${storeName}-history`) as Store<HistoryState<T>>;
  
  // Initialize history if needed
  useEffect(() => {
    const current = historyStore.getValue();
    if (!current.present) {
      historyStore.setValue({
        past: [],
        present: initialValue,
        future: []
      });
    }
  }, [historyStore, initialValue]);
  
  const setValue = useCallback((newValue: T) => {
    const { past, present } = historyStore.getValue();
    
    historyStore.setValue({
      past: [...past, present],
      present: newValue,
      future: [] // Clear future on new action
    });
  }, [historyStore]);
  
  const undo = useCallback(() => {
    const { past, present, future } = historyStore.getValue();
    
    if (past.length > 0) {
      const newPresent = past[past.length - 1];
      const newPast = past.slice(0, past.length - 1);
      
      historyStore.setValue({
        past: newPast,
        present: newPresent,
        future: [present, ...future]
      });
    }
  }, [historyStore]);
  
  const redo = useCallback(() => {
    const { past, present, future } = historyStore.getValue();
    
    if (future.length > 0) {
      const newPresent = future[0];
      const newFuture = future.slice(1);
      
      historyStore.setValue({
        past: [...past, present],
        present: newPresent,
        future: newFuture
      });
    }
  }, [historyStore]);
  
  const history = useStoreValue(historyStore);
  
  return {
    value: history.present,
    setValue,
    undo,
    redo,
    canUndo: history.past.length > 0,
    canRedo: history.future.length > 0
  };
}
```

---

## Summary

Effective store management in the Context-Action framework involves:

- **Clear Structure**: Well-defined domain data interfaces
- **Lifecycle Awareness**: Understanding store creation and persistence  
- **Access Patterns**: Choosing the right pattern for each use case
- **Performance**: Optimizing subscriptions and updates
- **Advanced Patterns**: Implementing common state management needs

Proper store management ensures predictable state updates, optimal performance, and maintainable code architecture.

---

::: tip Next Steps
- Learn [Action Handlers](./action-handlers) for business logic management
- Explore [Cross-Domain Integration](./cross-domain-integration) for multi-domain applications  
- See [Performance Optimization](./performance) for large-scale applications
:::

---


# Api Action Registry

**Source**: `api/action-registry.md`  
**Priority**: 75 (important)  

# Action Registry API

Complete API reference for the Action Registry system that manages action registration, execution, and pipeline control.

## Overview

The Action Registry is the core system that manages action handlers, executes action pipelines, and provides advanced control flow. It's the foundation of the Action Only Pattern and handles all action dispatching logic.

## Core Registry Methods

### `actionRegistry.register(actionName, handler, options?)`

Registers an action handler with the specified options.

**Parameters:**
- `actionName`: Name of the action to handle
- `handler`: Handler function
- `options`: Handler configuration options

**Returns:** Unregister function

```typescript
// Low-level registration (typically done through useActionHandler)
const unregister = actionRegistry.register('updateUser', 
  async (payload, controller) => {
    // Handler logic
    return { success: true };
  },
  { priority: 100, id: 'user-updater' }
);

// Cleanup
unregister();
```

### `actionRegistry.unregister(actionName, handlerId)`

Unregisters a specific handler for an action.

**Parameters:**
- `actionName`: Name of the action
- `handlerId`: ID of the handler to remove

**Returns:** `boolean` - Success status

```typescript
const success = actionRegistry.unregister('updateUser', 'user-updater');
console.log('Handler removed:', success);
```

### `actionRegistry.dispatch(actionName, payload)`

Dispatches an action to all registered handlers.

**Parameters:**
- `actionName`: Name of the action to dispatch
- `payload`: Action payload data

**Returns:** `Promise<ActionResult[]>`

```typescript
// Direct dispatch (typically done through useActionDispatch)
const results = await actionRegistry.dispatch('updateUser', {
  id: '123',
  name: 'John Doe'
});
```

## Handler Management

### `actionRegistry.getHandlers(actionName)`

Gets all handlers registered for a specific action.

**Parameters:**
- `actionName`: Name of the action

**Returns:** Array of handler information

```typescript
function HandlerInspector() {
  const dispatch = useActionDispatch();
  
  const inspectHandlers = () => {
    const handlers = actionRegistry.getHandlers('updateUser');
    console.log('Registered handlers:', handlers.map(h => ({
      id: h.id,
      priority: h.priority
    })));
  };
  
  return <button onClick={inspectHandlers}>Inspect Handlers</button>;
}
```

### `actionRegistry.getActionNames()`

Gets all registered action names.

**Returns:** `string[]`

```typescript
function ActionList() {
  const actionNames = actionRegistry.getActionNames();
  
  return (
    <div>
      <h3>Available Actions:</h3>
      <ul>
        {actionNames.map(name => (
          <li key={name}>{name}</li>
        ))}
      </ul>
    </div>
  );
}
```

### `actionRegistry.hasAction(actionName)`

Checks if an action has any registered handlers.

**Parameters:**
- `actionName`: Name of the action to check

**Returns:** `boolean`

```typescript
function ActionChecker() {
  const checkAction = (actionName: string) => {
    const hasHandlers = actionRegistry.hasAction(actionName);
    console.log(`Action ${actionName} ${hasHandlers ? 'has' : 'has no'} handlers`);
  };
  
  return (
    <div>
      <button onClick={() => checkAction('updateUser')}>
        Check updateUser
      </button>
    </div>
  );
}
```

## Pipeline Execution

### `actionRegistry.executePipeline(actionName, payload, options?)`

Executes the complete action pipeline with advanced options.

**Parameters:**
- `actionName`: Name of the action
- `payload`: Action payload
- `options`: Execution options

**Options:**
```typescript
interface ExecutionOptions {
  timeout?: number;           // Pipeline timeout in ms
  abortOnError?: boolean;     // Stop on first error
  collectResults?: boolean;   // Collect all handler results
  metadata?: any;            // Additional execution metadata
}
```

**Returns:** `Promise<PipelineResult>`

```typescript
// Advanced pipeline execution
const result = await actionRegistry.executePipeline('complexAction', payload, {
  timeout: 5000,
  abortOnError: false,
  collectResults: true,
  metadata: { source: 'admin-panel' }
});

console.log('Pipeline result:', result);
```

### `actionRegistry.createPipelineController(actionName, payload)`

Creates a pipeline controller for manual pipeline management.

**Parameters:**
- `actionName`: Name of the action
- `payload`: Initial payload

**Returns:** `PipelineController` instance

```typescript
// Manual pipeline control
const controller = actionRegistry.createPipelineController('updateUser', {
  id: '123',
  name: 'John'
});

// Modify payload before execution
controller.modifyPayload(current => ({
  ...current,
  timestamp: Date.now()
}));

// Execute with custom controller
const results = await actionRegistry.executeWithController(controller);
```

## Registry Statistics

### `actionRegistry.getStatistics()`

Gets registry statistics and performance metrics.

**Returns:** Registry statistics object

```typescript
function RegistryStats() {
  const getStats = () => {
    const stats = actionRegistry.getStatistics();
    console.log('Registry Statistics:', {
      totalActions: stats.totalActions,
      totalHandlers: stats.totalHandlers,
      executionCount: stats.executionCount,
      averageExecutionTime: stats.averageExecutionTime,
      errorRate: stats.errorRate
    });
  };
  
  return <button onClick={getStats}>Show Registry Stats</button>;
}
```

### `actionRegistry.getPerformanceMetrics(actionName?)`

Gets performance metrics for actions.

**Parameters:**
- `actionName?`: Optional specific action name

**Returns:** Performance metrics

```typescript
function PerformanceMonitor() {
  const showMetrics = () => {
    const allMetrics = actionRegistry.getPerformanceMetrics();
    const userMetrics = actionRegistry.getPerformanceMetrics('updateUser');
    
    console.log('All actions metrics:', allMetrics);
    console.log('updateUser metrics:', userMetrics);
  };
  
  return <button onClick={showMetrics}>Show Performance</button>;
}
```

## Advanced Handler Options

### Handler Configuration

```typescript
interface AdvancedHandlerOptions {
  priority: number;           // Execution priority (0-1000)
  id: string;                // Unique handler identifier
  once: boolean;             // Execute only once
  condition?: (payload: any) => boolean;  // Conditional execution
  timeout?: number;          // Handler timeout
  retries?: number;          // Retry attempts on failure
  retryDelay?: number;       // Delay between retries
  metadata?: any;            // Handler metadata
}
```

### Conditional Handlers

```typescript
function ConditionalHandlers() {
  // Handler only executes for admin users
  useActionHandler('adminAction', async (payload) => {
    await performAdminOperation(payload);
    return { success: true };
  }, {
    priority: 100,
    id: 'admin-handler',
    condition: (payload) => payload.userRole === 'admin'
  });
  
  // Handler with retry logic
  useActionHandler('unreliableAction', async (payload) => {
    return await unreliableService.call(payload);
  }, {
    priority: 90,
    id: 'unreliable-handler',
    retries: 3,
    retryDelay: 1000
  });
  
  return null;
}
```

## Registry Events

### `actionRegistry.onHandlerError(callback)`

Registers a callback for handler errors.

**Parameters:**
- `callback`: Error handling callback

**Returns:** Unregister function

```typescript
function GlobalErrorHandler() {
  useEffect(() => {
    const unsubscribe = actionRegistry.onHandlerError((error, context) => {
      console.error('Handler error:', error);
      console.error('Context:', context);
      
      // Send to error reporting service
      errorReporter.captureException(error, {
        extra: context,
        tags: { source: 'action-handler' }
      });
    });
    
    return unsubscribe;
  }, []);
  
  return null;
}
```

### `actionRegistry.onActionExecuted(callback)`

Registers a callback for completed action executions.

**Parameters:**
- `callback`: Execution completion callback

**Returns:** Unregister function

```typescript
function ActionAuditor() {
  useEffect(() => {
    const unsubscribe = actionRegistry.onActionExecuted((actionName, result) => {
      // Audit log
      auditLogger.log({
        action: actionName,
        timestamp: Date.now(),
        success: result.success,
        duration: result.duration,
        handlerCount: result.handlerResults.length
      });
    });
    
    return unsubscribe;
  }, []);
  
  return null;
}
```

## Registry Configuration

### Global Configuration

```typescript
// Configure registry behavior
actionRegistry.configure({
  defaultTimeout: 10000,        // Default handler timeout
  maxConcurrentActions: 10,     // Max concurrent action executions
  enableMetrics: true,          // Collect performance metrics
  enableLogging: true,          // Enable debug logging
  errorReporting: true          // Enable error reporting
});
```

### Development Tools

```typescript
function RegistryDevTools() {
  const enableDebugMode = () => {
    actionRegistry.setDebugMode(true);
    console.log('Action registry debug mode enabled');
  };
  
  const clearMetrics = () => {
    actionRegistry.clearMetrics();
    console.log('Performance metrics cleared');
  };
  
  const dumpRegistry = () => {
    const dump = actionRegistry.dumpState();
    console.log('Registry state dump:', dump);
  };
  
  return (
    <div className="dev-tools">
      <h3>Registry Dev Tools</h3>
      <button onClick={enableDebugMode}>Enable Debug</button>
      <button onClick={clearMetrics}>Clear Metrics</button>
      <button onClick={dumpRegistry}>Dump State</button>
    </div>
  );
}
```

## Testing Support

### Registry Mocking

```typescript
// Test utilities for action registry
export class MockActionRegistry {
  private handlers = new Map();
  private results = new Map();
  
  register(actionName: string, handler: Function, options?: any) {
    if (!this.handlers.has(actionName)) {
      this.handlers.set(actionName, []);
    }
    this.handlers.get(actionName).push({ handler, options });
    
    return () => this.unregister(actionName, options?.id);
  }
  
  async dispatch(actionName: string, payload: any) {
    const handlers = this.handlers.get(actionName) || [];
    const results = [];
    
    for (const { handler } of handlers) {
      try {
        const result = await handler(payload, createMockController());
        results.push(result);
      } catch (error) {
        results.push({ error: error.message });
      }
    }
    
    this.results.set(actionName, results);
    return results;
  }
  
  getLastResults(actionName: string) {
    return this.results.get(actionName) || [];
  }
}
```

### Handler Testing

```typescript
// Test individual handlers
describe('User Action Handlers', () => {
  let mockRegistry: MockActionRegistry;
  
  beforeEach(() => {
    mockRegistry = new MockActionRegistry();
  });
  
  test('updateUser handler processes payload correctly', async () => {
    const handler = (payload: any, controller: any) => {
      if (!payload.id) {
        controller.abort('ID required');
        return;
      }
      return { success: true, userId: payload.id };
    };
    
    mockRegistry.register('updateUser', handler);
    
    const results = await mockRegistry.dispatch('updateUser', {
      id: '123',
      name: 'John'
    });
    
    expect(results[0]).toEqual({ success: true, userId: '123' });
  });
});
```

## Best Practices

### 1. Handler Registration
- Use meaningful handler IDs for debugging
- Set appropriate priorities for execution order
- Always use `useCallback` to prevent re-registration

### 2. Error Management
- Implement global error handlers for monitoring
- Use registry events for centralized error handling
- Set up proper error reporting and metrics

### 3. Performance Monitoring
- Monitor registry performance metrics
- Set appropriate timeouts for handlers
- Use performance data to optimize handler priorities

### 4. Testing
- Mock the registry for unit tests
- Test handlers in isolation
- Verify error handling and edge cases

### 5. Development
- Use debug mode during development
- Monitor registry health in production
- Implement proper logging and metrics

## Related

- **[Action Only Methods](./action-only)** - Action dispatching and handler registration
- **[Pipeline Controller API](./pipeline-controller)** - Pipeline control methods
- **[Action Only Example](../examples/action-only)** - Complete usage examples

---


# Api Declarative Store Pattern

**Source**: `api/declarative-store-pattern.md`  
**Priority**: 75 (important)  

# Declarative Store Pattern API

Complete API reference for the Declarative Store Pattern implementation, the recommended approach for type-safe state management.

## Overview

The Declarative Store Pattern provides excellent type inference without manual type annotations and a simplified API focused on store management. This is the recommended pattern for most state management scenarios.

## Pattern Creation

### `createDeclarativeStorePattern(contextName, storeConfig)`

Creates a declarative store pattern with automatic type inference.

**Parameters:**
- `contextName`: Unique identifier for the store context
- `storeConfig`: Store configuration with initial values and optional validators

**Returns:**
```typescript
{
  Provider: React.ComponentType<{ children: React.ReactNode }>,
  useStore: <K extends keyof T>(storeName: K) => Store<T[K]>,
  useStoreManager: () => StoreManager<T>,
  withProvider: (Component: React.ComponentType) => React.ComponentType
}
```

**Type Inference:**
The pattern automatically infers types from the configuration:

```typescript
// Configuration with automatic type inference
const { Provider, useStore, useStoreManager, withProvider } = 
  createDeclarativeStorePattern('App', {
    // Simple values - type inferred as string
    username: '',
    
    // Complex objects - type inferred automatically
    user: {
      id: '',
      name: '',
      email: '',
      isAuthenticated: false
    },
    
    // Arrays - type inferred with proper array types
    notifications: [] as Array<{ id: string; message: string; type: 'info' | 'warning' | 'error' }>,
    
    // With validator - type preserved
    settings: {
      initialValue: { theme: 'light' as 'light' | 'dark', fontSize: 14 },
      validator: (value): value is { theme: 'light' | 'dark'; fontSize: number } => {
        return typeof value === 'object' &&
          'theme' in value &&
          'fontSize' in value &&
          ['light', 'dark'].includes(value.theme) &&
          typeof value.fontSize === 'number';
      }
    }
  });

// TypeScript automatically knows:
// - useStore('username') returns Store<string>
// - useStore('user') returns Store<{ id: string; name: string; email: string; isAuthenticated: boolean }>
// - useStore('notifications') returns Store<Array<{ id: string; message: string; type: 'info' | 'warning' | 'error' }>>
// - useStore('settings') returns Store<{ theme: 'light' | 'dark'; fontSize: number }>
```

## Store Configuration Patterns

### Simple Value Configuration

Direct value assignment for primitive types:

```typescript
const simpleConfig = {
  // String type inferred
  title: 'My App',
  
  // Number type inferred
  counter: 0,
  
  // Boolean type inferred
  isLoading: false,
  
  // Null union type inferred
  selectedItem: null as string | null,
  
  // Array type inferred with explicit typing
  items: [] as Array<{ id: string; name: string }>
};

const { useStore } = createDeclarativeStorePattern('Simple', simpleConfig);

// TypeScript knows exact types:
const titleStore = useStore('title');      // Store<string>
const counterStore = useStore('counter');  // Store<number>
const itemsStore = useStore('items');      // Store<Array<{ id: string; name: string }>>
```

### Advanced Configuration

With validators and complex objects:

```typescript
const advancedConfig = {
  // Complex object with nested structure
  userProfile: {
    personal: {
      firstName: '',
      lastName: '',
      dateOfBirth: null as Date | null
    },
    contact: {
      email: '',
      phone: '',
      address: {
        street: '',
        city: '',
        country: ''
      }
    },
    preferences: {
      notifications: true,
      theme: 'light' as 'light' | 'dark',
      language: 'en' as 'en' | 'es' | 'fr'
    }
  },
  
  // With validator for runtime validation
  appSettings: {
    initialValue: {
      maxRetries: 3,
      timeout: 5000,
      enableAnalytics: true
    },
    validator: (value): value is { maxRetries: number; timeout: number; enableAnalytics: boolean } => {
      return typeof value === 'object' &&
        typeof value.maxRetries === 'number' && value.maxRetries >= 0 &&
        typeof value.timeout === 'number' && value.timeout > 0 &&
        typeof value.enableAnalytics === 'boolean';
    }
  },
  
  // Computed initial values
  sessionInfo: {
    id: generateSessionId(),
    startTime: Date.now(),
    lastActivity: Date.now(),
    isActive: true
  }
};

const { useStore } = createDeclarativeStorePattern('Advanced', advancedConfig);
```

## Provider Pattern

### `Provider` Component

The context provider that makes stores available to child components.

```typescript
function App() {
  return (
    <Provider>
      <UserInterface />
      <DataLayer />
      <NotificationSystem />
    </Provider>
  );
}
```

### `withProvider(Component)` HOC

Higher-order component that automatically wraps a component with the provider.

**Parameters:**
- `Component`: React component to wrap

**Returns:** Wrapped component with provider

```typescript
// Manual provider wrapping
function ManualApp() {
  return (
    <Provider>
      <UserInterface />
    </Provider>
  );
}

// Automatic provider wrapping with HOC
const AutoApp = withProvider(() => (
  <UserInterface />
));

// Both approaches are equivalent
export default AutoApp;
```

## Store Type Safety

### Type Inference Examples

```typescript
const config = {
  // Primitives
  userName: 'john',           // Store<string>
  age: 25,                   // Store<number>
  isActive: true,            // Store<boolean>
  
  // Objects
  profile: {                 // Store<{ name: string; email: string }>
    name: 'John Doe',
    email: 'john@example.com'
  },
  
  // Arrays with explicit typing
  tags: [] as string[],      // Store<string[]>
  
  // Complex arrays
  items: [] as Array<{       // Store<Array<{ id: string; title: string; completed: boolean }>>
    id: string;
    title: string;
    completed: boolean;
  }>,
  
  // Union types
  status: 'idle' as 'idle' | 'loading' | 'success' | 'error',  // Store<'idle' | 'loading' | 'success' | 'error'>
  
  // Optional properties
  selectedId: null as string | null,  // Store<string | null>
  
  // Date objects
  lastUpdated: new Date(),   // Store<Date>
  
  // Generic objects
  metadata: {} as Record<string, any>  // Store<Record<string, any>>
};

function TypeSafeComponent() {
  // All these have perfect type inference
  const userNameStore = useStore('userName');        // Store<string>
  const profileStore = useStore('profile');          // Store<{ name: string; email: string }>
  const statusStore = useStore('status');            // Store<'idle' | 'loading' | 'success' | 'error'>
  
  // Values are properly typed
  const userName = useStoreValue(userNameStore);     // string
  const profile = useStoreValue(profileStore);       // { name: string; email: string }
  const status = useStoreValue(statusStore);         // 'idle' | 'loading' | 'success' | 'error'
  
  // Store methods are type-safe
  userNameStore.setValue('newName');                 // ✅ string
  // userNameStore.setValue(123);                    // ❌ TypeScript error
  
  profileStore.update(current => ({                  // ✅ Proper object structure
    ...current,
    name: 'Updated Name'
  }));
  
  statusStore.setValue('loading');                   // ✅ Valid union value
  // statusStore.setValue('invalid');               // ❌ TypeScript error
  
  return <div>Type-safe component</div>;
}
```

## Store Configuration Validation

### Runtime Validation

```typescript
const validatedConfig = {
  userSettings: {
    initialValue: {
      theme: 'light' as 'light' | 'dark',
      fontSize: 14,
      notifications: true
    },
    validator: (value): value is { theme: 'light' | 'dark'; fontSize: number; notifications: boolean } => {
      return typeof value === 'object' &&
        value !== null &&
        'theme' in value &&
        'fontSize' in value &&
        'notifications' in value &&
        ['light', 'dark'].includes(value.theme) &&
        typeof value.fontSize === 'number' &&
        value.fontSize >= 8 && value.fontSize <= 32 &&
        typeof value.notifications === 'boolean';
    }
  },
  
  apiConfiguration: {
    initialValue: {
      baseUrl: 'https://api.example.com',
      timeout: 5000,
      retries: 3
    },
    validator: (value): value is { baseUrl: string; timeout: number; retries: number } => {
      return typeof value === 'object' &&
        value !== null &&
        'baseUrl' in value &&
        'timeout' in value &&
        'retries' in value &&
        typeof value.baseUrl === 'string' &&
        value.baseUrl.startsWith('https://') &&
        typeof value.timeout === 'number' &&
        value.timeout > 0 &&
        typeof value.retries === 'number' &&
        value.retries >= 0;
    }
  }
};

function ValidatedStoreUsage() {
  const settingsStore = useStore('userSettings');
  
  const updateTheme = (newTheme: 'light' | 'dark') => {
    try {
      settingsStore.update(current => ({
        ...current,
        theme: newTheme
      }));
      console.log('Theme updated successfully');
    } catch (error) {
      console.error('Theme update failed validation:', error);
      // Handle validation error
    }
  };
  
  return <button onClick={() => updateTheme('dark')}>Dark Theme</button>;
}
```

## Advanced Store Patterns

### Computed Store Values

```typescript
function ComputedValues() {
  const userStore = useStore('user');
  const settingsStore = useStore('settings');
  
  const user = useStoreValue(userStore);
  const settings = useStoreValue(settingsStore);
  
  // Computed values with proper typing
  const displayName = useMemo(() => {
    return user.name || user.email?.split('@')[0] || 'Anonymous';
  }, [user.name, user.email]);
  
  const themeClass = useMemo(() => {
    return `theme-${settings.theme}`;
  }, [settings.theme]);
  
  const userStatus = useMemo(() => {
    if (!user.isAuthenticated) return 'guest';
    if (user.isAdmin) return 'admin';
    return 'user';
  }, [user.isAuthenticated, user.isAdmin]);
  
  return (
    <div className={themeClass}>
      <span>Welcome {displayName} ({userStatus})</span>
    </div>
  );
}
```

### Store Relationships

```typescript
function RelatedStores() {
  const userStore = useStore('user');
  const preferencesStore = useStore('preferences');
  const cacheStore = useStore('cache');
  
  // Sync user changes to preferences
  useEffect(() => {
    return userStore.subscribe((newUser, previousUser) => {
      if (newUser.id !== previousUser?.id) {
        // User changed - load their preferences
        preferencesStore.setValue({
          theme: newUser.preferredTheme || 'light',
          language: newUser.language || 'en',
          notifications: newUser.notificationsEnabled ?? true
        });
      }
    });
  }, [userStore, preferencesStore]);
  
  // Cache user data
  useEffect(() => {
    return userStore.subscribe((newUser) => {
      cacheStore.update(cache => ({
        ...cache,
        lastUser: newUser,
        lastUserUpdate: Date.now()
      }));
    });
  }, [userStore, cacheStore]);
  
  return null;
}
```

### Store Persistence

```typescript
function PersistentStores() {
  const storeManager = useStoreManager();
  
  // Save to localStorage on changes
  useEffect(() => {
    const persistentStores = ['user', 'settings', 'preferences'];
    const unsubscribers: (() => void)[] = [];
    
    persistentStores.forEach(storeName => {
      const store = storeManager.getStore(storeName);
      
      const unsubscribe = store.subscribe((newValue) => {
        try {
          localStorage.setItem(`store_${storeName}`, JSON.stringify(newValue));
        } catch (error) {
          console.error(`Failed to persist store ${storeName}:`, error);
        }
      });
      
      unsubscribers.push(unsubscribe);
    });
    
    return () => {
      unsubscribers.forEach(unsub => unsub());
    };
  }, [storeManager]);
  
  // Load from localStorage on mount
  useEffect(() => {
    const persistentStores = ['user', 'settings', 'preferences'];
    
    persistentStores.forEach(storeName => {
      try {
        const saved = localStorage.getItem(`store_${storeName}`);
        if (saved) {
          const value = JSON.parse(saved);
          const store = storeManager.getStore(storeName);
          store.setValue(value);
        }
      } catch (error) {
        console.error(`Failed to load store ${storeName}:`, error);
      }
    });
  }, [storeManager]);
  
  return null;
}
```

## React Integration Patterns

### Component Pattern Integration

```typescript
// Define store configuration
const appStoreConfig = {
  todos: [] as Array<{
    id: string;
    text: string;
    completed: boolean;
    createdAt: Date;
  }>,
  
  filter: 'all' as 'all' | 'active' | 'completed',
  
  ui: {
    loading: false,
    error: null as string | null,
    editingId: null as string | null
  }
};

const {
  Provider: TodoStoreProvider,
  useStore: useTodoStore,
  useStoreManager: useTodoStoreManager,
  withProvider: withTodoStoreProvider
} = createDeclarativeStorePattern('TodoApp', appStoreConfig);

// Component using the pattern
const TodoApp = withTodoStoreProvider(() => {
  return (
    <div className="todo-app">
      <TodoHeader />
      <TodoList />
      <TodoFooter />
    </div>
  );
});

function TodoList() {
  const todosStore = useTodoStore('todos');
  const filterStore = useTodoStore('filter');
  const uiStore = useTodoStore('ui');
  
  const todos = useStoreValue(todosStore);
  const filter = useStoreValue(filterStore);
  const ui = useStoreValue(uiStore);
  
  // Filtered todos with proper typing
  const filteredTodos = useMemo(() => {
    switch (filter) {
      case 'active': return todos.filter(todo => !todo.completed);
      case 'completed': return todos.filter(todo => todo.completed);
      default: return todos;
    }
  }, [todos, filter]);
  
  const addTodo = (text: string) => {
    todosStore.update(current => [...current, {
      id: generateId(),
      text,
      completed: false,
      createdAt: new Date()
    }]);
  };
  
  const toggleTodo = (id: string) => {
    todosStore.update(current => 
      current.map(todo => 
        todo.id === id 
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    );
  };
  
  const removeTodo = (id: string) => {
    todosStore.update(current => current.filter(todo => todo.id !== id));
  };
  
  return (
    <div className="todo-list">
      {filteredTodos.map(todo => (
        <TodoItem 
          key={todo.id}
          todo={todo}
          onToggle={() => toggleTodo(todo.id)}
          onRemove={() => removeTodo(todo.id)}
        />
      ))}
    </div>
  );
}
```

### Store Manager Integration

```typescript
function TodoManager() {
  const storeManager = useTodoStoreManager();
  
  const exportTodos = () => {
    const state = storeManager.exportState();
    const todoData = {
      todos: state.todos,
      filter: state.filter,
      exportedAt: new Date().toISOString()
    };
    
    const json = JSON.stringify(todoData, null, 2);
    downloadAsFile(json, 'todos.json');
  };
  
  const importTodos = (file: File) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target?.result as string);
        
        if (data.todos && Array.isArray(data.todos)) {
          const todosStore = storeManager.getStore('todos');
          todosStore.setValue(data.todos);
          
          if (data.filter) {
            const filterStore = storeManager.getStore('filter');
            filterStore.setValue(data.filter);
          }
        }
      } catch (error) {
        console.error('Import failed:', error);
      }
    };
    reader.readAsText(file);
  };
  
  const clearAllData = () => {
    if (confirm('Clear all todos?')) {
      storeManager.resetAll();
    }
  };
  
  return (
    <div className="todo-manager">
      <button onClick={exportTodos}>Export Todos</button>
      <input 
        type="file" 
        accept=".json" 
        onChange={(e) => e.target.files?.[0] && importTodos(e.target.files[0])} 
      />
      <button onClick={clearAllData}>Clear All</button>
    </div>
  );
}
```

## Performance Optimization

### Selective Re-rendering

```typescript
function OptimizedComponent() {
  const userStore = useStore('user');
  
  // Only re-render when name changes
  const userName = useStoreValue(userStore, user => user.name);
  
  // Only re-render when authentication status changes
  const isAuthenticated = useStoreValue(userStore, user => user.isAuthenticated);
  
  // Memoized expensive computation
  const expensiveValue = useMemo(() => {
    return computeExpensiveValue(userName);
  }, [userName]);
  
  return (
    <div>
      {isAuthenticated ? (
        <span>Welcome {userName}</span>
      ) : (
        <span>Please log in</span>
      )}
      <div>Computed: {expensiveValue}</div>
    </div>
  );
}
```

### Batched Updates

```typescript
function BatchedUpdater() {
  const userStore = useStore('user');
  const settingsStore = useStore('settings');
  const uiStore = useStore('ui');
  
  const updateUserProfile = (profileData: any) => {
    // Batch multiple store updates
    const updates = [
      () => userStore.update(current => ({
        ...current,
        ...profileData,
        lastUpdated: Date.now()
      })),
      () => settingsStore.update(current => ({
        ...current,
        lastProfileUpdate: Date.now()
      })),
      () => uiStore.update(current => ({
        ...current,
        notification: {
          message: 'Profile updated successfully',
          type: 'success' as const
        }
      }))
    ];
    
    // Execute all updates
    updates.forEach(update => update());
  };
  
  return (
    <button onClick={() => updateUserProfile({ name: 'New Name' })}>
      Update Profile
    </button>
  );
}
```

## Advanced Type Patterns

### Conditional Store Types

```typescript
// Configuration with conditional types
const conditionalConfig = {
  // Different shapes based on user type
  userData: null as {
    type: 'guest';
    sessionId: string;
  } | {
    type: 'user';
    id: string;
    name: string;
    email: string;
  } | {
    type: 'admin';
    id: string;
    name: string;
    email: string;
    permissions: string[];
  } | null,
  
  // State machines with type safety
  requestState: {
    status: 'idle',
    data: null,
    error: null
  } as 
    | { status: 'idle'; data: null; error: null }
    | { status: 'loading'; data: null; error: null }
    | { status: 'success'; data: any; error: null }
    | { status: 'error'; data: null; error: string }
};

function ConditionalComponent() {
  const userDataStore = useStore('userData');
  const requestStore = useStore('requestState');
  
  const userData = useStoreValue(userDataStore);
  const requestState = useStoreValue(requestStore);
  
  // Type-safe conditional rendering
  if (userData?.type === 'admin') {
    // TypeScript knows userData has permissions property
    return <AdminPanel permissions={userData.permissions} />;
  }
  
  if (userData?.type === 'user') {
    // TypeScript knows userData has user properties
    return <UserPanel user={userData} />;
  }
  
  // Handle request states
  switch (requestState.status) {
    case 'loading':
      return <LoadingSpinner />;
    case 'success':
      // TypeScript knows data is available
      return <SuccessView data={requestState.data} />;
    case 'error':
      // TypeScript knows error is available
      return <ErrorView error={requestState.error} />;
    default:
      return <IdleView />;
  }
}
```

### Generic Store Configuration

```typescript
// Generic configuration helper
function createTypedStoreConfig<T extends Record<string, any>>(config: T) {
  return config;
}

// Usage with perfect type inference
const typedConfig = createTypedStoreConfig({
  products: [] as Array<{
    id: string;
    name: string;
    price: number;
    category: string;
  }>,
  
  cart: {
    items: [] as Array<{
      productId: string;
      quantity: number;
      addedAt: Date;
    }>,
    total: 0,
    currency: 'USD' as const
  },
  
  checkout: {
    step: 1 as 1 | 2 | 3 | 4,
    isProcessing: false,
    paymentMethod: null as 'card' | 'paypal' | null
  }
});

const { useStore, withProvider } = createDeclarativeStorePattern('Shop', typedConfig);
```

## Integration with External Systems

### Redux DevTools Integration

```typescript
function DevToolsIntegration() {
  const storeManager = useStoreManager();
  
  useEffect(() => {
    if (typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__) {
      const devTools = window.__REDUX_DEVTOOLS_EXTENSION__.connect({
        name: 'Context-Action Stores'
      });
      
      // Send initial state
      devTools.init(storeManager.exportState());
      
      // Subscribe to all store changes
      const stores = storeManager.getAllStores();
      const unsubscribers: (() => void)[] = [];
      
      for (const [storeName, store] of stores) {
        const unsubscribe = store.subscribe((newValue, previousValue) => {
          devTools.send(
            { type: `UPDATE_${storeName.toUpperCase()}`, payload: newValue },
            storeManager.exportState()
          );
        });
        
        unsubscribers.push(unsubscribe);
      }
      
      return () => {
        unsubscribers.forEach(unsub => unsub());
        devTools.disconnect();
      };
    }
  }, [storeManager]);
  
  return null;
}
```

## Best Practices

### 1. Configuration Design
- Use explicit type annotations for complex types
- Provide validators for runtime safety
- Use meaningful store names that reflect their purpose

### 2. Type Safety
- Leverage TypeScript's type inference
- Use union types for state machines
- Implement proper validation for user inputs

### 3. Performance
- Use selective subscriptions with selectors
- Batch related updates together
- Implement proper memoization for computed values

### 4. Integration
- Use the HOC pattern for clean provider wrapping
- Implement proper persistence strategies
- Consider DevTools integration for debugging

### 5. Testing
- Test store configurations with various data shapes
- Validate that validators work correctly
- Test persistence and restoration logic

## Related

- **[Store Only Methods](./store-only)** - Individual store methods and operations
- **[Store Manager API](./store-manager)** - Store manager advanced operations
- **[Store Only Example](../examples/store-only)** - Complete usage examples

---


# Api Pipeline Controller

**Source**: `api/pipeline-controller.md`  
**Priority**: 75 (important)  

# Pipeline Controller API

Complete API reference for the Pipeline Controller object passed to action handlers for advanced pipeline control.

## Overview

The Pipeline Controller provides advanced control flow capabilities within action handlers. It allows handlers to modify payloads, share results, control execution flow, and coordinate with other handlers in the pipeline.

## Core Control Methods

### `controller.abort(reason, error?)`

Aborts the entire action pipeline execution.

**Parameters:**
- `reason`: Human-readable reason for aborting
- `error?`: Optional error object

**Behavior:** Stops all remaining handlers and throws PipelineAbortError

```typescript
useActionHandler('validateInput', (payload, controller) => {
  if (!payload.email || !payload.email.includes('@')) {
    controller.abort('Valid email is required');
    return;
  }
  
  if (payload.age < 18) {
    controller.abort('User must be 18 or older', new ValidationError('Age requirement'));
    return;
  }
  
  return { valid: true };
});
```

### `controller.skip(reason?)`

Skips the current handler without affecting other handlers.

**Parameters:**
- `reason?`: Optional reason for skipping

**Returns:** Special skip result

```typescript
useActionHandler('premiumFeature', (payload, controller) => {
  if (!payload.user.isPremium) {
    return controller.skip('User is not premium');
  }
  
  // Premium feature logic
  return { featureExecuted: true };
});
```

## Payload Management

### `controller.getPayload()`

Gets the current (possibly modified) payload.

**Returns:** Current payload object

```typescript
useActionHandler('logAction', (_, controller) => {
  const currentPayload = controller.getPayload();
  
  console.log('Final payload used:', currentPayload);
  auditLogger.log('action_payload', currentPayload);
  
  return { logged: true };
}, { priority: 1 }); // Low priority to run last
```

### `controller.modifyPayload(modifier)`

Modifies the payload for subsequent handlers.

**Parameters:**
- `modifier`: Function that receives current payload and returns modified payload

```typescript
useActionHandler('enrichPayload', (payload, controller) => {
  controller.modifyPayload(current => ({
    ...current,
    timestamp: Date.now(),
    sessionId: getSessionId(),
    userId: getCurrentUserId(),
    userAgent: navigator.userAgent,
    source: 'web-app'
  }));
  
  return { enriched: true };
}, { priority: 95 }); // High priority to run early
```

### `controller.setPayloadProperty(key, value)`

Sets a specific property on the payload.

**Parameters:**
- `key`: Property key to set
- `value`: Value to assign

```typescript
useActionHandler('addMetadata', (payload, controller) => {
  controller.setPayloadProperty('requestId', generateRequestId());
  controller.setPayloadProperty('timestamp', Date.now());
  
  return { metadataAdded: true };
});
```

## Result Management

### `controller.setResult(result)`

Sets a result that can be accessed by later handlers.

**Parameters:**
- `result`: Result object to store

```typescript
useActionHandler('processPayment', async (payload, controller) => {
  try {
    const transaction = await paymentService.charge({
      amount: payload.amount,
      source: payload.paymentMethod
    });
    
    controller.setResult({
      step: 'payment',
      transactionId: transaction.id,
      amount: transaction.amount,
      currency: transaction.currency,
      success: true,
      provider: 'stripe'
    });
    
    return { success: true, transactionId: transaction.id };
    
  } catch (error) {
    controller.setResult({
      step: 'payment',
      success: false,
      error: error.message,
      provider: 'stripe'
    });
    
    controller.abort(`Payment failed: ${error.message}`);
  }
}, { priority: 90, id: 'payment-processor' });
```

### `controller.getResults()`

Gets all results set by previous handlers.

**Returns:** Array of result objects

```typescript
useActionHandler('sendConfirmation', async (payload, controller) => {
  const results = controller.getResults();
  const paymentResult = results.find(r => r.step === 'payment');
  const userResult = results.find(r => r.step === 'user-update');
  
  if (paymentResult?.success && userResult?.success) {
    await emailService.sendConfirmation({
      email: payload.email,
      transactionId: paymentResult.transactionId,
      userId: userResult.userId
    });
    
    return { confirmationSent: true };
  }
  
  return { confirmationSent: false, reason: 'Prerequisites not met' };
}, { priority: 70, id: 'confirmation-sender' });
```

### `controller.getResult(predicate)`

Gets a specific result using a predicate function.

**Parameters:**
- `predicate`: Function to find the desired result

**Returns:** Matching result or undefined

```typescript
useActionHandler('processRefund', async (payload, controller) => {
  const paymentResult = controller.getResult(r => 
    r.step === 'payment' && r.provider === 'stripe'
  );
  
  if (paymentResult?.transactionId) {
    const refund = await stripeService.refund(paymentResult.transactionId);
    return { refunded: true, refundId: refund.id };
  }
  
  controller.abort('No valid payment found for refund');
}, { priority: 80 });
```

## Pipeline State Management

### `controller.setPipelineState(key, value)`

Sets pipeline-level state that persists across handlers.

**Parameters:**
- `key`: State key
- `value`: State value

```typescript
useActionHandler('initializeSession', (payload, controller) => {
  const sessionId = generateSessionId();
  const userId = payload.userId;
  
  controller.setPipelineState('sessionId', sessionId);
  controller.setPipelineState('userId', userId);
  controller.setPipelineState('startTime', Date.now());
  
  return { sessionInitialized: true, sessionId };
}, { priority: 100 });
```

### `controller.getPipelineState(key)`

Gets pipeline-level state.

**Parameters:**
- `key`: State key to retrieve

**Returns:** State value or undefined

```typescript
useActionHandler('trackDuration', (payload, controller) => {
  const startTime = controller.getPipelineState('startTime');
  const duration = Date.now() - (startTime || Date.now());
  
  controller.setResult({
    step: 'duration-tracking',
    duration,
    startTime
  });
  
  return { durationTracked: true, duration };
}, { priority: 10 }); // Low priority to run last
```

### `controller.getAllPipelineState()`

Gets all pipeline state.

**Returns:** Object with all pipeline state

```typescript
useActionHandler('pipelineSummary', (payload, controller) => {
  const allState = controller.getAllPipelineState();
  const allResults = controller.getResults();
  
  const summary = {
    pipelineState: allState,
    handlerResults: allResults,
    finalPayload: controller.getPayload(),
    executionSummary: {
      totalHandlers: allResults.length,
      successfulHandlers: allResults.filter(r => !r.error).length,
      duration: Date.now() - (allState.startTime || Date.now())
    }
  };
  
  console.log('Pipeline execution summary:', summary);
  return summary;
}, { priority: 5 }); // Very low priority to run at the end
```

## Advanced Pipeline Patterns

### Multi-Stage Processing

```typescript
function MultiStageProcessor() {
  // Stage 1: Input Processing
  useActionHandler('processOrder', (payload, controller) => {
    const processedPayload = {
      ...payload,
      orderId: generateOrderId(),
      processedAt: Date.now()
    };
    
    controller.modifyPayload(() => processedPayload);
    controller.setPipelineState('stage', 'input-processed');
    
    return { stage: 'input', success: true };
  }, { priority: 100, id: 'input-processor' });
  
  // Stage 2: Validation
  useActionHandler('processOrder', (payload, controller) => {
    const validationResult = validateOrder(payload);
    
    if (!validationResult.valid) {
      controller.abort(`Validation failed: ${validationResult.errors.join(', ')}`);
    }
    
    controller.setPipelineState('stage', 'validated');
    controller.setResult({
      step: 'validation',
      valid: true,
      checks: validationResult.checks
    });
    
    return { stage: 'validation', success: true };
  }, { priority: 90, id: 'validator' });
  
  // Stage 3: Business Logic
  useActionHandler('processOrder', async (payload, controller) => {
    const stage = controller.getPipelineState('stage');
    
    if (stage !== 'validated') {
      controller.abort('Order not properly validated');
    }
    
    const orderResult = await orderService.createOrder(payload);
    
    controller.setResult({
      step: 'order-creation',
      orderId: orderResult.id,
      amount: orderResult.amount,
      success: true
    });
    
    controller.setPipelineState('stage', 'completed');
    return orderResult;
  }, { priority: 80, id: 'order-processor' });
  
  return null;
}
```

### Conditional Pipeline Branching

```typescript
function ConditionalBranching() {
  // Route to different handlers based on payload
  useActionHandler('processPayment', (payload, controller) => {
    controller.setPipelineState('paymentMethod', payload.method);
    
    if (payload.method === 'credit_card') {
      controller.setPipelineState('processor', 'stripe');
    } else if (payload.method === 'paypal') {
      controller.setPipelineState('processor', 'paypal');
    } else {
      controller.abort(`Unsupported payment method: ${payload.method}`);
    }
    
    return { routed: true, processor: controller.getPipelineState('processor') };
  }, { priority: 100, id: 'payment-router' });
  
  // Stripe handler (conditional)
  useActionHandler('processPayment', async (payload, controller) => {
    const processor = controller.getPipelineState('processor');
    
    if (processor !== 'stripe') {
      return controller.skip('Not a Stripe payment');
    }
    
    const result = await stripeService.charge(payload);
    controller.setResult({ processor: 'stripe', ...result });
    
    return result;
  }, { priority: 80, id: 'stripe-processor' });
  
  // PayPal handler (conditional)
  useActionHandler('processPayment', async (payload, controller) => {
    const processor = controller.getPipelineState('processor');
    
    if (processor !== 'paypal') {
      return controller.skip('Not a PayPal payment');
    }
    
    const result = await paypalService.charge(payload);
    controller.setResult({ processor: 'paypal', ...result });
    
    return result;
  }, { priority: 80, id: 'paypal-processor' });
  
  return null;
}
```

## Controller State Inspection

### `controller.getExecutionContext()`

Gets information about the current execution context.

**Returns:** Execution context object

```typescript
useActionHandler('debugHandler', (payload, controller) => {
  const context = controller.getExecutionContext();
  
  console.log('Execution context:', {
    actionName: context.actionName,
    handlerId: context.currentHandlerId,
    executionId: context.executionId,
    startTime: context.startTime,
    remainingHandlers: context.remainingHandlers
  });
  
  return { debugInfo: context };
});
```

### `controller.getHandlerInfo()`

Gets information about the current handler.

**Returns:** Handler information object

```typescript
useActionHandler('selfAwareHandler', (payload, controller) => {
  const handlerInfo = controller.getHandlerInfo();
  
  console.log('Current handler:', {
    id: handlerInfo.id,
    priority: handlerInfo.priority,
    registeredAt: handlerInfo.registeredAt,
    executionCount: handlerInfo.executionCount
  });
  
  return handlerInfo;
}, { id: 'self-aware', priority: 50 });
```

## Error Handling

### Pipeline Error Recovery

```typescript
function ErrorRecoveryHandler() {
  useActionHandler('riskyOperation', async (payload, controller) => {
    try {
      const result = await riskyService.performOperation(payload);
      
      controller.setResult({
        step: 'risky-operation',
        success: true,
        data: result
      });
      
      return result;
      
    } catch (error) {
      // Log error but don't abort - let recovery handler try
      controller.setResult({
        step: 'risky-operation',
        success: false,
        error: error.message,
        needsRecovery: true
      });
      
      return { error: error.message, recovered: false };
    }
  }, { priority: 90, id: 'risky-handler' });
  
  // Recovery handler
  useActionHandler('riskyOperation', async (payload, controller) => {
    const results = controller.getResults();
    const needsRecovery = results.some(r => r.needsRecovery);
    
    if (needsRecovery) {
      try {
        const result = await fallbackService.performOperation(payload);
        
        controller.setResult({
          step: 'recovery',
          success: true,
          data: result,
          recoveredFrom: 'risky-operation'
        });
        
        return { recovered: true, data: result };
        
      } catch (error) {
        controller.abort(`Recovery failed: ${error.message}`);
      }
    }
    
    return controller.skip('No recovery needed');
  }, { priority: 80, id: 'recovery-handler' });
  
  return null;
}
```

## Advanced Pipeline Control

### Dynamic Handler Execution

```typescript
function DynamicHandler() {
  useActionHandler('dynamicAction', async (payload, controller) => {
    // Modify execution based on results
    const results = controller.getResults();
    const hasValidation = results.some(r => r.step === 'validation');
    
    if (!hasValidation) {
      // Trigger validation dynamically
      controller.modifyPayload(current => ({
        ...current,
        needsValidation: true
      }));
      
      // Set state to trigger validation in next handler
      controller.setPipelineState('requireValidation', true);
    }
    
    return { dynamicExecutionApplied: true };
  }, { priority: 85 });
  
  // Conditional validation handler
  useActionHandler('dynamicAction', (payload, controller) => {
    const needsValidation = controller.getPipelineState('requireValidation');
    
    if (needsValidation) {
      const isValid = performValidation(payload);
      
      if (!isValid) {
        controller.abort('Dynamic validation failed');
      }
      
      controller.setResult({ step: 'validation', success: true });
      return { validated: true };
    }
    
    return controller.skip('Validation not required');
  }, { priority: 80, id: 'dynamic-validator' });
  
  return null;
}
```

### Pipeline Coordination

```typescript
function PipelineCoordinator() {
  // Coordinator handler
  useActionHandler('complexWorkflow', async (payload, controller) => {
    // Check if all prerequisites are met
    const results = controller.getResults();
    const hasAuth = results.some(r => r.step === 'authentication' && r.success);
    const hasValidation = results.some(r => r.step === 'validation' && r.success);
    const hasPermission = results.some(r => r.step === 'permission' && r.success);
    
    if (!hasAuth || !hasValidation || !hasPermission) {
      const missing = [];
      if (!hasAuth) missing.push('authentication');
      if (!hasValidation) missing.push('validation');
      if (!hasPermission) missing.push('permission');
      
      controller.abort(`Missing prerequisites: ${missing.join(', ')}`);
      return;
    }
    
    // All prerequisites met, proceed with main operation
    const mainResult = await performMainOperation(payload);
    
    controller.setResult({
      step: 'main-operation',
      success: true,
      data: mainResult,
      prerequisites: { hasAuth, hasValidation, hasPermission }
    });
    
    return mainResult;
    
  }, { priority: 50, id: 'workflow-coordinator' });
  
  return null;
}
```

## Controller Configuration

### `controller.setTimeout(timeout)`

Sets a timeout for the current handler execution.

**Parameters:**
- `timeout`: Timeout in milliseconds

```typescript
useActionHandler('longRunningTask', async (payload, controller) => {
  controller.setTimeout(30000); // 30 second timeout
  
  try {
    const result = await longRunningService.process(payload);
    return { success: true, data: result };
  } catch (error) {
    if (error.name === 'TimeoutError') {
      controller.abort('Operation timed out after 30 seconds');
    } else {
      controller.abort(`Operation failed: ${error.message}`);
    }
  }
});
```

### `controller.setMetadata(metadata)`

Sets metadata for the current execution.

**Parameters:**
- `metadata`: Metadata object

```typescript
useActionHandler('trackedAction', (payload, controller) => {
  controller.setMetadata({
    handlerVersion: '1.2.0',
    environment: process.env.NODE_ENV,
    component: 'UserManager',
    feature: 'profile-update'
  });
  
  // Business logic
  return { success: true };
}, { id: 'tracked-handler' });
```

## Pipeline Debugging

### `controller.enableDebug()`

Enables debug logging for the current pipeline.

```typescript
useActionHandler('debuggableAction', (payload, controller) => {
  if (process.env.NODE_ENV === 'development') {
    controller.enableDebug();
  }
  
  controller.setResult({ step: 'debug-setup', enabled: true });
  return { debugEnabled: true };
}, { priority: 100 });
```

### `controller.log(message, data?)`

Logs debug information during pipeline execution.

**Parameters:**
- `message`: Log message
- `data?`: Optional data to log

```typescript
useActionHandler('verboseHandler', async (payload, controller) => {
  controller.log('Starting user validation');
  
  const user = await userService.getUser(payload.userId);
  controller.log('User retrieved', { userId: user.id, name: user.name });
  
  const isValid = validateUser(user);
  controller.log('Validation completed', { isValid });
  
  if (!isValid) {
    controller.log('Validation failed - aborting');
    controller.abort('User validation failed');
  }
  
  return { user, validated: true };
});
```

## Pipeline Metrics

### `controller.recordMetric(name, value)`

Records a custom metric for the current execution.

**Parameters:**
- `name`: Metric name
- `value`: Metric value

```typescript
useActionHandler('performanceTrackedAction', async (payload, controller) => {
  const startTime = performance.now();
  
  try {
    const result = await expensiveOperation(payload);
    
    const duration = performance.now() - startTime;
    controller.recordMetric('execution_time', duration);
    controller.recordMetric('payload_size', JSON.stringify(payload).length);
    controller.recordMetric('result_size', JSON.stringify(result).length);
    
    return result;
    
  } catch (error) {
    const duration = performance.now() - startTime;
    controller.recordMetric('error_time', duration);
    controller.recordMetric('error_type', error.constructor.name);
    
    controller.abort(`Operation failed after ${duration}ms: ${error.message}`);
  }
});
```

## Best Practices

### 1. Error Handling
- Use `abort()` for critical failures that should stop execution
- Use result sharing for non-critical errors
- Implement proper error recovery strategies

### 2. Payload Management
- Modify payloads early in the pipeline (high priority)
- Validate payload modifications for type safety
- Document payload structure changes

### 3. Result Coordination
- Use meaningful result structures for inter-handler communication
- Include step identifiers and success flags
- Share results that other handlers might need

### 4. Performance
- Set appropriate timeouts for long-running handlers
- Record metrics for performance monitoring
- Use pipeline state for expensive computations

### 5. Debugging
- Enable debug mode in development
- Use descriptive log messages
- Include relevant context in logs

## Related

- **[Action Only Methods](./action-only)** - Action dispatching and handler registration
- **[Action Registry API](./action-registry)** - Registry management methods
- **[Action Only Example](../examples/action-only)** - Complete usage examples

---


# Api Store Manager

**Source**: `api/store-manager.md`  
**Priority**: 75 (important)  

# Store Manager API

Complete API reference for the Store Manager object returned by `useStoreManager()`.

## Overview

The Store Manager provides advanced operations for managing multiple stores within a Declarative Store Pattern context. It offers bulk operations, state export/import, and administrative controls.

## Core Methods

### `storeManager.getStore(storeName)`

Gets a specific store instance by name.

**Parameters:**
- `storeName`: Key of the store from configuration

**Returns:** Store instance

```typescript
function AdminComponent() {
  const storeManager = useStoreManager();
  
  const userStore = storeManager.getStore('user');
  const settingsStore = storeManager.getStore('settings');
  
  // Use stores directly
  const currentUser = userStore.getValue();
  settingsStore.setValue({ theme: 'dark', language: 'en' });
}
```

### `storeManager.getAllStores()`

Gets all store instances as a map.

**Returns:** `Map<string, Store<any>>`

```typescript
function StoreInspector() {
  const storeManager = useStoreManager();
  
  const inspectAllStores = () => {
    const stores = storeManager.getAllStores();
    
    for (const [name, store] of stores) {
      console.log(`Store ${name}:`, store.getValue());
    }
  };
  
  return <button onClick={inspectAllStores}>Inspect Stores</button>;
}
```

### `storeManager.resetStore(storeName)`

Resets a specific store to its initial value.

**Parameters:**
- `storeName`: Key of the store to reset

**Returns:** `void`

```typescript
function ResetControls() {
  const storeManager = useStoreManager();
  
  const resetUser = () => {
    storeManager.resetStore('user');
    console.log('User store reset to initial state');
  };
  
  return <button onClick={resetUser}>Reset User</button>;
}
```

### `storeManager.resetAll()`

Resets all stores to their initial values.

**Returns:** `void`

```typescript
function GlobalReset() {
  const storeManager = useStoreManager();
  
  const resetApplication = () => {
    if (confirm('Reset all application data?')) {
      storeManager.resetAll();
      console.log('All stores reset to initial state');
    }
  };
  
  return <button onClick={resetApplication}>Reset All Data</button>;
}
```

## State Management

### `storeManager.exportState()`

Exports the current state of all stores.

**Returns:** Object with all store values

```typescript
function StateExporter() {
  const storeManager = useStoreManager();
  
  const exportToJson = () => {
    const state = storeManager.exportState();
    const json = JSON.stringify(state, null, 2);
    
    // Download as file
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'app-state.json';
    a.click();
    URL.revokeObjectURL(url);
  };
  
  return <button onClick={exportToJson}>Export State</button>;
}
```

### `storeManager.importState(state)`

Imports state data to all stores.

**Parameters:**
- `state`: Object containing store values

**Returns:** `void`

```typescript
function StateImporter() {
  const storeManager = useStoreManager();
  
  const importFromFile = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const state = JSON.parse(e.target?.result as string);
        storeManager.importState(state);
        console.log('State imported successfully');
      } catch (error) {
        console.error('Failed to import state:', error);
      }
    };
    reader.readAsText(file);
  };
  
  return (
    <div>
      <input type="file" accept=".json" onChange={importFromFile} />
      <label>Import State from JSON</label>
    </div>
  );
}
```

### `storeManager.getStoreNames()`

Gets the names of all available stores.

**Returns:** `string[]`

```typescript
function StoreList() {
  const storeManager = useStoreManager();
  
  const storeNames = storeManager.getStoreNames();
  
  return (
    <div>
      <h3>Available Stores:</h3>
      <ul>
        {storeNames.map(name => (
          <li key={name}>{name}</li>
        ))}
      </ul>
    </div>
  );
}
```

## Advanced Operations

### Bulk Store Operations

```typescript
function BulkOperations() {
  const storeManager = useStoreManager();
  
  const resetUserRelatedStores = () => {
    const userStores = ['user', 'userPreferences', 'userSettings'];
    
    userStores.forEach(storeName => {
      if (storeManager.getStoreNames().includes(storeName)) {
        storeManager.resetStore(storeName);
      }
    });
  };
  
  const exportUserData = () => {
    const fullState = storeManager.exportState();
    const userData = {
      user: fullState.user,
      userPreferences: fullState.userPreferences,
      userSettings: fullState.userSettings
    };
    
    return userData;
  };
  
  return (
    <div>
      <button onClick={resetUserRelatedStores}>Reset User Data</button>
      <button onClick={() => console.log(exportUserData())}>Export User Data</button>
    </div>
  );
}
```

### Store Validation

```typescript
function StoreValidator() {
  const storeManager = useStoreManager();
  
  const validateAllStores = () => {
    const stores = storeManager.getAllStores();
    const validation = {
      valid: true,
      errors: [] as string[]
    };
    
    for (const [name, store] of stores) {
      const value = store.getValue();
      
      // Custom validation logic
      if (!validateStoreValue(name, value)) {
        validation.valid = false;
        validation.errors.push(`Store ${name} has invalid value`);
      }
    }
    
    return validation;
  };
  
  const fixInvalidStores = () => {
    const validation = validateAllStores();
    
    if (!validation.valid) {
      console.warn('Invalid stores found:', validation.errors);
      
      // Reset invalid stores
      validation.errors.forEach(error => {
        const storeName = error.match(/Store (\w+)/)?.[1];
        if (storeName) {
          storeManager.resetStore(storeName);
        }
      });
    }
  };
  
  return (
    <div>
      <button onClick={() => console.log(validateAllStores())}>
        Validate Stores
      </button>
      <button onClick={fixInvalidStores}>
        Fix Invalid Stores
      </button>
    </div>
  );
}
```

### Store Synchronization

```typescript
function StoreSynchronizer() {
  const storeManager = useStoreManager();
  
  const syncToLocalStorage = () => {
    const state = storeManager.exportState();
    localStorage.setItem('app-state', JSON.stringify(state));
  };
  
  const syncFromLocalStorage = () => {
    try {
      const saved = localStorage.getItem('app-state');
      if (saved) {
        const state = JSON.parse(saved);
        storeManager.importState(state);
      }
    } catch (error) {
      console.error('Failed to sync from localStorage:', error);
    }
  };
  
  // Auto-sync on state changes
  useEffect(() => {
    const stores = storeManager.getAllStores();
    const unsubscribers: (() => void)[] = [];
    
    // Subscribe to all store changes
    for (const [name, store] of stores) {
      const unsubscribe = store.subscribe(() => {
        // Debounce to avoid excessive saves
        debouncedSyncToLocalStorage();
      });
      unsubscribers.push(unsubscribe);
    }
    
    return () => {
      unsubscribers.forEach(unsub => unsub());
    };
  }, []);
  
  return (
    <div>
      <button onClick={syncToLocalStorage}>Save to Local Storage</button>
      <button onClick={syncFromLocalStorage}>Load from Local Storage</button>
    </div>
  );
}
```

## Store Manager Utilities

### Store Statistics

```typescript
function StoreStatistics() {
  const storeManager = useStoreManager();
  
  const getStoreStats = () => {
    const stores = storeManager.getAllStores();
    const stats = {
      totalStores: stores.size,
      storeDetails: [] as Array<{
        name: string;
        hasValue: boolean;
        valueType: string;
        size: number;
      }>
    };
    
    for (const [name, store] of stores) {
      const value = store.getValue();
      stats.storeDetails.push({
        name,
        hasValue: value !== null && value !== undefined,
        valueType: typeof value,
        size: JSON.stringify(value).length
      });
    }
    
    return stats;
  };
  
  return (
    <div>
      <button onClick={() => console.table(getStoreStats().storeDetails)}>
        Show Store Statistics
      </button>
    </div>
  );
}
```

### Store Health Monitoring

```typescript
function StoreHealthMonitor() {
  const storeManager = useStoreManager();
  const [health, setHealth] = useState<Record<string, boolean>>({});
  
  useEffect(() => {
    const checkHealth = () => {
      const stores = storeManager.getAllStores();
      const healthStatus: Record<string, boolean> = {};
      
      for (const [name, store] of stores) {
        try {
          const value = store.getValue();
          healthStatus[name] = value !== null && value !== undefined;
        } catch (error) {
          healthStatus[name] = false;
        }
      }
      
      setHealth(healthStatus);
    };
    
    // Check health every 30 seconds
    const interval = setInterval(checkHealth, 30000);
    checkHealth(); // Initial check
    
    return () => clearInterval(interval);
  }, [storeManager]);
  
  return (
    <div className="store-health">
      <h3>Store Health Status</h3>
      {Object.entries(health).map(([storeName, isHealthy]) => (
        <div key={storeName} className={`health-item ${isHealthy ? 'healthy' : 'unhealthy'}`}>
          <span>{storeName}:</span>
          <span>{isHealthy ? '✅ Healthy' : '❌ Unhealthy'}</span>
        </div>
      ))}
    </div>
  );
}
```

## Error Handling

### Store Manager Error Recovery

```typescript
function StoreManagerErrorHandler() {
  const storeManager = useStoreManager();
  
  const handleStoreError = (storeName: string, error: Error) => {
    console.error(`Store ${storeName} error:`, error);
    
    // Try to recover by resetting the store
    try {
      storeManager.resetStore(storeName);
      console.log(`Store ${storeName} reset successfully`);
    } catch (resetError) {
      console.error(`Failed to reset store ${storeName}:`, resetError);
    }
  };
  
  const safeStoreOperation = <T>(
    operation: () => T,
    storeName: string
  ): T | null => {
    try {
      return operation();
    } catch (error) {
      handleStoreError(storeName, error as Error);
      return null;
    }
  };
  
  return { safeStoreOperation };
}
```

## Related

- **[Store Only Methods](./store-only)** - Individual store methods
- **[Declarative Store Pattern](./declarative-store-pattern)** - Pattern implementation
- **[Store Only Example](../examples/store-only)** - Complete usage examples

---


# Api Store Only

**Source**: `api/store-only.md`  
**Priority**: 75 (important)  

# Store Only Methods

Complete API reference for Store Only Pattern methods from `createDeclarativeStorePattern`.

## Overview

The Store Only Pattern provides type-safe state management without action dispatching. This pattern is ideal for data layers, simple state management, and scenarios where you need reactive state without complex business logic.

## Core Methods

### `createDeclarativeStorePattern<T>(contextName, storeConfig)`

Creates a declarative store pattern with type-safe state management.

**Parameters:**
- `contextName`: Unique identifier for the store context
- `storeConfig`: Configuration object defining stores and their initial values

**Returns:**
```typescript
{
  Provider: React.ComponentType,
  useStore: (storeName: keyof T) => Store<T[storeName]>,
  useStoreManager: () => StoreManager<T>,
  withProvider: (Component: React.ComponentType) => React.ComponentType
}
```

**Example:**
```typescript
const { Provider, useStore, useStoreManager, withProvider } = 
  createDeclarativeStorePattern('App', {
    user: { id: '', name: '', email: '' },
    settings: { theme: 'light', language: 'en' }
  });
```

## Store Instance Methods

### `store.getValue()`

Returns the current value of the store synchronously.

**Returns:** Current store value
**Use Case:** Reading current state in action handlers or effects

```typescript
const userStore = useStore('user');
const currentUser = userStore.getValue();
console.log('Current user:', currentUser);
```

### `store.setValue(newValue)`

Sets the entire store value, replacing the current state.

**Parameters:**
- `newValue`: Complete new value for the store

**Returns:** `void`

```typescript
const userStore = useStore('user');
userStore.setValue({
  id: '123',
  name: 'John Doe',
  email: 'john@example.com'
});
```

### `store.update(updater)`

Updates the store using an updater function that receives the current value.

**Parameters:**
- `updater`: Function that receives current value and returns new value

**Returns:** `void`

```typescript
const userStore = useStore('user');
userStore.update(current => ({
  ...current,
  name: 'Updated Name'
}));
```

### `store.subscribe(callback)`

Subscribes to store changes with a callback function.

**Parameters:**
- `callback`: Function called when store value changes

**Returns:** Unsubscribe function

```typescript
const userStore = useStore('user');
const unsubscribe = userStore.subscribe((newValue, previousValue) => {
  console.log('User changed:', { newValue, previousValue });
});

// Cleanup
useEffect(() => unsubscribe, []);
```

### `store.reset()`

Resets the store to its initial value.

**Returns:** `void`

```typescript
const userStore = useStore('user');
userStore.reset(); // Back to initial state
```

## Store Configuration Options

### Basic Configuration

Simple value initialization:

```typescript
const config = {
  user: { id: '', name: '', email: '' },
  settings: { theme: 'light', language: 'en' }
};
```

### Advanced Configuration

With validators and custom initial values:

```typescript
const config = {
  user: {
    initialValue: { id: '', name: '', email: '' },
    validator: (value) => typeof value === 'object' && 'id' in value
  },
  settings: {
    initialValue: { theme: 'light', language: 'en' },
    validator: (value) => 
      typeof value === 'object' && 
      'theme' in value && 
      ['light', 'dark'].includes(value.theme)
  }
};
```

## React Integration Hooks

### `useStoreValue(store)`

Hook for reactive store subscriptions in components.

**Parameters:**
- `store`: Store instance from `useStore()`

**Returns:** Current store value (reactive)

```typescript
function UserComponent() {
  const userStore = useStore('user');
  const user = useStoreValue(userStore); // Reactive subscription
  
  return <div>Welcome {user.name}</div>;
}
```

### `useStore(storeName)`

Hook to get a store instance by name.

**Parameters:**
- `storeName`: Key of the store from configuration

**Returns:** Store instance with methods

```typescript
function UserComponent() {
  const userStore = useStore('user');
  const settingsStore = useStore('settings');
  
  // Use store methods
  const handleUpdate = () => {
    userStore.update(current => ({ ...current, name: 'New Name' }));
  };
  
  return <button onClick={handleUpdate}>Update User</button>;
}
```

### `useStoreManager()`

Hook to get the store manager for advanced operations.

**Returns:** StoreManager instance

```typescript
function AdminPanel() {
  const storeManager = useStoreManager();
  
  const resetAllStores = () => {
    storeManager.resetAll();
  };
  
  const exportState = () => {
    const state = storeManager.exportState();
    console.log('Current state:', state);
  };
  
  return (
    <div>
      <button onClick={resetAllStores}>Reset All</button>
      <button onClick={exportState}>Export State</button>
    </div>
  );
}
```

## Store Configuration Patterns

### Simple Value Pattern

Direct value assignment for simple types:

```typescript
const simpleConfig = {
  counter: 0,
  username: '',
  isLoggedIn: false,
  theme: 'light'
};
```

### Object Pattern

Complex objects with initial state:

```typescript
const objectConfig = {
  user: {
    id: '',
    profile: {
      name: '',
      email: '',
      avatar: null as string | null
    },
    preferences: {
      notifications: true,
      theme: 'light'
    }
  }
};
```

### Validated Pattern

Stores with validation functions:

```typescript
const validatedConfig = {
  settings: {
    initialValue: { theme: 'light', fontSize: 14 },
    validator: (value) => {
      return typeof value === 'object' &&
        'theme' in value &&
        'fontSize' in value &&
        ['light', 'dark'].includes(value.theme) &&
        typeof value.fontSize === 'number' &&
        value.fontSize >= 10 && value.fontSize <= 24;
    }
  }
};
```

## Advanced Store Operations

### Conditional Updates

```typescript
function ConditionalUpdater() {
  const userStore = useStore('user');
  
  const updateIfLoggedIn = () => {
    const current = userStore.getValue();
    if (current.isAuthenticated) {
      userStore.update(user => ({
        ...user,
        lastActivity: Date.now()
      }));
    }
  };
  
  return <button onClick={updateIfLoggedIn}>Update Activity</button>;
}
```

### Computed Values

```typescript
function ComputedValues() {
  const userStore = useStore('user');
  const settingsStore = useStore('settings');
  
  const user = useStoreValue(userStore);
  const settings = useStoreValue(settingsStore);
  
  // Computed values based on multiple stores
  const displayName = user.name || user.email?.split('@')[0] || 'Anonymous';
  const isDarkTheme = settings.theme === 'dark';
  
  return (
    <div className={isDarkTheme ? 'dark' : 'light'}>
      Welcome {displayName}
    </div>
  );
}
```

### Store Synchronization

```typescript
function StoreSynchronizer() {
  const userStore = useStore('user');
  const cacheStore = useStore('cache');
  
  // Sync user changes to cache
  useEffect(() => {
    return userStore.subscribe((newUser) => {
      cacheStore.update(cache => ({
        ...cache,
        lastUser: newUser,
        lastUpdated: Date.now()
      }));
    });
  }, [userStore, cacheStore]);
  
  return null;
}
```

## Performance Optimization

### Selective Subscriptions

```typescript
function OptimizedComponent() {
  const userStore = useStore('user');
  
  // Only subscribe to specific changes
  const userName = useStoreValue(userStore, user => user.name);
  const userEmail = useStoreValue(userStore, user => user.email);
  
  // Component only re-renders when name or email changes
  return <div>{userName} ({userEmail})</div>;
}
```

### Batched Updates

```typescript
function BatchedUpdates() {
  const userStore = useStore('user');
  
  const updateUserProfile = () => {
    // Single update with all changes
    userStore.update(current => ({
      ...current,
      name: 'New Name',
      email: 'new@email.com',
      lastUpdated: Date.now()
    }));
  };
  
  return <button onClick={updateUserProfile}>Update Profile</button>;
}
```

## Error Handling

### Validation Errors

```typescript
function ValidatedStore() {
  const settingsStore = useStore('settings');
  
  const updateTheme = (theme: string) => {
    try {
      settingsStore.update(current => ({
        ...current,
        theme: theme as 'light' | 'dark'
      }));
    } catch (error) {
      console.error('Theme update failed:', error);
      // Handle validation error
    }
  };
  
  return <button onClick={() => updateTheme('dark')}>Dark Theme</button>;
}
```

## Related

- **[Store Manager API](./store-manager)** - Store manager methods and operations
- **[Declarative Store Pattern](./declarative-store-pattern)** - Pattern implementation details
- **[Store Only Example](../examples/store-only)** - Complete usage examples

---


# Basic Setup Examples

**Source**: `examples/basic-setup.md`  
**Priority**: 75 (important)  

# Basic Setup

This example shows the fundamental setup of Context-Action framework with both Action Only and Store Only patterns.

## Installation

First, install the required packages:

```bash
npm install @context-action/core @context-action/react
# or
pnpm add @context-action/core @context-action/react
# or  
yarn add @context-action/core @context-action/react
```

## Project Structure

```
src/
├── contexts/
│   ├── actions.tsx          # Action contexts
│   └── stores.tsx           # Store patterns
├── components/
│   ├── App.tsx              # Main application
│   ├── UserProfile.tsx      # User profile component
│   └── EventLogger.tsx      # Event logging component
└── types/
    └── actions.ts           # Action type definitions
```

## Step 1: Define Action Types

Create type definitions for your actions:

```typescript
// src/types/actions.ts
import type { ActionPayloadMap } from '@context-action/core';

export interface AppActions extends ActionPayloadMap {
  // User actions
  updateProfile: { name: string; email: string };
  login: { username: string; password: string };
  logout: void;
  
  // Event tracking
  trackEvent: { event: string; data: any };
  logError: { error: string; context: any };
  
  // UI actions
  showNotification: { message: string; type: 'success' | 'error' | 'info' };
  hideNotification: void;
}
```

## Step 2: Create Action Context

Set up the Action Only pattern for business logic:

```typescript
// src/contexts/actions.tsx
import { createActionContext } from '@context-action/react';
import type { AppActions } from '../types/actions';

export const {
  Provider: AppActionProvider,
  useActionDispatch: useAppAction,
  useActionHandler: useAppActionHandler
} = createActionContext<AppActions>('App');
```

## Step 3: Create Store Pattern

Set up the Store Only pattern for state management:

```typescript
// src/contexts/stores.tsx
import { createDeclarativeStorePattern } from '@context-action/react';

export const {
  Provider: AppStoreProvider,
  useStore: useAppStore,
  useStoreManager: useAppStoreManager,
  withProvider: withAppStoreProvider
} = createDeclarativeStorePattern('App', {
  // User state
  user: {
    id: '',
    name: '',
    email: '',
    isAuthenticated: false
  },
  
  // UI state
  ui: {
    loading: false,
    notification: null as { message: string; type: 'success' | 'error' | 'info' } | null
  },
  
  // Application settings
  settings: {
    initialValue: { theme: 'light', language: 'en' },
    validator: (value) => 
      typeof value === 'object' && 
      'theme' in value && 
      'language' in value
  }
});
```

## Step 4: Main Application Setup

Combine both patterns in your main app component:

```typescript
// src/components/App.tsx
import React from 'react';
import { AppActionProvider } from '../contexts/actions';
import { withAppStoreProvider } from '../contexts/stores';
import { UserProfile } from './UserProfile';
import { EventLogger } from './EventLogger';

// Use HOC pattern to automatically wrap with store provider
const App = withAppStoreProvider(() => (
  <AppActionProvider>
    <div className="app">
      <header>
        <h1>Context-Action Example</h1>
      </header>
      
      <main>
        <UserProfile />
        <EventLogger />
      </main>
    </div>
  </AppActionProvider>
));

export default App;
```

## Step 5: User Profile Component

Example component using both patterns:

```typescript
// src/components/UserProfile.tsx
import React, { useCallback } from 'react';
import { useStoreValue } from '@context-action/react';
import { useAppAction, useAppActionHandler } from '../contexts/actions';
import { useAppStore } from '../contexts/stores';

export function UserProfile() {
  const dispatch = useAppAction();
  const userStore = useAppStore('user');
  const uiStore = useAppStore('ui');
  
  // Subscribe to store values
  const user = useStoreValue(userStore);
  const ui = useStoreValue(uiStore);
  
  // Register action handlers
  useAppActionHandler('updateProfile', useCallback(async (payload, controller) => {
    try {
      // Set loading state
      uiStore.update(current => ({ ...current, loading: true }));
      
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Update user store
      userStore.update(current => ({
        ...current,
        name: payload.name,
        email: payload.email
      }));
      
      // Show success notification
      dispatch('showNotification', {
        message: 'Profile updated successfully!',
        type: 'success'
      });
      
    } catch (error) {
      // Handle error
      dispatch('logError', {
        error: (error as Error).message,
        context: { component: 'UserProfile', action: 'updateProfile' }
      });
      
      controller.abort('Profile update failed');
    } finally {
      // Clear loading state
      uiStore.update(current => ({ ...current, loading: false }));
    }
  }, [dispatch, userStore, uiStore]));
  
  // Login handler
  useAppActionHandler('login', useCallback(async (payload) => {
    uiStore.update(current => ({ ...current, loading: true }));
    
    try {
      // Simulate login API call
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      // Update user state
      userStore.setValue({
        id: '123',
        name: 'John Doe',
        email: payload.username + '@example.com',
        isAuthenticated: true
      });
      
      dispatch('trackEvent', {
        event: 'user_login',
        data: { username: payload.username, timestamp: Date.now() }
      });
      
    } catch (error) {
      dispatch('showNotification', {
        message: 'Login failed. Please try again.',
        type: 'error'
      });
    } finally {
      uiStore.update(current => ({ ...current, loading: false }));
    }
  }, [dispatch, userStore, uiStore]));
  
  // Notification handler
  useAppActionHandler('showNotification', useCallback((payload) => {
    uiStore.update(current => ({
      ...current,
      notification: { message: payload.message, type: payload.type }
    }));
    
    // Auto-hide notification after 3 seconds
    setTimeout(() => {
      dispatch('hideNotification');
    }, 3000);
  }, [dispatch, uiStore]));
  
  useAppActionHandler('hideNotification', useCallback(() => {
    uiStore.update(current => ({ ...current, notification: null }));
  }, [uiStore]));
  
  // Event handlers
  const handleUpdateProfile = () => {
    dispatch('updateProfile', {
      name: 'John Doe Updated',
      email: 'john.updated@example.com'
    });
  };
  
  const handleLogin = () => {
    dispatch('login', {
      username: 'john.doe',
      password: 'secret123'
    });
  };
  
  const handleLogout = () => {
    userStore.setValue({
      id: '',
      name: '',
      email: '',
      isAuthenticated: false
    });
    
    dispatch('trackEvent', {
      event: 'user_logout',
      data: { timestamp: Date.now() }
    });
  };
  
  return (
    <div className="user-profile">
      <h2>User Profile</h2>
      
      {/* Loading indicator */}
      {ui.loading && <div className="loading">Loading...</div>}
      
      {/* Notification */}
      {ui.notification && (
        <div className={`notification notification--${ui.notification.type}`}>
          {ui.notification.message}
        </div>
      )}
      
      {/* User info */}
      {user.isAuthenticated ? (
        <div className="user-info">
          <p><strong>ID:</strong> {user.id}</p>
          <p><strong>Name:</strong> {user.name}</p>
          <p><strong>Email:</strong> {user.email}</p>
          
          <div className="actions">
            <button onClick={handleUpdateProfile} disabled={ui.loading}>
              Update Profile
            </button>
            <button onClick={handleLogout}>
              Logout
            </button>
          </div>
        </div>
      ) : (
        <div className="login-form">
          <p>Please log in to continue</p>
          <button onClick={handleLogin} disabled={ui.loading}>
            Login as John Doe
          </button>
        </div>
      )}
    </div>
  );
}
```

## Step 6: Event Logger Component

Component that handles event tracking:

```typescript
// src/components/EventLogger.tsx
import React, { useCallback, useState } from 'react';
import { useAppActionHandler } from '../contexts/actions';

export function EventLogger() {
  const [events, setEvents] = useState<Array<{ event: string; data: any; timestamp: number }>>([]);
  const [errors, setErrors] = useState<Array<{ error: string; context: any; timestamp: number }>>([]);
  
  // Register event tracking handler
  useAppActionHandler('trackEvent', useCallback((payload) => {
    const eventLog = {
      event: payload.event,
      data: payload.data,
      timestamp: Date.now()
    };
    
    setEvents(current => [...current, eventLog]);
    console.log('Event tracked:', eventLog);
    
    // In a real app, send to analytics service
    // analytics.track(payload.event, payload.data);
  }, []));
  
  // Register error logging handler
  useAppActionHandler('logError', useCallback((payload) => {
    const errorLog = {
      error: payload.error,
      context: payload.context,
      timestamp: Date.now()
    };
    
    setErrors(current => [...current, errorLog]);
    console.error('Error logged:', errorLog);
    
    // In a real app, send to error reporting service
    // errorReporter.captureException(payload.error, payload.context);
  }, []));
  
  return (
    <div className="event-logger">
      <h2>Event Logger</h2>
      
      {/* Recent Events */}
      <div className="events-section">
        <h3>Recent Events ({events.length})</h3>
        <div className="log-container">
          {events.slice(-5).reverse().map((event, index) => (
            <div key={index} className="log-entry log-entry--event">
              <div className="log-time">
                {new Date(event.timestamp).toLocaleTimeString()}
              </div>
              <div className="log-content">
                <strong>{event.event}</strong>
                <pre>{JSON.stringify(event.data, null, 2)}</pre>
              </div>
            </div>
          ))}
        </div>
      </div>
      
      {/* Recent Errors */}
      <div className="errors-section">
        <h3>Recent Errors ({errors.length})</h3>
        <div className="log-container">
          {errors.slice(-3).reverse().map((error, index) => (
            <div key={index} className="log-entry log-entry--error">
              <div className="log-time">
                {new Date(error.timestamp).toLocaleTimeString()}
              </div>
              <div className="log-content">
                <strong>Error:</strong> {error.error}
                <pre>{JSON.stringify(error.context, null, 2)}</pre>
              </div>
            </div>
          ))}
        </div>
      </div>
      
      {/* Clear buttons */}
      <div className="actions">
        <button onClick={() => setEvents([])}>
          Clear Events
        </button>
        <button onClick={() => setErrors([])}>
          Clear Errors
        </button>
      </div>
    </div>
  );
}
```

## Step 7: Basic Styles

Add some basic CSS for the example:

```css
/* src/App.css */
.app {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  font-family: -apple-system, BlinkMacSystemFont, sans-serif;
}

.user-profile, .event-logger {
  background: #f5f5f5;
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 20px;
}

.loading {
  color: #007bff;
  font-weight: bold;
  margin-bottom: 10px;
}

.notification {
  padding: 10px;
  border-radius: 4px;
  margin-bottom: 15px;
}

.notification--success { background: #d4edda; color: #155724; }
.notification--error { background: #f8d7da; color: #721c24; }
.notification--info { background: #d1ecf1; color: #0c5460; }

.user-info {
  background: white;
  padding: 15px;
  border-radius: 4px;
  margin-bottom: 15px;
}

.actions {
  display: flex;
  gap: 10px;
  margin-top: 15px;
}

.actions button {
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  background: #007bff;
  color: white;
  cursor: pointer;
}

.actions button:hover {
  background: #0056b3;
}

.actions button:disabled {
  background: #ccc;
  cursor: not-allowed;
}

.log-container {
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
}

.log-entry {
  padding: 10px;
  border-bottom: 1px solid #eee;
  display: flex;
  gap: 10px;
}

.log-entry--event {
  border-left: 4px solid #28a745;
}

.log-entry--error {
  border-left: 4px solid #dc3545;
}

.log-time {
  color: #666;
  font-size: 0.9em;
  min-width: 80px;
}

.log-content pre {
  font-size: 0.8em;
  background: #f8f9fa;
  padding: 5px;
  border-radius: 2px;
  margin: 5px 0 0 0;
}
```

## Key Concepts Demonstrated

This example demonstrates several key Context-Action concepts:

### 1. Pattern Separation
- **Action Only Pattern** for business logic and events
- **Store Only Pattern** for state management
- Clear separation between actions and state

### 2. MVVM Architecture
- **View Layer**: React components (`UserProfile`, `EventLogger`)
- **ViewModel Layer**: Action handlers with business logic
- **Model Layer**: Store pattern for data management

### 3. Handler Registration
- Handlers registered in components using `useAppActionHandler`
- Priority-based execution (implicit default priority)
- Proper cleanup with `useCallback` dependencies

### 4. Store Management
- Reactive subscriptions with `useStoreValue`
- Store updates with `setValue()` and `update()`
- Type-safe store access

### 5. Error Handling
- Graceful error handling in action handlers
- Error logging and user feedback
- Pipeline control with `controller.abort()`

### 6. Event System
- Event tracking for analytics
- Error logging for monitoring
- Separation of concerns between different event types

## Running the Example

1. Set up a new React project
2. Install the dependencies
3. Copy the code files to your project
4. Add the CSS styles
5. Start the development server

```bash
npm create react-app context-action-example --template typescript
cd context-action-example
npm install @context-action/core @context-action/react
# Copy the files above
npm start
```

## Next Steps

- **[Action Only Pattern](./action-only)** - Deep dive into pure action dispatching
- **[Store Only Pattern](./store-only)** - Focus on state management patterns
- **[Pattern Composition](./pattern-composition)** - Advanced pattern combinations

---


# Concept Action Pipeline Guide

**Source**: `concept/action-pipeline-guide.md`  
**Priority**: 50 (reference)  

# Action Pipeline Guide: ActionPayloadMap & ActionRegister

Complete guide to building type-safe action pipelines with Context-Action framework.

## Table of Contents

- [Overview](#overview)
- [ActionPayloadMap: Type Foundation](#actionpayloadmap-type-foundation)
- [ActionRegister: Pipeline Engine](#actionregister-pipeline-engine)
- [Handler Registration Patterns](#handler-registration-patterns)
- [Pipeline Execution Strategies](#pipeline-execution-strategies)
- [Advanced Pipeline Patterns](#advanced-pipeline-patterns)
- [Real-world Examples](#real-world-examples)
- [Best Practices](#best-practices)
- [Troubleshooting](#troubleshooting)

## Overview

The Context-Action framework's action pipeline system provides type-safe, scalable business logic management through two core components:

- **ActionPayloadMap**: TypeScript interface defining action-to-payload type mappings
- **ActionRegister**: Central pipeline engine managing handler registration and execution

```typescript
// The complete pipeline flow
ActionPayloadMap → ActionRegister → Handler Registration → Pipeline Execution
```

## ActionPayloadMap: Type Foundation

### Basic Concept

ActionPayloadMap is a TypeScript interface that maps action names to their payload types, providing compile-time type safety throughout the pipeline.

```typescript
import { ActionPayloadMap } from '@context-action/core';

// Define your application's actions
interface AppActions extends ActionPayloadMap {
  // Action with object payload
  updateUser: { id: string; name: string; email?: string };
  
  // Action with primitive payload
  setTheme: 'light' | 'dark';
  
  // Action without payload
  logout: void;
  
  // Action with complex payload
  submitOrder: {
    items: Array<{ id: string; quantity: number; price: number }>;
    shipping: { address: string; method: 'standard' | 'express' };
    payment: { method: 'card' | 'paypal'; token: string };
  };
  
  // Action with union types
  showNotification: {
    type: 'success' | 'error' | 'warning' | 'info';
    message: string;
    duration?: number;
  };
}
```

### Advanced Type Patterns

#### Generic Payload Types

```typescript
interface CrudActions<T> extends ActionPayloadMap {
  create: T;
  update: { id: string } & Partial<T>;
  delete: { id: string };
  fetch: { id: string };
  list: { 
    filters?: Record<string, any>;
    pagination?: { page: number; limit: number };
  };
}

// Usage with specific types
interface UserActions extends CrudActions<User> {
  // Inherits: create: User, update: { id: string } & Partial<User>, etc.
  
  // Additional user-specific actions
  changePassword: { oldPassword: string; newPassword: string };
  uploadAvatar: { file: File };
}
```

#### Conditional Payload Types

```typescript
interface ConditionalActions extends ActionPayloadMap {
  // Payload type depends on mode
  saveData: {
    mode: 'auto';
  } | {
    mode: 'manual';
    data: any;
    validation: boolean;
  };
  
  // Optional payload based on context
  refresh: {
    force?: boolean;
    scope?: 'all' | 'current' | string[];
  } | void;
}
```

### Type Safety Benefits

1. **Compile-time Validation**: TypeScript ensures correct payload types
2. **IntelliSense Support**: Auto-completion for action names and payload properties
3. **Refactoring Safety**: Renaming actions or changing payload structure is type-checked
4. **Documentation**: Types serve as living documentation of your API

## ActionRegister: Pipeline Engine

### Core Architecture

ActionRegister is the central orchestrator that manages the action pipeline lifecycle:

```typescript
import { ActionRegister, ActionRegisterConfig } from '@context-action/core';

// Create typed ActionRegister
const actionRegister = new ActionRegister<AppActions>({
  name: 'AppActionRegister',
  registry: {
    debug: true,
    autoCleanup: true,
    maxHandlers: 50,
    defaultExecutionMode: 'sequential'
  }
});
```

### Configuration Options

```typescript
interface ActionRegisterConfig {
  /** Name identifier for this ActionRegister instance */
  name?: string;
  
  /** Registry-specific configuration options */
  registry?: {
    /** Debug mode for registry operations */
    debug?: boolean;
    
    /** Auto-cleanup configuration for one-time handlers */
    autoCleanup?: boolean;
    
    /** Maximum number of handlers per action */
    maxHandlers?: number;
    
    /** Default execution mode for actions */
    defaultExecutionMode?: ExecutionMode;
  };
}
```

### Pipeline Lifecycle

```typescript
// 1. Handler Registration Phase
actionRegister.register('updateUser', handler, config);

// 2. Pipeline Dispatch Phase  
await actionRegister.dispatch('updateUser', payload);

// 3. Pipeline Execution Phase (internal)
//    - Priority sorting
//    - Condition evaluation
//    - Handler execution
//    - Flow control
//    - Cleanup
```

## Handler Registration Patterns

### Basic Handler Registration

```typescript
// Simple handler
const unregisterUpdateUser = actionRegister.register(
  'updateUser',
  async (payload, controller) => {
    console.log('Updating user:', payload);
    // Business logic here
    // Handler automatically continues to next handler
  }
);

// Handler with configuration
const unregisterValidation = actionRegister.register(
  'updateUser',
  async (payload, controller) => {
    if (!payload.email?.includes('@')) {
      controller.abort('Invalid email format');
      return;
    }
    
    // Handler automatically continues to next handler
  },
  {
    priority: 100,           // Higher priority runs first
    id: 'email-validator',   // Unique identifier
    blocking: true,          // Wait for completion
    condition: () => isLoggedIn(), // Conditional execution
    tags: ['validation', 'email'], // Handler tags
    category: 'validation',  // Handler category
    description: 'Validates email format for user updates',
    version: '1.0.0',       // Handler version
    timeout: 5000,          // Handler timeout
    environment: 'production', // Target environment
    metrics: {
      collectTiming: true,
      collectErrors: true
    }
  }
);
```

### Multi-Store Coordination

```typescript
interface StoreMap {
  user: UserStore;
  settings: SettingsStore;
  notifications: NotificationStore;
}

actionRegister.register('updateUser', async (payload, controller) => {
  // Access multiple stores
  const userStore = storeRegistry.getStore<UserStore>('user');
  const settingsStore = storeRegistry.getStore<SettingsStore>('settings');
  const notificationStore = storeRegistry.getStore<NotificationStore>('notifications');
  
  // Read current state
  const currentUser = userStore.getValue();
  const settings = settingsStore.getValue();
  
  // Business logic with cross-store coordination
  if (settings.requireEmailVerification && payload.email !== currentUser.email) {
    // Send verification email
    await sendVerificationEmail(payload.email);
    
    // Update user with pending status
    userStore.setValue({
      ...currentUser,
      ...payload,
      emailVerificationPending: true
    });
    
    // Show notification
    notificationStore.setValue({
      type: 'info',
      message: 'Verification email sent to new address',
      duration: 5000
    });
  } else {
    // Direct update
    userStore.setValue({
      ...currentUser,
      ...payload,
      updatedAt: Date.now()
    });
  }
  
  // Handler automatically continues to next handler
}, { priority: 10, blocking: true });
```

### Async Operations with Error Handling

```typescript
actionRegister.register('submitOrder', async (payload, controller) => {
  try {
    // Set loading state
    loadingStore.setValue({ isSubmittingOrder: true });
    
    // Validate inventory
    const inventoryCheck = await validateInventory(payload.items);
    if (!inventoryCheck.valid) {
      throw new Error(`Insufficient inventory: ${inventoryCheck.missing.join(', ')}`);
    }
    
    // Process payment
    const paymentResult = await processPayment(payload.payment);
    if (!paymentResult.success) {
      throw new Error(`Payment failed: ${paymentResult.error}`);
    }
    
    // Create order
    const order = await createOrder({
      ...payload,
      paymentId: paymentResult.id,
      status: 'confirmed'
    });
    
    // Update stores
    ordersStore.update(orders => [...orders, order]);
    cartStore.setValue({ items: [] }); // Clear cart
    
    // Success notification
    notificationStore.setValue({
      type: 'success',
      message: `Order ${order.id} submitted successfully!`,
      duration: 3000
    });
    
    // Handler automatically continues to next handler
    
  } catch (error) {
    // Error handling
    console.error('Order submission failed:', error);
    
    notificationStore.setValue({
      type: 'error',
      message: error.message || 'Order submission failed',
      duration: 5000
    });
    
    controller.abort('Order submission failed', error);
  } finally {
    // Always clear loading state
    loadingStore.setValue({ isSubmittingOrder: false });
  }
}, {
  priority: 10,
  blocking: true,
  debounce: 1000, // Prevent double-submission
});
```

## Pipeline Execution Strategies

### Sequential Execution (Default)

Handlers execute in priority order, waiting for each to complete:

```typescript
// Configure sequential execution
actionRegister.setActionExecutionMode('updateUser', 'sequential');

// Handlers execute in this order:
// 1. Validation (priority: 100)
// 2. Business logic (priority: 50) 
// 3. Logging (priority: 10)
// 4. Analytics (priority: 0)
```

### Parallel Execution

All handlers execute simultaneously:

```typescript
actionRegister.setActionExecutionMode('logAnalytics', 'parallel');

// Good for independent operations:
// - Logging
// - Analytics tracking
// - Cache updates
// - Notifications
```

### Race Execution

First completed handler wins:

```typescript
actionRegister.setActionExecutionMode('fetchUserData', 'race');

// Useful for:
// - Cache vs API race
// - Multiple data sources
// - Timeout scenarios
```

## Advanced Pipeline Patterns

### Handler Filtering System (New)

The ActionRegister now supports advanced handler filtering during dispatch:

```typescript
// Filter handlers by tags
await actionRegister.dispatch('updateUser', payload, {
  filter: {
    tags: ['validation', 'business'],     // Only validation and business handlers
    excludeTags: ['logging', 'analytics'], // Exclude logging handlers
    category: 'critical',                  // Only critical category handlers
    environment: 'production',             // Only production handlers
    feature: 'newUserFlow',               // Only handlers with this feature flag
    handlerIds: ['validator-1', 'saver-2'], // Specific handler IDs
    excludeHandlerIds: ['debug-logger'],   // Exclude specific handlers
    custom: (config) => config.priority > 50 // Custom filter function
  }
});
```

### Result Collection and Processing (New)

Collect and process results from multiple handlers:

```typescript
// Dispatch with result collection
const result = await actionRegister.dispatchWithResult('processOrder', orderData, {
  result: {
    collect: true,                    // Enable result collection
    strategy: 'all',                  // Collect all results
    maxResults: 10,                   // Limit to 10 results
    timeout: 5000,                    // 5 second timeout
    merger: (results) => {            // Custom result merger
      return results.reduce((acc, curr) => ({ ...acc, ...curr }), {});
    }
  }
});

console.log('Execution successful:', result.success);
console.log('Results:', result.results);
console.log('Execution duration:', result.execution.duration);
console.log('Handlers executed:', result.execution.handlersExecuted);
```

### Auto AbortController Management (New)

Automatic AbortController creation and management:

```typescript
let createdController: AbortController | undefined;

await actionRegister.dispatch('longRunningTask', payload, {
  autoAbort: {
    enabled: true,                    // Auto-create AbortController
    allowHandlerAbort: true,          // Handlers can trigger abort
    onControllerCreated: (controller) => {
      createdController = controller; // Access the created controller
      
      // Set up timeout
      setTimeout(() => controller.abort('Timeout'), 10000);
    }
  }
});
```

### Priority-based Validation Pipeline

```typescript
// Validation chain with priorities
actionRegister.register('updateUser', validateRequired, { priority: 100 });
actionRegister.register('updateUser', validateEmail, { priority: 90 });
actionRegister.register('updateUser', validatePassword, { priority: 80 });
actionRegister.register('updateUser', sanitizeInput, { priority: 70 });
actionRegister.register('updateUser', businessLogic, { priority: 50 });
actionRegister.register('updateUser', audit, { priority: 10 });
```

### Conditional Handler Execution

```typescript
actionRegister.register('updateUser', adminOnlyHandler, {
  condition: () => currentUser.role === 'admin',
  priority: 60
});

actionRegister.register('updateUser', premiumFeatureHandler, {
  condition: () => currentUser.subscription === 'premium',
  priority: 55
});
```

### Dynamic Handler Registration

```typescript
// Feature flag based registration
if (featureFlags.newUserValidation) {
  actionRegister.register('updateUser', newValidationHandler, {
    priority: 95,
    id: 'feature-new-validation'
  });
}

// Plugin-based registration
plugins.forEach(plugin => {
  if (plugin.supports('updateUser')) {
    actionRegister.register('updateUser', 
      plugin.getHandler('updateUser'), 
      plugin.getConfig('updateUser')
    );
  }
});
```

### Handler Execution Flow (Updated)

ActionRegister handlers follow a natural execution flow without explicit continuation calls:

#### Handler Termination Patterns

```typescript
actionRegister.register('processData', async (payload, controller) => {
  // Pattern 1: Natural completion - handler continues to next
  if (payload.isValid) {
    await processValidData(payload);
    // Handler naturally completes, pipeline continues to next handler
  }
  
  // Pattern 2: Early return - stops current handler, continues pipeline
  if (!payload.shouldProcess) {
    console.log('Skipping processing');
    return; // Early return, pipeline continues to next handler
  }
  
  // Pattern 3: Explicit abort - stops entire pipeline
  if (payload.hasError) {
    controller.abort('Critical error encountered');
    return; // Pipeline execution stops here
  }
  
  // Pattern 4: Conditional processing with natural flow
  const result = await someAsyncOperation(payload);
  if (result.success) {
    // Process success case
    updateStore(result.data);
  } else {
    // Process error case  
    logError(result.error);
  }
  // Handler completes naturally, continues to next handler
});
```

#### Three Ways to End Handler Execution

1. **Natural Completion**: Handler finishes all statements, automatically continues
2. **Early Return**: Use `return` to exit handler early, pipeline continues
3. **Pipeline Abort**: Use `controller.abort()` to stop entire pipeline execution

### Enhanced PipelineController API (Updated)

The PipelineController now provides extensive control over pipeline execution:

```typescript
actionRegister.register('processData', async (payload, controller) => {
  // 1. Abort pipeline with reason
  if (!payload.isValid) {
    controller.abort('Invalid payload data');
    return;
  }
  
  // 2. Get current payload (might be modified by previous handlers)
  const currentPayload = controller.getPayload();
  
  // 3. Modify payload for next handlers
  controller.modifyPayload(data => ({
    ...data,
    processed: true,
    processedAt: Date.now(),
    processingId: Math.random().toString(36)
  }));
  
  // 4. Set result for collection (pipeline continues)
  const processedResult = await processData(currentPayload);
  controller.setResult(processedResult);
  
  // 5. Get all previous results
  const allResults = controller.getResults();
  console.log('Results so far:', allResults.length);
  
  // 6. Merge current result with previous ones
  controller.mergeResult((previousResults, currentResult) => {
    return {
      combined: previousResults,
      current: currentResult,
      total: previousResults.length + 1
    };
  });
  
  // 7. Jump to specific priority (skip intermediate handlers)
  if (payload.urgent) {
    controller.jumpToPriority(10); // Jump to priority 10
  }
  
  // 8. Terminate pipeline early with final result
  if (payload.shouldTerminate) {
    controller.return({
      terminated: true,
      reason: 'Early termination requested',
      result: processedResult
    });
    return; // Pipeline stops here
  }
  
  // 9. Handler automatically continues to next handler
  // No explicit next() call needed - handlers continue automatically
});
```

### Pipeline Middleware Pattern

```typescript
// Create reusable middleware
const createAuthMiddleware = (requiredRole: string) => 
  async (payload: any, controller: PipelineController) => {
    if (!isAuthenticated() || !hasRole(requiredRole)) {
      controller.abort('Authentication required');
      return;
    }
    // Handler automatically continues to next handler
  };

const createLoggingMiddleware = (actionName: string) =>
  async (payload: any, controller: PipelineController) => {
    console.log(`[${actionName}] Started:`, payload);
    const start = Date.now();
    
    // Handler automatically continues to next handler
    
    // Note: In real middleware, you'd need event listeners for completion
    console.log(`[${actionName}] Completed in ${Date.now() - start}ms`);
  };

// Apply middleware to actions
actionRegister.register('updateUser', createAuthMiddleware('user'), { priority: 200 });
actionRegister.register('updateUser', createLoggingMiddleware('updateUser'), { priority: 190 });
```

## Real-world Examples

### E-commerce Order Processing

```typescript
interface EcommerceActions extends ActionPayloadMap {
  addToCart: { productId: string; quantity: number; options?: Record<string, any> };
  removeFromCart: { itemId: string };
  updateCartItem: { itemId: string; quantity: number };
  applyDiscount: { code: string };
  submitOrder: {
    items: CartItem[];
    shipping: ShippingInfo;
    payment: PaymentInfo;
    notes?: string;
  };
  processPayment: { orderId: string; paymentMethod: PaymentMethod };
  fulfillOrder: { orderId: string; trackingNumber?: string };
}

const ecommerceRegister = new ActionRegister<EcommerceActions>({
  name: 'EcommerceRegister',
  logLevel: LogLevel.INFO
});

// Order submission pipeline
ecommerceRegister.register('submitOrder', validateOrderItems, { priority: 100 });
ecommerceRegister.register('submitOrder', checkInventory, { priority: 90 });
ecommerceRegister.register('submitOrder', calculatePricing, { priority: 80 });
ecommerceRegister.register('submitOrder', validateShipping, { priority: 70 });
ecommerceRegister.register('submitOrder', createOrderRecord, { priority: 60 });
ecommerceRegister.register('submitOrder', reserveInventory, { priority: 50 });
ecommerceRegister.register('submitOrder', processPaymentAction, { priority: 40 });
ecommerceRegister.register('submitOrder', sendConfirmationEmail, { priority: 30 });
ecommerceRegister.register('submitOrder', updateAnalytics, { priority: 10 });

// Parallel post-processing
ecommerceRegister.setExecutionMode('submitOrder', 'sequential'); // Main flow
ecommerceRegister.register('orderConfirmed', updateRecommendations, { priority: 10 });
ecommerceRegister.register('orderConfirmed', notifyWarehouse, { priority: 10 });
ecommerceRegister.register('orderConfirmed', updateLoyaltyPoints, { priority: 10 });
ecommerceRegister.setExecutionMode('orderConfirmed', 'parallel'); // Post-processing
```

### User Management System

```typescript
interface UserManagementActions extends ActionPayloadMap {
  registerUser: {
    email: string;
    password: string;
    profile: UserProfile;
    terms: boolean;
  };
  verifyEmail: { token: string };
  resetPassword: { email: string };
  updateProfile: { userId: string; changes: Partial<UserProfile> };
  deactivateUser: { userId: string; reason: string };
}

const userRegister = new ActionRegister<UserManagementActions>({
  name: 'UserManagement',
  logLevel: LogLevel.DEBUG
});

// User registration pipeline
userRegister.register('registerUser', async (payload, controller) => {
  // Validation
  if (!payload.terms) {
    controller.abort('Terms acceptance required');
    return;
  }
  
  if (!isValidEmail(payload.email)) {
    controller.abort('Invalid email format');
    return;
  }
  
  // Check existing user
  const existingUser = await findUserByEmail(payload.email);
  if (existingUser) {
    controller.abort('Email already registered');
    return;
  }
  
  // Handler automatically continues to next handler
}, { priority: 100, id: 'validation' });

userRegister.register('registerUser', async (payload, controller) => {
  // Create user account
  const hashedPassword = await hashPassword(payload.password);
  const user = await createUser({
    email: payload.email,
    password: hashedPassword,
    profile: payload.profile,
    status: 'pending_verification'
  });
  
  // Update payload for next handlers
  controller.modifyPayload(current => ({
    ...current,
    userId: user.id
  }));
  
  // Handler automatically continues to next handler
}, { priority: 50, id: 'account-creation', blocking: true });

userRegister.register('registerUser', async (payload, controller) => {
  // Send verification email
  const verificationToken = generateVerificationToken();
  await sendVerificationEmail(payload.email, verificationToken);
  
  // Store token
  await storeVerificationToken(payload.userId, verificationToken);
  
  // Handler automatically continues to next handler
}, { priority: 40, id: 'email-verification' });

userRegister.register('registerUser', async (payload, controller) => {
  // Analytics tracking
  trackUserRegistration({
    userId: payload.userId,
    source: payload.source || 'direct',
    timestamp: Date.now()
  });
  
  // Handler automatically continues to next handler
}, { priority: 10, id: 'analytics' });
```

## Registry Management & Statistics (New)

### Registry Information

Get comprehensive information about your ActionRegister:

```typescript
// Get registry overview
const registryInfo = actionRegister.getRegistryInfo();
console.log('Registry name:', registryInfo.name);
console.log('Total actions:', registryInfo.totalActions);
console.log('Total handlers:', registryInfo.totalHandlers);
console.log('Registered actions:', registryInfo.registeredActions);
console.log('Default execution mode:', registryInfo.defaultExecutionMode);
```

### Action Statistics

Monitor individual action performance:

```typescript
// Get detailed statistics for a specific action
const userStats = actionRegister.getActionStats('updateUser');
if (userStats) {
  console.log('Handler count:', userStats.handlerCount);
  console.log('Handlers by priority:', userStats.handlersByPriority);
  
  if (userStats.executionStats) {
    console.log('Total executions:', userStats.executionStats.totalExecutions);
    console.log('Average duration:', userStats.executionStats.averageDuration);
    console.log('Success rate:', userStats.executionStats.successRate);
    console.log('Error count:', userStats.executionStats.errorCount);
  }
}

// Get statistics for all actions
const allStats = actionRegister.getAllActionStats();
allStats.forEach(stats => {
  console.log(`Action: ${stats.action}, Handlers: ${stats.handlerCount}`);
});
```

### Handler Discovery

Find handlers by tags or categories:

```typescript
// Find all validation handlers across actions
const validationHandlers = actionRegister.getHandlersByTag('validation');
for (const [action, handlers] of validationHandlers) {
  console.log(`Action ${action} has ${handlers.length} validation handlers`);
}

// Find all critical handlers
const criticalHandlers = actionRegister.getHandlersByCategory('critical');
for (const [action, handlers] of criticalHandlers) {
  console.log(`Action ${action} has ${handlers.length} critical handlers`);
}
```

### Execution Mode Management

Advanced execution mode control:

```typescript
// Set execution mode for specific action
actionRegister.setActionExecutionMode('processPayment', 'sequential');

// Get current execution mode
const mode = actionRegister.getActionExecutionMode('processPayment');
console.log('Payment processing mode:', mode);

// Remove override (revert to default)
actionRegister.removeActionExecutionMode('processPayment');
```

### Statistics Management

Control execution statistics:

```typescript
// Clear all statistics
actionRegister.clearExecutionStats();

// Clear statistics for specific action
actionRegister.clearActionExecutionStats('updateUser');

// Check if debug mode is enabled
if (actionRegister.isDebugEnabled()) {
  console.log('Debug mode is active');
}
```

### ExecutionResult Interface (New)

The `dispatchWithResult` method returns comprehensive execution information:

```typescript
interface ExecutionResult<R = void> {
  success: boolean;        // Whether execution completed successfully
  aborted: boolean;        // Whether execution was aborted
  abortReason?: string;    // Reason for abortion if aborted
  terminated: boolean;     // Whether terminated early via controller.return()
  result?: R;             // Final processed result based on strategy
  results: R[];           // All individual handler results
  execution: {
    duration: number;           // Total execution time in ms
    handlersExecuted: number;   // Number of handlers that ran
    handlersSkipped: number;    // Number of handlers that were skipped
    handlersFailed: number;     // Number of handlers that failed
    startTime: number;          // Execution start timestamp
    endTime: number;            // Execution end timestamp
  };
  handlers: Array<{         // Detailed handler information
    id: string;             // Handler unique identifier
    executed: boolean;      // Whether this handler ran
    duration?: number;      // Handler execution time
    result?: R;            // Handler result
    error?: Error;         // Handler error if any
    metadata?: Record<string, any>; // Custom handler metadata
  }>;
  errors: Array<{          // All errors that occurred
    handlerId: string;     // Handler that caused the error
    error: Error;          // The error object
    timestamp: number;     // When the error occurred
  }>;
}

// Usage example
async function processOrderWithDetails(orderData: OrderData) {
  const result = await actionRegister.dispatchWithResult('processOrder', orderData, {
    result: {
      collect: true,         // Enable result collection
      strategy: 'merge',     // Merge all results
      timeout: 10000,        // 10 second timeout
      maxResults: 20,        // Limit results
      merger: (results) => { // Custom merger function
        return results.reduce((acc, curr) => ({ ...acc, ...curr }), {});
      }
    },
    filter: {
      tags: ['validation', 'business'], // Only these handlers
      excludeTags: ['logging']          // Exclude logging
    }
  });
  
  // Check execution status
  if (!result.success) {
    if (result.aborted) {
      console.error('Order processing aborted:', result.abortReason);
    } else {
      console.error('Order processing failed:', result.errors.length, 'errors');
    }
    return null;
  }
  
  // Log execution metrics
  console.log(`Order processed in ${result.execution.duration}ms`);
  console.log(`Executed ${result.execution.handlersExecuted}/${result.execution.handlersExecuted + result.execution.handlersSkipped} handlers`);
  
  // Check for early termination
  if (result.terminated) {
    console.log('Pipeline was terminated early');
  }
  
  return result.result; // Final processed result
}
```

## Best Practices

### 1. Type Safety

```typescript
// ✅ DO: Use specific, well-defined types
interface OrderActions extends ActionPayloadMap {
  updateOrderStatus: {
    orderId: string;
    status: 'pending' | 'confirmed' | 'shipped' | 'delivered' | 'cancelled';
    timestamp?: number;
    notes?: string;
  };
}

// ❌ DON'T: Use overly generic types
interface BadActions extends ActionPayloadMap {
  update: any; // Too generic
  process: object; // Not specific enough
}
```

### 2. Handler Organization

```typescript
// ✅ DO: Organize handlers by concern
const validationHandlers = {
  validateEmail: (payload, controller) => { /* ... */ },
  validatePassword: (payload, controller) => { /* ... */ },
  validateProfile: (payload, controller) => { /* ... */ }
};

const businessHandlers = {
  createUser: (payload, controller) => { /* ... */ },
  sendWelcomeEmail: (payload, controller) => { /* ... */ },
  setupDefaults: (payload, controller) => { /* ... */ }
};

// Register with clear priorities
Object.entries(validationHandlers).forEach(([name, handler], index) => {
  actionRegister.register('registerUser', handler, {
    id: name,
    priority: 100 - index
  });
});
```

### 3. Error Handling

```typescript
// ✅ DO: Comprehensive error handling
actionRegister.register('processPayment', async (payload, controller) => {
  try {
    const result = await paymentService.charge(payload);
    
    if (!result.success) {
      // Business logic error
      controller.abort(`Payment declined: ${result.reason}`);
      return;
    }
    
    // Update stores
    paymentStore.setValue(result.payment);
    orderStore.update(order => ({ 
      ...order, 
      paymentStatus: 'completed',
      paymentId: result.payment.id 
    }));
    
    // Handler automatically continues to next handler
    
  } catch (error) {
    // System error
    console.error('Payment processing failed:', error);
    
    // Rollback any partial changes
    await rollbackPayment(payload.orderId);
    
    controller.abort('Payment system unavailable', error);
  }
}, { priority: 50, blocking: true });
```

### 4. Performance Optimization

```typescript
// ✅ DO: Use appropriate execution modes
actionRegister.setExecutionMode('trackAnalytics', 'parallel'); // Independent operations
actionRegister.setExecutionMode('validateOrder', 'sequential'); // Dependent validations

// ✅ DO: Use debouncing for user input
actionRegister.register('searchUsers', searchHandler, {
  debounce: 300, // Wait 300ms after last input
  priority: 10
});

// ✅ DO: Use throttling for frequent events
actionRegister.register('trackMouseMovement', trackingHandler, {
  throttle: 100, // Max once per 100ms
  priority: 0
});
```

### 5. Memory Management

```typescript
// ✅ DO: Clean up handlers when components unmount
useEffect(() => {
  const unregisterHandlers = [
    actionRegister.register('updateUser', userHandler),
    actionRegister.register('deleteUser', deleteHandler),
    actionRegister.register('refreshUser', refreshHandler)
  ];
  
  return () => {
    // Clean up all handlers
    unregisterHandlers.forEach(unregister => unregister());
  };
}, []);

// ✅ DO: Use once: true for one-time handlers
actionRegister.register('appInitialized', initHandler, {
  once: true, // Automatically unregistered after first execution
  priority: 100
});
```

### 6. Handler Organization (New)

```typescript
// ✅ DO: Use tags and categories for organization
actionRegister.register('processPayment', validatePayment, {
  priority: 100,
  tags: ['validation', 'payment', 'critical'],
  category: 'validation',
  description: 'Validates payment information before processing',
  environment: 'production'
});

// ✅ DO: Use meaningful handler IDs
actionRegister.register('processPayment', processPaymentLogic, {
  id: 'payment-processor-v2',
  priority: 50,
  tags: ['business', 'payment'],
  category: 'core-logic',
  version: '2.1.0'
});
```

### 7. Handler Termination Patterns (New)

```typescript
// ✅ DO: Use natural completion for normal flow
actionRegister.register('processUser', async (payload, controller) => {
  const user = await fetchUser(payload.id);
  userStore.setValue(user);
  // Natural completion - continues to next handler
});

// ✅ DO: Use early return for conditional logic
actionRegister.register('validateUser', (payload, controller) => {
  if (!payload.email) {
    logError('Email is required');
    return; // Early return - pipeline continues
  }
  
  if (!isValidEmail(payload.email)) {
    logError('Invalid email format');
    return; // Early return - pipeline continues
  }
  
  // Validation passed - natural completion
});

// ✅ DO: Use abort for critical errors
actionRegister.register('securityCheck', (payload, controller) => {
  if (isSuspiciousActivity(payload)) {
    controller.abort('Security violation detected');
    return; // Pipeline stops completely
  }
  
  // Security check passed - natural completion
});

// ❌ DON'T: Forget to return after abort
actionRegister.register('badHandler', (payload, controller) => {
  if (error) {
    controller.abort('Error occurred');
    // ❌ Missing return - code continues executing
    doSomethingElse(); // This will still run!
  }
});
```

### 8. Result Handling (New)

```typescript
// ✅ DO: Use appropriate result strategies
const result = await actionRegister.dispatchWithResult('collectData', payload, {
  result: {
    strategy: 'merge',     // Combine all results
    collect: true,
    maxResults: 10,
    merger: (results) => {
      // Smart merging logic
      return results.reduce((acc, curr) => {
        return { ...acc, ...curr, timestamp: Date.now() };
      }, {});
    }
  }
});

// ✅ DO: Handle execution results properly
if (!result.success) {
  if (result.aborted) {
    console.warn('Operation was aborted:', result.abortReason);
  } else if (result.errors.length > 0) {
    console.error('Operation failed:', result.errors);
  }
  return;
}
```

## Troubleshooting

### Common Issues and Solutions

#### 1. Type Errors

```typescript
// ❌ Problem: Type mismatch
dispatch('updateUser', { invalidField: true }); // Type error

// ✅ Solution: Check ActionPayloadMap definition
interface AppActions extends ActionPayloadMap {
  updateUser: { id: string; name: string }; // Only these fields allowed
}

dispatch('updateUser', { id: '1', name: 'John' }); // ✅ Correct
```

#### 2. Handler Not Executing

```typescript
// ❌ Problem: Handler registered but not executing
actionRegister.register('myAction', handler, {
  condition: () => false // Always false!
});

// ✅ Solution: Check condition logic
actionRegister.register('myAction', handler, {
  condition: () => isFeatureEnabled('myFeature') // Proper condition
});
```

#### 3. Handler Termination Issues

```typescript
// ❌ Problem: Handler continues executing after abort
actionRegister.register('processData', async (payload, controller) => {
  if (payload.invalid) {
    controller.abort('Invalid data');
    // ❌ Missing return - code continues!
    await processData(payload); // This still executes
  }
});

// ✅ Solution: Always return after abort
actionRegister.register('processData', async (payload, controller) => {
  if (payload.invalid) {
    controller.abort('Invalid data');
    return; // ✅ Stop handler execution
  }
  
  try {
    await processData(payload);
    // Natural completion - continues to next handler
  } catch (error) {
    controller.abort('Processing failed', error);
    return; // ✅ Stop on error
  }
});

// ✅ Alternative: Use early returns for flow control
actionRegister.register('validateAndProcess', async (payload, controller) => {
  // Validation with early return
  if (!payload.email) {
    logError('Email required');
    return; // Skip processing, continue pipeline
  }
  
  if (!payload.name) {
    logError('Name required');
    return; // Skip processing, continue pipeline
  }
  
  // All valid - process normally
  await processValidData(payload);
  // Natural completion
});
```

#### 4. Memory Leaks

```typescript
// ❌ Problem: Handlers not cleaned up
function BadComponent() {
  useEffect(() => {
    actionRegister.register('action', handler);
    // No cleanup!
  }, []);
}

// ✅ Solution: Always return cleanup function
function GoodComponent() {
  useEffect(() => {
    const unregister = actionRegister.register('action', handler);
    return unregister; // ✅ Cleanup on unmount
  }, []);
}
```

### Debug Tools

#### 1. Enable Debug Logging

```typescript
const actionRegister = new ActionRegister<AppActions>({
  name: 'DebugRegister',
  registry: {
    debug: true,        // Enable debug mode (development only)
    maxHandlers: 100,   // Increase if needed for debugging
    autoCleanup: true   // Auto-cleanup for easier debugging
  }
});
```

#### 2. Registry Information for Debugging

```typescript
// Get comprehensive registry information
const registryInfo = actionRegister.getRegistryInfo();
console.log('Registry Debug Info:', {
  name: registryInfo.name,
  totalActions: registryInfo.totalActions,
  totalHandlers: registryInfo.totalHandlers,
  actions: registryInfo.registeredActions,
  defaultExecutionMode: registryInfo.defaultExecutionMode
});

// Check specific action details
const actionStats = actionRegister.getActionStats('updateUser');
if (actionStats) {
  console.log('Action Debug Info:', {
    handlerCount: actionStats.handlerCount,
    handlersByPriority: actionStats.handlersByPriority,
    executionStats: actionStats.executionStats
  });
}
```

#### 3. Handler Performance Monitoring

```typescript
// Use dispatchWithResult for comprehensive monitoring
async function debugDispatch(action: string, payload: any) {
  const result = await actionRegister.dispatchWithResult(action, payload);
  
  console.log(`[${action}] Execution Summary:`, {
    success: result.success,
    duration: `${result.execution.duration}ms`,
    handlersExecuted: result.execution.handlersExecuted,
    handlersSkipped: result.execution.handlersSkipped,
    handlersFailed: result.execution.handlersFailed,
    aborted: result.aborted,
    abortReason: result.abortReason,
    terminated: result.terminated
  });
  
  // Log individual handler performance
  result.handlers.forEach(handler => {
    if (handler.executed) {
      console.log(`  Handler ${handler.id}: ${handler.duration}ms`);
    } else {
      console.log(`  Handler ${handler.id}: skipped`);
    }
    
    if (handler.error) {
      console.error(`  Handler ${handler.id} error:`, handler.error);
    }
  });
  
  return result;
}

// Enable metrics collection for specific handlers
actionRegister.register('updateUser', userHandler, {
  priority: 50,
  metrics: {
    collectTiming: true,
    collectErrors: true,
    customMetrics: { trackUserUpdates: true }
  }
});
```

---

## Conclusion

The ActionPayloadMap and ActionRegister system provides a powerful, type-safe foundation for building scalable business logic pipelines. With the latest enhancements, you now have comprehensive control over pipeline execution, advanced filtering capabilities, result collection, and detailed monitoring.

### Key takeaways:

1. **Type Safety First**: Always define clear ActionPayloadMap interfaces
2. **Natural Handler Flow**: Use natural completion, early returns, and explicit aborts for clean handler termination
3. **Advanced Configuration**: Leverage the new registry configuration options for better control
4. **Handler Organization**: Use tags, categories, and metadata for better organization
5. **Result Management**: Take advantage of the new result collection and processing system
6. **Performance Monitoring**: Use ExecutionResult and statistics APIs for comprehensive monitoring
7. **Filtering & Control**: Utilize advanced filtering options for precise handler execution
8. **Error Handling**: Always return after controller.abort() to prevent continued execution
9. **Memory Management**: Always clean up handlers and use auto-cleanup features
10. **Debugging**: Use registry information and debug modes for troubleshooting

### Latest Features Summary:

- **Enhanced HandlerConfig** with tags, categories, metadata, and environment controls
- **Advanced Filtering System** for selective handler execution  
- **Result Collection & Processing** with multiple strategies and custom mergers
- **Auto AbortController Management** for better cancellation control
- **Comprehensive ExecutionResult** with detailed execution information
- **Registry Management APIs** for monitoring and statistics
- **Performance Metrics** with timing and error collection

For more advanced patterns and integration examples, see the [Context-Action Framework Documentation](../README.md) and other concept guides in this directory.

---


# Concept Architecture Guide

**Source**: `concept/architecture-guide.md`  
**Priority**: 50 (reference)  

# Context-Action Store Integration Architecture

## 1. Overview & Core Concepts

### What is Context-Action Architecture?

The Context-Action framework is a **revolutionary state management system** designed to overcome the fundamental limitations of existing libraries through document-centric context separation and effective artifact management.

#### Project Philosophy

The Context-Action framework addresses critical issues in modern state management:

**Problems with Existing Libraries:**
- **High React Coupling**: Tight integration makes component modularization and props handling difficult
- **Binary State Approach**: Simple global/local state dichotomy fails to handle specific scope-based separation  
- **Inadequate Handler/Trigger Management**: Poor support for complex interactions and business logic processing

**Context-Action's Solution:**
- **Document-Artifact Centered Design**: Context separation based on document themes and deliverable management
- **Perfect Separation of Concerns**: 
  - View design in isolation → Design Context
  - Development architecture in isolation → Architecture Context
  - Business logic in isolation → Business Context  
  - Data validation in isolation → Validation Context
- **Clear Boundaries**: Implementation results maintain distinct, well-defined domain boundaries
- **Effective Document-Artifact Management**: State management library that actively supports the relationship between documentation and deliverables

### Architecture Implementation

The framework implements a clean separation of concerns through an MVVM-inspired pattern combined with **Declarative Store Pattern** for complete domain isolation:

- **Actions** handle business logic (ViewModel layer)
- **Declarative Store Pattern** manages state with domain isolation (Model layer)
- **Components** render UI (View layer)
- **Context Boundaries** isolate functional domains
- **Type-Safe Integration** through domain-specific hooks

### Core Architecture Flow

```
[Component] → dispatch → [Action Pipeline] → handlers → [Store] → subscribe → [Component]
```

### Context Separation Strategy

#### Domain-Based Context Architecture
- **Business Context**: Business logic, data processing, and domain rules
- **UI Context**: Screen state, user interactions, and component behavior  
- **Validation Context**: Data validation, form processing, and error handling
- **Design Context**: Theme management, styling, layout, and visual states
- **Architecture Context**: System configuration, infrastructure, and technical decisions

#### Document-Based Context Design
Each context is designed to manage its corresponding documentation and deliverables:
- **Design Documentation** → Design Context (themes, component specifications, style guides)
- **Business Requirements** → Business Context (workflows, rules, domain logic)  
- **Architecture Documents** → Architecture Context (system design, technical decisions)
- **Validation Specifications** → Validation Context (rules, schemas, error handling)
- **UI Specifications** → UI Context (interactions, state management, user flows)

### Advanced Handler & Trigger Management

Context-Action provides sophisticated handler and trigger management that existing libraries lack:

#### Priority-Based Handler Execution
- **Sequential Processing**: Handlers execute in priority order with proper async handling
- **Domain Isolation**: Each context maintains its own handler registry
- **Cross-Context Coordination**: Controlled communication between domain contexts
- **Result Collection**: Aggregate results from multiple handlers for complex workflows

#### Intelligent Trigger System
- **State-Change Triggers**: Automatic triggers based on store value changes
- **Cross-Context Triggers**: Domain boundaries can trigger actions in other contexts
- **Conditional Triggers**: Smart triggers based on business rules and conditions
- **Trigger Cleanup**: Automatic cleanup prevents memory leaks and stale references

### Key Benefits

1. **Document-Artifact Management**: Direct relationship between documentation and implementation
2. **Domain Isolation**: Each context maintains complete independence
3. **Type Safety**: Full TypeScript support with domain-specific hooks
4. **Performance**: Only affected components re-render
5. **Scalability**: Easy to add new domains without affecting existing ones
6. **Team Collaboration**: Different teams can work on different domains without conflicts
7. **Clear Boundaries**: Perfect separation of concerns based on document domains

## 2. Domain-Specific Hooks Pattern (Core)

### Philosophy: Renamed Hook Pattern

The framework's core philosophy is to create **domain-specific hooks** through destructuring assignments, providing intuitive, type-safe APIs that improve developer experience.

```typescript
// ✅ Domain-specific hook naming pattern
export const {
  Provider: UserBusinessProvider,
  useStore: useUserBusinessStore,        // Domain-specific store hook
  useStoreManager: useUserBusinessStoreManager,    // Domain-specific store registry hook
  useStoreInfo: useUserBusinessStoreInfo
} = createDeclarativeStorePattern('UserBusiness', storeDefinitions);

export const {
  Provider: UserBusinessActionProvider,
  useActionDispatch: useUserBusinessAction,      // Domain-specific action hook
  useActionHandler: useUserBusinessActionHandler
} = createActionContext<UserBusinessActions>('UserBusinessAction');
```

### Benefits of Domain-Specific Naming

1. **Type Safety**: Full TypeScript inference with domain-specific types
2. **Developer Experience**: Clear, autocomplete-friendly API
3. **Maintainability**: Easy to identify which domain a hook belongs to
4. **Refactoring Safety**: Type errors immediately highlight breaking changes
5. **Team Scalability**: Different teams can work on different domains without conflicts

### Store Access Patterns

Three valid patterns for accessing stores, each with specific use cases:

```typescript
// Pattern 1: Domain-specific hooks (Components)
const store = useUserBusinessStore('profile');

// Pattern 2: Store manager access for advanced use cases (Handlers)
const storeManager = useUserBusinessStoreManager();
const store = storeManager.getStore('profile');
```

## 3. Basic Setup & Usage

### Step 1: Define Domain Stores and Actions

```typescript
// stores/userBusiness.store.ts
import { createDeclarativeStorePattern } from '@context-action/react';
import { createActionContext } from '@context-action/react';

// Define store interface
export interface UserBusinessData {
  profile: {
    id: string;
    name: string;
    email: string;
    role: 'admin' | 'user' | 'guest';
  };
  preferences: {
    theme: 'light' | 'dark';
    language: string;
  };
}

// Define action interface (ActionPayloadMap optional)
export interface UserBusinessActions {
  updateProfile: {
    data: Partial<UserBusinessData['profile']>;
    validate?: boolean;
  };
  deleteUser: { userId: string };
}

// Create domain-specific store hooks

// Option 1: Type inference (current approach)
export const {
  Provider: UserBusinessStoreProvider,
  useStore: useUserBusinessStore,
  useStoreManager: useUserBusinessStoreManager,
  useStoreInfo: useUserBusinessStoreInfo
} = createDeclarativeStorePattern('UserBusiness', {
  profile: {
    initialValue: {
      id: '',
      name: '',
      email: '',
      role: 'guest'
    }
  },
  preferences: {
    initialValue: {
      theme: 'light',
      language: 'en'
    }
  }
});

// Option 2: Explicit generic types (new approach)
export const {
  Provider: UserBusinessStoreProvider,
  useStore: useUserBusinessStore,
  useStoreManager: useUserBusinessStoreManager,
  useStoreInfo: useUserBusinessStoreInfo
} = createDeclarativeStorePattern<UserBusinessData>('UserBusiness', {
  // ⚠️ Note: Still requires InitialStores<T> structure even with explicit generics
  profile: {
    id: '',
    name: '',
    email: '',
    role: 'guest'
  },
  preferences: {
    // Can use direct values or config objects
    initialValue: { theme: 'light', language: 'en' },
    strategy: 'shallow'
  }
});

// Create domain-specific action hooks
export const {
  Provider: UserBusinessActionProvider,
  useActionDispatch: useUserBusinessAction,
  useActionHandler: useUserBusinessActionHandler,
  useActionDispatchWithResult: useUserBusinessActionDispatchWithResult
} = createActionContext<UserBusinessActions>('UserBusinessAction');
```

### Step 2: Provider Composition

```tsx
// providers/UserProvider.tsx
import React, { FC } from 'react';
import { 
  UserBusinessStoreProvider,
  UserBusinessActionProvider,
  UserUIStoreProvider,
  UserUIActionProvider
} from '@/stores';

// Compose all providers for the domain
export const UserProvider: FC<{ children: React.ReactNode }> = ({ children }) => (
  <UserBusinessStoreProvider>
    <UserUIStoreProvider>
      <UserBusinessActionProvider>
        <UserUIActionProvider>
          {children}
        </UserUIActionProvider>
      </UserBusinessActionProvider>
    </UserUIStoreProvider>
  </UserBusinessStoreProvider>
);

// HOC pattern for cleaner composition (alternative)
export const withUserProviders = (Component: React.ComponentType) => {
  return (props: any) => (
    <UserProvider>
      <Component {...props} />
    </UserProvider>
  );
};
```

### Step 3: Component Implementation

```tsx
// components/UserProfile.tsx
import React, { useCallback } from 'react';
import { useStoreValue } from '@context-action/react';
import { useUserBusinessStore, useUserBusinessAction } from '@/stores/userBusiness.store';

export function UserProfile() {
  // Access domain-specific stores
  const profileStore = useUserBusinessStore('profile');
  const preferencesStore = useUserBusinessStore('preferences');
  
  // Get current values
  const profile = useStoreValue(profileStore);
  const preferences = useStoreValue(preferencesStore);
  
  // Get domain-specific action dispatcher
  const dispatch = useUserBusinessAction();
  
  const handleUpdateProfile = useCallback(async () => {
    await dispatch('updateProfile', {
      data: { name: 'New Name' },
      validate: true
    });
  }, [dispatch]);
  
  return (
    <div>
      <h2>{profile.name}</h2>
      <p>Theme: {preferences.theme}</p>
      <button onClick={handleUpdateProfile}>
        Update Profile
      </button>
    </div>
  );
}
```

## 4. Store Management

### Store Creation and Access

```tsx
// Store setup component
function UserStoreSetup() {
  // Create stores in the context registry
  useCreateUserBusinessStore('profile', {
    id: '',
    name: '',
    email: '',
    role: 'guest'
  });
  
  useCreateUserBusinessStore('preferences', {
    theme: 'light',
    language: 'en'
  });
  
  return null;
}

// Store access in components
function UserSettings() {
  const preferencesStore = useUserBusinessStore('preferences');
  const preferences = useStoreValue(preferencesStore);
  
  const updateTheme = useCallback((theme: 'light' | 'dark') => {
    preferencesStore.setValue({ ...preferences, theme });
  }, [preferences, preferencesStore]);
  
  return (
    <div>
      <button onClick={() => updateTheme('dark')}>
        Switch to Dark Theme
      </button>
    </div>
  );
}
```

### Store Patterns

#### Singleton Behavior

Stores are singletons within Provider boundaries - same name returns same instance:

```typescript
function ComponentA() {
  const store = useUserBusinessStore('profile'); // Same instance
}

function ComponentB() {
  const store = useUserBusinessStore('profile'); // Same instance as ComponentA
}
```

#### Lazy Evaluation in Handlers

Use stores.getStore() for lazy evaluation to avoid stale closures:

```typescript
const handler = async (payload, controller) => {
  // Lazy evaluation - gets current value at execution time
  const profileStore = registry.getStore<UserProfile>('profile');
  const currentProfile = profileStore.getValue();
  
  // Business logic with current data
  profileStore.setValue({ ...currentProfile, ...payload });
};
```

## 5. Action Handlers

### Best Practice: useActionHandler Pattern

The recommended pattern for handler registration uses `useActionHandler` + `useEffect` for optimal performance and proper cleanup:

```typescript
import React, { useEffect, useCallback } from 'react';
import { useUserBusinessActionHandler, useUserBusinessStoreManager } from '@/stores/userBusiness.store';

function useUserBusinessHandlers() {
  const storeManager = useUserBusinessStoreManager();
  
  // Wrap handler with useCallback to prevent re-registration
  const updateProfileHandler = useCallback(async (payload, controller) => {
    // Lazy evaluation using store manager for current state
    const profileStore = storeManager.getStore('profile');
    const currentProfile = profileStore.getValue();
    
    // Validation
    if (payload.validate && !isValidEmail(payload.data.email)) {
      controller.abort('Invalid email format');
      return;
    }
    
    // Business logic
    const updatedProfile = {
      ...currentProfile,
      ...payload.data,
      updatedAt: Date.now()
    };
    
    // Update store
    profileStore.setValue(updatedProfile);
    
    // Return result for collection
    return { success: true, profile: updatedProfile };
  }, [storeManager]);
  
  // Register handler using useActionHandler hook (actual API)
  useUserBusinessActionHandler('updateProfile', updateProfileHandler, {
    priority: 100,      // Higher priority executes first
    blocking: true,     // Wait for async completion in sequential mode
    tags: ['business'], // For filtering
    id: 'profile-updater' // Explicit ID for debugging
  });
}
```

### Handler Registration Options

```typescript
interface HandlerConfig {
  priority?: number;        // Execution order (higher = first)
  blocking?: boolean;       // Wait for async completion
  tags?: string[];         // For filtering and categorization
  id?: string;            // Explicit handler ID
  category?: string;      // Handler category
  returnType?: 'value';   // Enable return value collection
}
```

### Handler Execution Flow

1. **Sequential Mode** (default): Handlers run in priority order
2. **Parallel Mode**: All handlers execute simultaneously
3. **Race Mode**: First handler to complete wins

```typescript
// Sequential with blocking
register('processOrder', handler1, { priority: 100, blocking: true });
register('processOrder', handler2, { priority: 90, blocking: true });
register('processOrder', handler3, { priority: 80, blocking: true });
// Execution: handler1 → waits → handler2 → waits → handler3

// Parallel execution
dispatch('processOrder', payload, { executionMode: 'parallel' });
```

### Controller Methods

```typescript
const handler = async (payload, controller) => {
  // Abort pipeline
  if (error) controller.abort('Error message');
  
  // Jump to specific priority
  if (urgent) controller.jumpToPriority(90);
  
  // Set result for collection
  controller.setResult(computedValue);
  
  // Terminate pipeline with result
  if (canFinishEarly) controller.return(finalResult);
};
```

### Result Collection

```typescript
function useOrderProcessing() {
  const dispatchWithResult = useUserBusinessActionWithResult();
  
  const processOrder = async (orderData) => {
    const result = await dispatchWithResult('processOrder', orderData, {
      result: {
        collect: true,         // Enable collection
        strategy: 'all',       // Collect all results
        timeout: 5000,         // 5 second timeout
        maxResults: 10         // Limit results
      },
      filter: {
        tags: ['validation', 'business'], // Only these handlers
        excludeTags: ['logging']          // Exclude logging
      }
    });
    
    if (result.success) {
      console.log('Results:', result.results);
      console.log('Duration:', result.execution.duration);
    }
    
    return result.result;
  };
}
```

## 6. Advanced Patterns

### Cross-Domain Integration (When Needed)

While domain isolation is preferred, sometimes cross-domain interaction is necessary:

```typescript
// hooks/useUserCartIntegration.ts
export function useUserCartIntegration() {
  // Access multiple domains
  const userProfile = useUserBusinessStore('profile');
  const cartItems = useCartStore('items');
  const userAction = useUserBusinessAction();
  const cartAction = useCartAction();
  
  const profile = useStoreValue(userProfile);
  const items = useStoreValue(cartItems);
  
  const processCheckout = useCallback(async () => {
    // Validate user
    if (!profile.id) {
      await userAction('requireLogin', {});
      return;
    }
    
    // Process cart
    await cartAction('processCheckout', {
      userId: profile.id,
      items: items
    });
  }, [profile.id, items, userAction, cartAction]);
  
  return { processCheckout };
}
```

### Logic Fit Hooks Pattern

Combine business and UI logic in reusable hooks:

```typescript
export function useUserEditor() {
  // Business layer
  const profileStore = useUserBusinessStore('profile');
  const businessAction = useUserBusinessAction();
  
  // UI layer  
  const viewStore = useUserUIStore('view');
  const uiAction = useUserUIAction();
  
  const profile = useStoreValue(profileStore);
  const view = useStoreValue(viewStore);
  
  const startEditing = useCallback(() => {
    uiAction('setEditMode', { editing: true });
  }, [uiAction]);
  
  const saveChanges = useCallback(async (data) => {
    await businessAction('updateProfile', { data });
    uiAction('setEditMode', { editing: false });
  }, [businessAction, uiAction]);
  
  return {
    profile,
    isEditing: view.isEditing,
    startEditing,
    saveChanges
  };
}
```

### Handler ID Strategies for Component Instances

When multiple instances of the same component exist:

```tsx
function TodoItem({ todoId }: { todoId: string }) {
  const componentId = useId(); // React's unique ID
  const addHandler = useTodoActionHandler();
  
  const handler = useCallback(async (payload) => {
    // Handler logic specific to this instance
  }, [todoId]);
  
  useEffect(() => {
    if (!addHandler) return;
    
    // Unique ID per component instance
    const unaddHandler = addHandler('updateTodo', handler, {
      id: `updateTodo-${componentId}`,
      cleanup: true
    });
    
    return unregister;
  }, [register, handler, componentId]);
}
```

## 7. Best Practices

### Handler Registration

1. **Always use `useActionHandler` hook for automatic registration and cleanup**
2. **Wrap handlers with `useCallback` to prevent re-registration**
3. **Use `blocking: true` for sequential async handlers**
4. **Consider explicit IDs for debugging and critical handlers**
5. **Use `useActionRegister()` only for advanced manual control**

### Store Access

6. **Use domain-specific hooks in components**
7. **Use `stores.getStore()` for lazy evaluation in handlers**
8. **Provide proper initial values, not null**
9. **Keep store updates predictable and traceable**

### Type Safety (Recommended)

10. **Define interfaces for better type safety**
11. **Use domain-specific hooks for type inference**
12. **Avoid `any` types - leverage TypeScript**

### Performance

13. **Only subscribe to needed stores**
14. **Use proper handler priorities**
15. **Clean up handlers on unmount**
16. **Use result collection selectively**

### Architecture

17. **One domain = One context boundary**
18. **Separate business and UI concerns**
19. **Prefer domain isolation, use cross-domain communication when necessary**
20. **Document domain boundaries clearly**

## 8. Common Pitfalls

### ❌ Missing Cleanup

```typescript
// Wrong - No cleanup
useEffect(() => {
  register('action', handler);
}, []);

// ✅ Correct - With cleanup
useEffect(() => {
  if (!addHandler) return;
  const unaddHandler = addHandler('action', handler);
  return unregister; // Memory cleanup on unmount
}, [register, handler]);
```

### ❌ Missing blocking for Async Handlers

```typescript
// Wrong - Handlers execute simultaneously
register('action', asyncHandler, { priority: 100 });

// ✅ Correct - Sequential execution
register('action', asyncHandler, { 
  priority: 100, 
  blocking: true // Wait for completion
});
```

### ❌ Using Stale Closures

```typescript
// Wrong - Stale closure
const profile = profileStore.getValue();
const handler = async () => {
  console.log(profile); // Stale value
};

// ✅ Correct - Lazy evaluation
const handler = async () => {
  const profileStore = stores.getStore('profile');
  const profile = profileStore.getValue(); // Current value
};
```


## Architecture Diagrams 

### Provider Composition Pattern

```mermaid
graph TD
    subgraph "Application Root"
        App[App Component]
    end
    
    subgraph "User Domain Providers"
        UBP[UserBusinessProvider]
        UUP[UserUIProvider]
        UBAP[UserBusinessActionProvider]
        UUAP[UserUIActionProvider]
    end
    
    subgraph "Components"
        UC[User Components]
    end
    
    App --> UBP
    UBP --> UUP
    UUP --> UBAP
    UBAP --> UUAP
    UUAP --> UC
    
    style UBP fill:#e3f2fd
    style UUP fill:#fff8e1
    style UBAP fill:#e3f2fd
    style UUAP fill:#fff8e1
```

### Store Singleton Behavior

```mermaid
graph TB
    subgraph "Provider Scope 1"
        P1[Provider Instance]
        S1[Store Registry - Singleton]
        C1[Component A]
        C2[Component B]
        
        P1 --> S1
        S1 --> C1
        S1 --> C2
    end
    
    subgraph "Provider Scope 2"
        P2[Provider Instance]
        S2[Store Registry - Different Singleton]
        C3[Component C]
        C4[Component D]
        
        P2 --> S2
        S2 --> C3
        S2 --> C4
    end
    
    Note[Same Provider = Same Store Instance<br/>Different Provider = Different Instance]
    
    style S1 fill:#bbdefb
    style S2 fill:#ffccbc
```

## 9. Implementation Examples

### Quick Start Example

```typescript
// 1. Define Domain (stores/user.store.ts)
export interface UserData {
  profile: { id: string; name: string; email: string; role: 'admin' | 'user' | 'guest' };
  preferences: { theme: 'light' | 'dark'; language: string };
}

export interface UserActions {
  login: { email: string; password: string };
  logout: void;
  updateProfile: { data: Partial<UserData['profile']> };
}

// Create domain-specific hooks
export const {
  Provider: UserProvider,
  useStore: useUserStore,
  useStoreManager: useUserStoreManager
} = createDeclarativeStorePattern('User', {
  profile: { initialValue: { id: '', name: '', email: '', role: 'guest' } },
  preferences: { initialValue: { theme: 'light', language: 'en' } }
});

export const {
  Provider: UserActionProvider,
  useActionDispatch: useUserAction,
  useActionHandler: useUserActionHandler
} = createActionContext<UserActions>('UserAction');
```

```typescript
// 2. Define Actions & Handlers (hooks/useUserHandlers.ts)
export function useUserHandlers() {
  const storeManager = useUserStoreManager();
  
  // Login handler example
  const loginHandler = useCallback(async (payload, controller) => {
    const profileStore = storeManager.getStore('profile');
    
    try {
      // Validation
      if (!validateEmail(payload.email)) {
        controller.abort('Invalid email format');
        return;
      }
      
      // API call
      const response = await authAPI.login(payload.email, payload.password);
      
      // Update store
      profileStore.setValue({
        ...response.user,
        status: 'active'
      });
      
      return { success: true, userId: response.user.id };
    } catch (error) {
      controller.abort('Login failed', error);
      return { success: false };
    }
  }, [storeManager]);
  
  // Register handler using useActionHandler hook (actual API)
  useUserActionHandler('login', loginHandler, {
    priority: 100,
    blocking: true,
    id: 'user-login-handler'
  });
  
  // Similar patterns for logout, updateProfile handlers...
}
```

```tsx
// 3. Use in Component (components/UserProfile.tsx)
export function UserProfile() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  const dispatch = useUserAction();
  
  const handleLogin = useCallback(async () => {
    const result = await dispatch('login', {
      email: 'user@example.com',
      password: 'password123'
    });
    
    if (result?.success) {
      console.log('Login successful');
    }
  }, [dispatch]);
  
  const handleUpdateProfile = useCallback(() => {
    dispatch('updateProfile', {
      data: { name: 'New Name' }
    });
  }, [dispatch]);
  
  return (
    <div>
      <h1>Welcome, {profile.name || 'Guest'}</h1>
      <p>Email: {profile.email}</p>
      <p>Role: {profile.role}</p>
      
      {profile.id ? (
        <button onClick={handleUpdateProfile}>Update Profile</button>
      ) : (
        <button onClick={handleLogin}>Login</button>
      )}
    </div>
  );
}
```

```tsx
// 4. App Setup (App.tsx)
function App() {
  return (
    <UserProvider>
      <UserActionProvider>
        <UserHandlersSetup />
        <UserProfile />
      </UserActionProvider>
    </UserProvider>
  );
}

// Handler setup component
function UserHandlersSetup() {
  useUserHandlers();
  return null;
}
```

### Logic Fit Hook Pattern (Combining Business & UI)

```typescript
// hooks/useUserEditor.ts
export function useUserEditor() {
  // Business layer
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  const dispatch = useUserAction();
  
  // UI state (local or separate UI store)
  const [isEditing, setIsEditing] = useState(false);
  const [formData, setFormData] = useState(profile);
  
  // Combined logic
  const startEditing = useCallback(() => {
    setIsEditing(true);
    setFormData(profile);
  }, [profile]);
  
  const saveChanges = useCallback(async () => {
    const result = await dispatch('updateProfile', { data: formData });
    if (result?.success) {
      setIsEditing(false);
    }
    return result;
  }, [dispatch, formData]);
  
  const cancelEditing = useCallback(() => {
    setIsEditing(false);
    setFormData(profile);
  }, [profile]);
  
  return {
    // Data
    profile,
    formData,
    isEditing,
    
    // Methods
    startEditing,
    saveChanges,
    cancelEditing,
    setFormData
  };
}
```

### Complete Implementation Pattern

For a full implementation with Business/UI separation, provider composition, and comprehensive handler patterns, see the [GitHub repository examples](https://github.com/mineclover/context-action/tree/main/example).

Key patterns demonstrated:
- **Store Definition**: Business data, UI state, and domain isolation
- **Handler Registration**: Priority-based execution with cleanup
- **Provider Composition**: Nested providers for domain boundaries
- **Logic Fit Hooks**: Combining business and UI logic
- **Testing Patterns**: Unit and integration testing approaches

## 10. Testing Guide

### Unit Testing Handlers

```typescript
// __tests__/handlers/userBusinessHandlers.test.ts
import { renderHook } from '@testing-library/react-hooks';
import { useUserBusinessHandlers } from '@/hooks/handlers/useUserBusinessHandlers';
import { createMockRegistry, createMockController } from '@/test-utils';

describe('User Business Handlers', () => {
  let mockRegistry;
  let mockController;
  
  beforeEach(() => {
    mockRegistry = createMockRegistry();
    mockController = createMockController();
  });
  
  it('should validate email in login handler', async () => {
    const { result } = renderHook(() => useUserBusinessHandlers());
    
    const loginHandler = result.current.loginHandler;
    
    await loginHandler(
      { email: 'invalid-email', password: 'password123' },
      mockController
    );
    
    expect(mockController.abort).toHaveBeenCalledWith('Invalid email format');
  });
  
  it('should update profile store on successful login', async () => {
    const mockProfileStore = {
      getValue: jest.fn(() => ({ id: '', name: '' })),
      setValue: jest.fn()
    };
    
    mockRegistry.getStore.mockReturnValue(mockProfileStore);
    
    const { result } = renderHook(() => useUserBusinessHandlers());
    
    await result.current.loginHandler(
      { email: 'user@example.com', password: 'password123' },
      mockController
    );
    
    expect(mockProfileStore.setValue).toHaveBeenCalledWith(
      expect.objectContaining({
        email: 'user@example.com',
        status: 'active'
      })
    );
  });
});
```

### Integration Testing

```tsx
// __tests__/integration/userFlow.test.tsx
import React from 'react';
import { render, fireEvent, waitFor } from '@testing-library/react';
import { UserProvider } from '@/providers/UserProvider';
import { UserProfile } from '@/components/UserProfile';

describe('User Profile Integration', () => {
  it('should handle complete edit flow', async () => {
    const { getByText, getByLabelText } = render(
      <UserProvider>
        <UserProfile />
      </UserProvider>
    );
    
    // Start editing
    fireEvent.click(getByText('Edit Profile'));
    
    // Update fields
    const nameInput = getByLabelText('Name:');
    fireEvent.change(nameInput, { target: { value: 'New Name' } });
    
    // Save changes
    fireEvent.click(getByText('Save'));
    
    // Verify updates
    await waitFor(() => {
      expect(getByText('Name: New Name')).toBeInTheDocument();
    });
  });
});
```

## 11. Migration Guide

### From Legacy Patterns

```typescript
// ❌ Old Pattern: Manual handler registration with useEffect
function OldComponent() {
  const dispatch = useDispatch();
  const register = useActionRegister();
  
  const handler = () => {
    // handler logic
  };
  
  useEffect(() => {
    if (!register) return;
    const unregister = register.register('action', handler);
    return unregister;
  }, [register, handler]);
}

// ✅ New Pattern: useActionHandler hook (current API)
function NewComponent() {
  const dispatch = useAction();
  
  const handler = useCallback(() => {
    // handler logic
  }, []);
  
  // Handler automatically registered and cleaned up
  useActionHandler('action', handler, {
    id: 'unique-handler-id',
    blocking: true
  });
}
```

### Incremental Migration Steps

1. **Phase 1: Add Type Definitions**
    
    - Define interfaces for all stores and actions
    - Add domain-specific hook exports
2. **Phase 2: Update Handler Registration**
    
    - Convert to useActionHandler pattern
    - Add cleanup functions
    - Add explicit handler IDs
3. **Phase 3: Implement Domain Isolation**
    
    - Separate business and UI concerns
    - Create domain-specific providers
    - Update component imports
4. **Phase 4: Testing & Validation**
    
    - Update tests for new patterns
    - Verify cleanup on unmount
    - Performance testing

## 12. Troubleshooting

### Common Issues and Solutions

#### Handler Not Executing

```typescript
// Problem: Handler registered but not executing
register('action', asyncHandler, { priority: 100 });

// Solution: Add blocking for async handlers
register('action', asyncHandler, { 
  priority: 100,
  blocking: true // Required for sequential async execution
});
```

#### Stale State in Handlers

```typescript
// Problem: Getting old values
const value = store.getValue();
const handler = () => console.log(value); // Stale

// Solution: Use lazy evaluation
const handler = () => {
  const store = stores.getStore('name');
  const value = store.getValue(); // Current
};
```

#### Memory Leaks

```typescript
// Problem: Manual registration without cleanup
useEffect(() => {
  if (!register) return;
  register.register('action', handler);
  // No cleanup!
}, [register, handler]);

// Solution: Use useActionHandler hook (automatic cleanup)
const handler = useCallback(() => {
  // handler logic
}, []);

useActionHandler('action', handler, {
  id: 'action-handler',
  blocking: true
}); // Cleanup handled automatically
```

#### Type Errors

```typescript
// Problem: Type inference not working
const store = useStore('profile'); // Generic type

// Solution: Use domain-specific hooks
const store = useUserBusinessStore('profile'); // Typed
```

## Conclusion

The Context-Action Store Integration Architecture provides a robust, scalable, and type-safe foundation for React applications. By following the patterns and best practices outlined in this guide, you can build maintainable applications with clear separation of concerns, excellent performance, and great developer experience.

### Key Takeaways

1. **Use domain-specific hooks** for type safety and clarity
2. **Use `useActionHandler` hook** for automatic registration and cleanup
3. **Use lazy evaluation** in handlers to avoid stale state
4. **Separate business and UI concerns** with different stores/actions
5. **Prefer domain isolation** - use cross-domain only when necessary
6. **Consider explicit IDs** for debugging and critical handlers
7. **Use blocking: true** for sequential async handlers
8. **Test handlers in isolation** before integration

For more information and updates, visit the project repository.

---


# Concept Conventions

**Source**: `concept/conventions.md`  
**Priority**: 50 (reference)  

# Context-Action Framework Conventions

이 문서는 Context-Action 프레임워크를 사용할 때 따라야 할 코딩 컨벤션과 베스트 프랙티스를 정의합니다.

## 📋 목차

1. [네이밍 컨벤션](#네이밍-컨벤션)
2. [파일 구조](#파일-구조)
3. [패턴 사용법](#패턴-사용법)
4. [타입 정의](#타입-정의)
5. [코드 스타일](#코드-스타일)
6. [성능 가이드라인](#성능-가이드라인)
7. [에러 핸들링](#에러-핸들링)

---

## 네이밍 컨벤션

### 🏷️ 리네이밍 패턴 (Renaming Pattern)

Context-Action 프레임워크의 핵심 컨벤션은 **도메인별 리네이밍 패턴**입니다.

#### ✅ Store Pattern 리네이밍
```tsx
// ✅ 권장: 도메인별 리네이밍
const {
  Provider: UserStoreProvider,
  useStore: useUserStore,
  useStoreManager: useUserStoreManager
} = createDeclarativeStorePattern('User', {...});

// ❌ 지양: 직접 객체 접근
const UserStores = createDeclarativeStorePattern('User', {...});
const userStore = UserStores.useStore('profile'); // 도메인이 불분명
```

#### ✅ Action Pattern 리네이밍
```tsx
// ✅ 권장: 도메인별 리네이밍 (제네릭 타입 명시)
const {
  Provider: UserActionProvider,
  useActionDispatch: useUserAction,
  useActionHandler: useUserActionHandler
} = createActionContext<UserActions>('UserActions');

// ❌ 지양: 제네릭 이름 사용
const {
  Provider,
  useActionDispatch,
  useActionHandler
} = createActionContext<UserActions>('UserActions');
```

### 🎯 컨텍스트 이름 규칙

#### 도메인 기반 네이밍
```tsx
// ✅ 권장: 명확한 도메인 구분
'UserProfile'     // 사용자 프로필 관련
'ShoppingCart'    // 쇼핑카트 관련  
'ProductCatalog'  // 상품 카탈로그 관련
'OrderManagement' // 주문 관리 관련
'AuthSystem'      // 인증 시스템 관련

// ❌ 지양: 모호한 이름
'Data'           // 너무 포괄적
'State'          // 구체적이지 않음
'App'            // 범위가 불분명 (루트 레벨에서만 사용)
'Manager'        // 역할이 불분명
```

#### Action vs Store 구분
```tsx
// Action Context (행동/이벤트 중심)
'UserActions'         // 사용자 액션들
'PaymentActions'      // 결제 액션들
'NavigationActions'   // 내비게이션 액션들

// Store Context (데이터/상태 중심)  
'UserData'           // 사용자 데이터
'ProductCatalog'     // 상품 카탈로그
'ShoppingCart'       // 쇼핑카트 상태
'AppSettings'        // 앱 설정
```

### 🔤 Hook 네이밍 패턴

#### Store Hook 네이밍
```tsx
// ✅ 권장: use + 도메인 + Store 패턴
const useUserStore = UserContext.useStore;
const useProductStore = ProductContext.useStore;
const useCartStore = CartContext.useStore;

// 사용 시
const profileStore = useUserStore('profile');
const wishlistStore = useUserStore('wishlist');
```

#### Action Hook 네이밍
```tsx
// ✅ 권장: use + 도메인 + Action 패턴
const useUserAction = UserContext.useActionDispatch;
const usePaymentAction = PaymentContext.useActionDispatch;
const useUserActionHandler = UserContext.useActionHandler;

// 사용 시
const dispatch = useUserAction();
useUserActionHandler('updateProfile', handler);
```

---

## 파일 구조

### 📁 권장 디렉토리 구조

```
src/
├── contexts/           # 컨텍스트 정의
│   ├── user/
│   │   ├── user.actions.ts     # UserActions 인터페이스 + createActionContext
│   │   ├── user.stores.ts      # UserData 인터페이스 + createDeclarativeStorePattern  
│   │   └── index.ts            # 리네이밍된 exports
│   ├── product/
│   │   ├── product.actions.ts
│   │   ├── product.stores.ts
│   │   └── index.ts
│   └── index.ts        # 모든 컨텍스트 re-export
├── providers/          # Provider 컴포넌트들
│   ├── UserProvider.tsx
│   ├── ProductProvider.tsx
│   └── AppProvider.tsx         # 루트 Provider 조합
├── hooks/             # 도메인별 커스텀 훅들
│   ├── user/
│   │   ├── useUserHandlers.ts   # 액션 핸들러 모음
│   │   ├── useUserProfile.ts    # 비즈니스 로직 훅
│   │   └── index.ts
│   └── index.ts
├── types/             # 공통 타입 정의
│   ├── user.types.ts
│   ├── product.types.ts
│   └── index.ts
└── components/        # React 컴포넌트들
    ├── user/
    ├── product/
    └── common/
```

### 📄 파일명 컨벤션

#### Context 파일명
```tsx
// ✅ 권장
user.actions.ts       // 액션 컨텍스트
user.stores.ts        // 스토어 컨텍스트
payment.actions.ts    // 결제 액션
product.stores.ts     // 상품 스토어

// ❌ 지양
userContext.ts        // 모호함 (액션인지 스토어인지 불분명)
User.ts              // 대문자 시작 (컴포넌트와 혼동)
userState.ts         // "state"보다는 "stores" 선호
```

#### Provider 파일명
```tsx
// ✅ 권장
UserProvider.tsx      // 사용자 관련 프로바이더
ProductProvider.tsx   // 상품 관련 프로바이더
AppProvider.tsx       // 루트 프로바이더

// ❌ 지양  
user-provider.tsx     // kebab-case 대신 PascalCase
userProvider.tsx      // camelCase 대신 PascalCase
```

---

## 패턴 사용법

### 🎯 패턴 선택 가이드

#### Store Only Pattern
```tsx
// ✅ 사용 시기: 순수 상태 관리가 필요한 경우
// - 폼 데이터 관리
// - 설정값 저장
// - 캐시된 데이터 관리
// - UI 상태 (모달, 토글 등)

// 방법 1: 타입 추론 (현재 방식)
const {
  Provider: SettingsStoreProvider,
  useStore: useSettingsStore,
  useStoreManager: useSettingsStoreManager
} = createDeclarativeStorePattern('Settings', {
  theme: 'light' as 'light' | 'dark',
  language: 'ko',
  notifications: true
});

// 방법 2: 명시적 제네릭 타입 (새로운 방식)
interface SettingsStoreTypes {
  theme: 'light' | 'dark';
  language: string;
  notifications: boolean;
}

const {
  Provider: SettingsStoreProvider,
  useStore: useSettingsStore,
  useStoreManager: useSettingsStoreManager
} = createDeclarativeStorePattern<SettingsStoreTypes>('Settings', {
  theme: 'light',  // 타입이 SettingsStoreTypes에서 추론됨
  language: 'ko',
  notifications: true
});
```

#### Action Only Pattern  
```tsx
// ✅ 사용 시기: 순수 액션 디스패치가 필요한 경우
// - 이벤트 트래킹
// - 로깅 시스템
// - 알림 발송
// - API 호출 (상태 변경 없이)

const {
  Provider: AnalyticsActionProvider,
  useActionDispatch: useAnalyticsAction,
  useActionHandler: useAnalyticsActionHandler
} = createActionContext<AnalyticsActions>('Analytics');
```

#### Pattern Composition
```tsx
// ✅ 사용 시기: 액션과 상태 관리가 모두 필요한 경우  
// - 복잡한 비즈니스 로직
// - 사용자 프로필 관리
// - 쇼핑카트 시스템
// - 게임 상태 관리

function App() {
  return (
    <UserActionProvider>
      <UserStoreProvider>
        <UserProfile />
      </UserStoreProvider>
    </UserActionProvider>
  );
}
```

### 🔄 Provider 조합 패턴

#### HOC 패턴 (권장)
```tsx
// ✅ 권장: HOC를 이용한 자동 Provider 감싸기
const { withProvider: withUserStoreProvider } = createDeclarativeStorePattern('User', {...});
const { withProvider: withUserActionProvider } = createActionContext<UserActions>('UserActions');

// 여러 Provider 조합
const withUserProviders = (Component: React.ComponentType) => 
  withUserActionProvider(withUserStoreProvider(Component));

const UserProfileWithProviders = withUserProviders(UserProfile);

// 사용
function App() {
  return <UserProfileWithProviders />;
}
```

#### Manual Provider 조합
```tsx
// ✅ 수동 조합 (복잡한 의존성이 있는 경우)
function UserProvider({ children }: { children: React.ReactNode }) {
  return (
    <UserActionProvider>
      <UserStoreProvider>
        <UserAnalyticsProvider>
          {children}
        </UserAnalyticsProvider>
      </UserStoreProvider>
    </UserActionProvider>
  );
}
```

---

## 타입 정의

### 🏷️ Interface 네이밍

#### Action Payload Map
```tsx
// ✅ 권장: 도메인 + Actions 패턴 (ActionPayloadMap 확장)
interface UserActions extends ActionPayloadMap {
  updateProfile: { id: string; data: Partial<UserProfile> };
  deleteAccount: { id: string; reason?: string };
  refreshToken: void;
}

// ✅ 권장: 도메인 + Actions 패턴 (단순 인터페이스 - 미래 방식)
interface UserActions {
  updateProfile: { id: string; data: Partial<UserProfile> };
  deleteAccount: { id: string; reason?: string };
  refreshToken: void;
}

interface PaymentActions {
  processPayment: { amount: number; method: string };
  refundPayment: { transactionId: string };
  validateCard: { cardNumber: string };
}

// ❌ 지양
interface Actions { ... }           // 너무 포괄적
interface UserActionTypes { ... }   // 일관성 없는 이름
```

#### Store Data Interface
```tsx
// ✅ 권장: 도메인 + Data 패턴 또는 직관적 이름
interface UserData {
  profile: UserProfile;
  preferences: UserPreferences;
  session: UserSession;
}

interface ShoppingCartData {
  items: CartItem[];
  total: number;
  discounts: Discount[];
}

// 또는 직관적 이름
interface UserState {
  profile: UserProfile;
  preferences: UserPreferences;
}

// ❌ 지양
interface Data { ... }           // 너무 포괄적
interface UserStoreType { ... }  // 불필요한 Type 접미사
```

### 🎯 제네릭 타입 사용

```tsx
// ✅ 권장: 명확한 제네릭 타입 사용
interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

interface User extends BaseEntity {
  name: string;
  email: string;
}

interface Product extends BaseEntity {
  name: string;
  price: number;
  category: string;
}

// Store 정의에서 활용 - 방법 1: 타입 추론 (권장)
const {
  Provider: UserStoreProvider,
  useStore: useUserStore
} = createDeclarativeStorePattern('User', {
  users: { initialValue: [] as User[] },
  currentUser: { initialValue: null as User | null }
});

// Store 정의에서 활용 - 방법 2: 명시적 제네릭
interface UserStoreTypes {
  users: User[];
  currentUser: User | null;
}

const {
  Provider: UserStoreProvider,
  useStore: useUserStore
} = createDeclarativeStorePattern<UserStoreTypes>('User', {
  // ⚠️ 주의: 명시적 제네릭 사용 시에도 InitialStores<T> 구조 필요
  users: [],  // 직접 값 또는
  currentUser: {  // 설정 객체
    initialValue: null,
    strategy: 'reference'
  }
});

// Action 정의에서 활용 - 새로운 API (contextName 우선)
interface UserActions {
  createUser: { userData: Omit<User, 'id' | 'createdAt' | 'updatedAt'> };
  updateUser: { id: string; updates: Partial<User> };
  deleteUser: { id: string };
}

const {
  Provider: UserActionProvider,
  useActionDispatch: useUserAction
} = createActionContext<UserActions>('UserActions', {
  registry: { debug: true, maxHandlers: 10 }
});
```

---

## 코드 스타일

### ✨ 컴포넌트 패턴

#### Store 사용 패턴
```tsx
// ✅ 권장: 명확한 변수명과 구조분해
function UserProfile() {
  // Store 접근
  const profileStore = useUserStore('profile');
  const preferencesStore = useUserStore('preferences');
  
  // 값 구독
  const profile = useStoreValue(profileStore);
  const preferences = useStoreValue(preferencesStore);
  
  // 로컬 상태와 구분
  const [isEditing, setIsEditing] = useState(false);
  
  return (
    <div>
      <ProfileView profile={profile} preferences={preferences} />
      {isEditing && <ProfileEditor />}
    </div>
  );
}

// ❌ 지양: 혼동되는 변수명
function UserProfile() {
  const store1 = useUserStore('profile');  // 무엇인지 불분명
  const data = useStoreValue(store1);      // 구체적이지 않음
  const userState = useStoreValue(store2); // 혼동 가능
}
```

#### Action Handler 패턴
```tsx
// ✅ 권장: useCallback과 명확한 핸들러명
function UserProfile() {
  const dispatch = useUserAction();
  
  // 핸들러 등록 (useCallback 필수)
  useUserActionHandler('updateProfile', useCallback(async (payload, controller) => {
    try {
      const profileStore = storeManager.getStore('profile');
      const currentProfile = profileStore.getValue();
      
      // 비즈니스 로직 실행
      const updatedProfile = await updateUserProfile(payload.data);
      
      // 스토어 업데이트
      profileStore.setValue({ ...currentProfile, ...updatedProfile });
      
      // 성공 알림
      dispatch('showNotification', { 
        type: 'success', 
        message: '프로필이 업데이트되었습니다.' 
      });
    } catch (error) {
      controller.abort('프로필 업데이트 실패', error);
    }
  }, [dispatch, storeManager]));
  
  const handleEditProfile = () => {
    dispatch('updateProfile', {
      data: { name: 'New Name' }
    });
  };
  
  return <button onClick={handleEditProfile}>Edit Profile</button>;
}
```

### 🎨 Import 정리

```tsx
// ✅ 권장: 그룹별 import 정리
// 1. React 관련
import React, { useCallback, useState, useEffect } from 'react';

// 2. 서드파티 라이브러리
import { toast } from 'react-hot-toast';

// 3. Context-Action 프레임워크
import { useStoreValue } from '@context-action/react';

// 4. 로컬 컨텍스트 (리네이밍된 훅들)
import { 
  useUserStore, 
  useUserAction, 
  useUserActionHandler 
} from '@/contexts/user';

// 5. 컴포넌트
import { ProfileForm } from './ProfileForm';

// 6. 타입
import type { UserProfile } from '@/types/user.types';
```

---

## 성능 가이드라인

### ⚡ Store 최적화

#### Comparison Strategy 선택
```tsx
// ✅ 권장: 데이터 특성에 맞는 strategy 선택
const {
  Provider: DataStoreProvider,
  useStore: useDataStore
} = createDeclarativeStorePattern('Data', {
  // 원시값: reference (기본값)
  counter: 0,
  isLoading: false,
  
  // 객체의 속성이 변경되는 경우: shallow  
  userProfile: {
    initialValue: { name: '', email: '', age: 0 },
    strategy: 'shallow'
  },
  
  // 중첩 객체가 자주 변경되는 경우: deep
  complexForm: {
    initialValue: { nested: { deep: { values: {} } } },
    strategy: 'deep'
  },
  
  // 큰 배열이나 성능이 중요한 경우: reference
  largeDataset: {
    initialValue: [] as DataItem[],
    strategy: 'reference',
    description: '성능을 위해 reference equality 사용'
  },
  
  // 고급 비교 옵션 사용
  advancedData: {
    initialValue: { id: '', data: {}, lastUpdated: new Date() },
    comparisonOptions: {
      strategy: 'shallow',
      ignoreKeys: ['lastUpdated'], // 특정 키 무시
      maxDepth: 2,                 // 성능을 위한 깊이 제한
      enableCircularCheck: true    // 순환 참조 방지
    }
  },
  
  // 커스텀 비교 로직
  versionedData: {
    initialValue: { version: 1, content: {} },
    comparisonOptions: {
      strategy: 'custom',
      customComparator: (oldVal, newVal) => {
        // 버전 기반 비교
        return oldVal.version === newVal.version;
      }
    }
  }
});
```

#### 메모이제이션 패턴
```tsx
// ✅ 권장: useCallback으로 핸들러 메모이제이션
function UserComponent() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  // 핸들러 메모이제이션 (의존성 배열 주의)
  const updateHandler = useCallback(async (payload) => {
    profileStore.setValue({ ...profile, ...payload.data });
  }, [profile, profileStore]);
  
  useUserActionHandler('updateProfile', updateHandler);
  
  // 계산된 값 메모이제이션
  const displayName = useMemo(() => {
    return profile.firstName + ' ' + profile.lastName;
  }, [profile.firstName, profile.lastName]);
  
  return <div>{displayName}</div>;
}
```

### 🔄 Action 최적화

#### Debounce/Throttle 설정
```tsx
// ✅ 권장: 적절한 debounce/throttle 사용
useUserActionHandler('searchUsers', searchHandler, {
  debounce: 300,  // 검색은 debounce
  id: 'search-handler'
});

useUserActionHandler('trackScroll', scrollHandler, {
  throttle: 100,  // 스크롤은 throttle  
  id: 'scroll-handler'
});

useUserActionHandler('saveForm', saveHandler, {
  blocking: true,  // 중요한 액션은 blocking
  once: false,
  id: 'save-handler'
});
```

---

## 🧪 타입 테스트 및 검증

### ✅ 타입 안전성 검증

#### 컴파일 타임 타입 테스트
```tsx
// ✅ 권장: 타입 테스트 파일 작성
// src/contexts/__tests__/user.types.test.tsx

import { createDeclarativeStorePattern, createActionContext } from '@context-action/react';

// 명시적 제네릭 테스트
interface UserStores {
  profile: { id: string; name: string; email: string };
  settings: { theme: 'light' | 'dark'; language: string };
}

// 타입 안전성 검증
const ExplicitStores = createDeclarativeStorePattern<UserStores>('User', {
  profile: { id: '', name: '', email: '' },  // 타입 체크됨
  settings: {
    initialValue: { theme: 'light', language: 'en' },
    strategy: 'shallow'
  }
});

// 타입 추론 테스트
const InferredStores = createDeclarativeStorePattern('Inferred', {
  counter: 0,  // Store<number>로 추론
  user: { id: '', name: '' },  // Store<{id: string, name: string}>로 추론
  isActive: false  // Store<boolean>로 추론
});

// Action Context 타입 테스트
interface TestActions {
  updateUser: { id: string; name: string };
  deleteUser: { id: string };
  refresh: void;
}

const ActionContext = createActionContext<TestActions>('Test', {
  registry: { debug: true }
});

// 사용 패턴 검증
function TypeValidationComponent() {
  const profileStore = ExplicitStores.useStore('profile');
  const counterStore = InferredStores.useStore('counter');
  const dispatch = ActionContext.useActionDispatch();
  
  // 올바른 타입 사용 검증
  dispatch('updateUser', { id: '123', name: 'John' }); // ✅ 타입 안전
  dispatch('refresh'); // ✅ void payload
  
  return null;
}
```

#### 런타임 에러 처리 개선
```tsx
// ✅ 권장: 개발 모드 디버깅 지원
// JSON 직렬화 실패 시 자동 fallback

const DataStores = createDeclarativeStorePattern('Data', {
  // 순환 참조나 특수 타입이 포함된 데이터
  complexData: {
    initialValue: { /* BigInt, Symbol, Function 등 */ },
    comparisonOptions: {
      strategy: 'deep',
      // 개발 모드에서 JSON 직렬화 실패 로그 출력
      enableCircularCheck: true
    }
  }
});
```

### 🔍 디버깅 도구

#### 개발 모드 로깅
```tsx
// ✅ 권장: 개발 모드에서만 활성화되는 디버깅
const DebugStores = createDeclarativeStorePattern('Debug', {
  userData: {
    initialValue: { id: '', profile: {} },
    debug: true,  // 개발 모드에서 스토어 생성 로그
    comparisonOptions: {
      strategy: 'shallow',
      // 비교 실패 시 개발 모드에서만 경고 출력
    }
  }
});
```

---

## 에러 핸들링

### 🚨 Error Boundary 패턴

```tsx
// ✅ 권장: 도메인별 Error Boundary
function UserErrorBoundary({ children }: { children: React.ReactNode }) {
  return (
    <ErrorBoundary
      fallback={<UserErrorFallback />}
      onError={(error, errorInfo) => {
        // 사용자 관련 에러 로깅
        console.error('User context error:', error, errorInfo);
      }}
    >
      {children}
    </ErrorBoundary>
  );
}

function UserProvider({ children }: { children: React.ReactNode }) {
  return (
    <UserActionProvider>
      <UserStoreProvider>
        <UserErrorBoundary>
          {children}
        </UserErrorBoundary>
      </UserStoreProvider>
    </UserActionProvider>
  );
}
```

### 🛡️ Action Error 처리

```tsx
// ✅ 권장: Pipeline Controller를 이용한 에러 처리
useUserActionHandler('riskyOperation', useCallback(async (payload, controller) => {
  try {
    // 1. 입력 검증
    if (!payload.data || !payload.data.id) {
      controller.abort('유효하지 않은 입력 데이터');
      return;
    }
    
    // 2. 비즈니스 로직 실행
    const result = await performRiskyOperation(payload.data);
    
    // 3. 성공 시 상태 업데이트
    const store = storeManager.getStore('userData');
    store.setValue(result);
    
    // 4. 결과 반환 (필요한 경우)
    controller.setResult(result);
    
  } catch (error) {
    // 5. 에러 처리
    if (error instanceof ValidationError) {
      controller.abort('데이터 검증 실패', error);
    } else if (error instanceof NetworkError) {
      controller.abort('네트워크 오류', error);
    } else {
      controller.abort('알 수 없는 오류가 발생했습니다', error);
    }
  }
}, [storeManager]));
```

---

## 📚 추가 리소스

### 관련 문서
- [Pattern Guide](./pattern-guide.md) - 상세한 패턴 사용법
- [Full Architecture Guide](./architecture-guide.md) - 완전한 아키텍처 가이드
- [Hooks Reference](./hooks-reference.md) - Hooks 참조 문서
- [API Reference](../../api/) - API 문서

### 예제 프로젝트
- [Basic Example](../../../example/) - 기본 사용 예제
- [Advanced Patterns](../../examples/) - 고급 패턴 예제

### 마이그레이션 가이드
- [Legacy Pattern Migration](./pattern-guide.md#migration-guide) - 레거시 패턴에서 마이그레이션

---

## ❓ FAQ

### Q: 언제 Store Only vs Action Only vs Composition을 사용해야 하나요?
- **Store Only**: 순수 상태 관리 (폼, 설정, 캐시)
- **Action Only**: 순수 이벤트 처리 (로깅, 트래킹, 알림)  
- **Composition**: 복잡한 비즈니스 로직 (사용자 관리, 쇼핑카트)

### Q: 리네이밍 패턴을 꼭 사용해야 하나요?
네, 리네이밍 패턴은 Context-Action 프레임워크의 핵심 컨벤션입니다. 타입 안전성과 개발자 경험을 크게 향상시킵니다.

### Q: 성능 최적화는 어떻게 해야 하나요?
1. 적절한 comparison strategy 선택
2. useCallback으로 핸들러 메모이제이션  
3. 큰 데이터는 reference strategy 사용
4. 필요시 debounce/throttle 적용

### Q: 에러 처리는 어떻게 해야 하나요?
1. Pipeline Controller의 abort() 메서드 사용
2. 도메인별 Error Boundary 설정
3. 적절한 에러 타입별 처리
4. 사용자 친화적 에러 메시지 제공

### Q: 명시적 제네릭과 타입 추론 중 어떤 것을 사용해야 하나요?
- **타입 추론 (권장)**: 대부분의 경우, 코드가 간결하고 타입 안전성 보장
- **명시적 제네릭**: 복잡한 타입 구조나 엄격한 타입 제약이 필요한 경우

### Q: comparisonOptions는 언제 사용해야 하나요?
1. **ignoreKeys**: 타임스탬프 등 특정 필드 변경을 무시하고 싶을 때
2. **customComparator**: 비즈니스 로직에 맞는 특별한 비교가 필요할 때
3. **maxDepth**: 성능 최적화를 위해 깊은 비교의 깊이를 제한하고 싶을 때
4. **enableCircularCheck**: 순환 참조 가능성이 있는 객체를 다룰 때

### Q: 타입 테스트는 어떻게 작성해야 하나요?
1. 명시적 제네릭과 타입 추론 모두 테스트
2. 컴파일 타임에 타입 안전성 검증
3. 에러 케이스도 주석으로 문서화
4. 실제 사용 패턴을 반영한 테스트 컴포넌트 작성

---


# Concept Hooks Reference

**Source**: `concept/hooks-reference.md`  
**Priority**: 50 (reference)  

# Context-Action React Hooks Reference

This document categorizes all available React hooks in the Context-Action framework into **Essential Hooks** (core functionality) and **Utility Hooks** (convenience and optimization).

## 📋 Table of Contents

1. [Essential Hooks](#essential-hooks)
2. [Utility Hooks](#utility-hooks)
3. [Hook Categories](#hook-categories)
4. [Usage Guidelines](#usage-guidelines)

---

## Essential Hooks

These hooks are fundamental to using the Context-Action framework. Most applications will need these.

### 🎯 Action Hooks (Core)

#### `createActionContext<T>()`
**Factory function** that creates all action-related hooks for a specific action context.
- **Purpose**: Creates type-safe action dispatch and handler system
- **Returns**: `{ Provider, useActionDispatch, useActionHandler, useActionRegister }`
- **Essential for**: Any action-based logic

```tsx
const { 
  Provider: UserActionProvider,
  useActionDispatch: useUserAction,
  useActionHandler: useUserActionHandler
} = createActionContext<UserActions>('UserActions');
```

#### `useActionDispatch()`
**Primary hook** for dispatching actions to handlers.
- **Purpose**: Get dispatch function to trigger actions
- **Essential for**: Component interaction with business logic
- **Pattern**: ViewModel layer in MVVM architecture

#### `useActionHandler()`
**Primary hook** for registering action handlers.
- **Purpose**: Register business logic for specific actions
- **Essential for**: Implementing business logic
- **Best Practice**: Use with `useCallback` for optimization

### 🏪 Store Hooks (Core)

#### `createDeclarativeStorePattern<T>()`
**Factory function** that creates all store-related hooks with type safety.
- **Purpose**: Creates type-safe store management system
- **Returns**: `{ Provider, useStore, useStoreManager, withProvider }`
- **Essential for**: Any state management

```tsx
const {
  Provider: UserStoreProvider,
  useStore: useUserStore,
  useStoreManager: useUserStoreManager
} = createDeclarativeStorePattern('User', {
  profile: { id: '', name: '' }
});
```

#### `useStoreValue<T>(store)`
**Primary hook** for subscribing to store changes.
- **Purpose**: Get reactive value from store
- **Essential for**: Reading state in components
- **Performance**: Only re-renders on actual value changes

```tsx
const userStore = useUserStore('profile');
const user = useStoreValue(userStore);
```

#### `useStore(name)` (from pattern)
**Primary hook** for accessing stores by name.
- **Purpose**: Get store instance from context
- **Essential for**: Accessing stores in components
- **Type-safe**: Returns properly typed store

---

## Utility Hooks

These hooks provide additional functionality, optimizations, and convenience features.

### 🎯 Action Utility Hooks

#### `useActionDispatchWithResult()`
**Utility hook** for actions that need to collect results.
- **Purpose**: Dispatch actions and collect handler results
- **Use Case**: When you need return values from handlers
- **Advanced**: For complex workflows requiring handler responses

```tsx
const { dispatchWithResult } = useActionDispatchWithResult();
const result = await dispatchWithResult('login', credentials);
```

#### `useActionRegister()`
**Utility hook** for direct access to ActionRegister instance.
- **Purpose**: Advanced control over action registry
- **Use Case**: Dynamic handler management, debugging
- **Advanced**: Rarely needed in typical applications

### 🏪 Store Utility Hooks

#### `useStoreSelector<T, R>(store, selector, equalityFn?)`
**Performance hook** for selective subscriptions.
- **Purpose**: Subscribe to specific parts of store
- **Optimization**: Prevents unnecessary re-renders
- **Use Case**: Large objects where only part changes

```tsx
const userName = useStoreSelector(userStore, user => user.name, shallowEqual);
```

#### `useComputedStore<T, R>(store, compute, config?)`
**Derived state hook** for computed values.
- **Purpose**: Create derived state from stores
- **Optimization**: Only recomputes when dependencies change
- **Use Case**: Calculated values, aggregations

```tsx
const fullName = useComputedStore(
  userStore,
  user => `${user.firstName} ${user.lastName}`
);
```

#### `useLocalStore<T>(initialValue, name?)`
**Component-local store** hook.
- **Purpose**: Create store scoped to component lifecycle
- **Use Case**: Complex component state
- **Benefit**: Store API without global state

```tsx
const { value, setValue, store } = useLocalStore({ count: 0 });
```

#### `usePersistedStore<T>(key, initialValue, options?)`
**Persistence hook** for browser storage.
- **Purpose**: Auto-sync store with localStorage/sessionStorage
- **Use Case**: Settings, user preferences, draft data
- **Feature**: Cross-tab synchronization

```tsx
const themeStore = usePersistedStore('theme', 'light', {
  storage: localStorage
});
```


#### `assertStoreValue<T>(value, storeName)`
**Type assertion utility** for store values.
- **Purpose**: Runtime assertion for non-undefined values
- **Type Safety**: Throws error if undefined
- **Use Case**: When store must have a value

```tsx
const user = useStoreValue(userStore);
const safeUser = assertStoreValue(user, 'userStore'); // never undefined
```


### 🔧 Performance Optimization Hooks

#### `useMultiStoreSelector(stores, selector, equalityFn?)`
**Multi-store selector** for combining stores.
- **Purpose**: Select from multiple stores efficiently
- **Optimization**: Single subscription for multiple stores
- **Use Case**: Cross-store computed values

#### `useStorePathSelector(store, path, equalityFn?)`
**Path-based selector** for nested objects.
- **Purpose**: Select nested values by path
- **Convenience**: Dot notation for deep selection
- **Use Case**: Complex nested state

#### `useAsyncComputedStore(asyncCompute, deps, config?)`
**Async computed values** hook.
- **Purpose**: Compute values asynchronously
- **Feature**: Loading states, error handling
- **Use Case**: API-derived state

---

## Hook Categories

### By Domain

#### State Management
- **Essential**: `useStoreValue`, `useStore` (from pattern)
- **Utility**: `useStoreSelector`, `useComputedStore`, `useLocalStore`

#### Action Handling
- **Essential**: `useActionDispatch`, `useActionHandler`
- **Utility**: `useActionDispatchWithResult`, `useActionRegister`

#### Performance
- **Utility**: `useStoreSelector`, `useComputedStore`, `useStoreActions`

#### Persistence
- **Utility**: `usePersistedStore`

#### Advanced/Meta
- **Utility**: `useActionRegister`

### By Usage Frequency

#### High Frequency (>80% of components)
- `useStoreValue`
- `useActionDispatch`
- `useStore` (from pattern)

#### Medium Frequency (20-80% of components)
- `useActionHandler`
- `useStoreSelector`
- `useLocalStore`

#### Low Frequency (<20% of components)
- `useComputedStore`
- `usePersistedStore`
- `useActionDispatchWithResult`

---

## Usage Guidelines

### When to Use Essential Hooks

1. **Starting a new feature**: Always start with essential hooks
2. **Basic CRUD operations**: Essential hooks are sufficient
3. **Simple state management**: `useStoreValue` + `useActionDispatch`
4. **Standard business logic**: `useActionHandler` for logic implementation

### When to Use Utility Hooks

1. **Performance issues**: Use selector hooks for optimization
2. **Complex state derivation**: Use `useComputedStore`
3. **Browser storage needs**: Use `usePersistedStore`
4. **Component-local complex state**: Use `useLocalStore`
5. **Advanced workflows**: Use result collection hooks
6. **Meta-programming**: Use registry hooks

### Best Practices

#### Essential Hook Patterns
```tsx
// Standard component pattern
function UserProfile() {
  // Essential: Get stores
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  // Essential: Get dispatch
  const dispatch = useUserAction();
  
  // Essential: Register handler
  useUserActionHandler('updateProfile', useCallback(async (payload) => {
    // Business logic here
  }, []));
  
  return <div>{profile.name}</div>;
}
```

#### Utility Hook Patterns
```tsx
// Optimized component with utilities
function OptimizedUserProfile() {
  // Utility: Selective subscription
  const userName = useStoreSelector(userStore, u => u.name);
  
  // Utility: Computed value
  const displayName = useComputedStore(userStore, u => 
    u.nickname || u.name || 'Anonymous'
  );
  
  // Utility: Persisted settings
  const settings = usePersistedStore('userSettings', {
    theme: 'light',
    notifications: true
  });
  
  // Utility: Result collection
  const { dispatchWithResult } = useActionDispatchWithResult();
  
  return <div>{displayName}</div>;
}
```

### Migration Path

For new projects:
1. Start with essential hooks only
2. Add utility hooks as needs arise
3. Refactor to utility hooks for optimization

For existing projects:
1. Keep existing patterns working
2. Gradually adopt utility hooks for new features
3. Refactor performance-critical areas with selector hooks

---

## Additional Hooks and Utilities

### 🔍 Context Hooks

#### `useStoreContext()`
**Low-level context hook** for accessing store context directly.
- **Purpose**: Direct access to store context internals
- **Use Case**: Custom store patterns, debugging
- **Advanced**: Rarely needed in applications

```tsx
const context = useStoreContext();
// Access to internal store context structure
```

### 📊 Multiple Store Hooks

#### `useStoreValues<T, S>(store, selectors)`
**Multiple selector hook** for extracting multiple values at once.
- **Purpose**: Extract multiple values with single subscription
- **Performance**: More efficient than multiple `useStoreValue` calls
- **Use Case**: Components needing multiple derived values

```tsx
const { name, age, email } = useStoreValues(userStore, {
  name: user => user.name,
  age: user => user.age,
  email: user => user.email
});
```

#### `useMultiStoreSelector<R>(stores, selector, equalityFn?)`
**Cross-store selector** for combining multiple stores.
- **Purpose**: Compute value from multiple stores
- **Performance**: Single subscription for all stores
- **Use Case**: Cross-store computed values

```tsx
const summary = useMultiStoreSelector(
  [userStore, settingsStore],
  ([user, settings]) => ({
    displayName: user.name,
    theme: settings.theme
  }),
  shallowEqual
);
```

#### `useMultiComputedStore<R>(stores, compute, config?)`
**Multi-store computed hook** for complex derivations.
- **Purpose**: Compute values from multiple store dependencies
- **Memoization**: Only recomputes when dependencies change
- **Use Case**: Complex cross-store calculations

```tsx
const dashboard = useMultiComputedStore(
  [salesStore, inventoryStore, userStore],
  ([sales, inventory, users]) => ({
    totalRevenue: sales.reduce((sum, s) => sum + s.amount, 0),
    lowStock: inventory.filter(i => i.quantity < 10),
    activeUsers: users.filter(u => u.isActive)
  })
);
```

### 🎯 Specialized Selector Hooks

#### `useStorePathSelector<T>(store, path, equalityFn?)`
**Path-based selector** for nested values.
- **Purpose**: Select deeply nested values by path
- **Convenience**: Array or dot notation for paths
- **Use Case**: Complex nested state structures

```tsx
// Using array path
const city = useStorePathSelector(userStore, ['address', 'city']);

// Would also support dot notation if implemented
const city = useStorePathSelector(userStore, 'address.city');
```

#### `useAsyncComputedStore<R>(dependencies, compute, config?)`
**Async computation hook** for asynchronous derived state.
- **Purpose**: Compute values asynchronously from stores
- **Features**: Loading states, error handling, caching
- **Use Case**: API calls based on store values

```tsx
const enrichedUser = useAsyncComputedStore(
  [userStore],
  async ([user]) => {
    const profile = await fetchUserProfile(user.id);
    return { ...user, ...profile };
  },
  {
    initialValue: null,
    onError: (err) => console.error('Failed to fetch profile:', err)
  }
);
```

#### `useComputedStoreInstance<R>(dependencies, compute, config?)`
**Store instance creator** for computed stores.
- **Purpose**: Create a Store instance from computed values
- **Returns**: Actual `Store<R>` instance (not just value)
- **Use Case**: When you need a store interface for computed values

```tsx
const computedStore = useComputedStoreInstance(
  [priceStore, quantityStore],
  ([price, quantity]) => price * quantity,
  { name: 'totalPriceStore' }
);

// Can now pass this to other components expecting a Store
<PriceDisplay store={computedStore} />
```

### 🔧 Higher-Order Components (HOCs)

#### `withProvider(Component, config?)`
**HOC for automatic provider wrapping**.
- **Purpose**: Wrap components with their required providers
- **Convenience**: Eliminates manual provider nesting
- **Configuration**: Optional display name and registry ID

```tsx
// Basic usage
const UserProfileWithProvider = UserStores.withProvider(UserProfile);

// With configuration
const UserProfileWithProvider = UserStores.withProvider(UserProfile, {
  displayName: 'UserProfileWithStores',
  registryId: 'user-profile-stores'
});

// Usage - no manual provider needed
<UserProfileWithProvider />
```

### 🔧 Utility Functions

#### `shallowEqual<T>(a, b)`
**Shallow equality comparison** function.
- **Purpose**: Compare objects at first level only
- **Performance**: Faster than deep comparison
- **Use Case**: Object/array comparison in selectors

```tsx
const user = useStoreSelector(
  userStore,
  state => ({ name: state.name, age: state.age }),
  shallowEqual // Only re-render if name or age changes
);
```

#### `deepEqual<T>(a, b)`
**Deep equality comparison** function.
- **Purpose**: Recursively compare nested structures
- **Caution**: Performance cost for large objects
- **Use Case**: Complex nested object comparison

```tsx
const settings = useStoreSelector(
  settingsStore,
  state => state.preferences,
  deepEqual // Deep comparison of preferences object
);
```

#### `defaultEqualityFn<T>(a, b)`
**Default equality function** (Object.is).
- **Purpose**: Default comparison using Object.is
- **Behavior**: Same as `===` except for NaN and +0/-0
- **Use Case**: Primitive values, reference equality

#### `assertStoreValue<T>(value, storeName)`
**Runtime assertion** helper for store values.
- **Purpose**: Assert value is not undefined at runtime
- **Safety**: Throws descriptive error if undefined
- **Use Case**: Critical values that must exist

```tsx
function CriticalComponent() {
  const userStore = useUserStore('profile');
  const user = useStoreValue(userStore);
  
  // Ensure user exists before proceeding
  const safeUser = assertStoreValue(user, 'userProfile');
  
  return <div>Welcome {safeUser.name}</div>;
}
```

### 📦 Pattern-Specific Hooks

These hooks are created by factory functions:

#### From `createDeclarativeStorePattern()`
- `Provider` - Context provider component
- `useStore(name)` - Get store by name
- `useStoreManager()` - Get store manager instance
- `withProvider(Component, config?)` - HOC for auto-wrapping

#### From `createActionContext()`
- `Provider` - Action context provider
- `useActionContext()` - Get action context
- `useActionDispatch()` - Get dispatch function
- `useActionHandler(action, handler, config?)` - Register handler
- `useActionRegister()` - Get ActionRegister instance
- `useActionDispatchWithResult()` - Dispatch with result collection

---

## Complete Hook Categories

### By Functionality

#### Core State Management
- `useStoreValue` - Subscribe to store value
- `useStoreValues` - Subscribe to multiple values
- `useStore` - Get store instance

#### Performance Optimization
- `useStoreSelector` - Selective subscription
- `useMultiStoreSelector` - Multi-store selection
- `useStorePathSelector` - Path-based selection
- `useComputedStore` - Computed values
- `useMultiComputedStore` - Multi-store computation
- `useAsyncComputedStore` - Async computation

#### Store Creation & Management
- `useLocalStore` - Component-local store
- `usePersistedStore` - Persistent store
- `useComputedStoreInstance` - Computed store instance

#### Action System
- `useActionDispatch` - Dispatch actions
- `useActionHandler` - Register handlers
- `useActionDispatchWithResult` - Dispatch with results
- `useActionRegister` - Access register
- `useActionContext` - Access context

#### Utilities & Helpers
- `useStoreContext` - Store context access
- `assertStoreValue` - Value assertion
- `shallowEqual` - Shallow comparison
- `deepEqual` - Deep comparison
- `defaultEqualityFn` - Default comparison

#### HOCs & Patterns
- `withProvider` - Auto-provider HOC

---

## Summary

### Essential Hooks (Must Learn)
- **Factory Functions**: `createActionContext`, `createDeclarativeStorePattern`
- **Core Hooks**: `useStoreValue`, `useActionDispatch`, `useActionHandler`, `useStore`

### Utility Hooks (Learn As Needed)
- **Performance**: `useStoreSelector`, `useComputedStore`
- **Convenience**: `useLocalStore`, `usePersistedStore`
- **Advanced**: `useActionDispatchWithResult`

### Specialized Hooks (For Specific Cases)
- **Multi-Store**: `useMultiStoreSelector`, `useMultiComputedStore`, `useStoreValues`
- **Async**: `useAsyncComputedStore`
- **Path Selection**: `useStorePathSelector`
- **Type Safety**: `assertStoreValue`
- **Low-Level**: `useStoreContext`, `useActionContext`

### Helper Functions
- **Equality**: `shallowEqual`, `deepEqual`, `defaultEqualityFn`
- **HOCs**: `withProvider`

The framework provides **30+ hooks and utilities** total, but most applications only need the essential hooks. The focused utility hooks provide powerful optimizations and conveniences when specific needs arise.

---


# Concept Pattern Guide

**Source**: `concept/pattern-guide.md`  
**Priority**: 50 (reference)  

# @context-action/react Pattern Guide

Complete guide to the two main patterns available in @context-action/react framework.

## 📋 Quick Start Guide

Choose the right pattern for your use case:

| Pattern | Use Case | Import | Best For |
|---------|----------|--------|----------|
| **🎯 Action Only** | Action dispatching without stores | `createActionContext` | Event systems, command patterns |
| **🏪 Store Only** | State management without actions | `createDeclarativeStorePattern` | Pure state management, data layers |

**Note**: For complex applications needing both actions and state, compose Action Only + Store Only patterns together.

---

## 🎯 Action Only Pattern

**When to use**: Pure action dispatching without state management (event systems, command patterns).

### Import
```typescript
import { createActionContext } from '@context-action/react';
```

### Features
- ✅ Type-safe action dispatching
- ✅ Action handler registration
- ✅ Abort support
- ✅ Result handling
- ✅ Lightweight (no store overhead)

### Basic Usage
```tsx
// 1. Define Actions (ActionPayloadMap optional)
interface EventActions {
  userClick: { x: number; y: number };
  userHover: { elementId: string };
  analytics: { event: string; data: any };
}

// 2. Create Context with Renaming Pattern
const {
  Provider: EventActionProvider,
  useActionDispatch: useEventAction,
  useActionHandler: useEventActionHandler
} = createActionContext<EventActions>('Events');

// 3. Provider Setup
function App() {
  return (
    <EventActionProvider>
      <InteractiveComponent />
    </EventActionProvider>
  );
}

// 4. Component Usage with Renamed Hooks  
function InteractiveComponent() {
  const dispatch = useEventAction();
  
  // Register action handlers with renamed hook
  useEventActionHandler('userClick', (payload, controller) => {
    console.log('User clicked at:', payload.x, payload.y);
    // Pure side effects, no state management
  });
  
  useEventActionHandler('analytics', async (payload) => {
    await fetch('/analytics', {
      method: 'POST',
      body: JSON.stringify(payload)
    });
  });
  
  const handleClick = (e: MouseEvent) => {
    dispatch('userClick', { x: e.clientX, y: e.clientY });
    dispatch('analytics', { event: 'click', data: { timestamp: Date.now() } });
  };
  
  return <button onClick={handleClick}>Click Me</button>;
}
```

### Advanced Features
```tsx
// Use the renamed context hooks for advanced features
const { useActionDispatchWithResult: useEventActionWithResult } = createActionContext<EventActions>('Events');

function AdvancedComponent() {
  const { 
    dispatch, 
    dispatchWithResult, 
    abortAll 
  } = useEventActionWithResult();
  
  const handleAsyncAction = async () => {
    try {
      const result = await dispatchWithResult('analytics', {
        event: 'complex-operation',
        data: { userId: 123 }
      });
      console.log('Action result:', result);
    } catch (error) {
      console.error('Action failed:', error);
    }
  };
  
  const handleAbortAll = () => {
    abortAll(); // Abort all pending actions
  };
  
  return (
    <div>
      <button onClick={handleAsyncAction}>Async Action</button>
      <button onClick={handleAbortAll}>Abort All</button>
    </div>
  );
}
```

### Available Hooks
- `useActionDispatch()` - Basic action dispatcher
- `useActionHandler(action, handler, config?)` - Register action handlers
- `useActionDispatchWithResult()` - Advanced dispatcher with results/abort
- `useActionRegister()` - Access raw ActionRegister
- `useActionContext()` - Access raw context

---

## 🏪 Store Only Pattern (Recommended)

**When to use**: Pure state management without action dispatching (data layers, simple state).

**Key Features**: 
- ✅ Excellent type inference without manual type annotations
- ✅ Simplified API focused on store management
- ✅ Direct value or configuration object support
- ✅ No need for separate `createStore` calls

### Import
```typescript
import { createDeclarativeStorePattern } from '@context-action/react';
```

### Basic Usage

#### Option 1: Type Inference (Current)
```tsx
// 1. Define stores with renaming pattern for type-safe access
const {
  Provider: AppStoreProvider,
  useStore: useAppStore,
  useStoreManager: useAppStoreManager
} = createDeclarativeStorePattern('App', {
  // Simple direct values - cleanest syntax
  counter: 0,
  userName: '',
  isLoggedIn: false,
  
  // With configuration for complex types
  user: {
    initialValue: { id: '', name: '', email: '' },
    strategy: 'shallow',
    description: 'User profile data'
  },
  
  // Nested structures with type safety
  settings: {
    initialValue: {
      theme: 'light' as 'light' | 'dark',
      language: 'en',
      notifications: true
    },
    strategy: 'shallow'
  }
});
```

#### Option 2: Explicit Generic Types (New)
```tsx
// 1. Define store types explicitly
interface AppStoreTypes {
  counter: number;
  userName: string;
  isLoggedIn: boolean;
  user: { id: string; name: string; email: string };
  settings: { theme: 'light' | 'dark'; language: string; notifications: boolean };
}

// 2. Create stores with explicit types - still requires InitialStores<T> structure
const {
  Provider: AppStoreProvider,
  useStore: useAppStore,
  useStoreManager: useAppStoreManager
} = createDeclarativeStorePattern<AppStoreTypes>('App', {
  // Types validated against AppStoreTypes interface
  counter: 0,  // Must match AppStoreTypes['counter'] = number
  userName: '', // Must match AppStoreTypes['userName'] = string
  isLoggedIn: false,
  
  // Complex types with configuration
  user: { id: '', name: '', email: '' },
  settings: {
    initialValue: { theme: 'light', language: 'en', notifications: true },
    strategy: 'shallow'
  }
});

// 2. Provider Setup (minimal boilerplate)
function App() {
  return (
    <AppStoreProvider>
      <UserProfile />
      <Settings />
    </AppStoreProvider>
  );
}

// 3. Component Usage with Excellent Type Inference
function UserProfile() {
  // Perfect type inference - no manual type annotations needed!
  const counterStore = useAppStore('counter');      // Store<number>
  const userStore = useAppStore('user');           // Store<{id: string, name: string, email: string}>
  const settingsStore = useAppStore('settings');   // Store<{theme: 'light' | 'dark', language: string, notifications: boolean}>
  
  // Subscribe to values
  const counter = useStoreValue(counterStore);
  const user = useStoreValue(userStore);
  const settings = useStoreValue(settingsStore);
  
  const incrementCounter = () => {
    counterStore.setValue(counter + 1);
  };
  
  const updateUser = () => {
    userStore.setValue({
      ...user,
      name: 'John Doe',
      email: 'john@example.com'
    });
  };
  
  const toggleTheme = () => {
    settingsStore.setValue({
      ...settings,
      theme: settings.theme === 'light' ? 'dark' : 'light'
    });
  };
  
  return (
    <div data-theme={settings.theme}>
      <div>Counter: {counter}</div>
      <div>User: {user.name} ({user.email})</div>
      <div>Theme: {settings.theme}</div>
      
      <button onClick={incrementCounter}>+1</button>
      <button onClick={updateUser}>Update User</button>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </div>
  );
}
```

### HOC Pattern (Advanced)
```tsx
// Get withProvider from the renamed context
const { withProvider: withAppStoreProvider } = createDeclarativeStorePattern('App', {...});

// Automatic Provider wrapping with HOC
const AppWithStores = withAppStoreProvider(App);

// With custom registry ID
const AppWithCustomStores = withAppStoreProvider(App, {
  registryId: 'custom-app-stores'
});

// Use anywhere without manual Provider wrapping
function Root() {
  return <AppWithStores />;
}
```

### Advanced Configuration
```tsx
// Advanced store configuration with renaming pattern
const {
  Provider: AdvancedStoreProvider,
  useStore: useAdvancedStore,
  useStoreManager: useAdvancedStoreManager
} = createDeclarativeStorePattern('Advanced', {
  // Performance-optimized store
  largeDataset: {
    initialValue: [] as DataItem[],
    strategy: 'reference',  // Reference equality for performance
    debug: true,           // Enable debug logging
    tags: ['performance', 'data'],
    version: '1.0.0',
    description: 'Large dataset with reference equality'
  },
  
  // Deep comparison store
  complexObject: {
    initialValue: { nested: { deep: { value: 0 } } },
    strategy: 'deep',      // Deep comparison for nested changes
    comparisonOptions: {
      ignoreKeys: ['timestamp'],  // Ignore specific keys
      maxDepth: 5                 // Limit comparison depth
    }
  },
  
  // Custom comparison
  customStore: {
    initialValue: new Map(),
    comparisonOptions: {
      customComparator: (oldValue, newValue) => {
        // Custom comparison logic
        return oldValue.size === newValue.size;
      }
    }
  }
});
```

### Available Hooks
- `useStore(name)` - Get typed store by name (primary API)
- `useStoreManager()` - Access store manager (advanced use)
- `useStoreInfo()` - Get registry information
- `useStoreClear()` - Clear all stores

---

## 🔧 Pattern Composition

For complex applications that need both actions and state management, compose the patterns:

```tsx
// 1. Create separate contexts with renaming patterns
const { 
  Provider: EventActionProvider, 
  useActionDispatch: useEventAction,
  useActionHandler: useEventActionHandler
} = createActionContext<EventActions>('Events');

const {
  Provider: AppStoreProvider,
  useStore: useAppStore,
  useStoreManager: useAppStoreManager
} = createDeclarativeStorePattern('App', {
  user: { id: '', name: '' },
  counter: 0
});

// 2. Compose providers
function App() {
  return (
    <EventActionProvider>
      <AppStoreProvider>
        <ComplexComponent />
      </AppStoreProvider>
    </EventActionProvider>
  );
}

// 3. Use both patterns in components
function ComplexComponent() {
  // Actions from Action Only pattern (renamed hooks)
  const dispatch = useEventAction();
  
  // State from Store Only pattern (renamed hooks)
  const userStore = useAppStore('user');
  const counterStore = useAppStore('counter');
  
  const user = useStoreValue(userStore);
  const counter = useStoreValue(counterStore);
  
  // Action handlers that update state (renamed hook)
  useEventActionHandler('updateUser', (payload) => {
    userStore.setValue(payload);
    dispatch('analytics', { event: 'user-updated' });
  });
  
  return (
    <div>
      <div>User: {user.name}</div>
      <div>Counter: {counter}</div>
    </div>
  );
}
```

---

## 🎯 Migration Guide

### From Legacy Action Context Pattern

If you were using the removed `createActionContextPattern`, migrate to pattern composition:

```tsx
// ❌ Old (removed)
// const UserContext = createActionContextPattern<UserActions>('User');

// ✅ New (compose patterns with renaming)
const { 
  Provider: UserActionProvider, 
  useActionDispatch: useUserAction,
  useActionHandler: useUserActionHandler
} = createActionContext<UserActions>('UserActions');

const {
  Provider: UserStoreProvider,
  useStore: useUserStore,
  useStoreManager: useUserStoreManager
} = createDeclarativeStorePattern('UserStores', {
  profile: { id: '', name: '', email: '' },
  preferences: { theme: 'light' as const }
});

// Compose providers
function App() {
  return (
    <UserActionProvider>
      <UserStoreProvider>
        <UserComponent />
      </UserStoreProvider>
    </UserActionProvider>
  );
}
```

---

## 📚 Best Practices

### 1. Pattern Selection
- **Start with Store Only** for simple state management
- **Add Action Only** when you need side effects or complex workflows
- **Compose patterns** for full-featured applications

### 2. Naming Conventions
- Use descriptive context names: `UserActions`, `AppStores`
- Rename exported hooks for clarity: `useUserAction`, `useAppStore`
- Keep store names simple: `user`, `counter`, `settings`

### 3. Performance
- Use `strategy: 'reference'` for large datasets
- Use `strategy: 'shallow'` for objects that change properties
- Use `strategy: 'deep'` only when necessary

### 4. Type Safety
- Use explicit interfaces for actions (ActionPayloadMap optional)
- Consider explicit generic types for better type safety
- Let TypeScript infer store types from initial values or use explicit generics
- Use `as const` for literal types in store definitions

---

## 🔍 Examples

See the `examples/` directory for complete working examples of each pattern.

---



---

## Document Collection Summary

This collection includes all original documentation content from the Context-Action framework, preserving the complete information while removing YAML metadata for clean presentation.

**Generation Date**: 2025-08-14
**Content Type**: Original Documentation  
**Processing**: YAML frontmatter removed, content preserved

*Generated automatically from source documentation files*