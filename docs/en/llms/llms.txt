# Context-Action Framework - Complete LLM Integration Guide v1.0.1

Generated from documentation sources on 2025-08-14

## Framework Overview

Context-Action is a revolutionary TypeScript state management framework that solves fundamental limitations through document-centric context separation and MVVM architecture.

### Core Philosophy
- **Document-Centric Context Separation**: Each context represents specific document domains (design, architecture, business, validation)
- **Perfect Separation of Concerns**: Isolated view design, development architecture, business logic, data validation
- **MVVM Architecture**: Clear separation between View (components), ViewModel (actions), Model (stores)
- **Type Safety First**: Full TypeScript support with strict type checking

### Problems Solved
- **High React Coupling**: Existing libraries create tight integration making component modularization difficult
- **Binary State Approach**: Simple global/local dichotomy fails to handle scope-based separation
- **Inadequate Handler/Trigger Management**: Poor support for complex interactions and business logic

### Package Structure
- `@context-action/core` - Core action pipeline management (no React dependency)
- `@context-action/react` - React integration with Context API and hooks

### Installation
```bash
npm install @context-action/core @context-action/react
# or
pnpm add @context-action/core @context-action/react
# or
yarn add @context-action/core @context-action/react
```

### Requirements
- TypeScript 4.5+
- React 16.8+ (for React package)
- ES2018+ browser support

### Bundle Sizes
- Core package: ~15KB minified
- React package: ~25KB minified
- Combined: ~35KB total (tree-shakeable)

---

# Framework Conventions and Best Practices

# Context-Action Framework Conventions

이 문서는 Context-Action 프레임워크를 사용할 때 따라야 할 코딩 컨벤션과 베스트 프랙티스를 정의합니다.

## 📋 목차

1. [네이밍 컨벤션](#네이밍-컨벤션)
2. [파일 구조](#파일-구조)
3. [패턴 사용법](#패턴-사용법)
4. [타입 정의](#타입-정의)
5. [코드 스타일](#코드-스타일)
6. [성능 가이드라인](#성능-가이드라인)
7. [에러 핸들링](#에러-핸들링)

---

## 네이밍 컨벤션

### 🏷️ 리네이밍 패턴 (Renaming Pattern)

Context-Action 프레임워크의 핵심 컨벤션은 **도메인별 리네이밍 패턴**입니다.

#### ✅ Store Pattern 리네이밍
```tsx
// ✅ 권장: 도메인별 리네이밍
const {
  Provider: UserStoreProvider,
  useStore: useUserStore,
  useStoreManager: useUserStoreManager
} = createDeclarativeStorePattern('User', {...});

// ❌ 지양: 직접 객체 접근
const UserStores = createDeclarativeStorePattern('User', {...});
const userStore = UserStores.useStore('profile'); // 도메인이 불분명
```

#### ✅ Action Pattern 리네이밍
```tsx
// ✅ 권장: 도메인별 리네이밍 (제네릭 타입 명시)
const {
  Provider: UserActionProvider,
  useActionDispatch: useUserAction,
  useActionHandler: useUserActionHandler
} = createActionContext<UserActions>('UserActions');

// ❌ 지양: 제네릭 이름 사용
const {
  Provider,
  useActionDispatch,
  useActionHandler
} = createActionContext<UserActions>('UserActions');
```

### 🎯 컨텍스트 이름 규칙

#### 도메인 기반 네이밍
```tsx
// ✅ 권장: 명확한 도메인 구분
'UserProfile'     // 사용자 프로필 관련
'ShoppingCart'    // 쇼핑카트 관련  
'ProductCatalog'  // 상품 카탈로그 관련
'OrderManagement' // 주문 관리 관련
'AuthSystem'      // 인증 시스템 관련

// ❌ 지양: 모호한 이름
'Data'           // 너무 포괄적
'State'          // 구체적이지 않음
'App'            // 범위가 불분명 (루트 레벨에서만 사용)
'Manager'        // 역할이 불분명
```

#### Action vs Store 구분
```tsx
// Action Context (행동/이벤트 중심)
'UserActions'         // 사용자 액션들
'PaymentActions'      // 결제 액션들
'NavigationActions'   // 내비게이션 액션들

// Store Context (데이터/상태 중심)  
'UserData'           // 사용자 데이터
'ProductCatalog'     // 상품 카탈로그
'ShoppingCart'       // 쇼핑카트 상태
'AppSettings'        // 앱 설정
```

### 🔤 Hook 네이밍 패턴

#### Store Hook 네이밍
```tsx
// ✅ 권장: use + 도메인 + Store 패턴
const useUserStore = UserContext.useStore;
const useProductStore = ProductContext.useStore;
const useCartStore = CartContext.useStore;

// 사용 시
const profileStore = useUserStore('profile');
const wishlistStore = useUserStore('wishlist');
```

#### Action Hook 네이밍
```tsx
// ✅ 권장: use + 도메인 + Action 패턴
const useUserAction = UserContext.useActionDispatch;
const usePaymentAction = PaymentContext.useActionDispatch;
const useUserActionHandler = UserContext.useActionHandler;

// 사용 시
const dispatch = useUserAction();
useUserActionHandler('updateProfile', handler);
```

---

## 파일 구조

### 📁 권장 디렉토리 구조

```
src/
├── contexts/           # 컨텍스트 정의
│   ├── user/
│   │   ├── user.actions.ts     # UserActions 인터페이스 + createActionContext
│   │   ├── user.stores.ts      # UserData 인터페이스 + createDeclarativeStorePattern  
│   │   └── index.ts            # 리네이밍된 exports
│   ├── product/
│   │   ├── product.actions.ts
│   │   ├── product.stores.ts
│   │   └── index.ts
│   └── index.ts        # 모든 컨텍스트 re-export
├── providers/          # Provider 컴포넌트들
│   ├── UserProvider.tsx
│   ├── ProductProvider.tsx
│   └── AppProvider.tsx         # 루트 Provider 조합
├── hooks/             # 도메인별 커스텀 훅들
│   ├── user/
│   │   ├── useUserHandlers.ts   # 액션 핸들러 모음
│   │   ├── useUserProfile.ts    # 비즈니스 로직 훅
│   │   └── index.ts
│   └── index.ts
├── types/             # 공통 타입 정의
│   ├── user.types.ts
│   ├── product.types.ts
│   └── index.ts
└── components/        # React 컴포넌트들
    ├── user/
    ├── product/
    └── common/
```

### 📄 파일명 컨벤션

#### Context 파일명
```tsx
// ✅ 권장
user.actions.ts       // 액션 컨텍스트
user.stores.ts        // 스토어 컨텍스트
payment.actions.ts    // 결제 액션
product.stores.ts     // 상품 스토어

// ❌ 지양
userContext.ts        // 모호함 (액션인지 스토어인지 불분명)
User.ts              // 대문자 시작 (컴포넌트와 혼동)
userState.ts         // "state"보다는 "stores" 선호
```

#### Provider 파일명
```tsx
// ✅ 권장
UserProvider.tsx      // 사용자 관련 프로바이더
ProductProvider.tsx   // 상품 관련 프로바이더
AppProvider.tsx       // 루트 프로바이더

// ❌ 지양  
user-provider.tsx     // kebab-case 대신 PascalCase
userProvider.tsx      // camelCase 대신 PascalCase
```

---

## 패턴 사용법

### 🎯 패턴 선택 가이드

#### Store Only Pattern
```tsx
// ✅ 사용 시기: 순수 상태 관리가 필요한 경우
// - 폼 데이터 관리
// - 설정값 저장
// - 캐시된 데이터 관리
// - UI 상태 (모달, 토글 등)

// 방법 1: 타입 추론 (현재 방식)
const {
  Provider: SettingsStoreProvider,
  useStore: useSettingsStore,
  useStoreManager: useSettingsStoreManager
} = createDeclarativeStorePattern('Settings', {
  theme: 'light' as 'light' | 'dark',
  language: 'ko',
  notifications: true
});

// 방법 2: 명시적 제네릭 타입 (새로운 방식)
interface SettingsStoreTypes {
  theme: 'light' | 'dark';
  language: string;
  notifications: boolean;
}

const {
  Provider: SettingsStoreProvider,
  useStore: useSettingsStore,
  useStoreManager: useSettingsStoreManager
} = createDeclarativeStorePattern<SettingsStoreTypes>('Settings', {
  theme: 'light',  // 타입이 SettingsStoreTypes에서 추론됨
  language: 'ko',
  notifications: true
});
```

#### Action Only Pattern  
```tsx
// ✅ 사용 시기: 순수 액션 디스패치가 필요한 경우
// - 이벤트 트래킹
// - 로깅 시스템
// - 알림 발송
// - API 호출 (상태 변경 없이)

const {
  Provider: AnalyticsActionProvider,
  useActionDispatch: useAnalyticsAction,
  useActionHandler: useAnalyticsActionHandler
} = createActionContext<AnalyticsActions>('Analytics');
```

#### Pattern Composition
```tsx
// ✅ 사용 시기: 액션과 상태 관리가 모두 필요한 경우  
// - 복잡한 비즈니스 로직
// - 사용자 프로필 관리
// - 쇼핑카트 시스템
// - 게임 상태 관리

function App() {
  return (
    <UserActionProvider>
      <UserStoreProvider>
        <UserProfile />
      </UserStoreProvider>
    </UserActionProvider>
  );
}
```

### 🔄 Provider 조합 패턴

#### HOC 패턴 (권장)
```tsx
// ✅ 권장: HOC를 이용한 자동 Provider 감싸기
const { withProvider: withUserStoreProvider } = createDeclarativeStorePattern('User', {...});
const { withProvider: withUserActionProvider } = createActionContext<UserActions>('UserActions');

// 여러 Provider 조합
const withUserProviders = (Component: React.ComponentType) => 
  withUserActionProvider(withUserStoreProvider(Component));

const UserProfileWithProviders = withUserProviders(UserProfile);

// 사용
function App() {
  return <UserProfileWithProviders />;
}
```

#### Manual Provider 조합
```tsx
// ✅ 수동 조합 (복잡한 의존성이 있는 경우)
function UserProvider({ children }: { children: React.ReactNode }) {
  return (
    <UserActionProvider>
      <UserStoreProvider>
        <UserAnalyticsProvider>
          {children}
        </UserAnalyticsProvider>
      </UserStoreProvider>
    </UserActionProvider>
  );
}
```

---

## 타입 정의

### 🏷️ Interface 네이밍

#### Action Payload Map
```tsx
// ✅ 권장: 도메인 + Actions 패턴 (ActionPayloadMap 확장)
interface UserActions extends ActionPayloadMap {
  updateProfile: { id: string; data: Partial<UserProfile> };
  deleteAccount: { id: string; reason?: string };
  refreshToken: void;
}

// ✅ 권장: 도메인 + Actions 패턴 (단순 인터페이스 - 미래 방식)
interface UserActions {
  updateProfile: { id: string; data: Partial<UserProfile> };
  deleteAccount: { id: string; reason?: string };
  refreshToken: void;
}

interface PaymentActions {
  processPayment: { amount: number; method: string };
  refundPayment: { transactionId: string };
  validateCard: { cardNumber: string };
}

// ❌ 지양
interface Actions { ... }           // 너무 포괄적
interface UserActionTypes { ... }   // 일관성 없는 이름
```

#### Store Data Interface
```tsx
// ✅ 권장: 도메인 + Data 패턴 또는 직관적 이름
interface UserData {
  profile: UserProfile;
  preferences: UserPreferences;
  session: UserSession;
}

interface ShoppingCartData {
  items: CartItem[];
  total: number;
  discounts: Discount[];
}

// 또는 직관적 이름
interface UserState {
  profile: UserProfile;
  preferences: UserPreferences;
}

// ❌ 지양
interface Data { ... }           // 너무 포괄적
interface UserStoreType { ... }  // 불필요한 Type 접미사
```

### 🎯 제네릭 타입 사용

```tsx
// ✅ 권장: 명확한 제네릭 타입 사용
interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

interface User extends BaseEntity {
  name: string;
  email: string;
}

interface Product extends BaseEntity {
  name: string;
  price: number;
  category: string;
}

// Store 정의에서 활용 - 방법 1: 타입 추론 (권장)
const {
  Provider: UserStoreProvider,
  useStore: useUserStore
} = createDeclarativeStorePattern('User', {
  users: { initialValue: [] as User[] },
  currentUser: { initialValue: null as User | null }
});

// Store 정의에서 활용 - 방법 2: 명시적 제네릭
interface UserStoreTypes {
  users: User[];
  currentUser: User | null;
}

const {
  Provider: UserStoreProvider,
  useStore: useUserStore
} = createDeclarativeStorePattern<UserStoreTypes>('User', {
  // ⚠️ 주의: 명시적 제네릭 사용 시에도 InitialStores<T> 구조 필요
  users: [],  // 직접 값 또는
  currentUser: {  // 설정 객체
    initialValue: null,
    strategy: 'reference'
  }
});

// Action 정의에서 활용 - 새로운 API (contextName 우선)
interface UserActions {
  createUser: { userData: Omit<User, 'id' | 'createdAt' | 'updatedAt'> };
  updateUser: { id: string; updates: Partial<User> };
  deleteUser: { id: string };
}

const {
  Provider: UserActionProvider,
  useActionDispatch: useUserAction
} = createActionContext<UserActions>('UserActions', {
  registry: { debug: true, maxHandlers: 10 }
});
```

---

## 코드 스타일

### ✨ 컴포넌트 패턴

#### Store 사용 패턴
```tsx
// ✅ 권장: 명확한 변수명과 구조분해
function UserProfile() {
  // Store 접근
  const profileStore = useUserStore('profile');
  const preferencesStore = useUserStore('preferences');
  
  // 값 구독
  const profile = useStoreValue(profileStore);
  const preferences = useStoreValue(preferencesStore);
  
  // 로컬 상태와 구분
  const [isEditing, setIsEditing] = useState(false);
  
  return (
    <div>
      <ProfileView profile={profile} preferences={preferences} />
      {isEditing && <ProfileEditor />}
    </div>
  );
}

// ❌ 지양: 혼동되는 변수명
function UserProfile() {
  const store1 = useUserStore('profile');  // 무엇인지 불분명
  const data = useStoreValue(store1);      // 구체적이지 않음
  const userState = useStoreValue(store2); // 혼동 가능
}
```

#### Action Handler 패턴
```tsx
// ✅ 권장: useCallback과 명확한 핸들러명
function UserProfile() {
  const dispatch = useUserAction();
  
  // 핸들러 등록 (useCallback 필수)
  useUserActionHandler('updateProfile', useCallback(async (payload, controller) => {
    try {
      const profileStore = storeManager.getStore('profile');
      const currentProfile = profileStore.getValue();
      
      // 비즈니스 로직 실행
      const updatedProfile = await updateUserProfile(payload.data);
      
      // 스토어 업데이트
      profileStore.setValue({ ...currentProfile, ...updatedProfile });
      
      // 성공 알림
      dispatch('showNotification', { 
        type: 'success', 
        message: '프로필이 업데이트되었습니다.' 
      });
    } catch (error) {
      controller.abort('프로필 업데이트 실패', error);
    }
  }, [dispatch, storeManager]));
  
  const handleEditProfile = () => {
    dispatch('updateProfile', {
      data: { name: 'New Name' }
    });
  };
  
  return <button onClick={handleEditProfile}>Edit Profile</button>;
}
```

### 🎨 Import 정리

```tsx
// ✅ 권장: 그룹별 import 정리
// 1. React 관련
import React, { useCallback, useState, useEffect } from 'react';

// 2. 서드파티 라이브러리
import { toast } from 'react-hot-toast';

// 3. Context-Action 프레임워크
import { useStoreValue } from '@context-action/react';

// 4. 로컬 컨텍스트 (리네이밍된 훅들)
import { 
  useUserStore, 
  useUserAction, 
  useUserActionHandler 
} from '@/contexts/user';

// 5. 컴포넌트
import { ProfileForm } from './ProfileForm';

// 6. 타입
import type { UserProfile } from '@/types/user.types';
```

---

## 성능 가이드라인

### ⚡ Store 최적화

#### Comparison Strategy 선택
```tsx
// ✅ 권장: 데이터 특성에 맞는 strategy 선택
const {
  Provider: DataStoreProvider,
  useStore: useDataStore
} = createDeclarativeStorePattern('Data', {
  // 원시값: reference (기본값)
  counter: 0,
  isLoading: false,
  
  // 객체의 속성이 변경되는 경우: shallow  
  userProfile: {
    initialValue: { name: '', email: '', age: 0 },
    strategy: 'shallow'
  },
  
  // 중첩 객체가 자주 변경되는 경우: deep
  complexForm: {
    initialValue: { nested: { deep: { values: {} } } },
    strategy: 'deep'
  },
  
  // 큰 배열이나 성능이 중요한 경우: reference
  largeDataset: {
    initialValue: [] as DataItem[],
    strategy: 'reference',
    description: '성능을 위해 reference equality 사용'
  },
  
  // 고급 비교 옵션 사용
  advancedData: {
    initialValue: { id: '', data: {}, lastUpdated: new Date() },
    comparisonOptions: {
      strategy: 'shallow',
      ignoreKeys: ['lastUpdated'], // 특정 키 무시
      maxDepth: 2,                 // 성능을 위한 깊이 제한
      enableCircularCheck: true    // 순환 참조 방지
    }
  },
  
  // 커스텀 비교 로직
  versionedData: {
    initialValue: { version: 1, content: {} },
    comparisonOptions: {
      strategy: 'custom',
      customComparator: (oldVal, newVal) => {
        // 버전 기반 비교
        return oldVal.version === newVal.version;
      }
    }
  }
});
```

#### 메모이제이션 패턴
```tsx
// ✅ 권장: useCallback으로 핸들러 메모이제이션
function UserComponent() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  // 핸들러 메모이제이션 (의존성 배열 주의)
  const updateHandler = useCallback(async (payload) => {
    profileStore.setValue({ ...profile, ...payload.data });
  }, [profile, profileStore]);
  
  useUserActionHandler('updateProfile', updateHandler);
  
  // 계산된 값 메모이제이션
  const displayName = useMemo(() => {
    return profile.firstName + ' ' + profile.lastName;
  }, [profile.firstName, profile.lastName]);
  
  return <div>{displayName}</div>;
}
```

### 🔄 Action 최적화

#### Debounce/Throttle 설정
```tsx
// ✅ 권장: 적절한 debounce/throttle 사용
useUserActionHandler('searchUsers', searchHandler, {
  debounce: 300,  // 검색은 debounce
  id: 'search-handler'
});

useUserActionHandler('trackScroll', scrollHandler, {
  throttle: 100,  // 스크롤은 throttle  
  id: 'scroll-handler'
});

useUserActionHandler('saveForm', saveHandler, {
  blocking: true,  // 중요한 액션은 blocking
  once: false,
  id: 'save-handler'
});
```

---

## 🧪 타입 테스트 및 검증

### ✅ 타입 안전성 검증

#### 컴파일 타임 타입 테스트
```tsx
// ✅ 권장: 타입 테스트 파일 작성
// src/contexts/__tests__/user.types.test.tsx

import { createDeclarativeStorePattern, createActionContext } from '@context-action/react';

// 명시적 제네릭 테스트
interface UserStores {
  profile: { id: string; name: string; email: string };
  settings: { theme: 'light' | 'dark'; language: string };
}

// 타입 안전성 검증
const ExplicitStores = createDeclarativeStorePattern<UserStores>('User', {
  profile: { id: '', name: '', email: '' },  // 타입 체크됨
  settings: {
    initialValue: { theme: 'light', language: 'en' },
    strategy: 'shallow'
  }
});

// 타입 추론 테스트
const InferredStores = createDeclarativeStorePattern('Inferred', {
  counter: 0,  // Store<number>로 추론
  user: { id: '', name: '' },  // Store<{id: string, name: string}>로 추론
  isActive: false  // Store<boolean>로 추론
});

// Action Context 타입 테스트
interface TestActions {
  updateUser: { id: string; name: string };
  deleteUser: { id: string };
  refresh: void;
}

const ActionContext = createActionContext<TestActions>('Test', {
  registry: { debug: true }
});

// 사용 패턴 검증
function TypeValidationComponent() {
  const profileStore = ExplicitStores.useStore('profile');
  const counterStore = InferredStores.useStore('counter');
  const dispatch = ActionContext.useActionDispatch();
  
  // 올바른 타입 사용 검증
  dispatch('updateUser', { id: '123', name: 'John' }); // ✅ 타입 안전
  dispatch('refresh'); // ✅ void payload
  
  return null;
}
```

#### 런타임 에러 처리 개선
```tsx
// ✅ 권장: 개발 모드 디버깅 지원
// JSON 직렬화 실패 시 자동 fallback

const DataStores = createDeclarativeStorePattern('Data', {
  // 순환 참조나 특수 타입이 포함된 데이터
  complexData: {
    initialValue: { /* BigInt, Symbol, Function 등 */ },
    comparisonOptions: {
      strategy: 'deep',
      // 개발 모드에서 JSON 직렬화 실패 로그 출력
      enableCircularCheck: true
    }
  }
});
```

### 🔍 디버깅 도구

#### 개발 모드 로깅
```tsx
// ✅ 권장: 개발 모드에서만 활성화되는 디버깅
const DebugStores = createDeclarativeStorePattern('Debug', {
  userData: {
    initialValue: { id: '', profile: {} },
    debug: true,  // 개발 모드에서 스토어 생성 로그
    comparisonOptions: {
      strategy: 'shallow',
      // 비교 실패 시 개발 모드에서만 경고 출력
    }
  }
});
```

---

## 에러 핸들링

### 🚨 Error Boundary 패턴

```tsx
// ✅ 권장: 도메인별 Error Boundary
function UserErrorBoundary({ children }: { children: React.ReactNode }) {
  return (
    <ErrorBoundary
      fallback={<UserErrorFallback />}
      onError={(error, errorInfo) => {
        // 사용자 관련 에러 로깅
        console.error('User context error:', error, errorInfo);
      }}
    >
      {children}
    </ErrorBoundary>
  );
}

function UserProvider({ children }: { children: React.ReactNode }) {
  return (
    <UserActionProvider>
      <UserStoreProvider>
        <UserErrorBoundary>
          {children}
        </UserErrorBoundary>
      </UserStoreProvider>
    </UserActionProvider>
  );
}
```

### 🛡️ Action Error 처리

```tsx
// ✅ 권장: Pipeline Controller를 이용한 에러 처리
useUserActionHandler('riskyOperation', useCallback(async (payload, controller) => {
  try {
    // 1. 입력 검증
    if (!payload.data || !payload.data.id) {
      controller.abort('유효하지 않은 입력 데이터');
      return;
    }
    
    // 2. 비즈니스 로직 실행
    const result = await performRiskyOperation(payload.data);
    
    // 3. 성공 시 상태 업데이트
    const store = storeManager.getStore('userData');
    store.setValue(result);
    
    // 4. 결과 반환 (필요한 경우)
    controller.setResult(result);
    
  } catch (error) {
    // 5. 에러 처리
    if (error instanceof ValidationError) {
      controller.abort('데이터 검증 실패', error);
    } else if (error instanceof NetworkError) {
      controller.abort('네트워크 오류', error);
    } else {
      controller.abort('알 수 없는 오류가 발생했습니다', error);
    }
  }
}, [storeManager]));
```

---

## 📚 추가 리소스

### 관련 문서
- [Pattern Guide](./pattern-guide.md) - 상세한 패턴 사용법
- [Full Architecture Guide](./architecture-guide.md) - 완전한 아키텍처 가이드
- [Hooks Reference](./hooks-reference.md) - Hooks 참조 문서
- [API Reference](../../api/) - API 문서

### 예제 프로젝트
- [Basic Example](../../../example/) - 기본 사용 예제
- [Advanced Patterns](../../examples/) - 고급 패턴 예제

### 마이그레이션 가이드
- [Legacy Pattern Migration](./pattern-guide.md#migration-guide) - 레거시 패턴에서 마이그레이션

---

## ❓ FAQ

### Q: 언제 Store Only vs Action Only vs Composition을 사용해야 하나요?
- **Store Only**: 순수 상태 관리 (폼, 설정, 캐시)
- **Action Only**: 순수 이벤트 처리 (로깅, 트래킹, 알림)  
- **Composition**: 복잡한 비즈니스 로직 (사용자 관리, 쇼핑카트)

### Q: 리네이밍 패턴을 꼭 사용해야 하나요?
네, 리네이밍 패턴은 Context-Action 프레임워크의 핵심 컨벤션입니다. 타입 안전성과 개발자 경험을 크게 향상시킵니다.

### Q: 성능 최적화는 어떻게 해야 하나요?
1. 적절한 comparison strategy 선택
2. useCallback으로 핸들러 메모이제이션  
3. 큰 데이터는 reference strategy 사용
4. 필요시 debounce/throttle 적용

### Q: 에러 처리는 어떻게 해야 하나요?
1. Pipeline Controller의 abort() 메서드 사용
2. 도메인별 Error Boundary 설정
3. 적절한 에러 타입별 처리
4. 사용자 친화적 에러 메시지 제공

### Q: 명시적 제네릭과 타입 추론 중 어떤 것을 사용해야 하나요?
- **타입 추론 (권장)**: 대부분의 경우, 코드가 간결하고 타입 안전성 보장
- **명시적 제네릭**: 복잡한 타입 구조나 엄격한 타입 제약이 필요한 경우

### Q: comparisonOptions는 언제 사용해야 하나요?
1. **ignoreKeys**: 타임스탬프 등 특정 필드 변경을 무시하고 싶을 때
2. **customComparator**: 비즈니스 로직에 맞는 특별한 비교가 필요할 때
3. **maxDepth**: 성능 최적화를 위해 깊은 비교의 깊이를 제한하고 싶을 때
4. **enableCircularCheck**: 순환 참조 가능성이 있는 객체를 다룰 때

### Q: 타입 테스트는 어떻게 작성해야 하나요?
1. 명시적 제네릭과 타입 추론 모두 테스트
2. 컴파일 타임에 타입 안전성 검증
3. 에러 케이스도 주석으로 문서화
4. 실제 사용 패턴을 반영한 테스트 컴포넌트 작성

---

# Pattern Implementation Guide

# @context-action/react Pattern Guide

Complete guide to the two main patterns available in @context-action/react framework.

## 📋 Quick Start Guide

Choose the right pattern for your use case:

| Pattern | Use Case | Import | Best For |
|---------|----------|--------|----------|
| **🎯 Action Only** | Action dispatching without stores | `createActionContext` | Event systems, command patterns |
| **🏪 Store Only** | State management without actions | `createDeclarativeStorePattern` | Pure state management, data layers |

**Note**: For complex applications needing both actions and state, compose Action Only + Store Only patterns together.

---

## 🎯 Action Only Pattern

**When to use**: Pure action dispatching without state management (event systems, command patterns).

### Import
```typescript
import { createActionContext } from '@context-action/react';
```

### Features
- ✅ Type-safe action dispatching
- ✅ Action handler registration
- ✅ Abort support
- ✅ Result handling
- ✅ Lightweight (no store overhead)

### Basic Usage
```tsx
// 1. Define Actions (ActionPayloadMap optional)
interface EventActions {
  userClick: { x: number; y: number };
  userHover: { elementId: string };
  analytics: { event: string; data: any };
}

// 2. Create Context with Renaming Pattern
const {
  Provider: EventActionProvider,
  useActionDispatch: useEventAction,
  useActionHandler: useEventActionHandler
} = createActionContext<EventActions>('Events');

// 3. Provider Setup
function App() {
  return (
    <EventActionProvider>
      <InteractiveComponent />
    </EventActionProvider>
  );
}

// 4. Component Usage with Renamed Hooks  
function InteractiveComponent() {
  const dispatch = useEventAction();
  
  // Register action handlers with renamed hook
  useEventActionHandler('userClick', (payload, controller) => {
    console.log('User clicked at:', payload.x, payload.y);
    // Pure side effects, no state management
  });
  
  useEventActionHandler('analytics', async (payload) => {
    await fetch('/analytics', {
      method: 'POST',
      body: JSON.stringify(payload)
    });
  });
  
  const handleClick = (e: MouseEvent) => {
    dispatch('userClick', { x: e.clientX, y: e.clientY });
    dispatch('analytics', { event: 'click', data: { timestamp: Date.now() } });
  };
  
  return <button onClick={handleClick}>Click Me</button>;
}
```

### Advanced Features
```tsx
// Use the renamed context hooks for advanced features
const { useActionDispatchWithResult: useEventActionWithResult } = createActionContext<EventActions>('Events');

function AdvancedComponent() {
  const { 
    dispatch, 
    dispatchWithResult, 
    abortAll 
  } = useEventActionWithResult();
  
  const handleAsyncAction = async () => {
    try {
      const result = await dispatchWithResult('analytics', {
        event: 'complex-operation',
        data: { userId: 123 }
      });
      console.log('Action result:', result);
    } catch (error) {
      console.error('Action failed:', error);
    }
  };
  
  const handleAbortAll = () => {
    abortAll(); // Abort all pending actions
  };
  
  return (
    <div>
      <button onClick={handleAsyncAction}>Async Action</button>
      <button onClick={handleAbortAll}>Abort All</button>
    </div>
  );
}
```

### Available Hooks
- `useActionDispatch()` - Basic action dispatcher
- `useActionHandler(action, handler, config?)` - Register action handlers
- `useActionDispatchWithResult()` - Advanced dispatcher with results/abort
- `useActionRegister()` - Access raw ActionRegister
- `useActionContext()` - Access raw context

---

## 🏪 Store Only Pattern (Recommended)

**When to use**: Pure state management without action dispatching (data layers, simple state).

**Key Features**: 
- ✅ Excellent type inference without manual type annotations
- ✅ Simplified API focused on store management
- ✅ Direct value or configuration object support
- ✅ No need for separate `createStore` calls

### Import
```typescript
import { createDeclarativeStorePattern } from '@context-action/react';
```

### Basic Usage

#### Option 1: Type Inference (Current)
```tsx
// 1. Define stores with renaming pattern for type-safe access
const {
  Provider: AppStoreProvider,
  useStore: useAppStore,
  useStoreManager: useAppStoreManager
} = createDeclarativeStorePattern('App', {
  // Simple direct values - cleanest syntax
  counter: 0,
  userName: '',
  isLoggedIn: false,
  
  // With configuration for complex types
  user: {
    initialValue: { id: '', name: '', email: '' },
    strategy: 'shallow',
    description: 'User profile data'
  },
  
  // Nested structures with type safety
  settings: {
    initialValue: {
      theme: 'light' as 'light' | 'dark',
      language: 'en',
      notifications: true
    },
    strategy: 'shallow'
  }
});
```

#### Option 2: Explicit Generic Types (New)
```tsx
// 1. Define store types explicitly
interface AppStoreTypes {
  counter: number;
  userName: string;
  isLoggedIn: boolean;
  user: { id: string; name: string; email: string };
  settings: { theme: 'light' | 'dark'; language: string; notifications: boolean };
}

// 2. Create stores with explicit types - still requires InitialStores<T> structure
const {
  Provider: AppStoreProvider,
  useStore: useAppStore,
  useStoreManager: useAppStoreManager
} = createDeclarativeStorePattern<AppStoreTypes>('App', {
  // Types validated against AppStoreTypes interface
  counter: 0,  // Must match AppStoreTypes['counter'] = number
  userName: '', // Must match AppStoreTypes['userName'] = string
  isLoggedIn: false,
  
  // Complex types with configuration
  user: { id: '', name: '', email: '' },
  settings: {
    initialValue: { theme: 'light', language: 'en', notifications: true },
    strategy: 'shallow'
  }
});

// 2. Provider Setup (minimal boilerplate)
function App() {
  return (
    <AppStoreProvider>
      <UserProfile />
      <Settings />
    </AppStoreProvider>
  );
}

// 3. Component Usage with Excellent Type Inference
function UserProfile() {
  // Perfect type inference - no manual type annotations needed!
  const counterStore = useAppStore('counter');      // Store<number>
  const userStore = useAppStore('user');           // Store<{id: string, name: string, email: string}>
  const settingsStore = useAppStore('settings');   // Store<{theme: 'light' | 'dark', language: string, notifications: boolean}>
  
  // Subscribe to values
  const counter = useStoreValue(counterStore);
  const user = useStoreValue(userStore);
  const settings = useStoreValue(settingsStore);
  
  const incrementCounter = () => {
    counterStore.setValue(counter + 1);
  };
  
  const updateUser = () => {
    userStore.setValue({
      ...user,
      name: 'John Doe',
      email: 'john@example.com'
    });
  };
  
  const toggleTheme = () => {
    settingsStore.setValue({
      ...settings,
      theme: settings.theme === 'light' ? 'dark' : 'light'
    });
  };
  
  return (
    <div data-theme={settings.theme}>
      <div>Counter: {counter}</div>
      <div>User: {user.name} ({user.email})</div>
      <div>Theme: {settings.theme}</div>
      
      <button onClick={incrementCounter}>+1</button>
      <button onClick={updateUser}>Update User</button>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </div>
  );
}
```

### HOC Pattern (Advanced)
```tsx
// Get withProvider from the renamed context
const { withProvider: withAppStoreProvider } = createDeclarativeStorePattern('App', {...});

// Automatic Provider wrapping with HOC
const AppWithStores = withAppStoreProvider(App);

// With custom registry ID
const AppWithCustomStores = withAppStoreProvider(App, {
  registryId: 'custom-app-stores'
});

// Use anywhere without manual Provider wrapping
function Root() {
  return <AppWithStores />;
}
```

### Advanced Configuration
```tsx
// Advanced store configuration with renaming pattern
const {
  Provider: AdvancedStoreProvider,
  useStore: useAdvancedStore,
  useStoreManager: useAdvancedStoreManager
} = createDeclarativeStorePattern('Advanced', {
  // Performance-optimized store
  largeDataset: {
    initialValue: [] as DataItem[],
    strategy: 'reference',  // Reference equality for performance
    debug: true,           // Enable debug logging
    tags: ['performance', 'data'],
    version: '1.0.0',
    description: 'Large dataset with reference equality'
  },
  
  // Deep comparison store
  complexObject: {
    initialValue: { nested: { deep: { value: 0 } } },
    strategy: 'deep',      // Deep comparison for nested changes
    comparisonOptions: {
      ignoreKeys: ['timestamp'],  // Ignore specific keys
      maxDepth: 5                 // Limit comparison depth
    }
  },
  
  // Custom comparison
  customStore: {
    initialValue: new Map(),
    comparisonOptions: {
      customComparator: (oldValue, newValue) => {
        // Custom comparison logic
        return oldValue.size === newValue.size;
      }
    }
  }
});
```

### Available Hooks
- `useStore(name)` - Get typed store by name (primary API)
- `useStoreManager()` - Access store manager (advanced use)
- `useStoreInfo()` - Get registry information
- `useStoreClear()` - Clear all stores

---

## 🔧 Pattern Composition

For complex applications that need both actions and state management, compose the patterns:

```tsx
// 1. Create separate contexts with renaming patterns
const { 
  Provider: EventActionProvider, 
  useActionDispatch: useEventAction,
  useActionHandler: useEventActionHandler
} = createActionContext<EventActions>('Events');

const {
  Provider: AppStoreProvider,
  useStore: useAppStore,
  useStoreManager: useAppStoreManager
} = createDeclarativeStorePattern('App', {
  user: { id: '', name: '' },
  counter: 0
});

// 2. Compose providers
function App() {
  return (
    <EventActionProvider>
      <AppStoreProvider>
        <ComplexComponent />
      </AppStoreProvider>
    </EventActionProvider>
  );
}

// 3. Use both patterns in components
function ComplexComponent() {
  // Actions from Action Only pattern (renamed hooks)
  const dispatch = useEventAction();
  
  // State from Store Only pattern (renamed hooks)
  const userStore = useAppStore('user');
  const counterStore = useAppStore('counter');
  
  const user = useStoreValue(userStore);
  const counter = useStoreValue(counterStore);
  
  // Action handlers that update state (renamed hook)
  useEventActionHandler('updateUser', (payload) => {
    userStore.setValue(payload);
    dispatch('analytics', { event: 'user-updated' });
  });
  
  return (
    <div>
      <div>User: {user.name}</div>
      <div>Counter: {counter}</div>
    </div>
  );
}
```

---

## 🎯 Migration Guide

### From Legacy Action Context Pattern

If you were using the removed `createActionContextPattern`, migrate to pattern composition:

```tsx
// ❌ Old (removed)
// const UserContext = createActionContextPattern<UserActions>('User');

// ✅ New (compose patterns with renaming)
const { 
  Provider: UserActionProvider, 
  useActionDispatch: useUserAction,
  useActionHandler: useUserActionHandler
} = createActionContext<UserActions>('UserActions');

const {
  Provider: UserStoreProvider,
  useStore: useUserStore,
  useStoreManager: useUserStoreManager
} = createDeclarativeStorePattern('UserStores', {
  profile: { id: '', name: '', email: '' },
  preferences: { theme: 'light' as const }
});

// Compose providers
function App() {
  return (
    <UserActionProvider>
      <UserStoreProvider>
        <UserComponent />
      </UserStoreProvider>
    </UserActionProvider>
  );
}
```

---

## 📚 Best Practices

### 1. Pattern Selection
- **Start with Store Only** for simple state management
- **Add Action Only** when you need side effects or complex workflows
- **Compose patterns** for full-featured applications

### 2. Naming Conventions
- Use descriptive context names: `UserActions`, `AppStores`
- Rename exported hooks for clarity: `useUserAction`, `useAppStore`
- Keep store names simple: `user`, `counter`, `settings`

### 3. Performance
- Use `strategy: 'reference'` for large datasets
- Use `strategy: 'shallow'` for objects that change properties
- Use `strategy: 'deep'` only when necessary

### 4. Type Safety
- Use explicit interfaces for actions (ActionPayloadMap optional)
- Consider explicit generic types for better type safety
- Let TypeScript infer store types from initial values or use explicit generics
- Use `as const` for literal types in store definitions

---

## 🔍 Examples

See the `examples/` directory for complete working examples of each pattern.

---

# MVVM Architecture Guide

# Context-Action Store Integration Architecture

## 1. Overview & Core Concepts

### What is Context-Action Architecture?

The Context-Action framework is a **revolutionary state management system** designed to overcome the fundamental limitations of existing libraries through document-centric context separation and effective artifact management.

#### Project Philosophy

The Context-Action framework addresses critical issues in modern state management:

**Problems with Existing Libraries:**
- **High React Coupling**: Tight integration makes component modularization and props handling difficult
- **Binary State Approach**: Simple global/local state dichotomy fails to handle specific scope-based separation  
- **Inadequate Handler/Trigger Management**: Poor support for complex interactions and business logic processing

**Context-Action's Solution:**
- **Document-Artifact Centered Design**: Context separation based on document themes and deliverable management
- **Perfect Separation of Concerns**: 
  - View design in isolation → Design Context
  - Development architecture in isolation → Architecture Context
  - Business logic in isolation → Business Context  
  - Data validation in isolation → Validation Context
- **Clear Boundaries**: Implementation results maintain distinct, well-defined domain boundaries
- **Effective Document-Artifact Management**: State management library that actively supports the relationship between documentation and deliverables

### Architecture Implementation

The framework implements a clean separation of concerns through an MVVM-inspired pattern combined with **Declarative Store Pattern** for complete domain isolation:

- **Actions** handle business logic (ViewModel layer)
- **Declarative Store Pattern** manages state with domain isolation (Model layer)
- **Components** render UI (View layer)
- **Context Boundaries** isolate functional domains
- **Type-Safe Integration** through domain-specific hooks

### Core Architecture Flow

```
[Component] → dispatch → [Action Pipeline] → handlers → [Store] → subscribe → [Component]
```

### Context Separation Strategy

#### Domain-Based Context Architecture
- **Business Context**: Business logic, data processing, and domain rules
- **UI Context**: Screen state, user interactions, and component behavior  
- **Validation Context**: Data validation, form processing, and error handling
- **Design Context**: Theme management, styling, layout, and visual states
- **Architecture Context**: System configuration, infrastructure, and technical decisions

#### Document-Based Context Design
Each context is designed to manage its corresponding documentation and deliverables:
- **Design Documentation** → Design Context (themes, component specifications, style guides)
- **Business Requirements** → Business Context (workflows, rules, domain logic)  
- **Architecture Documents** → Architecture Context (system design, technical decisions)
- **Validation Specifications** → Validation Context (rules, schemas, error handling)
- **UI Specifications** → UI Context (interactions, state management, user flows)

### Advanced Handler & Trigger Management

Context-Action provides sophisticated handler and trigger management that existing libraries lack:

#### Priority-Based Handler Execution
- **Sequential Processing**: Handlers execute in priority order with proper async handling
- **Domain Isolation**: Each context maintains its own handler registry
- **Cross-Context Coordination**: Controlled communication between domain contexts
- **Result Collection**: Aggregate results from multiple handlers for complex workflows

#### Intelligent Trigger System
- **State-Change Triggers**: Automatic triggers based on store value changes
- **Cross-Context Triggers**: Domain boundaries can trigger actions in other contexts
- **Conditional Triggers**: Smart triggers based on business rules and conditions
- **Trigger Cleanup**: Automatic cleanup prevents memory leaks and stale references

### Key Benefits

1. **Document-Artifact Management**: Direct relationship between documentation and implementation
2. **Domain Isolation**: Each context maintains complete independence
3. **Type Safety**: Full TypeScript support with domain-specific hooks
4. **Performance**: Only affected components re-render
5. **Scalability**: Easy to add new domains without affecting existing ones
6. **Team Collaboration**: Different teams can work on different domains without conflicts
7. **Clear Boundaries**: Perfect separation of concerns based on document domains

## 2. Domain-Specific Hooks Pattern (Core)

### Philosophy: Renamed Hook Pattern

The framework's core philosophy is to create **domain-specific hooks** through destructuring assignments, providing intuitive, type-safe APIs that improve developer experience.

```typescript
// ✅ Domain-specific hook naming pattern
export const {
  Provider: UserBusinessProvider,
  useStore: useUserBusinessStore,        // Domain-specific store hook
  useStoreManager: useUserBusinessStoreManager,    // Domain-specific store registry hook
  useStoreInfo: useUserBusinessStoreInfo
} = createDeclarativeStorePattern('UserBusiness', storeDefinitions);

export const {
  Provider: UserBusinessActionProvider,
  useActionDispatch: useUserBusinessAction,      // Domain-specific action hook
  useActionHandler: useUserBusinessActionHandler
} = createActionContext<UserBusinessActions>('UserBusinessAction');
```

### Benefits of Domain-Specific Naming

1. **Type Safety**: Full TypeScript inference with domain-specific types
2. **Developer Experience**: Clear, autocomplete-friendly API
3. **Maintainability**: Easy to identify which domain a hook belongs to
4. **Refactoring Safety**: Type errors immediately highlight breaking changes
5. **Team Scalability**: Different teams can work on different domains without conflicts

### Store Access Patterns

Three valid patterns for accessing stores, each with specific use cases:

```typescript
// Pattern 1: Domain-specific hooks (Components)
const store = useUserBusinessStore('profile');

// Pattern 2: Store manager access for advanced use cases (Handlers)
const storeManager = useUserBusinessStoreManager();
const store = storeManager.getStore('profile');
```

## 3. Basic Setup & Usage

### Step 1: Define Domain Stores and Actions

```typescript
// stores/userBusiness.store.ts
import { createDeclarativeStorePattern } from '@context-action/react';
import { createActionContext } from '@context-action/react';

// Define store interface
export interface UserBusinessData {
  profile: {
    id: string;
    name: string;
    email: string;
    role: 'admin' | 'user' | 'guest';
  };
  preferences: {
    theme: 'light' | 'dark';
    language: string;
  };
}

// Define action interface (ActionPayloadMap optional)
export interface UserBusinessActions {
  updateProfile: {
    data: Partial<UserBusinessData['profile']>;
    validate?: boolean;
  };
  deleteUser: { userId: string };
}

// Create domain-specific store hooks

// Option 1: Type inference (current approach)
export const {
  Provider: UserBusinessStoreProvider,
  useStore: useUserBusinessStore,
  useStoreManager: useUserBusinessStoreManager,
  useStoreInfo: useUserBusinessStoreInfo
} = createDeclarativeStorePattern('UserBusiness', {
  profile: {
    initialValue: {
      id: '',
      name: '',
      email: '',
      role: 'guest'
    }
  },
  preferences: {
    initialValue: {
      theme: 'light',
      language: 'en'
    }
  }
});

// Option 2: Explicit generic types (new approach)
export const {
  Provider: UserBusinessStoreProvider,
  useStore: useUserBusinessStore,
  useStoreManager: useUserBusinessStoreManager,
  useStoreInfo: useUserBusinessStoreInfo
} = createDeclarativeStorePattern<UserBusinessData>('UserBusiness', {
  // ⚠️ Note: Still requires InitialStores<T> structure even with explicit generics
  profile: {
    id: '',
    name: '',
    email: '',
    role: 'guest'
  },
  preferences: {
    // Can use direct values or config objects
    initialValue: { theme: 'light', language: 'en' },
    strategy: 'shallow'
  }
});

// Create domain-specific action hooks
export const {
  Provider: UserBusinessActionProvider,
  useActionDispatch: useUserBusinessAction,
  useActionHandler: useUserBusinessActionHandler,
  useActionDispatchWithResult: useUserBusinessActionDispatchWithResult
} = createActionContext<UserBusinessActions>('UserBusinessAction');
```

### Step 2: Provider Composition

```tsx
// providers/UserProvider.tsx
import React, { FC } from 'react';
import { 
  UserBusinessStoreProvider,
  UserBusinessActionProvider,
  UserUIStoreProvider,
  UserUIActionProvider
} from '@/stores';

// Compose all providers for the domain
export const UserProvider: FC<{ children: React.ReactNode }> = ({ children }) => (
  <UserBusinessStoreProvider>
    <UserUIStoreProvider>
      <UserBusinessActionProvider>
        <UserUIActionProvider>
          {children}
        </UserUIActionProvider>
      </UserBusinessActionProvider>
    </UserUIStoreProvider>
  </UserBusinessStoreProvider>
);

// HOC pattern for cleaner composition (alternative)
export const withUserProviders = (Component: React.ComponentType) => {
  return (props: any) => (
    <UserProvider>
      <Component {...props} />
    </UserProvider>
  );
};
```

### Step 3: Component Implementation

```tsx
// components/UserProfile.tsx
import React, { useCallback } from 'react';
import { useStoreValue } from '@context-action/react';
import { useUserBusinessStore, useUserBusinessAction } from '@/stores/userBusiness.store';

export function UserProfile() {
  // Access domain-specific stores
  const profileStore = useUserBusinessStore('profile');
  const preferencesStore = useUserBusinessStore('preferences');
  
  // Get current values
  const profile = useStoreValue(profileStore);
  const preferences = useStoreValue(preferencesStore);
  
  // Get domain-specific action dispatcher
  const dispatch = useUserBusinessAction();
  
  const handleUpdateProfile = useCallback(async () => {
    await dispatch('updateProfile', {
      data: { name: 'New Name' },
      validate: true
    });
  }, [dispatch]);
  
  return (
    <div>
      <h2>{profile.name}</h2>
      <p>Theme: {preferences.theme}</p>
      <button onClick={handleUpdateProfile}>
        Update Profile
      </button>
    </div>
  );
}
```

## 4. Store Management

### Store Creation and Access

```tsx
// Store setup component
function UserStoreSetup() {
  // Create stores in the context registry
  useCreateUserBusinessStore('profile', {
    id: '',
    name: '',
    email: '',
    role: 'guest'
  });
  
  useCreateUserBusinessStore('preferences', {
    theme: 'light',
    language: 'en'
  });
  
  return null;
}

// Store access in components
function UserSettings() {
  const preferencesStore = useUserBusinessStore('preferences');
  const preferences = useStoreValue(preferencesStore);
  
  const updateTheme = useCallback((theme: 'light' | 'dark') => {
    preferencesStore.setValue({ ...preferences, theme });
  }, [preferences, preferencesStore]);
  
  return (
    <div>
      <button onClick={() => updateTheme('dark')}>
        Switch to Dark Theme
      </button>
    </div>
  );
}
```

### Store Patterns

#### Singleton Behavior

Stores are singletons within Provider boundaries - same name returns same instance:

```typescript
function ComponentA() {
  const store = useUserBusinessStore('profile'); // Same instance
}

function ComponentB() {
  const store = useUserBusinessStore('profile'); // Same instance as ComponentA
}
```

#### Lazy Evaluation in Handlers

Use stores.getStore() for lazy evaluation to avoid stale closures:

```typescript
const handler = async (payload, controller) => {
  // Lazy evaluation - gets current value at execution time
  const profileStore = registry.getStore<UserProfile>('profile');
  const currentProfile = profileStore.getValue();
  
  // Business logic with current data
  profileStore.setValue({ ...currentProfile, ...payload });
};
```

## 5. Action Handlers

### Best Practice: useActionHandler Pattern

The recommended pattern for handler registration uses `useActionHandler` + `useEffect` for optimal performance and proper cleanup:

```typescript
import React, { useEffect, useCallback } from 'react';
import { useUserBusinessActionHandler, useUserBusinessStoreManager } from '@/stores/userBusiness.store';

function useUserBusinessHandlers() {
  const storeManager = useUserBusinessStoreManager();
  
  // Wrap handler with useCallback to prevent re-registration
  const updateProfileHandler = useCallback(async (payload, controller) => {
    // Lazy evaluation using store manager for current state
    const profileStore = storeManager.getStore('profile');
    const currentProfile = profileStore.getValue();
    
    // Validation
    if (payload.validate && !isValidEmail(payload.data.email)) {
      controller.abort('Invalid email format');
      return;
    }
    
    // Business logic
    const updatedProfile = {
      ...currentProfile,
      ...payload.data,
      updatedAt: Date.now()
    };
    
    // Update store
    profileStore.setValue(updatedProfile);
    
    // Return result for collection
    return { success: true, profile: updatedProfile };
  }, [storeManager]);
  
  // Register handler using useActionHandler hook (actual API)
  useUserBusinessActionHandler('updateProfile', updateProfileHandler, {
    priority: 100,      // Higher priority executes first
    blocking: true,     // Wait for async completion in sequential mode
    tags: ['business'], // For filtering
    id: 'profile-updater' // Explicit ID for debugging
  });
}
```

### Handler Registration Options

```typescript
interface HandlerConfig {
  priority?: number;        // Execution order (higher = first)
  blocking?: boolean;       // Wait for async completion
  tags?: string[];         // For filtering and categorization
  id?: string;            // Explicit handler ID
  category?: string;      // Handler category
  returnType?: 'value';   // Enable return value collection
}
```

### Handler Execution Flow

1. **Sequential Mode** (default): Handlers run in priority order
2. **Parallel Mode**: All handlers execute simultaneously
3. **Race Mode**: First handler to complete wins

```typescript
// Sequential with blocking
register('processOrder', handler1, { priority: 100, blocking: true });
register('processOrder', handler2, { priority: 90, blocking: true });
register('processOrder', handler3, { priority: 80, blocking: true });
// Execution: handler1 → waits → handler2 → waits → handler3

// Parallel execution
dispatch('processOrder', payload, { executionMode: 'parallel' });
```

### Controller Methods

```typescript
const handler = async (payload, controller) => {
  // Abort pipeline
  if (error) controller.abort('Error message');
  
  // Jump to specific priority
  if (urgent) controller.jumpToPriority(90);
  
  // Set result for collection
  controller.setResult(computedValue);
  
  // Terminate pipeline with result
  if (canFinishEarly) controller.return(finalResult);
};
```

### Result Collection

```typescript
function useOrderProcessing() {
  const dispatchWithResult = useUserBusinessActionWithResult();
  
  const processOrder = async (orderData) => {
    const result = await dispatchWithResult('processOrder', orderData, {
      result: {
        collect: true,         // Enable collection
        strategy: 'all',       // Collect all results
        timeout: 5000,         // 5 second timeout
        maxResults: 10         // Limit results
      },
      filter: {
        tags: ['validation', 'business'], // Only these handlers
        excludeTags: ['logging']          // Exclude logging
      }
    });
    
    if (result.success) {
      console.log('Results:', result.results);
      console.log('Duration:', result.execution.duration);
    }
    
    return result.result;
  };
}
```

## 6. Advanced Patterns

### Cross-Domain Integration (When Needed)

While domain isolation is preferred, sometimes cross-domain interaction is necessary:

```typescript
// hooks/useUserCartIntegration.ts
export function useUserCartIntegration() {
  // Access multiple domains
  const userProfile = useUserBusinessStore('profile');
  const cartItems = useCartStore('items');
  const userAction = useUserBusinessAction();
  const cartAction = useCartAction();
  
  const profile = useStoreValue(userProfile);
  const items = useStoreValue(cartItems);
  
  const processCheckout = useCallback(async () => {
    // Validate user
    if (!profile.id) {
      await userAction('requireLogin', {});
      return;
    }
    
    // Process cart
    await cartAction('processCheckout', {
      userId: profile.id,
      items: items
    });
  }, [profile.id, items, userAction, cartAction]);
  
  return { processCheckout };
}
```

### Logic Fit Hooks Pattern

Combine business and UI logic in reusable hooks:

```typescript
export function useUserEditor() {
  // Business layer
  const profileStore = useUserBusinessStore('profile');
  const businessAction = useUserBusinessAction();
  
  // UI layer  
  const viewStore = useUserUIStore('view');
  const uiAction = useUserUIAction();
  
  const profile = useStoreValue(profileStore);
  const view = useStoreValue(viewStore);
  
  const startEditing = useCallback(() => {
    uiAction('setEditMode', { editing: true });
  }, [uiAction]);
  
  const saveChanges = useCallback(async (data) => {
    await businessAction('updateProfile', { data });
    uiAction('setEditMode', { editing: false });
  }, [businessAction, uiAction]);
  
  return {
    profile,
    isEditing: view.isEditing,
    startEditing,
    saveChanges
  };
}
```

### Handler ID Strategies for Component Instances

When multiple instances of the same component exist:

```tsx
function TodoItem({ todoId }: { todoId: string }) {
  const componentId = useId(); // React's unique ID
  const addHandler = useTodoActionHandler();
  
  const handler = useCallback(async (payload) => {
    // Handler logic specific to this instance
  }, [todoId]);
  
  useEffect(() => {
    if (!addHandler) return;
    
    // Unique ID per component instance
    const unaddHandler = addHandler('updateTodo', handler, {
      id: `updateTodo-${componentId}`,
      cleanup: true
    });
    
    return unregister;
  }, [register, handler, componentId]);
}
```

## 7. Best Practices

### Handler Registration

1. **Always use `useActionHandler` hook for automatic registration and cleanup**
2. **Wrap handlers with `useCallback` to prevent re-registration**
3. **Use `blocking: true` for sequential async handlers**
4. **Consider explicit IDs for debugging and critical handlers**
5. **Use `useActionRegister()` only for advanced manual control**

### Store Access

6. **Use domain-specific hooks in components**
7. **Use `stores.getStore()` for lazy evaluation in handlers**
8. **Provide proper initial values, not null**
9. **Keep store updates predictable and traceable**

### Type Safety (Recommended)

10. **Define interfaces for better type safety**
11. **Use domain-specific hooks for type inference**
12. **Avoid `any` types - leverage TypeScript**

### Performance

13. **Only subscribe to needed stores**
14. **Use proper handler priorities**
15. **Clean up handlers on unmount**
16. **Use result collection selectively**

### Architecture

17. **One domain = One context boundary**
18. **Separate business and UI concerns**
19. **Prefer domain isolation, use cross-domain communication when necessary**
20. **Document domain boundaries clearly**

## 8. Common Pitfalls

### ❌ Missing Cleanup

```typescript
// Wrong - No cleanup
useEffect(() => {
  register('action', handler);
}, []);

// ✅ Correct - With cleanup
useEffect(() => {
  if (!addHandler) return;
  const unaddHandler = addHandler('action', handler);
  return unregister; // Memory cleanup on unmount
}, [register, handler]);
```

### ❌ Missing blocking for Async Handlers

```typescript
// Wrong - Handlers execute simultaneously
register('action', asyncHandler, { priority: 100 });

// ✅ Correct - Sequential execution
register('action', asyncHandler, { 
  priority: 100, 
  blocking: true // Wait for completion
});
```

### ❌ Using Stale Closures

```typescript
// Wrong - Stale closure
const profile = profileStore.getValue();
const handler = async () => {
  console.log(profile); // Stale value
};

// ✅ Correct - Lazy evaluation
const handler = async () => {
  const profileStore = stores.getStore('profile');
  const profile = profileStore.getValue(); // Current value
};
```

## Architecture Diagrams 

### Provider Composition Pattern

```mermaid
graph TD
    subgraph "Application Root"
        App[App Component]
    end
    
    subgraph "User Domain Providers"
        UBP[UserBusinessProvider]
        UUP[UserUIProvider]
        UBAP[UserBusinessActionProvider]
        UUAP[UserUIActionProvider]
    end
    
    subgraph "Components"
        UC[User Components]
    end
    
    App --> UBP
    UBP --> UUP
    UUP --> UBAP
    UBAP --> UUAP
    UUAP --> UC
    
    style UBP fill:#e3f2fd
    style UUP fill:#fff8e1
    style UBAP fill:#e3f2fd
    style UUAP fill:#fff8e1
```

### Store Singleton Behavior

```mermaid
graph TB
    subgraph "Provider Scope 1"
        P1[Provider Instance]
        S1[Store Registry - Singleton]
        C1[Component A]
        C2[Component B]
        
        P1 --> S1
        S1 --> C1
        S1 --> C2
    end
    
    subgraph "Provider Scope 2"
        P2[Provider Instance]
        S2[Store Registry - Different Singleton]
        C3[Component C]
        C4[Component D]
        
        P2 --> S2
        S2 --> C3
        S2 --> C4
    end
    
    Note[Same Provider = Same Store Instance<br/>Different Provider = Different Instance]
    
    style S1 fill:#bbdefb
    style S2 fill:#ffccbc
```

## 9. Implementation Examples

### Quick Start Example

```typescript
// 1. Define Domain (stores/user.store.ts)
export interface UserData {
  profile: { id: string; name: string; email: string; role: 'admin' | 'user' | 'guest' };
  preferences: { theme: 'light' | 'dark'; language: string };
}

export interface UserActions {
  login: { email: string; password: string };
  logout: void;
  updateProfile: { data: Partial<UserData['profile']> };
}

// Create domain-specific hooks
export const {
  Provider: UserProvider,
  useStore: useUserStore,
  useStoreManager: useUserStoreManager
} = createDeclarativeStorePattern('User', {
  profile: { initialValue: { id: '', name: '', email: '', role: 'guest' } },
  preferences: { initialValue: { theme: 'light', language: 'en' } }
});

export const {
  Provider: UserActionProvider,
  useActionDispatch: useUserAction,
  useActionHandler: useUserActionHandler
} = createActionContext<UserActions>('UserAction');
```

```typescript
// 2. Define Actions & Handlers (hooks/useUserHandlers.ts)
export function useUserHandlers() {
  const storeManager = useUserStoreManager();
  
  // Login handler example
  const loginHandler = useCallback(async (payload, controller) => {
    const profileStore = storeManager.getStore('profile');
    
    try {
      // Validation
      if (!validateEmail(payload.email)) {
        controller.abort('Invalid email format');
        return;
      }
      
      // API call
      const response = await authAPI.login(payload.email, payload.password);
      
      // Update store
      profileStore.setValue({
        ...response.user,
        status: 'active'
      });
      
      return { success: true, userId: response.user.id };
    } catch (error) {
      controller.abort('Login failed', error);
      return { success: false };
    }
  }, [storeManager]);
  
  // Register handler using useActionHandler hook (actual API)
  useUserActionHandler('login', loginHandler, {
    priority: 100,
    blocking: true,
    id: 'user-login-handler'
  });
  
  // Similar patterns for logout, updateProfile handlers...
}
```

```tsx
// 3. Use in Component (components/UserProfile.tsx)
export function UserProfile() {
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  const dispatch = useUserAction();
  
  const handleLogin = useCallback(async () => {
    const result = await dispatch('login', {
      email: 'user@example.com',
      password: 'password123'
    });
    
    if (result?.success) {
      console.log('Login successful');
    }
  }, [dispatch]);
  
  const handleUpdateProfile = useCallback(() => {
    dispatch('updateProfile', {
      data: { name: 'New Name' }
    });
  }, [dispatch]);
  
  return (
    <div>
      <h1>Welcome, {profile.name || 'Guest'}</h1>
      <p>Email: {profile.email}</p>
      <p>Role: {profile.role}</p>
      
      {profile.id ? (
        <button onClick={handleUpdateProfile}>Update Profile</button>
      ) : (
        <button onClick={handleLogin}>Login</button>
      )}
    </div>
  );
}
```

```tsx
// 4. App Setup (App.tsx)
function App() {
  return (
    <UserProvider>
      <UserActionProvider>
        <UserHandlersSetup />
        <UserProfile />
      </UserActionProvider>
    </UserProvider>
  );
}

// Handler setup component
function UserHandlersSetup() {
  useUserHandlers();
  return null;
}
```

### Logic Fit Hook Pattern (Combining Business & UI)

```typescript
// hooks/useUserEditor.ts
export function useUserEditor() {
  // Business layer
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  const dispatch = useUserAction();
  
  // UI state (local or separate UI store)
  const [isEditing, setIsEditing] = useState(false);
  const [formData, setFormData] = useState(profile);
  
  // Combined logic
  const startEditing = useCallback(() => {
    setIsEditing(true);
    setFormData(profile);
  }, [profile]);
  
  const saveChanges = useCallback(async () => {
    const result = await dispatch('updateProfile', { data: formData });
    if (result?.success) {
      setIsEditing(false);
    }
    return result;
  }, [dispatch, formData]);
  
  const cancelEditing = useCallback(() => {
    setIsEditing(false);
    setFormData(profile);
  }, [profile]);
  
  return {
    // Data
    profile,
    formData,
    isEditing,
    
    // Methods
    startEditing,
    saveChanges,
    cancelEditing,
    setFormData
  };
}
```

### Complete Implementation Pattern

For a full implementation with Business/UI separation, provider composition, and comprehensive handler patterns, see the [GitHub repository examples](https://github.com/mineclover/context-action/tree/main/example).

Key patterns demonstrated:
- **Store Definition**: Business data, UI state, and domain isolation
- **Handler Registration**: Priority-based execution with cleanup
- **Provider Composition**: Nested providers for domain boundaries
- **Logic Fit Hooks**: Combining business and UI logic
- **Testing Patterns**: Unit and integration testing approaches

## 10. Testing Guide

### Unit Testing Handlers

```typescript
// __tests__/handlers/userBusinessHandlers.test.ts
import { renderHook } from '@testing-library/react-hooks';
import { useUserBusinessHandlers } from '@/hooks/handlers/useUserBusinessHandlers';
import { createMockRegistry, createMockController } from '@/test-utils';

describe('User Business Handlers', () => {
  let mockRegistry;
  let mockController;
  
  beforeEach(() => {
    mockRegistry = createMockRegistry();
    mockController = createMockController();
  });
  
  it('should validate email in login handler', async () => {
    const { result } = renderHook(() => useUserBusinessHandlers());
    
    const loginHandler = result.current.loginHandler;
    
    await loginHandler(
      { email: 'invalid-email', password: 'password123' },
      mockController
    );
    
    expect(mockController.abort).toHaveBeenCalledWith('Invalid email format');
  });
  
  it('should update profile store on successful login', async () => {
    const mockProfileStore = {
      getValue: jest.fn(() => ({ id: '', name: '' })),
      setValue: jest.fn()
    };
    
    mockRegistry.getStore.mockReturnValue(mockProfileStore);
    
    const { result } = renderHook(() => useUserBusinessHandlers());
    
    await result.current.loginHandler(
      { email: 'user@example.com', password: 'password123' },
      mockController
    );
    
    expect(mockProfileStore.setValue).toHaveBeenCalledWith(
      expect.objectContaining({
        email: 'user@example.com',
        status: 'active'
      })
    );
  });
});
```

### Integration Testing

```tsx
// __tests__/integration/userFlow.test.tsx
import React from 'react';
import { render, fireEvent, waitFor } from '@testing-library/react';
import { UserProvider } from '@/providers/UserProvider';
import { UserProfile } from '@/components/UserProfile';

describe('User Profile Integration', () => {
  it('should handle complete edit flow', async () => {
    const { getByText, getByLabelText } = render(
      <UserProvider>
        <UserProfile />
      </UserProvider>
    );
    
    // Start editing
    fireEvent.click(getByText('Edit Profile'));
    
    // Update fields
    const nameInput = getByLabelText('Name:');
    fireEvent.change(nameInput, { target: { value: 'New Name' } });
    
    // Save changes
    fireEvent.click(getByText('Save'));
    
    // Verify updates
    await waitFor(() => {
      expect(getByText('Name: New Name')).toBeInTheDocument();
    });
  });
});
```

## 11. Migration Guide

### From Legacy Patterns

```typescript
// ❌ Old Pattern: Manual handler registration with useEffect
function OldComponent() {
  const dispatch = useDispatch();
  const register = useActionRegister();
  
  const handler = () => {
    // handler logic
  };
  
  useEffect(() => {
    if (!register) return;
    const unregister = register.register('action', handler);
    return unregister;
  }, [register, handler]);
}

// ✅ New Pattern: useActionHandler hook (current API)
function NewComponent() {
  const dispatch = useAction();
  
  const handler = useCallback(() => {
    // handler logic
  }, []);
  
  // Handler automatically registered and cleaned up
  useActionHandler('action', handler, {
    id: 'unique-handler-id',
    blocking: true
  });
}
```

### Incremental Migration Steps

1. **Phase 1: Add Type Definitions**
    
    - Define interfaces for all stores and actions
    - Add domain-specific hook exports
2. **Phase 2: Update Handler Registration**
    
    - Convert to useActionHandler pattern
    - Add cleanup functions
    - Add explicit handler IDs
3. **Phase 3: Implement Domain Isolation**
    
    - Separate business and UI concerns
    - Create domain-specific providers
    - Update component imports
4. **Phase 4: Testing & Validation**
    
    - Update tests for new patterns
    - Verify cleanup on unmount
    - Performance testing

## 12. Troubleshooting

### Common Issues and Solutions

#### Handler Not Executing

```typescript
// Problem: Handler registered but not executing
register('action', asyncHandler, { priority: 100 });

// Solution: Add blocking for async handlers
register('action', asyncHandler, { 
  priority: 100,
  blocking: true // Required for sequential async execution
});
```

#### Stale State in Handlers

```typescript
// Problem: Getting old values
const value = store.getValue();
const handler = () => console.log(value); // Stale

// Solution: Use lazy evaluation
const handler = () => {
  const store = stores.getStore('name');
  const value = store.getValue(); // Current
};
```

#### Memory Leaks

```typescript
// Problem: Manual registration without cleanup
useEffect(() => {
  if (!register) return;
  register.register('action', handler);
  // No cleanup!
}, [register, handler]);

// Solution: Use useActionHandler hook (automatic cleanup)
const handler = useCallback(() => {
  // handler logic
}, []);

useActionHandler('action', handler, {
  id: 'action-handler',
  blocking: true
}); // Cleanup handled automatically
```

#### Type Errors

```typescript
// Problem: Type inference not working
const store = useStore('profile'); // Generic type

// Solution: Use domain-specific hooks
const store = useUserBusinessStore('profile'); // Typed
```

## Conclusion

The Context-Action Store Integration Architecture provides a robust, scalable, and type-safe foundation for React applications. By following the patterns and best practices outlined in this guide, you can build maintainable applications with clear separation of concerns, excellent performance, and great developer experience.

### Key Takeaways

1. **Use domain-specific hooks** for type safety and clarity
2. **Use `useActionHandler` hook** for automatic registration and cleanup
3. **Use lazy evaluation** in handlers to avoid stale state
4. **Separate business and UI concerns** with different stores/actions
5. **Prefer domain isolation** - use cross-domain only when necessary
6. **Consider explicit IDs** for debugging and critical handlers
7. **Use blocking: true** for sequential async handlers
8. **Test handlers in isolation** before integration

For more information and updates, visit the project repository.

---

# Action Pipeline System Guide

# Action Pipeline Guide: ActionPayloadMap & ActionRegister

Complete guide to building type-safe action pipelines with Context-Action framework.

## Table of Contents

- [Overview](#overview)
- [ActionPayloadMap: Type Foundation](#actionpayloadmap-type-foundation)
- [ActionRegister: Pipeline Engine](#actionregister-pipeline-engine)
- [Handler Registration Patterns](#handler-registration-patterns)
- [Pipeline Execution Strategies](#pipeline-execution-strategies)
- [Advanced Pipeline Patterns](#advanced-pipeline-patterns)
- [Real-world Examples](#real-world-examples)
- [Best Practices](#best-practices)
- [Troubleshooting](#troubleshooting)

## Overview

The Context-Action framework's action pipeline system provides type-safe, scalable business logic management through two core components:

- **ActionPayloadMap**: TypeScript interface defining action-to-payload type mappings
- **ActionRegister**: Central pipeline engine managing handler registration and execution

```typescript
// The complete pipeline flow
ActionPayloadMap → ActionRegister → Handler Registration → Pipeline Execution
```

## ActionPayloadMap: Type Foundation

### Basic Concept

ActionPayloadMap is a TypeScript interface that maps action names to their payload types, providing compile-time type safety throughout the pipeline.

```typescript
import { ActionPayloadMap } from '@context-action/core';

// Define your application's actions
interface AppActions extends ActionPayloadMap {
  // Action with object payload
  updateUser: { id: string; name: string; email?: string };
  
  // Action with primitive payload
  setTheme: 'light' | 'dark';
  
  // Action without payload
  logout: void;
  
  // Action with complex payload
  submitOrder: {
    items: Array<{ id: string; quantity: number; price: number }>;
    shipping: { address: string; method: 'standard' | 'express' };
    payment: { method: 'card' | 'paypal'; token: string };
  };
  
  // Action with union types
  showNotification: {
    type: 'success' | 'error' | 'warning' | 'info';
    message: string;
    duration?: number;
  };
}
```

### Advanced Type Patterns

#### Generic Payload Types

```typescript
interface CrudActions<T> extends ActionPayloadMap {
  create: T;
  update: { id: string } & Partial<T>;
  delete: { id: string };
  fetch: { id: string };
  list: { 
    filters?: Record<string, any>;
    pagination?: { page: number; limit: number };
  };
}

// Usage with specific types
interface UserActions extends CrudActions<User> {
  // Inherits: create: User, update: { id: string } & Partial<User>, etc.
  
  // Additional user-specific actions
  changePassword: { oldPassword: string; newPassword: string };
  uploadAvatar: { file: File };
}
```

#### Conditional Payload Types

```typescript
interface ConditionalActions extends ActionPayloadMap {
  // Payload type depends on mode
  saveData: {
    mode: 'auto';
  } | {
    mode: 'manual';
    data: any;
    validation: boolean;
  };
  
  // Optional payload based on context
  refresh: {
    force?: boolean;
    scope?: 'all' | 'current' | string[];
  } | void;
}
```

### Type Safety Benefits

1. **Compile-time Validation**: TypeScript ensures correct payload types
2. **IntelliSense Support**: Auto-completion for action names and payload properties
3. **Refactoring Safety**: Renaming actions or changing payload structure is type-checked
4. **Documentation**: Types serve as living documentation of your API

## ActionRegister: Pipeline Engine

### Core Architecture

ActionRegister is the central orchestrator that manages the action pipeline lifecycle:

```typescript
import { ActionRegister, ActionRegisterConfig } from '@context-action/core';

// Create typed ActionRegister
const actionRegister = new ActionRegister<AppActions>({
  name: 'AppActionRegister',
  registry: {
    debug: true,
    autoCleanup: true,
    maxHandlers: 50,
    defaultExecutionMode: 'sequential'
  }
});
```

### Configuration Options

```typescript
interface ActionRegisterConfig {
  /** Name identifier for this ActionRegister instance */
  name?: string;
  
  /** Registry-specific configuration options */
  registry?: {
    /** Debug mode for registry operations */
    debug?: boolean;
    
    /** Auto-cleanup configuration for one-time handlers */
    autoCleanup?: boolean;
    
    /** Maximum number of handlers per action */
    maxHandlers?: number;
    
    /** Default execution mode for actions */
    defaultExecutionMode?: ExecutionMode;
  };
}
```

### Pipeline Lifecycle

```typescript
// 1. Handler Registration Phase
actionRegister.register('updateUser', handler, config);

// 2. Pipeline Dispatch Phase  
await actionRegister.dispatch('updateUser', payload);

// 3. Pipeline Execution Phase (internal)
//    - Priority sorting
//    - Condition evaluation
//    - Handler execution
//    - Flow control
//    - Cleanup
```

## Handler Registration Patterns

### Basic Handler Registration

```typescript
// Simple handler
const unregisterUpdateUser = actionRegister.register(
  'updateUser',
  async (payload, controller) => {
    console.log('Updating user:', payload);
    // Business logic here
    // Handler automatically continues to next handler
  }
);

// Handler with configuration
const unregisterValidation = actionRegister.register(
  'updateUser',
  async (payload, controller) => {
    if (!payload.email?.includes('@')) {
      controller.abort('Invalid email format');
      return;
    }
    
    // Handler automatically continues to next handler
  },
  {
    priority: 100,           // Higher priority runs first
    id: 'email-validator',   // Unique identifier
    blocking: true,          // Wait for completion
    condition: () => isLoggedIn(), // Conditional execution
    tags: ['validation', 'email'], // Handler tags
    category: 'validation',  // Handler category
    description: 'Validates email format for user updates',
    version: '1.0.0',       // Handler version
    timeout: 5000,          // Handler timeout
    environment: 'production', // Target environment
    metrics: {
      collectTiming: true,
      collectErrors: true
    }
  }
);
```

### Multi-Store Coordination

```typescript
interface StoreMap {
  user: UserStore;
  settings: SettingsStore;
  notifications: NotificationStore;
}

actionRegister.register('updateUser', async (payload, controller) => {
  // Access multiple stores
  const userStore = storeRegistry.getStore<UserStore>('user');
  const settingsStore = storeRegistry.getStore<SettingsStore>('settings');
  const notificationStore = storeRegistry.getStore<NotificationStore>('notifications');
  
  // Read current state
  const currentUser = userStore.getValue();
  const settings = settingsStore.getValue();
  
  // Business logic with cross-store coordination
  if (settings.requireEmailVerification && payload.email !== currentUser.email) {
    // Send verification email
    await sendVerificationEmail(payload.email);
    
    // Update user with pending status
    userStore.setValue({
      ...currentUser,
      ...payload,
      emailVerificationPending: true
    });
    
    // Show notification
    notificationStore.setValue({
      type: 'info',
      message: 'Verification email sent to new address',
      duration: 5000
    });
  } else {
    // Direct update
    userStore.setValue({
      ...currentUser,
      ...payload,
      updatedAt: Date.now()
    });
  }
  
  // Handler automatically continues to next handler
}, { priority: 10, blocking: true });
```

### Async Operations with Error Handling

```typescript
actionRegister.register('submitOrder', async (payload, controller) => {
  try {
    // Set loading state
    loadingStore.setValue({ isSubmittingOrder: true });
    
    // Validate inventory
    const inventoryCheck = await validateInventory(payload.items);
    if (!inventoryCheck.valid) {
      throw new Error(`Insufficient inventory: ${inventoryCheck.missing.join(', ')}`);
    }
    
    // Process payment
    const paymentResult = await processPayment(payload.payment);
    if (!paymentResult.success) {
      throw new Error(`Payment failed: ${paymentResult.error}`);
    }
    
    // Create order
    const order = await createOrder({
      ...payload,
      paymentId: paymentResult.id,
      status: 'confirmed'
    });
    
    // Update stores
    ordersStore.update(orders => [...orders, order]);
    cartStore.setValue({ items: [] }); // Clear cart
    
    // Success notification
    notificationStore.setValue({
      type: 'success',
      message: `Order ${order.id} submitted successfully!`,
      duration: 3000
    });
    
    // Handler automatically continues to next handler
    
  } catch (error) {
    // Error handling
    console.error('Order submission failed:', error);
    
    notificationStore.setValue({
      type: 'error',
      message: error.message || 'Order submission failed',
      duration: 5000
    });
    
    controller.abort('Order submission failed', error);
  } finally {
    // Always clear loading state
    loadingStore.setValue({ isSubmittingOrder: false });
  }
}, {
  priority: 10,
  blocking: true,
  debounce: 1000, // Prevent double-submission
});
```

## Pipeline Execution Strategies

### Sequential Execution (Default)

Handlers execute in priority order, waiting for each to complete:

```typescript
// Configure sequential execution
actionRegister.setActionExecutionMode('updateUser', 'sequential');

// Handlers execute in this order:
// 1. Validation (priority: 100)
// 2. Business logic (priority: 50) 
// 3. Logging (priority: 10)
// 4. Analytics (priority: 0)
```

### Parallel Execution

All handlers execute simultaneously:

```typescript
actionRegister.setActionExecutionMode('logAnalytics', 'parallel');

// Good for independent operations:
// - Logging
// - Analytics tracking
// - Cache updates
// - Notifications
```

### Race Execution

First completed handler wins:

```typescript
actionRegister.setActionExecutionMode('fetchUserData', 'race');

// Useful for:
// - Cache vs API race
// - Multiple data sources
// - Timeout scenarios
```

## Advanced Pipeline Patterns

### Handler Filtering System (New)

The ActionRegister now supports advanced handler filtering during dispatch:

```typescript
// Filter handlers by tags
await actionRegister.dispatch('updateUser', payload, {
  filter: {
    tags: ['validation', 'business'],     // Only validation and business handlers
    excludeTags: ['logging', 'analytics'], // Exclude logging handlers
    category: 'critical',                  // Only critical category handlers
    environment: 'production',             // Only production handlers
    feature: 'newUserFlow',               // Only handlers with this feature flag
    handlerIds: ['validator-1', 'saver-2'], // Specific handler IDs
    excludeHandlerIds: ['debug-logger'],   // Exclude specific handlers
    custom: (config) => config.priority > 50 // Custom filter function
  }
});
```

### Result Collection and Processing (New)

Collect and process results from multiple handlers:

```typescript
// Dispatch with result collection
const result = await actionRegister.dispatchWithResult('processOrder', orderData, {
  result: {
    collect: true,                    // Enable result collection
    strategy: 'all',                  // Collect all results
    maxResults: 10,                   // Limit to 10 results
    timeout: 5000,                    // 5 second timeout
    merger: (results) => {            // Custom result merger
      return results.reduce((acc, curr) => ({ ...acc, ...curr }), {});
    }
  }
});

console.log('Execution successful:', result.success);
console.log('Results:', result.results);
console.log('Execution duration:', result.execution.duration);
console.log('Handlers executed:', result.execution.handlersExecuted);
```

### Auto AbortController Management (New)

Automatic AbortController creation and management:

```typescript
let createdController: AbortController | undefined;

await actionRegister.dispatch('longRunningTask', payload, {
  autoAbort: {
    enabled: true,                    // Auto-create AbortController
    allowHandlerAbort: true,          // Handlers can trigger abort
    onControllerCreated: (controller) => {
      createdController = controller; // Access the created controller
      
      // Set up timeout
      setTimeout(() => controller.abort('Timeout'), 10000);
    }
  }
});
```

### Priority-based Validation Pipeline

```typescript
// Validation chain with priorities
actionRegister.register('updateUser', validateRequired, { priority: 100 });
actionRegister.register('updateUser', validateEmail, { priority: 90 });
actionRegister.register('updateUser', validatePassword, { priority: 80 });
actionRegister.register('updateUser', sanitizeInput, { priority: 70 });
actionRegister.register('updateUser', businessLogic, { priority: 50 });
actionRegister.register('updateUser', audit, { priority: 10 });
```

### Conditional Handler Execution

```typescript
actionRegister.register('updateUser', adminOnlyHandler, {
  condition: () => currentUser.role === 'admin',
  priority: 60
});

actionRegister.register('updateUser', premiumFeatureHandler, {
  condition: () => currentUser.subscription === 'premium',
  priority: 55
});
```

### Dynamic Handler Registration

```typescript
// Feature flag based registration
if (featureFlags.newUserValidation) {
  actionRegister.register('updateUser', newValidationHandler, {
    priority: 95,
    id: 'feature-new-validation'
  });
}

// Plugin-based registration
plugins.forEach(plugin => {
  if (plugin.supports('updateUser')) {
    actionRegister.register('updateUser', 
      plugin.getHandler('updateUser'), 
      plugin.getConfig('updateUser')
    );
  }
});
```

### Handler Execution Flow (Updated)

ActionRegister handlers follow a natural execution flow without explicit continuation calls:

#### Handler Termination Patterns

```typescript
actionRegister.register('processData', async (payload, controller) => {
  // Pattern 1: Natural completion - handler continues to next
  if (payload.isValid) {
    await processValidData(payload);
    // Handler naturally completes, pipeline continues to next handler
  }
  
  // Pattern 2: Early return - stops current handler, continues pipeline
  if (!payload.shouldProcess) {
    console.log('Skipping processing');
    return; // Early return, pipeline continues to next handler
  }
  
  // Pattern 3: Explicit abort - stops entire pipeline
  if (payload.hasError) {
    controller.abort('Critical error encountered');
    return; // Pipeline execution stops here
  }
  
  // Pattern 4: Conditional processing with natural flow
  const result = await someAsyncOperation(payload);
  if (result.success) {
    // Process success case
    updateStore(result.data);
  } else {
    // Process error case  
    logError(result.error);
  }
  // Handler completes naturally, continues to next handler
});
```

#### Three Ways to End Handler Execution

1. **Natural Completion**: Handler finishes all statements, automatically continues
2. **Early Return**: Use `return` to exit handler early, pipeline continues
3. **Pipeline Abort**: Use `controller.abort()` to stop entire pipeline execution

### Enhanced PipelineController API (Updated)

The PipelineController now provides extensive control over pipeline execution:

```typescript
actionRegister.register('processData', async (payload, controller) => {
  // 1. Abort pipeline with reason
  if (!payload.isValid) {
    controller.abort('Invalid payload data');
    return;
  }
  
  // 2. Get current payload (might be modified by previous handlers)
  const currentPayload = controller.getPayload();
  
  // 3. Modify payload for next handlers
  controller.modifyPayload(data => ({
    ...data,
    processed: true,
    processedAt: Date.now(),
    processingId: Math.random().toString(36)
  }));
  
  // 4. Set result for collection (pipeline continues)
  const processedResult = await processData(currentPayload);
  controller.setResult(processedResult);
  
  // 5. Get all previous results
  const allResults = controller.getResults();
  console.log('Results so far:', allResults.length);
  
  // 6. Merge current result with previous ones
  controller.mergeResult((previousResults, currentResult) => {
    return {
      combined: previousResults,
      current: currentResult,
      total: previousResults.length + 1
    };
  });
  
  // 7. Jump to specific priority (skip intermediate handlers)
  if (payload.urgent) {
    controller.jumpToPriority(10); // Jump to priority 10
  }
  
  // 8. Terminate pipeline early with final result
  if (payload.shouldTerminate) {
    controller.return({
      terminated: true,
      reason: 'Early termination requested',
      result: processedResult
    });
    return; // Pipeline stops here
  }
  
  // 9. Handler automatically continues to next handler
  // No explicit next() call needed - handlers continue automatically
});
```

### Pipeline Middleware Pattern

```typescript
// Create reusable middleware
const createAuthMiddleware = (requiredRole: string) => 
  async (payload: any, controller: PipelineController) => {
    if (!isAuthenticated() || !hasRole(requiredRole)) {
      controller.abort('Authentication required');
      return;
    }
    // Handler automatically continues to next handler
  };

const createLoggingMiddleware = (actionName: string) =>
  async (payload: any, controller: PipelineController) => {
    console.log(`[${actionName}] Started:`, payload);
    const start = Date.now();
    
    // Handler automatically continues to next handler
    
    // Note: In real middleware, you'd need event listeners for completion
    console.log(`[${actionName}] Completed in ${Date.now() - start}ms`);
  };

// Apply middleware to actions
actionRegister.register('updateUser', createAuthMiddleware('user'), { priority: 200 });
actionRegister.register('updateUser', createLoggingMiddleware('updateUser'), { priority: 190 });
```

## Real-world Examples

### E-commerce Order Processing

```typescript
interface EcommerceActions extends ActionPayloadMap {
  addToCart: { productId: string; quantity: number; options?: Record<string, any> };
  removeFromCart: { itemId: string };
  updateCartItem: { itemId: string; quantity: number };
  applyDiscount: { code: string };
  submitOrder: {
    items: CartItem[];
    shipping: ShippingInfo;
    payment: PaymentInfo;
    notes?: string;
  };
  processPayment: { orderId: string; paymentMethod: PaymentMethod };
  fulfillOrder: { orderId: string; trackingNumber?: string };
}

const ecommerceRegister = new ActionRegister<EcommerceActions>({
  name: 'EcommerceRegister',
  logLevel: LogLevel.INFO
});

// Order submission pipeline
ecommerceRegister.register('submitOrder', validateOrderItems, { priority: 100 });
ecommerceRegister.register('submitOrder', checkInventory, { priority: 90 });
ecommerceRegister.register('submitOrder', calculatePricing, { priority: 80 });
ecommerceRegister.register('submitOrder', validateShipping, { priority: 70 });
ecommerceRegister.register('submitOrder', createOrderRecord, { priority: 60 });
ecommerceRegister.register('submitOrder', reserveInventory, { priority: 50 });
ecommerceRegister.register('submitOrder', processPaymentAction, { priority: 40 });
ecommerceRegister.register('submitOrder', sendConfirmationEmail, { priority: 30 });
ecommerceRegister.register('submitOrder', updateAnalytics, { priority: 10 });

// Parallel post-processing
ecommerceRegister.setExecutionMode('submitOrder', 'sequential'); // Main flow
ecommerceRegister.register('orderConfirmed', updateRecommendations, { priority: 10 });
ecommerceRegister.register('orderConfirmed', notifyWarehouse, { priority: 10 });
ecommerceRegister.register('orderConfirmed', updateLoyaltyPoints, { priority: 10 });
ecommerceRegister.setExecutionMode('orderConfirmed', 'parallel'); // Post-processing
```

### User Management System

```typescript
interface UserManagementActions extends ActionPayloadMap {
  registerUser: {
    email: string;
    password: string;
    profile: UserProfile;
    terms: boolean;
  };
  verifyEmail: { token: string };
  resetPassword: { email: string };
  updateProfile: { userId: string; changes: Partial<UserProfile> };
  deactivateUser: { userId: string; reason: string };
}

const userRegister = new ActionRegister<UserManagementActions>({
  name: 'UserManagement',
  logLevel: LogLevel.DEBUG
});

// User registration pipeline
userRegister.register('registerUser', async (payload, controller) => {
  // Validation
  if (!payload.terms) {
    controller.abort('Terms acceptance required');
    return;
  }
  
  if (!isValidEmail(payload.email)) {
    controller.abort('Invalid email format');
    return;
  }
  
  // Check existing user
  const existingUser = await findUserByEmail(payload.email);
  if (existingUser) {
    controller.abort('Email already registered');
    return;
  }
  
  // Handler automatically continues to next handler
}, { priority: 100, id: 'validation' });

userRegister.register('registerUser', async (payload, controller) => {
  // Create user account
  const hashedPassword = await hashPassword(payload.password);
  const user = await createUser({
    email: payload.email,
    password: hashedPassword,
    profile: payload.profile,
    status: 'pending_verification'
  });
  
  // Update payload for next handlers
  controller.modifyPayload(current => ({
    ...current,
    userId: user.id
  }));
  
  // Handler automatically continues to next handler
}, { priority: 50, id: 'account-creation', blocking: true });

userRegister.register('registerUser', async (payload, controller) => {
  // Send verification email
  const verificationToken = generateVerificationToken();
  await sendVerificationEmail(payload.email, verificationToken);
  
  // Store token
  await storeVerificationToken(payload.userId, verificationToken);
  
  // Handler automatically continues to next handler
}, { priority: 40, id: 'email-verification' });

userRegister.register('registerUser', async (payload, controller) => {
  // Analytics tracking
  trackUserRegistration({
    userId: payload.userId,
    source: payload.source || 'direct',
    timestamp: Date.now()
  });
  
  // Handler automatically continues to next handler
}, { priority: 10, id: 'analytics' });
```

## Registry Management & Statistics (New)

### Registry Information

Get comprehensive information about your ActionRegister:

```typescript
// Get registry overview
const registryInfo = actionRegister.getRegistryInfo();
console.log('Registry name:', registryInfo.name);
console.log('Total actions:', registryInfo.totalActions);
console.log('Total handlers:', registryInfo.totalHandlers);
console.log('Registered actions:', registryInfo.registeredActions);
console.log('Default execution mode:', registryInfo.defaultExecutionMode);
```

### Action Statistics

Monitor individual action performance:

```typescript
// Get detailed statistics for a specific action
const userStats = actionRegister.getActionStats('updateUser');
if (userStats) {
  console.log('Handler count:', userStats.handlerCount);
  console.log('Handlers by priority:', userStats.handlersByPriority);
  
  if (userStats.executionStats) {
    console.log('Total executions:', userStats.executionStats.totalExecutions);
    console.log('Average duration:', userStats.executionStats.averageDuration);
    console.log('Success rate:', userStats.executionStats.successRate);
    console.log('Error count:', userStats.executionStats.errorCount);
  }
}

// Get statistics for all actions
const allStats = actionRegister.getAllActionStats();
allStats.forEach(stats => {
  console.log(`Action: ${stats.action}, Handlers: ${stats.handlerCount}`);
});
```

### Handler Discovery

Find handlers by tags or categories:

```typescript
// Find all validation handlers across actions
const validationHandlers = actionRegister.getHandlersByTag('validation');
for (const [action, handlers] of validationHandlers) {
  console.log(`Action ${action} has ${handlers.length} validation handlers`);
}

// Find all critical handlers
const criticalHandlers = actionRegister.getHandlersByCategory('critical');
for (const [action, handlers] of criticalHandlers) {
  console.log(`Action ${action} has ${handlers.length} critical handlers`);
}
```

### Execution Mode Management

Advanced execution mode control:

```typescript
// Set execution mode for specific action
actionRegister.setActionExecutionMode('processPayment', 'sequential');

// Get current execution mode
const mode = actionRegister.getActionExecutionMode('processPayment');
console.log('Payment processing mode:', mode);

// Remove override (revert to default)
actionRegister.removeActionExecutionMode('processPayment');
```

### Statistics Management

Control execution statistics:

```typescript
// Clear all statistics
actionRegister.clearExecutionStats();

// Clear statistics for specific action
actionRegister.clearActionExecutionStats('updateUser');

// Check if debug mode is enabled
if (actionRegister.isDebugEnabled()) {
  console.log('Debug mode is active');
}
```

### ExecutionResult Interface (New)

The `dispatchWithResult` method returns comprehensive execution information:

```typescript
interface ExecutionResult<R = void> {
  success: boolean;        // Whether execution completed successfully
  aborted: boolean;        // Whether execution was aborted
  abortReason?: string;    // Reason for abortion if aborted
  terminated: boolean;     // Whether terminated early via controller.return()
  result?: R;             // Final processed result based on strategy
  results: R[];           // All individual handler results
  execution: {
    duration: number;           // Total execution time in ms
    handlersExecuted: number;   // Number of handlers that ran
    handlersSkipped: number;    // Number of handlers that were skipped
    handlersFailed: number;     // Number of handlers that failed
    startTime: number;          // Execution start timestamp
    endTime: number;            // Execution end timestamp
  };
  handlers: Array<{         // Detailed handler information
    id: string;             // Handler unique identifier
    executed: boolean;      // Whether this handler ran
    duration?: number;      // Handler execution time
    result?: R;            // Handler result
    error?: Error;         // Handler error if any
    metadata?: Record<string, any>; // Custom handler metadata
  }>;
  errors: Array<{          // All errors that occurred
    handlerId: string;     // Handler that caused the error
    error: Error;          // The error object
    timestamp: number;     // When the error occurred
  }>;
}

// Usage example
async function processOrderWithDetails(orderData: OrderData) {
  const result = await actionRegister.dispatchWithResult('processOrder', orderData, {
    result: {
      collect: true,         // Enable result collection
      strategy: 'merge',     // Merge all results
      timeout: 10000,        // 10 second timeout
      maxResults: 20,        // Limit results
      merger: (results) => { // Custom merger function
        return results.reduce((acc, curr) => ({ ...acc, ...curr }), {});
      }
    },
    filter: {
      tags: ['validation', 'business'], // Only these handlers
      excludeTags: ['logging']          // Exclude logging
    }
  });
  
  // Check execution status
  if (!result.success) {
    if (result.aborted) {
      console.error('Order processing aborted:', result.abortReason);
    } else {
      console.error('Order processing failed:', result.errors.length, 'errors');
    }
    return null;
  }
  
  // Log execution metrics
  console.log(`Order processed in ${result.execution.duration}ms`);
  console.log(`Executed ${result.execution.handlersExecuted}/${result.execution.handlersExecuted + result.execution.handlersSkipped} handlers`);
  
  // Check for early termination
  if (result.terminated) {
    console.log('Pipeline was terminated early');
  }
  
  return result.result; // Final processed result
}
```

## Best Practices

### 1. Type Safety

```typescript
// ✅ DO: Use specific, well-defined types
interface OrderActions extends ActionPayloadMap {
  updateOrderStatus: {
    orderId: string;
    status: 'pending' | 'confirmed' | 'shipped' | 'delivered' | 'cancelled';
    timestamp?: number;
    notes?: string;
  };
}

// ❌ DON'T: Use overly generic types
interface BadActions extends ActionPayloadMap {
  update: any; // Too generic
  process: object; // Not specific enough
}
```

### 2. Handler Organization

```typescript
// ✅ DO: Organize handlers by concern
const validationHandlers = {
  validateEmail: (payload, controller) => { /* ... */ },
  validatePassword: (payload, controller) => { /* ... */ },
  validateProfile: (payload, controller) => { /* ... */ }
};

const businessHandlers = {
  createUser: (payload, controller) => { /* ... */ },
  sendWelcomeEmail: (payload, controller) => { /* ... */ },
  setupDefaults: (payload, controller) => { /* ... */ }
};

// Register with clear priorities
Object.entries(validationHandlers).forEach(([name, handler], index) => {
  actionRegister.register('registerUser', handler, {
    id: name,
    priority: 100 - index
  });
});
```

### 3. Error Handling

```typescript
// ✅ DO: Comprehensive error handling
actionRegister.register('processPayment', async (payload, controller) => {
  try {
    const result = await paymentService.charge(payload);
    
    if (!result.success) {
      // Business logic error
      controller.abort(`Payment declined: ${result.reason}`);
      return;
    }
    
    // Update stores
    paymentStore.setValue(result.payment);
    orderStore.update(order => ({ 
      ...order, 
      paymentStatus: 'completed',
      paymentId: result.payment.id 
    }));
    
    // Handler automatically continues to next handler
    
  } catch (error) {
    // System error
    console.error('Payment processing failed:', error);
    
    // Rollback any partial changes
    await rollbackPayment(payload.orderId);
    
    controller.abort('Payment system unavailable', error);
  }
}, { priority: 50, blocking: true });
```

### 4. Performance Optimization

```typescript
// ✅ DO: Use appropriate execution modes
actionRegister.setExecutionMode('trackAnalytics', 'parallel'); // Independent operations
actionRegister.setExecutionMode('validateOrder', 'sequential'); // Dependent validations

// ✅ DO: Use debouncing for user input
actionRegister.register('searchUsers', searchHandler, {
  debounce: 300, // Wait 300ms after last input
  priority: 10
});

// ✅ DO: Use throttling for frequent events
actionRegister.register('trackMouseMovement', trackingHandler, {
  throttle: 100, // Max once per 100ms
  priority: 0
});
```

### 5. Memory Management

```typescript
// ✅ DO: Clean up handlers when components unmount
useEffect(() => {
  const unregisterHandlers = [
    actionRegister.register('updateUser', userHandler),
    actionRegister.register('deleteUser', deleteHandler),
    actionRegister.register('refreshUser', refreshHandler)
  ];
  
  return () => {
    // Clean up all handlers
    unregisterHandlers.forEach(unregister => unregister());
  };
}, []);

// ✅ DO: Use once: true for one-time handlers
actionRegister.register('appInitialized', initHandler, {
  once: true, // Automatically unregistered after first execution
  priority: 100
});
```

### 6. Handler Organization (New)

```typescript
// ✅ DO: Use tags and categories for organization
actionRegister.register('processPayment', validatePayment, {
  priority: 100,
  tags: ['validation', 'payment', 'critical'],
  category: 'validation',
  description: 'Validates payment information before processing',
  environment: 'production'
});

// ✅ DO: Use meaningful handler IDs
actionRegister.register('processPayment', processPaymentLogic, {
  id: 'payment-processor-v2',
  priority: 50,
  tags: ['business', 'payment'],
  category: 'core-logic',
  version: '2.1.0'
});
```

### 7. Handler Termination Patterns (New)

```typescript
// ✅ DO: Use natural completion for normal flow
actionRegister.register('processUser', async (payload, controller) => {
  const user = await fetchUser(payload.id);
  userStore.setValue(user);
  // Natural completion - continues to next handler
});

// ✅ DO: Use early return for conditional logic
actionRegister.register('validateUser', (payload, controller) => {
  if (!payload.email) {
    logError('Email is required');
    return; // Early return - pipeline continues
  }
  
  if (!isValidEmail(payload.email)) {
    logError('Invalid email format');
    return; // Early return - pipeline continues
  }
  
  // Validation passed - natural completion
});

// ✅ DO: Use abort for critical errors
actionRegister.register('securityCheck', (payload, controller) => {
  if (isSuspiciousActivity(payload)) {
    controller.abort('Security violation detected');
    return; // Pipeline stops completely
  }
  
  // Security check passed - natural completion
});

// ❌ DON'T: Forget to return after abort
actionRegister.register('badHandler', (payload, controller) => {
  if (error) {
    controller.abort('Error occurred');
    // ❌ Missing return - code continues executing
    doSomethingElse(); // This will still run!
  }
});
```

### 8. Result Handling (New)

```typescript
// ✅ DO: Use appropriate result strategies
const result = await actionRegister.dispatchWithResult('collectData', payload, {
  result: {
    strategy: 'merge',     // Combine all results
    collect: true,
    maxResults: 10,
    merger: (results) => {
      // Smart merging logic
      return results.reduce((acc, curr) => {
        return { ...acc, ...curr, timestamp: Date.now() };
      }, {});
    }
  }
});

// ✅ DO: Handle execution results properly
if (!result.success) {
  if (result.aborted) {
    console.warn('Operation was aborted:', result.abortReason);
  } else if (result.errors.length > 0) {
    console.error('Operation failed:', result.errors);
  }
  return;
}
```

## Troubleshooting

### Common Issues and Solutions

#### 1. Type Errors

```typescript
// ❌ Problem: Type mismatch
dispatch('updateUser', { invalidField: true }); // Type error

// ✅ Solution: Check ActionPayloadMap definition
interface AppActions extends ActionPayloadMap {
  updateUser: { id: string; name: string }; // Only these fields allowed
}

dispatch('updateUser', { id: '1', name: 'John' }); // ✅ Correct
```

#### 2. Handler Not Executing

```typescript
// ❌ Problem: Handler registered but not executing
actionRegister.register('myAction', handler, {
  condition: () => false // Always false!
});

// ✅ Solution: Check condition logic
actionRegister.register('myAction', handler, {
  condition: () => isFeatureEnabled('myFeature') // Proper condition
});
```

#### 3. Handler Termination Issues

```typescript
// ❌ Problem: Handler continues executing after abort
actionRegister.register('processData', async (payload, controller) => {
  if (payload.invalid) {
    controller.abort('Invalid data');
    // ❌ Missing return - code continues!
    await processData(payload); // This still executes
  }
});

// ✅ Solution: Always return after abort
actionRegister.register('processData', async (payload, controller) => {
  if (payload.invalid) {
    controller.abort('Invalid data');
    return; // ✅ Stop handler execution
  }
  
  try {
    await processData(payload);
    // Natural completion - continues to next handler
  } catch (error) {
    controller.abort('Processing failed', error);
    return; // ✅ Stop on error
  }
});

// ✅ Alternative: Use early returns for flow control
actionRegister.register('validateAndProcess', async (payload, controller) => {
  // Validation with early return
  if (!payload.email) {
    logError('Email required');
    return; // Skip processing, continue pipeline
  }
  
  if (!payload.name) {
    logError('Name required');
    return; // Skip processing, continue pipeline
  }
  
  // All valid - process normally
  await processValidData(payload);
  // Natural completion
});
```

#### 4. Memory Leaks

```typescript
// ❌ Problem: Handlers not cleaned up
function BadComponent() {
  useEffect(() => {
    actionRegister.register('action', handler);
    // No cleanup!
  }, []);
}

// ✅ Solution: Always return cleanup function
function GoodComponent() {
  useEffect(() => {
    const unregister = actionRegister.register('action', handler);
    return unregister; // ✅ Cleanup on unmount
  }, []);
}
```

### Debug Tools

#### 1. Enable Debug Logging

```typescript
const actionRegister = new ActionRegister<AppActions>({
  name: 'DebugRegister',
  registry: {
    debug: true,        // Enable debug mode (development only)
    maxHandlers: 100,   // Increase if needed for debugging
    autoCleanup: true   // Auto-cleanup for easier debugging
  }
});
```

#### 2. Registry Information for Debugging

```typescript
// Get comprehensive registry information
const registryInfo = actionRegister.getRegistryInfo();
console.log('Registry Debug Info:', {
  name: registryInfo.name,
  totalActions: registryInfo.totalActions,
  totalHandlers: registryInfo.totalHandlers,
  actions: registryInfo.registeredActions,
  defaultExecutionMode: registryInfo.defaultExecutionMode
});

// Check specific action details
const actionStats = actionRegister.getActionStats('updateUser');
if (actionStats) {
  console.log('Action Debug Info:', {
    handlerCount: actionStats.handlerCount,
    handlersByPriority: actionStats.handlersByPriority,
    executionStats: actionStats.executionStats
  });
}
```

#### 3. Handler Performance Monitoring

```typescript
// Use dispatchWithResult for comprehensive monitoring
async function debugDispatch(action: string, payload: any) {
  const result = await actionRegister.dispatchWithResult(action, payload);
  
  console.log(`[${action}] Execution Summary:`, {
    success: result.success,
    duration: `${result.execution.duration}ms`,
    handlersExecuted: result.execution.handlersExecuted,
    handlersSkipped: result.execution.handlersSkipped,
    handlersFailed: result.execution.handlersFailed,
    aborted: result.aborted,
    abortReason: result.abortReason,
    terminated: result.terminated
  });
  
  // Log individual handler performance
  result.handlers.forEach(handler => {
    if (handler.executed) {
      console.log(`  Handler ${handler.id}: ${handler.duration}ms`);
    } else {
      console.log(`  Handler ${handler.id}: skipped`);
    }
    
    if (handler.error) {
      console.error(`  Handler ${handler.id} error:`, handler.error);
    }
  });
  
  return result;
}

// Enable metrics collection for specific handlers
actionRegister.register('updateUser', userHandler, {
  priority: 50,
  metrics: {
    collectTiming: true,
    collectErrors: true,
    customMetrics: { trackUserUpdates: true }
  }
});
```

---

## Conclusion

The ActionPayloadMap and ActionRegister system provides a powerful, type-safe foundation for building scalable business logic pipelines. With the latest enhancements, you now have comprehensive control over pipeline execution, advanced filtering capabilities, result collection, and detailed monitoring.

### Key takeaways:

1. **Type Safety First**: Always define clear ActionPayloadMap interfaces
2. **Natural Handler Flow**: Use natural completion, early returns, and explicit aborts for clean handler termination
3. **Advanced Configuration**: Leverage the new registry configuration options for better control
4. **Handler Organization**: Use tags, categories, and metadata for better organization
5. **Result Management**: Take advantage of the new result collection and processing system
6. **Performance Monitoring**: Use ExecutionResult and statistics APIs for comprehensive monitoring
7. **Filtering & Control**: Utilize advanced filtering options for precise handler execution
8. **Error Handling**: Always return after controller.abort() to prevent continued execution
9. **Memory Management**: Always clean up handlers and use auto-cleanup features
10. **Debugging**: Use registry information and debug modes for troubleshooting

### Latest Features Summary:

- **Enhanced HandlerConfig** with tags, categories, metadata, and environment controls
- **Advanced Filtering System** for selective handler execution  
- **Result Collection & Processing** with multiple strategies and custom mergers
- **Auto AbortController Management** for better cancellation control
- **Comprehensive ExecutionResult** with detailed execution information
- **Registry Management APIs** for monitoring and statistics
- **Performance Metrics** with timing and error collection

For more advanced patterns and integration examples, see the [Context-Action Framework Documentation](../README.md) and other concept guides in this directory.

---

# Hooks Reference Documentation

# Context-Action React Hooks Reference

This document categorizes all available React hooks in the Context-Action framework into **Essential Hooks** (core functionality) and **Utility Hooks** (convenience and optimization).

## 📋 Table of Contents

1. [Essential Hooks](#essential-hooks)
2. [Utility Hooks](#utility-hooks)
3. [Hook Categories](#hook-categories)
4. [Usage Guidelines](#usage-guidelines)

---

## Essential Hooks

These hooks are fundamental to using the Context-Action framework. Most applications will need these.

### 🎯 Action Hooks (Core)

#### `createActionContext<T>()`
**Factory function** that creates all action-related hooks for a specific action context.
- **Purpose**: Creates type-safe action dispatch and handler system
- **Returns**: `{ Provider, useActionDispatch, useActionHandler, useActionRegister }`
- **Essential for**: Any action-based logic

```tsx
const { 
  Provider: UserActionProvider,
  useActionDispatch: useUserAction,
  useActionHandler: useUserActionHandler
} = createActionContext<UserActions>('UserActions');
```

#### `useActionDispatch()`
**Primary hook** for dispatching actions to handlers.
- **Purpose**: Get dispatch function to trigger actions
- **Essential for**: Component interaction with business logic
- **Pattern**: ViewModel layer in MVVM architecture

#### `useActionHandler()`
**Primary hook** for registering action handlers.
- **Purpose**: Register business logic for specific actions
- **Essential for**: Implementing business logic
- **Best Practice**: Use with `useCallback` for optimization

### 🏪 Store Hooks (Core)

#### `createDeclarativeStorePattern<T>()`
**Factory function** that creates all store-related hooks with type safety.
- **Purpose**: Creates type-safe store management system
- **Returns**: `{ Provider, useStore, useStoreManager, withProvider }`
- **Essential for**: Any state management

```tsx
const {
  Provider: UserStoreProvider,
  useStore: useUserStore,
  useStoreManager: useUserStoreManager
} = createDeclarativeStorePattern('User', {
  profile: { id: '', name: '' }
});
```

#### `useStoreValue<T>(store)`
**Primary hook** for subscribing to store changes.
- **Purpose**: Get reactive value from store
- **Essential for**: Reading state in components
- **Performance**: Only re-renders on actual value changes

```tsx
const userStore = useUserStore('profile');
const user = useStoreValue(userStore);
```

#### `useStore(name)` (from pattern)
**Primary hook** for accessing stores by name.
- **Purpose**: Get store instance from context
- **Essential for**: Accessing stores in components
- **Type-safe**: Returns properly typed store

---

## Utility Hooks

These hooks provide additional functionality, optimizations, and convenience features.

### 🎯 Action Utility Hooks

#### `useActionDispatchWithResult()`
**Utility hook** for actions that need to collect results.
- **Purpose**: Dispatch actions and collect handler results
- **Use Case**: When you need return values from handlers
- **Advanced**: For complex workflows requiring handler responses

```tsx
const { dispatchWithResult } = useActionDispatchWithResult();
const result = await dispatchWithResult('login', credentials);
```

#### `useActionRegister()`
**Utility hook** for direct access to ActionRegister instance.
- **Purpose**: Advanced control over action registry
- **Use Case**: Dynamic handler management, debugging
- **Advanced**: Rarely needed in typical applications

### 🏪 Store Utility Hooks

#### `useStoreSelector<T, R>(store, selector, equalityFn?)`
**Performance hook** for selective subscriptions.
- **Purpose**: Subscribe to specific parts of store
- **Optimization**: Prevents unnecessary re-renders
- **Use Case**: Large objects where only part changes

```tsx
const userName = useStoreSelector(userStore, user => user.name, shallowEqual);
```

#### `useComputedStore<T, R>(store, compute, config?)`
**Derived state hook** for computed values.
- **Purpose**: Create derived state from stores
- **Optimization**: Only recomputes when dependencies change
- **Use Case**: Calculated values, aggregations

```tsx
const fullName = useComputedStore(
  userStore,
  user => `${user.firstName} ${user.lastName}`
);
```

#### `useLocalStore<T>(initialValue, name?)`
**Component-local store** hook.
- **Purpose**: Create store scoped to component lifecycle
- **Use Case**: Complex component state
- **Benefit**: Store API without global state

```tsx
const { value, setValue, store } = useLocalStore({ count: 0 });
```

#### `usePersistedStore<T>(key, initialValue, options?)`
**Persistence hook** for browser storage.
- **Purpose**: Auto-sync store with localStorage/sessionStorage
- **Use Case**: Settings, user preferences, draft data
- **Feature**: Cross-tab synchronization

```tsx
const themeStore = usePersistedStore('theme', 'light', {
  storage: localStorage
});
```

#### `assertStoreValue<T>(value, storeName)`
**Type assertion utility** for store values.
- **Purpose**: Runtime assertion for non-undefined values
- **Type Safety**: Throws error if undefined
- **Use Case**: When store must have a value

```tsx
const user = useStoreValue(userStore);
const safeUser = assertStoreValue(user, 'userStore'); // never undefined
```

### 🔧 Performance Optimization Hooks

#### `useMultiStoreSelector(stores, selector, equalityFn?)`
**Multi-store selector** for combining stores.
- **Purpose**: Select from multiple stores efficiently
- **Optimization**: Single subscription for multiple stores
- **Use Case**: Cross-store computed values

#### `useStorePathSelector(store, path, equalityFn?)`
**Path-based selector** for nested objects.
- **Purpose**: Select nested values by path
- **Convenience**: Dot notation for deep selection
- **Use Case**: Complex nested state

#### `useAsyncComputedStore(asyncCompute, deps, config?)`
**Async computed values** hook.
- **Purpose**: Compute values asynchronously
- **Feature**: Loading states, error handling
- **Use Case**: API-derived state

---

## Hook Categories

### By Domain

#### State Management
- **Essential**: `useStoreValue`, `useStore` (from pattern)
- **Utility**: `useStoreSelector`, `useComputedStore`, `useLocalStore`

#### Action Handling
- **Essential**: `useActionDispatch`, `useActionHandler`
- **Utility**: `useActionDispatchWithResult`, `useActionRegister`

#### Performance
- **Utility**: `useStoreSelector`, `useComputedStore`, `useStoreActions`

#### Persistence
- **Utility**: `usePersistedStore`

#### Advanced/Meta
- **Utility**: `useActionRegister`

### By Usage Frequency

#### High Frequency (>80% of components)
- `useStoreValue`
- `useActionDispatch`
- `useStore` (from pattern)

#### Medium Frequency (20-80% of components)
- `useActionHandler`
- `useStoreSelector`
- `useLocalStore`

#### Low Frequency (<20% of components)
- `useComputedStore`
- `usePersistedStore`
- `useActionDispatchWithResult`

---

## Usage Guidelines

### When to Use Essential Hooks

1. **Starting a new feature**: Always start with essential hooks
2. **Basic CRUD operations**: Essential hooks are sufficient
3. **Simple state management**: `useStoreValue` + `useActionDispatch`
4. **Standard business logic**: `useActionHandler` for logic implementation

### When to Use Utility Hooks

1. **Performance issues**: Use selector hooks for optimization
2. **Complex state derivation**: Use `useComputedStore`
3. **Browser storage needs**: Use `usePersistedStore`
4. **Component-local complex state**: Use `useLocalStore`
5. **Advanced workflows**: Use result collection hooks
6. **Meta-programming**: Use registry hooks

### Best Practices

#### Essential Hook Patterns
```tsx
// Standard component pattern
function UserProfile() {
  // Essential: Get stores
  const profileStore = useUserStore('profile');
  const profile = useStoreValue(profileStore);
  
  // Essential: Get dispatch
  const dispatch = useUserAction();
  
  // Essential: Register handler
  useUserActionHandler('updateProfile', useCallback(async (payload) => {
    // Business logic here
  }, []));
  
  return <div>{profile.name}</div>;
}
```

#### Utility Hook Patterns
```tsx
// Optimized component with utilities
function OptimizedUserProfile() {
  // Utility: Selective subscription
  const userName = useStoreSelector(userStore, u => u.name);
  
  // Utility: Computed value
  const displayName = useComputedStore(userStore, u => 
    u.nickname || u.name || 'Anonymous'
  );
  
  // Utility: Persisted settings
  const settings = usePersistedStore('userSettings', {
    theme: 'light',
    notifications: true
  });
  
  // Utility: Result collection
  const { dispatchWithResult } = useActionDispatchWithResult();
  
  return <div>{displayName}</div>;
}
```

### Migration Path

For new projects:
1. Start with essential hooks only
2. Add utility hooks as needs arise
3. Refactor to utility hooks for optimization

For existing projects:
1. Keep existing patterns working
2. Gradually adopt utility hooks for new features
3. Refactor performance-critical areas with selector hooks

---

## Additional Hooks and Utilities

### 🔍 Context Hooks

#### `useStoreContext()`
**Low-level context hook** for accessing store context directly.
- **Purpose**: Direct access to store context internals
- **Use Case**: Custom store patterns, debugging
- **Advanced**: Rarely needed in applications

```tsx
const context = useStoreContext();
// Access to internal store context structure
```

### 📊 Multiple Store Hooks

#### `useStoreValues<T, S>(store, selectors)`
**Multiple selector hook** for extracting multiple values at once.
- **Purpose**: Extract multiple values with single subscription
- **Performance**: More efficient than multiple `useStoreValue` calls
- **Use Case**: Components needing multiple derived values

```tsx
const { name, age, email } = useStoreValues(userStore, {
  name: user => user.name,
  age: user => user.age,
  email: user => user.email
});
```

#### `useMultiStoreSelector<R>(stores, selector, equalityFn?)`
**Cross-store selector** for combining multiple stores.
- **Purpose**: Compute value from multiple stores
- **Performance**: Single subscription for all stores
- **Use Case**: Cross-store computed values

```tsx
const summary = useMultiStoreSelector(
  [userStore, settingsStore],
  ([user, settings]) => ({
    displayName: user.name,
    theme: settings.theme
  }),
  shallowEqual
);
```

#### `useMultiComputedStore<R>(stores, compute, config?)`
**Multi-store computed hook** for complex derivations.
- **Purpose**: Compute values from multiple store dependencies
- **Memoization**: Only recomputes when dependencies change
- **Use Case**: Complex cross-store calculations

```tsx
const dashboard = useMultiComputedStore(
  [salesStore, inventoryStore, userStore],
  ([sales, inventory, users]) => ({
    totalRevenue: sales.reduce((sum, s) => sum + s.amount, 0),
    lowStock: inventory.filter(i => i.quantity < 10),
    activeUsers: users.filter(u => u.isActive)
  })
);
```

### 🎯 Specialized Selector Hooks

#### `useStorePathSelector<T>(store, path, equalityFn?)`
**Path-based selector** for nested values.
- **Purpose**: Select deeply nested values by path
- **Convenience**: Array or dot notation for paths
- **Use Case**: Complex nested state structures

```tsx
// Using array path
const city = useStorePathSelector(userStore, ['address', 'city']);

// Would also support dot notation if implemented
const city = useStorePathSelector(userStore, 'address.city');
```

#### `useAsyncComputedStore<R>(dependencies, compute, config?)`
**Async computation hook** for asynchronous derived state.
- **Purpose**: Compute values asynchronously from stores
- **Features**: Loading states, error handling, caching
- **Use Case**: API calls based on store values

```tsx
const enrichedUser = useAsyncComputedStore(
  [userStore],
  async ([user]) => {
    const profile = await fetchUserProfile(user.id);
    return { ...user, ...profile };
  },
  {
    initialValue: null,
    onError: (err) => console.error('Failed to fetch profile:', err)
  }
);
```

#### `useComputedStoreInstance<R>(dependencies, compute, config?)`
**Store instance creator** for computed stores.
- **Purpose**: Create a Store instance from computed values
- **Returns**: Actual `Store<R>` instance (not just value)
- **Use Case**: When you need a store interface for computed values

```tsx
const computedStore = useComputedStoreInstance(
  [priceStore, quantityStore],
  ([price, quantity]) => price * quantity,
  { name: 'totalPriceStore' }
);

// Can now pass this to other components expecting a Store
<PriceDisplay store={computedStore} />
```

### 🔧 Higher-Order Components (HOCs)

#### `withProvider(Component, config?)`
**HOC for automatic provider wrapping**.
- **Purpose**: Wrap components with their required providers
- **Convenience**: Eliminates manual provider nesting
- **Configuration**: Optional display name and registry ID

```tsx
// Basic usage
const UserProfileWithProvider = UserStores.withProvider(UserProfile);

// With configuration
const UserProfileWithProvider = UserStores.withProvider(UserProfile, {
  displayName: 'UserProfileWithStores',
  registryId: 'user-profile-stores'
});

// Usage - no manual provider needed
<UserProfileWithProvider />
```

### 🔧 Utility Functions

#### `shallowEqual<T>(a, b)`
**Shallow equality comparison** function.
- **Purpose**: Compare objects at first level only
- **Performance**: Faster than deep comparison
- **Use Case**: Object/array comparison in selectors

```tsx
const user = useStoreSelector(
  userStore,
  state => ({ name: state.name, age: state.age }),
  shallowEqual // Only re-render if name or age changes
);
```

#### `deepEqual<T>(a, b)`
**Deep equality comparison** function.
- **Purpose**: Recursively compare nested structures
- **Caution**: Performance cost for large objects
- **Use Case**: Complex nested object comparison

```tsx
const settings = useStoreSelector(
  settingsStore,
  state => state.preferences,
  deepEqual // Deep comparison of preferences object
);
```

#### `defaultEqualityFn<T>(a, b)`
**Default equality function** (Object.is).
- **Purpose**: Default comparison using Object.is
- **Behavior**: Same as `===` except for NaN and +0/-0
- **Use Case**: Primitive values, reference equality

#### `assertStoreValue<T>(value, storeName)`
**Runtime assertion** helper for store values.
- **Purpose**: Assert value is not undefined at runtime
- **Safety**: Throws descriptive error if undefined
- **Use Case**: Critical values that must exist

```tsx
function CriticalComponent() {
  const userStore = useUserStore('profile');
  const user = useStoreValue(userStore);
  
  // Ensure user exists before proceeding
  const safeUser = assertStoreValue(user, 'userProfile');
  
  return <div>Welcome {safeUser.name}</div>;
}
```

### 📦 Pattern-Specific Hooks

These hooks are created by factory functions:

#### From `createDeclarativeStorePattern()`
- `Provider` - Context provider component
- `useStore(name)` - Get store by name
- `useStoreManager()` - Get store manager instance
- `withProvider(Component, config?)` - HOC for auto-wrapping

#### From `createActionContext()`
- `Provider` - Action context provider
- `useActionContext()` - Get action context
- `useActionDispatch()` - Get dispatch function
- `useActionHandler(action, handler, config?)` - Register handler
- `useActionRegister()` - Get ActionRegister instance
- `useActionDispatchWithResult()` - Dispatch with result collection

---

## Complete Hook Categories

### By Functionality

#### Core State Management
- `useStoreValue` - Subscribe to store value
- `useStoreValues` - Subscribe to multiple values
- `useStore` - Get store instance

#### Performance Optimization
- `useStoreSelector` - Selective subscription
- `useMultiStoreSelector` - Multi-store selection
- `useStorePathSelector` - Path-based selection
- `useComputedStore` - Computed values
- `useMultiComputedStore` - Multi-store computation
- `useAsyncComputedStore` - Async computation

#### Store Creation & Management
- `useLocalStore` - Component-local store
- `usePersistedStore` - Persistent store
- `useComputedStoreInstance` - Computed store instance

#### Action System
- `useActionDispatch` - Dispatch actions
- `useActionHandler` - Register handlers
- `useActionDispatchWithResult` - Dispatch with results
- `useActionRegister` - Access register
- `useActionContext` - Access context

#### Utilities & Helpers
- `useStoreContext` - Store context access
- `assertStoreValue` - Value assertion
- `shallowEqual` - Shallow comparison
- `deepEqual` - Deep comparison
- `defaultEqualityFn` - Default comparison

#### HOCs & Patterns
- `withProvider` - Auto-provider HOC

---

## Summary

### Essential Hooks (Must Learn)
- **Factory Functions**: `createActionContext`, `createDeclarativeStorePattern`
- **Core Hooks**: `useStoreValue`, `useActionDispatch`, `useActionHandler`, `useStore`

### Utility Hooks (Learn As Needed)
- **Performance**: `useStoreSelector`, `useComputedStore`
- **Convenience**: `useLocalStore`, `usePersistedStore`
- **Advanced**: `useActionDispatchWithResult`

### Specialized Hooks (For Specific Cases)
- **Multi-Store**: `useMultiStoreSelector`, `useMultiComputedStore`, `useStoreValues`
- **Async**: `useAsyncComputedStore`
- **Path Selection**: `useStorePathSelector`
- **Type Safety**: `assertStoreValue`
- **Low-Level**: `useStoreContext`, `useActionContext`

### Helper Functions
- **Equality**: `shallowEqual`, `deepEqual`, `defaultEqualityFn`
- **HOCs**: `withProvider`

The framework provides **30+ hooks and utilities** total, but most applications only need the essential hooks. The focused utility hooks provide powerful optimizations and conveniences when specific needs arise.

---

# Store Only Pattern API

# Store Only Methods

Complete API reference for Store Only Pattern methods from `createDeclarativeStorePattern`.

## Overview

The Store Only Pattern provides type-safe state management without action dispatching. This pattern is ideal for data layers, simple state management, and scenarios where you need reactive state without complex business logic.

## Core Methods

### `createDeclarativeStorePattern<T>(contextName, storeConfig)`

Creates a declarative store pattern with type-safe state management.

**Parameters:**
- `contextName`: Unique identifier for the store context
- `storeConfig`: Configuration object defining stores and their initial values

**Returns:**
```typescript
{
  Provider: React.ComponentType,
  useStore: (storeName: keyof T) => Store<T[storeName]>,
  useStoreManager: () => StoreManager<T>,
  withProvider: (Component: React.ComponentType) => React.ComponentType
}
```

**Example:**
```typescript
const { Provider, useStore, useStoreManager, withProvider } = 
  createDeclarativeStorePattern('App', {
    user: { id: '', name: '', email: '' },
    settings: { theme: 'light', language: 'en' }
  });
```

## Store Instance Methods

### `store.getValue()`

Returns the current value of the store synchronously.

**Returns:** Current store value
**Use Case:** Reading current state in action handlers or effects

```typescript
const userStore = useStore('user');
const currentUser = userStore.getValue();
console.log('Current user:', currentUser);
```

### `store.setValue(newValue)`

Sets the entire store value, replacing the current state.

**Parameters:**
- `newValue`: Complete new value for the store

**Returns:** `void`

```typescript
const userStore = useStore('user');
userStore.setValue({
  id: '123',
  name: 'John Doe',
  email: 'john@example.com'
});
```

### `store.update(updater)`

Updates the store using an updater function that receives the current value.

**Parameters:**
- `updater`: Function that receives current value and returns new value

**Returns:** `void`

```typescript
const userStore = useStore('user');
userStore.update(current => ({
  ...current,
  name: 'Updated Name'
}));
```

### `store.subscribe(callback)`

Subscribes to store changes with a callback function.

**Parameters:**
- `callback`: Function called when store value changes

**Returns:** Unsubscribe function

```typescript
const userStore = useStore('user');
const unsubscribe = userStore.subscribe((newValue, previousValue) => {
  console.log('User changed:', { newValue, previousValue });
});

// Cleanup
useEffect(() => unsubscribe, []);
```

### `store.reset()`

Resets the store to its initial value.

**Returns:** `void`

```typescript
const userStore = useStore('user');
userStore.reset(); // Back to initial state
```

## Store Configuration Options

### Basic Configuration

Simple value initialization:

```typescript
const config = {
  user: { id: '', name: '', email: '' },
  settings: { theme: 'light', language: 'en' }
};
```

### Advanced Configuration

With validators and custom initial values:

```typescript
const config = {
  user: {
    initialValue: { id: '', name: '', email: '' },
    validator: (value) => typeof value === 'object' && 'id' in value
  },
  settings: {
    initialValue: { theme: 'light', language: 'en' },
    validator: (value) => 
      typeof value === 'object' && 
      'theme' in value && 
      ['light', 'dark'].includes(value.theme)
  }
};
```

## React Integration Hooks

### `useStoreValue(store)`

Hook for reactive store subscriptions in components.

**Parameters:**
- `store`: Store instance from `useStore()`

**Returns:** Current store value (reactive)

```typescript
function UserComponent() {
  const userStore = useStore('user');
  const user = useStoreValue(userStore); // Reactive subscription
  
  return <div>Welcome {user.name}</div>;
}
```

### `useStore(storeName)`

Hook to get a store instance by name.

**Parameters:**
- `storeName`: Key of the store from configuration

**Returns:** Store instance with methods

```typescript
function UserComponent() {
  const userStore = useStore('user');
  const settingsStore = useStore('settings');
  
  // Use store methods
  const handleUpdate = () => {
    userStore.update(current => ({ ...current, name: 'New Name' }));
  };
  
  return <button onClick={handleUpdate}>Update User</button>;
}
```

### `useStoreManager()`

Hook to get the store manager for advanced operations.

**Returns:** StoreManager instance

```typescript
function AdminPanel() {
  const storeManager = useStoreManager();
  
  const resetAllStores = () => {
    storeManager.resetAll();
  };
  
  const exportState = () => {
    const state = storeManager.exportState();
    console.log('Current state:', state);
  };
  
  return (
    <div>
      <button onClick={resetAllStores}>Reset All</button>
      <button onClick={exportState}>Export State</button>
    </div>
  );
}
```

## Store Configuration Patterns

### Simple Value Pattern

Direct value assignment for simple types:

```typescript
const simpleConfig = {
  counter: 0,
  username: '',
  isLoggedIn: false,
  theme: 'light'
};
```

### Object Pattern

Complex objects with initial state:

```typescript
const objectConfig = {
  user: {
    id: '',
    profile: {
      name: '',
      email: '',
      avatar: null as string | null
    },
    preferences: {
      notifications: true,
      theme: 'light'
    }
  }
};
```

### Validated Pattern

Stores with validation functions:

```typescript
const validatedConfig = {
  settings: {
    initialValue: { theme: 'light', fontSize: 14 },
    validator: (value) => {
      return typeof value === 'object' &&
        'theme' in value &&
        'fontSize' in value &&
        ['light', 'dark'].includes(value.theme) &&
        typeof value.fontSize === 'number' &&
        value.fontSize >= 10 && value.fontSize <= 24;
    }
  }
};
```

## Advanced Store Operations

### Conditional Updates

```typescript
function ConditionalUpdater() {
  const userStore = useStore('user');
  
  const updateIfLoggedIn = () => {
    const current = userStore.getValue();
    if (current.isAuthenticated) {
      userStore.update(user => ({
        ...user,
        lastActivity: Date.now()
      }));
    }
  };
  
  return <button onClick={updateIfLoggedIn}>Update Activity</button>;
}
```

### Computed Values

```typescript
function ComputedValues() {
  const userStore = useStore('user');
  const settingsStore = useStore('settings');
  
  const user = useStoreValue(userStore);
  const settings = useStoreValue(settingsStore);
  
  // Computed values based on multiple stores
  const displayName = user.name || user.email?.split('@')[0] || 'Anonymous';
  const isDarkTheme = settings.theme === 'dark';
  
  return (
    <div className={isDarkTheme ? 'dark' : 'light'}>
      Welcome {displayName}
    </div>
  );
}
```

### Store Synchronization

```typescript
function StoreSynchronizer() {
  const userStore = useStore('user');
  const cacheStore = useStore('cache');
  
  // Sync user changes to cache
  useEffect(() => {
    return userStore.subscribe((newUser) => {
      cacheStore.update(cache => ({
        ...cache,
        lastUser: newUser,
        lastUpdated: Date.now()
      }));
    });
  }, [userStore, cacheStore]);
  
  return null;
}
```

## Performance Optimization

### Selective Subscriptions

```typescript
function OptimizedComponent() {
  const userStore = useStore('user');
  
  // Only subscribe to specific changes
  const userName = useStoreValue(userStore, user => user.name);
  const userEmail = useStoreValue(userStore, user => user.email);
  
  // Component only re-renders when name or email changes
  return <div>{userName} ({userEmail})</div>;
}
```

### Batched Updates

```typescript
function BatchedUpdates() {
  const userStore = useStore('user');
  
  const updateUserProfile = () => {
    // Single update with all changes
    userStore.update(current => ({
      ...current,
      name: 'New Name',
      email: 'new@email.com',
      lastUpdated: Date.now()
    }));
  };
  
  return <button onClick={updateUserProfile}>Update Profile</button>;
}
```

## Error Handling

### Validation Errors

```typescript
function ValidatedStore() {
  const settingsStore = useStore('settings');
  
  const updateTheme = (theme: string) => {
    try {
      settingsStore.update(current => ({
        ...current,
        theme: theme as 'light' | 'dark'
      }));
    } catch (error) {
      console.error('Theme update failed:', error);
      // Handle validation error
    }
  };
  
  return <button onClick={() => updateTheme('dark')}>Dark Theme</button>;
}
```

---

# Action Only Pattern API

# Action Only Methods

Complete API reference for Action Only Pattern methods from `createActionContext`.

## Overview

The Action Only Pattern provides type-safe action dispatching without state management. This pattern is ideal for event systems, command patterns, business logic orchestration, and scenarios where you need action processing without local state.

## Core Methods

### `createActionContext<T>(contextName)`

Creates an action context for type-safe action dispatching and handler registration.

**Parameters:**
- `contextName`: Unique identifier for the action context

**Returns:**
```typescript
{
  Provider: React.ComponentType,
  useActionDispatch: () => ActionDispatcher<T>,
  useActionHandler: (actionName, handler, options?) => void
}
```

**Example:**
```typescript
interface AppActions extends ActionPayloadMap {
  updateUser: { id: string; name: string };
  deleteUser: { id: string };
}

const { Provider, useActionDispatch, useActionHandler } = 
  createActionContext<AppActions>('App');
```

## Action Dispatcher Methods

### `dispatch(actionName, payload)`

Dispatches an action with the specified payload to all registered handlers.

**Parameters:**
- `actionName`: Name of the action to dispatch
- `payload`: Action payload data

**Returns:** `Promise<ActionResult[]>` - Results from all handlers

```typescript
function UserComponent() {
  const dispatch = useActionDispatch();
  
  const handleUpdate = async () => {
    try {
      const results = await dispatch('updateUser', {
        id: '123',
        name: 'John Doe'
      });
      console.log('Action results:', results);
    } catch (error) {
      console.error('Action failed:', error);
    }
  };
  
  return <button onClick={handleUpdate}>Update User</button>;
}
```

### `dispatch.async(actionName, payload)`

Alias for the standard dispatch method, explicitly indicating async behavior.

**Parameters:**
- `actionName`: Name of the action to dispatch  
- `payload`: Action payload data

**Returns:** `Promise<ActionResult[]>`

```typescript
const results = await dispatch.async('processData', { data: 'example' });
```

## Handler Registration

### `useActionHandler(actionName, handler, options?)`

Registers an action handler for the specified action.

**Parameters:**
- `actionName`: Name of the action to handle
- `handler`: Handler function `(payload, controller) => Promise<any> | any`
- `options`: Optional configuration object

**Handler Function Signature:**
```typescript
type ActionHandler<TPayload> = (
  payload: TPayload,
  controller: PipelineController
) => Promise<any> | any;
```

**Options:**
```typescript
interface HandlerOptions {
  priority?: number;      // Execution priority (higher = earlier, default: 0)
  id?: string;           // Unique handler identifier
  once?: boolean;        // Execute only once then unregister
}
```

**Example:**
```typescript
function UserHandler() {
  const dispatch = useActionDispatch();
  
  useActionHandler('updateUser', useCallback(async (payload, controller) => {
    try {
      // Validate payload
      if (!payload.id) {
        controller.abort('User ID is required');
        return;
      }
      
      // Business logic
      const result = await userService.updateUser(payload.id, {
        name: payload.name
      });
      
      // Set result for other handlers
      controller.setResult({
        step: 'user-update',
        success: true,
        userId: result.id
      });
      
      return { success: true, user: result };
      
    } catch (error) {
      controller.abort(`User update failed: ${error.message}`);
    }
  }, []), { priority: 100, id: 'user-updater' });
  
  return null;
}
```

## Pipeline Controller Methods

The `controller` parameter in action handlers provides advanced pipeline control.

### `controller.abort(reason, error?)`

Aborts the action pipeline execution.

**Parameters:**
- `reason`: Reason for aborting
- `error?`: Optional error object

```typescript
useActionHandler('validateData', (payload, controller) => {
  if (!payload.data) {
    controller.abort('Data is required');
    return;
  }
  
  if (!isValid(payload.data)) {
    controller.abort('Invalid data format', new ValidationError());
    return;
  }
});
```

### `controller.modifyPayload(modifier)`

Modifies the payload for subsequent handlers in the pipeline.

**Parameters:**
- `modifier`: Function that receives current payload and returns modified payload

```typescript
useActionHandler('enrichData', (payload, controller) => {
  controller.modifyPayload(current => ({
    ...current,
    timestamp: Date.now(),
    userId: getCurrentUserId(),
    sessionId: getSessionId()
  }));
  
  return { enriched: true };
}, { priority: 100 }); // High priority to run first
```

### `controller.setResult(result)`

Sets a result that can be accessed by later handlers.

**Parameters:**
- `result`: Result object to store

```typescript
useActionHandler('processPayment', async (payload, controller) => {
  const transaction = await paymentService.process(payload);
  
  controller.setResult({
    step: 'payment',
    transactionId: transaction.id,
    amount: transaction.amount,
    success: true
  });
  
  return transaction;
}, { priority: 90 });
```

### `controller.getResults()`

Gets all results set by previous handlers.

**Returns:** Array of result objects

```typescript
useActionHandler('sendReceipt', async (payload, controller) => {
  const results = controller.getResults();
  const paymentResult = results.find(r => r.step === 'payment');
  
  if (paymentResult?.success) {
    await emailService.sendReceipt({
      transactionId: paymentResult.transactionId,
      amount: paymentResult.amount,
      email: payload.email
    });
  }
}, { priority: 80 }); // Lower priority to run after payment
```

### `controller.getPayload()`

Gets the current (possibly modified) payload.

**Returns:** Current payload object

```typescript
useActionHandler('logAction', (_, controller) => {
  const currentPayload = controller.getPayload();
  console.log('Final payload:', currentPayload);
  
  return { logged: true };
}, { priority: 10 }); // Low priority to run last
```

## Handler Patterns

### Sequential Processing

Handlers execute in priority order for sequential processing:

```typescript
function SequentialHandlers() {
  // Step 1: Validation (priority 100)
  useActionHandler('processOrder', (payload, controller) => {
    if (!validateOrder(payload)) {
      controller.abort('Invalid order');
    }
    return { step: 'validation', valid: true };
  }, { priority: 100 });
  
  // Step 2: Payment (priority 90)
  useActionHandler('processOrder', async (payload, controller) => {
    const payment = await processPayment(payload.paymentInfo);
    controller.setResult({ step: 'payment', transactionId: payment.id });
    return payment;
  }, { priority: 90 });
  
  // Step 3: Fulfillment (priority 80)
  useActionHandler('processOrder', async (payload, controller) => {
    const results = controller.getResults();
    const paymentResult = results.find(r => r.step === 'payment');
    
    if (paymentResult) {
      const order = await fulfillOrder(payload, paymentResult.transactionId);
      return { step: 'fulfillment', orderId: order.id };
    }
  }, { priority: 80 });
  
  return null;
}
```

### Parallel Processing

Multiple handlers processing the same action independently:

```typescript
function ParallelHandlers() {
  // Analytics tracking (independent)
  useActionHandler('userAction', async (payload) => {
    await analytics.track(payload.action, payload.data);
    return { provider: 'analytics', tracked: true };
  }, { id: 'analytics' });
  
  // Error monitoring (independent)
  useActionHandler('userAction', async (payload) => {
    await errorMonitor.log(payload.action, payload.context);
    return { provider: 'monitor', logged: true };
  }, { id: 'monitor' });
  
  // User feedback (independent)
  useActionHandler('userAction', (payload) => {
    showToast(`Action ${payload.action} completed`);
    return { provider: 'ui', notified: true };
  }, { id: 'ui-feedback' });
  
  return null;
}
```

### Error Recovery

Graceful error handling and recovery:

```typescript
function ErrorRecoveryHandlers() {
  // Primary handler
  useActionHandler('apiCall', async (payload, controller) => {
    try {
      const result = await primaryApi.call(payload.endpoint, payload.data);
      controller.setResult({ provider: 'primary', success: true, data: result });
      return result;
    } catch (error) {
      controller.setResult({ provider: 'primary', success: false, error });
      // Don't abort - let fallback handler try
      return { error: error.message };
    }
  }, { priority: 100, id: 'primary-api' });
  
  // Fallback handler
  useActionHandler('apiCall', async (payload, controller) => {
    const results = controller.getResults();
    const primaryFailed = results.some(r => r.provider === 'primary' && !r.success);
    
    if (primaryFailed) {
      try {
        const result = await fallbackApi.call(payload.endpoint, payload.data);
        return { success: true, data: result, fallback: true };
      } catch (error) {
        controller.abort(`All API providers failed: ${error.message}`);
      }
    }
    
    return { skipped: true, reason: 'primary-succeeded' };
  }, { priority: 90, id: 'fallback-api' });
  
  return null;
}
```

## Advanced Use Cases

### Command Pattern Implementation

```typescript
interface CommandActions extends ActionPayloadMap {
  executeCommand: {
    type: 'create' | 'update' | 'delete';
    entity: string;
    data: any;
  };
}

function CommandProcessor() {
  const dispatch = useActionDispatch();
  
  useActionHandler('executeCommand', async (payload, controller) => {
    const command = createCommand(payload.type, payload.entity, payload.data);
    
    try {
      const result = await command.execute();
      
      // Log command execution
      dispatch('trackEvent', {
        event: 'command_executed',
        data: {
          commandType: payload.type,
          entity: payload.entity,
          success: true
        }
      });
      
      return result;
    } catch (error) {
      // Log command failure
      dispatch('logError', {
        error: error.message,
        context: { command: payload },
        severity: 'high'
      });
      
      controller.abort(`Command execution failed: ${error.message}`);
    }
  }, [dispatch]);
  
  return null;
}
```

### Event Aggregation

```typescript
function EventAggregator() {
  const dispatch = useActionDispatch();
  
  useActionHandler('userInteraction', useCallback((payload, controller) => {
    // Collect interaction data
    const interactionData = {
      type: payload.type,
      element: payload.element,
      timestamp: Date.now(),
      sessionId: getSessionId()
    };
    
    // Store for batching
    addToInteractionBuffer(interactionData);
    
    // Trigger batch processing if buffer is full
    if (isBufferFull()) {
      dispatch('flushInteractions', { interactions: getBufferContents() });
      clearBuffer();
    }
    
    return { buffered: true };
  }, [dispatch]), { id: 'interaction-aggregator' });
  
  useActionHandler('flushInteractions', async (payload) => {
    await analytics.batchTrack(payload.interactions);
    return { flushed: payload.interactions.length };
  }, { id: 'interaction-flusher' });
  
  return null;
}
```

## Best Practices

### 1. Handler Organization
- Create dedicated handler components for related functionality
- Use meaningful handler IDs for debugging
- Group handlers by domain or responsibility

### 2. Priority Management
- Use high priorities (90-100) for critical setup/validation
- Use medium priorities (50-80) for business logic
- Use low priorities (10-40) for cleanup/logging

### 3. Error Handling
- Use `controller.abort()` for critical failures that should stop execution
- Return error objects for non-critical failures
- Implement fallback handlers for resilience

### 4. Performance
- Always wrap handlers with `useCallback` to prevent re-registration
- Use handler IDs to enable debugging and profiling
- Avoid complex computations in handlers - delegate to services

### 5. Testing
- Test handlers in isolation using direct action dispatch
- Mock dependencies and services
- Test error scenarios and edge cases

---

# Store Manager API

# Store Manager API

Complete API reference for the Store Manager object returned by `useStoreManager()`.

## Overview

The Store Manager provides advanced operations for managing multiple stores within a Declarative Store Pattern context. It offers bulk operations, state export/import, and administrative controls.

## Core Methods

### `storeManager.getStore(storeName)`

Gets a specific store instance by name.

**Parameters:**
- `storeName`: Key of the store from configuration

**Returns:** Store instance

```typescript
function AdminComponent() {
  const storeManager = useStoreManager();
  
  const userStore = storeManager.getStore('user');
  const settingsStore = storeManager.getStore('settings');
  
  // Use stores directly
  const currentUser = userStore.getValue();
  settingsStore.setValue({ theme: 'dark', language: 'en' });
}
```

### `storeManager.getAllStores()`

Gets all store instances as a map.

**Returns:** `Map<string, Store<any>>`

```typescript
function StoreInspector() {
  const storeManager = useStoreManager();
  
  const inspectAllStores = () => {
    const stores = storeManager.getAllStores();
    
    for (const [name, store] of stores) {
      console.log(`Store ${name}:`, store.getValue());
    }
  };
  
  return <button onClick={inspectAllStores}>Inspect Stores</button>;
}
```

### `storeManager.resetStore(storeName)`

Resets a specific store to its initial value.

**Parameters:**
- `storeName`: Key of the store to reset

**Returns:** `void`

```typescript
function ResetControls() {
  const storeManager = useStoreManager();
  
  const resetUser = () => {
    storeManager.resetStore('user');
    console.log('User store reset to initial state');
  };
  
  return <button onClick={resetUser}>Reset User</button>;
}
```

### `storeManager.resetAll()`

Resets all stores to their initial values.

**Returns:** `void`

```typescript
function GlobalReset() {
  const storeManager = useStoreManager();
  
  const resetApplication = () => {
    if (confirm('Reset all application data?')) {
      storeManager.resetAll();
      console.log('All stores reset to initial state');
    }
  };
  
  return <button onClick={resetApplication}>Reset All Data</button>;
}
```

## State Management

### `storeManager.exportState()`

Exports the current state of all stores.

**Returns:** Object with all store values

```typescript
function StateExporter() {
  const storeManager = useStoreManager();
  
  const exportToJson = () => {
    const state = storeManager.exportState();
    const json = JSON.stringify(state, null, 2);
    
    // Download as file
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'app-state.json';
    a.click();
    URL.revokeObjectURL(url);
  };
  
  return <button onClick={exportToJson}>Export State</button>;
}
```

### `storeManager.importState(state)`

Imports state data to all stores.

**Parameters:**
- `state`: Object containing store values

**Returns:** `void`

```typescript
function StateImporter() {
  const storeManager = useStoreManager();
  
  const importFromFile = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const state = JSON.parse(e.target?.result as string);
        storeManager.importState(state);
        console.log('State imported successfully');
      } catch (error) {
        console.error('Failed to import state:', error);
      }
    };
    reader.readAsText(file);
  };
  
  return (
    <div>
      <input type="file" accept=".json" onChange={importFromFile} />
      <label>Import State from JSON</label>
    </div>
  );
}
```

### `storeManager.getStoreNames()`

Gets the names of all available stores.

**Returns:** `string[]`

```typescript
function StoreList() {
  const storeManager = useStoreManager();
  
  const storeNames = storeManager.getStoreNames();
  
  return (
    <div>
      <h3>Available Stores:</h3>
      <ul>
        {storeNames.map(name => (
          <li key={name}>{name}</li>
        ))}
      </ul>
    </div>
  );
}
```

## Advanced Operations

### Bulk Store Operations

```typescript
function BulkOperations() {
  const storeManager = useStoreManager();
  
  const resetUserRelatedStores = () => {
    const userStores = ['user', 'userPreferences', 'userSettings'];
    
    userStores.forEach(storeName => {
      if (storeManager.getStoreNames().includes(storeName)) {
        storeManager.resetStore(storeName);
      }
    });
  };
  
  const exportUserData = () => {
    const fullState = storeManager.exportState();
    const userData = {
      user: fullState.user,
      userPreferences: fullState.userPreferences,
      userSettings: fullState.userSettings
    };
    
    return userData;
  };
  
  return (
    <div>
      <button onClick={resetUserRelatedStores}>Reset User Data</button>
      <button onClick={() => console.log(exportUserData())}>Export User Data</button>
    </div>
  );
}
```

### Store Validation

```typescript
function StoreValidator() {
  const storeManager = useStoreManager();
  
  const validateAllStores = () => {
    const stores = storeManager.getAllStores();
    const validation = {
      valid: true,
      errors: [] as string[]
    };
    
    for (const [name, store] of stores) {
      const value = store.getValue();
      
      // Custom validation logic
      if (!validateStoreValue(name, value)) {
        validation.valid = false;
        validation.errors.push(`Store ${name} has invalid value`);
      }
    }
    
    return validation;
  };
  
  const fixInvalidStores = () => {
    const validation = validateAllStores();
    
    if (!validation.valid) {
      console.warn('Invalid stores found:', validation.errors);
      
      // Reset invalid stores
      validation.errors.forEach(error => {
        const storeName = error.match(/Store (\w+)/)?.[1];
        if (storeName) {
          storeManager.resetStore(storeName);
        }
      });
    }
  };
  
  return (
    <div>
      <button onClick={() => console.log(validateAllStores())}>
        Validate Stores
      </button>
      <button onClick={fixInvalidStores}>
        Fix Invalid Stores
      </button>
    </div>
  );
}
```

### Store Synchronization

```typescript
function StoreSynchronizer() {
  const storeManager = useStoreManager();
  
  const syncToLocalStorage = () => {
    const state = storeManager.exportState();
    localStorage.setItem('app-state', JSON.stringify(state));
  };
  
  const syncFromLocalStorage = () => {
    try {
      const saved = localStorage.getItem('app-state');
      if (saved) {
        const state = JSON.parse(saved);
        storeManager.importState(state);
      }
    } catch (error) {
      console.error('Failed to sync from localStorage:', error);
    }
  };
  
  // Auto-sync on state changes
  useEffect(() => {
    const stores = storeManager.getAllStores();
    const unsubscribers: (() => void)[] = [];
    
    // Subscribe to all store changes
    for (const [name, store] of stores) {
      const unsubscribe = store.subscribe(() => {
        // Debounce to avoid excessive saves
        debouncedSyncToLocalStorage();
      });
      unsubscribers.push(unsubscribe);
    }
    
    return () => {
      unsubscribers.forEach(unsub => unsub());
    };
  }, []);
  
  return (
    <div>
      <button onClick={syncToLocalStorage}>Save to Local Storage</button>
      <button onClick={syncFromLocalStorage}>Load from Local Storage</button>
    </div>
  );
}
```

## Store Manager Utilities

### Store Statistics

```typescript
function StoreStatistics() {
  const storeManager = useStoreManager();
  
  const getStoreStats = () => {
    const stores = storeManager.getAllStores();
    const stats = {
      totalStores: stores.size,
      storeDetails: [] as Array<{
        name: string;
        hasValue: boolean;
        valueType: string;
        size: number;
      }>
    };
    
    for (const [name, store] of stores) {
      const value = store.getValue();
      stats.storeDetails.push({
        name,
        hasValue: value !== null && value !== undefined,
        valueType: typeof value,
        size: JSON.stringify(value).length
      });
    }
    
    return stats;
  };
  
  return (
    <div>
      <button onClick={() => console.table(getStoreStats().storeDetails)}>
        Show Store Statistics
      </button>
    </div>
  );
}
```

### Store Health Monitoring

```typescript
function StoreHealthMonitor() {
  const storeManager = useStoreManager();
  const [health, setHealth] = useState<Record<string, boolean>>({});
  
  useEffect(() => {
    const checkHealth = () => {
      const stores = storeManager.getAllStores();
      const healthStatus: Record<string, boolean> = {};
      
      for (const [name, store] of stores) {
        try {
          const value = store.getValue();
          healthStatus[name] = value !== null && value !== undefined;
        } catch (error) {
          healthStatus[name] = false;
        }
      }
      
      setHealth(healthStatus);
    };
    
    // Check health every 30 seconds
    const interval = setInterval(checkHealth, 30000);
    checkHealth(); // Initial check
    
    return () => clearInterval(interval);
  }, [storeManager]);
  
  return (
    <div className="store-health">
      <h3>Store Health Status</h3>
      {Object.entries(health).map(([storeName, isHealthy]) => (
        <div key={storeName} className={`health-item ${isHealthy ? 'healthy' : 'unhealthy'}`}>
          <span>{storeName}:</span>
          <span>{isHealthy ? '✅ Healthy' : '❌ Unhealthy'}</span>
        </div>
      ))}
    </div>
  );
}
```

## Error Handling

### Store Manager Error Recovery

```typescript
function StoreManagerErrorHandler() {
  const storeManager = useStoreManager();
  
  const handleStoreError = (storeName: string, error: Error) => {
    console.error(`Store ${storeName} error:`, error);
    
    // Try to recover by resetting the store
    try {
      storeManager.resetStore(storeName);
      console.log(`Store ${storeName} reset successfully`);
    } catch (resetError) {
      console.error(`Failed to reset store ${storeName}:`, resetError);
    }
  };
  
  const safeStoreOperation = <T>(
    operation: () => T,
    storeName: string
  ): T | null => {
    try {
      return operation();
    } catch (error) {
      handleStoreError(storeName, error as Error);
      return null;
    }
  };
  
  return { safeStoreOperation };
}
```

---

# Action Registry API

# Action Registry API

Complete API reference for the Action Registry system that manages action registration, execution, and pipeline control.

## Overview

The Action Registry is the core system that manages action handlers, executes action pipelines, and provides advanced control flow. It's the foundation of the Action Only Pattern and handles all action dispatching logic.

## Core Registry Methods

### `actionRegistry.register(actionName, handler, options?)`

Registers an action handler with the specified options.

**Parameters:**
- `actionName`: Name of the action to handle
- `handler`: Handler function
- `options`: Handler configuration options

**Returns:** Unregister function

```typescript
// Low-level registration (typically done through useActionHandler)
const unregister = actionRegistry.register('updateUser', 
  async (payload, controller) => {
    // Handler logic
    return { success: true };
  },
  { priority: 100, id: 'user-updater' }
);

// Cleanup
unregister();
```

### `actionRegistry.unregister(actionName, handlerId)`

Unregisters a specific handler for an action.

**Parameters:**
- `actionName`: Name of the action
- `handlerId`: ID of the handler to remove

**Returns:** `boolean` - Success status

```typescript
const success = actionRegistry.unregister('updateUser', 'user-updater');
console.log('Handler removed:', success);
```

### `actionRegistry.dispatch(actionName, payload)`

Dispatches an action to all registered handlers.

**Parameters:**
- `actionName`: Name of the action to dispatch
- `payload`: Action payload data

**Returns:** `Promise<ActionResult[]>`

```typescript
// Direct dispatch (typically done through useActionDispatch)
const results = await actionRegistry.dispatch('updateUser', {
  id: '123',
  name: 'John Doe'
});
```

## Handler Management

### `actionRegistry.getHandlers(actionName)`

Gets all handlers registered for a specific action.

**Parameters:**
- `actionName`: Name of the action

**Returns:** Array of handler information

```typescript
function HandlerInspector() {
  const dispatch = useActionDispatch();
  
  const inspectHandlers = () => {
    const handlers = actionRegistry.getHandlers('updateUser');
    console.log('Registered handlers:', handlers.map(h => ({
      id: h.id,
      priority: h.priority
    })));
  };
  
  return <button onClick={inspectHandlers}>Inspect Handlers</button>;
}
```

### `actionRegistry.getActionNames()`

Gets all registered action names.

**Returns:** `string[]`

```typescript
function ActionList() {
  const actionNames = actionRegistry.getActionNames();
  
  return (
    <div>
      <h3>Available Actions:</h3>
      <ul>
        {actionNames.map(name => (
          <li key={name}>{name}</li>
        ))}
      </ul>
    </div>
  );
}
```

### `actionRegistry.hasAction(actionName)`

Checks if an action has any registered handlers.

**Parameters:**
- `actionName`: Name of the action to check

**Returns:** `boolean`

```typescript
function ActionChecker() {
  const checkAction = (actionName: string) => {
    const hasHandlers = actionRegistry.hasAction(actionName);
    console.log(`Action ${actionName} ${hasHandlers ? 'has' : 'has no'} handlers`);
  };
  
  return (
    <div>
      <button onClick={() => checkAction('updateUser')}>
        Check updateUser
      </button>
    </div>
  );
}
```

## Pipeline Execution

### `actionRegistry.executePipeline(actionName, payload, options?)`

Executes the complete action pipeline with advanced options.

**Parameters:**
- `actionName`: Name of the action
- `payload`: Action payload
- `options`: Execution options

**Options:**
```typescript
interface ExecutionOptions {
  timeout?: number;           // Pipeline timeout in ms
  abortOnError?: boolean;     // Stop on first error
  collectResults?: boolean;   // Collect all handler results
  metadata?: any;            // Additional execution metadata
}
```

**Returns:** `Promise<PipelineResult>`

```typescript
// Advanced pipeline execution
const result = await actionRegistry.executePipeline('complexAction', payload, {
  timeout: 5000,
  abortOnError: false,
  collectResults: true,
  metadata: { source: 'admin-panel' }
});

console.log('Pipeline result:', result);
```

### `actionRegistry.createPipelineController(actionName, payload)`

Creates a pipeline controller for manual pipeline management.

**Parameters:**
- `actionName`: Name of the action
- `payload`: Initial payload

**Returns:** `PipelineController` instance

```typescript
// Manual pipeline control
const controller = actionRegistry.createPipelineController('updateUser', {
  id: '123',
  name: 'John'
});

// Modify payload before execution
controller.modifyPayload(current => ({
  ...current,
  timestamp: Date.now()
}));

// Execute with custom controller
const results = await actionRegistry.executeWithController(controller);
```

## Registry Statistics

### `actionRegistry.getStatistics()`

Gets registry statistics and performance metrics.

**Returns:** Registry statistics object

```typescript
function RegistryStats() {
  const getStats = () => {
    const stats = actionRegistry.getStatistics();
    console.log('Registry Statistics:', {
      totalActions: stats.totalActions,
      totalHandlers: stats.totalHandlers,
      executionCount: stats.executionCount,
      averageExecutionTime: stats.averageExecutionTime,
      errorRate: stats.errorRate
    });
  };
  
  return <button onClick={getStats}>Show Registry Stats</button>;
}
```

### `actionRegistry.getPerformanceMetrics(actionName?)`

Gets performance metrics for actions.

**Parameters:**
- `actionName?`: Optional specific action name

**Returns:** Performance metrics

```typescript
function PerformanceMonitor() {
  const showMetrics = () => {
    const allMetrics = actionRegistry.getPerformanceMetrics();
    const userMetrics = actionRegistry.getPerformanceMetrics('updateUser');
    
    console.log('All actions metrics:', allMetrics);
    console.log('updateUser metrics:', userMetrics);
  };
  
  return <button onClick={showMetrics}>Show Performance</button>;
}
```

## Advanced Handler Options

### Handler Configuration

```typescript
interface AdvancedHandlerOptions {
  priority: number;           // Execution priority (0-1000)
  id: string;                // Unique handler identifier
  once: boolean;             // Execute only once
  condition?: (payload: any) => boolean;  // Conditional execution
  timeout?: number;          // Handler timeout
  retries?: number;          // Retry attempts on failure
  retryDelay?: number;       // Delay between retries
  metadata?: any;            // Handler metadata
}
```

### Conditional Handlers

```typescript
function ConditionalHandlers() {
  // Handler only executes for admin users
  useActionHandler('adminAction', async (payload) => {
    await performAdminOperation(payload);
    return { success: true };
  }, {
    priority: 100,
    id: 'admin-handler',
    condition: (payload) => payload.userRole === 'admin'
  });
  
  // Handler with retry logic
  useActionHandler('unreliableAction', async (payload) => {
    return await unreliableService.call(payload);
  }, {
    priority: 90,
    id: 'unreliable-handler',
    retries: 3,
    retryDelay: 1000
  });
  
  return null;
}
```

## Registry Events

### `actionRegistry.onHandlerError(callback)`

Registers a callback for handler errors.

**Parameters:**
- `callback`: Error handling callback

**Returns:** Unregister function

```typescript
function GlobalErrorHandler() {
  useEffect(() => {
    const unsubscribe = actionRegistry.onHandlerError((error, context) => {
      console.error('Handler error:', error);
      console.error('Context:', context);
      
      // Send to error reporting service
      errorReporter.captureException(error, {
        extra: context,
        tags: { source: 'action-handler' }
      });
    });
    
    return unsubscribe;
  }, []);
  
  return null;
}
```

### `actionRegistry.onActionExecuted(callback)`

Registers a callback for completed action executions.

**Parameters:**
- `callback`: Execution completion callback

**Returns:** Unregister function

```typescript
function ActionAuditor() {
  useEffect(() => {
    const unsubscribe = actionRegistry.onActionExecuted((actionName, result) => {
      // Audit log
      auditLogger.log({
        action: actionName,
        timestamp: Date.now(),
        success: result.success,
        duration: result.duration,
        handlerCount: result.handlerResults.length
      });
    });
    
    return unsubscribe;
  }, []);
  
  return null;
}
```

## Registry Configuration

### Global Configuration

```typescript
// Configure registry behavior
actionRegistry.configure({
  defaultTimeout: 10000,        // Default handler timeout
  maxConcurrentActions: 10,     // Max concurrent action executions
  enableMetrics: true,          // Collect performance metrics
  enableLogging: true,          // Enable debug logging
  errorReporting: true          // Enable error reporting
});
```

### Development Tools

```typescript
function RegistryDevTools() {
  const enableDebugMode = () => {
    actionRegistry.setDebugMode(true);
    console.log('Action registry debug mode enabled');
  };
  
  const clearMetrics = () => {
    actionRegistry.clearMetrics();
    console.log('Performance metrics cleared');
  };
  
  const dumpRegistry = () => {
    const dump = actionRegistry.dumpState();
    console.log('Registry state dump:', dump);
  };
  
  return (
    <div className="dev-tools">
      <h3>Registry Dev Tools</h3>
      <button onClick={enableDebugMode}>Enable Debug</button>
      <button onClick={clearMetrics}>Clear Metrics</button>
      <button onClick={dumpRegistry}>Dump State</button>
    </div>
  );
}
```

## Testing Support

### Registry Mocking

```typescript
// Test utilities for action registry
export class MockActionRegistry {
  private handlers = new Map();
  private results = new Map();
  
  register(actionName: string, handler: Function, options?: any) {
    if (!this.handlers.has(actionName)) {
      this.handlers.set(actionName, []);
    }
    this.handlers.get(actionName).push({ handler, options });
    
    return () => this.unregister(actionName, options?.id);
  }
  
  async dispatch(actionName: string, payload: any) {
    const handlers = this.handlers.get(actionName) || [];
    const results = [];
    
    for (const { handler } of handlers) {
      try {
        const result = await handler(payload, createMockController());
        results.push(result);
      } catch (error) {
        results.push({ error: error.message });
      }
    }
    
    this.results.set(actionName, results);
    return results;
  }
  
  getLastResults(actionName: string) {
    return this.results.get(actionName) || [];
  }
}
```

### Handler Testing

```typescript
// Test individual handlers
describe('User Action Handlers', () => {
  let mockRegistry: MockActionRegistry;
  
  beforeEach(() => {
    mockRegistry = new MockActionRegistry();
  });
  
  test('updateUser handler processes payload correctly', async () => {
    const handler = (payload: any, controller: any) => {
      if (!payload.id) {
        controller.abort('ID required');
        return;
      }
      return { success: true, userId: payload.id };
    };
    
    mockRegistry.register('updateUser', handler);
    
    const results = await mockRegistry.dispatch('updateUser', {
      id: '123',
      name: 'John'
    });
    
    expect(results[0]).toEqual({ success: true, userId: '123' });
  });
});
```

## Best Practices

### 1. Handler Registration
- Use meaningful handler IDs for debugging
- Set appropriate priorities for execution order
- Always use `useCallback` to prevent re-registration

### 2. Error Management
- Implement global error handlers for monitoring
- Use registry events for centralized error handling
- Set up proper error reporting and metrics

### 3. Performance Monitoring
- Monitor registry performance metrics
- Set appropriate timeouts for handlers
- Use performance data to optimize handler priorities

### 4. Testing
- Mock the registry for unit tests
- Test handlers in isolation
- Verify error handling and edge cases

### 5. Development
- Use debug mode during development
- Monitor registry health in production
- Implement proper logging and metrics

---

# Pipeline Controller API

# Pipeline Controller API

Complete API reference for the Pipeline Controller object passed to action handlers for advanced pipeline control.

## Overview

The Pipeline Controller provides advanced control flow capabilities within action handlers. It allows handlers to modify payloads, share results, control execution flow, and coordinate with other handlers in the pipeline.

## Core Control Methods

### `controller.abort(reason, error?)`

Aborts the entire action pipeline execution.

**Parameters:**
- `reason`: Human-readable reason for aborting
- `error?`: Optional error object

**Behavior:** Stops all remaining handlers and throws PipelineAbortError

```typescript
useActionHandler('validateInput', (payload, controller) => {
  if (!payload.email || !payload.email.includes('@')) {
    controller.abort('Valid email is required');
    return;
  }
  
  if (payload.age < 18) {
    controller.abort('User must be 18 or older', new ValidationError('Age requirement'));
    return;
  }
  
  return { valid: true };
});
```

### `controller.skip(reason?)`

Skips the current handler without affecting other handlers.

**Parameters:**
- `reason?`: Optional reason for skipping

**Returns:** Special skip result

```typescript
useActionHandler('premiumFeature', (payload, controller) => {
  if (!payload.user.isPremium) {
    return controller.skip('User is not premium');
  }
  
  // Premium feature logic
  return { featureExecuted: true };
});
```

## Payload Management

### `controller.getPayload()`

Gets the current (possibly modified) payload.

**Returns:** Current payload object

```typescript
useActionHandler('logAction', (_, controller) => {
  const currentPayload = controller.getPayload();
  
  console.log('Final payload used:', currentPayload);
  auditLogger.log('action_payload', currentPayload);
  
  return { logged: true };
}, { priority: 1 }); // Low priority to run last
```

### `controller.modifyPayload(modifier)`

Modifies the payload for subsequent handlers.

**Parameters:**
- `modifier`: Function that receives current payload and returns modified payload

```typescript
useActionHandler('enrichPayload', (payload, controller) => {
  controller.modifyPayload(current => ({
    ...current,
    timestamp: Date.now(),
    sessionId: getSessionId(),
    userId: getCurrentUserId(),
    userAgent: navigator.userAgent,
    source: 'web-app'
  }));
  
  return { enriched: true };
}, { priority: 95 }); // High priority to run early
```

### `controller.setPayloadProperty(key, value)`

Sets a specific property on the payload.

**Parameters:**
- `key`: Property key to set
- `value`: Value to assign

```typescript
useActionHandler('addMetadata', (payload, controller) => {
  controller.setPayloadProperty('requestId', generateRequestId());
  controller.setPayloadProperty('timestamp', Date.now());
  
  return { metadataAdded: true };
});
```

## Result Management

### `controller.setResult(result)`

Sets a result that can be accessed by later handlers.

**Parameters:**
- `result`: Result object to store

```typescript
useActionHandler('processPayment', async (payload, controller) => {
  try {
    const transaction = await paymentService.charge({
      amount: payload.amount,
      source: payload.paymentMethod
    });
    
    controller.setResult({
      step: 'payment',
      transactionId: transaction.id,
      amount: transaction.amount,
      currency: transaction.currency,
      success: true,
      provider: 'stripe'
    });
    
    return { success: true, transactionId: transaction.id };
    
  } catch (error) {
    controller.setResult({
      step: 'payment',
      success: false,
      error: error.message,
      provider: 'stripe'
    });
    
    controller.abort(`Payment failed: ${error.message}`);
  }
}, { priority: 90, id: 'payment-processor' });
```

### `controller.getResults()`

Gets all results set by previous handlers.

**Returns:** Array of result objects

```typescript
useActionHandler('sendConfirmation', async (payload, controller) => {
  const results = controller.getResults();
  const paymentResult = results.find(r => r.step === 'payment');
  const userResult = results.find(r => r.step === 'user-update');
  
  if (paymentResult?.success && userResult?.success) {
    await emailService.sendConfirmation({
      email: payload.email,
      transactionId: paymentResult.transactionId,
      userId: userResult.userId
    });
    
    return { confirmationSent: true };
  }
  
  return { confirmationSent: false, reason: 'Prerequisites not met' };
}, { priority: 70, id: 'confirmation-sender' });
```

### `controller.getResult(predicate)`

Gets a specific result using a predicate function.

**Parameters:**
- `predicate`: Function to find the desired result

**Returns:** Matching result or undefined

```typescript
useActionHandler('processRefund', async (payload, controller) => {
  const paymentResult = controller.getResult(r => 
    r.step === 'payment' && r.provider === 'stripe'
  );
  
  if (paymentResult?.transactionId) {
    const refund = await stripeService.refund(paymentResult.transactionId);
    return { refunded: true, refundId: refund.id };
  }
  
  controller.abort('No valid payment found for refund');
}, { priority: 80 });
```

## Pipeline State Management

### `controller.setPipelineState(key, value)`

Sets pipeline-level state that persists across handlers.

**Parameters:**
- `key`: State key
- `value`: State value

```typescript
useActionHandler('initializeSession', (payload, controller) => {
  const sessionId = generateSessionId();
  const userId = payload.userId;
  
  controller.setPipelineState('sessionId', sessionId);
  controller.setPipelineState('userId', userId);
  controller.setPipelineState('startTime', Date.now());
  
  return { sessionInitialized: true, sessionId };
}, { priority: 100 });
```

### `controller.getPipelineState(key)`

Gets pipeline-level state.

**Parameters:**
- `key`: State key to retrieve

**Returns:** State value or undefined

```typescript
useActionHandler('trackDuration', (payload, controller) => {
  const startTime = controller.getPipelineState('startTime');
  const duration = Date.now() - (startTime || Date.now());
  
  controller.setResult({
    step: 'duration-tracking',
    duration,
    startTime
  });
  
  return { durationTracked: true, duration };
}, { priority: 10 }); // Low priority to run last
```

### `controller.getAllPipelineState()`

Gets all pipeline state.

**Returns:** Object with all pipeline state

```typescript
useActionHandler('pipelineSummary', (payload, controller) => {
  const allState = controller.getAllPipelineState();
  const allResults = controller.getResults();
  
  const summary = {
    pipelineState: allState,
    handlerResults: allResults,
    finalPayload: controller.getPayload(),
    executionSummary: {
      totalHandlers: allResults.length,
      successfulHandlers: allResults.filter(r => !r.error).length,
      duration: Date.now() - (allState.startTime || Date.now())
    }
  };
  
  console.log('Pipeline execution summary:', summary);
  return summary;
}, { priority: 5 }); // Very low priority to run at the end
```

## Advanced Pipeline Patterns

### Multi-Stage Processing

```typescript
function MultiStageProcessor() {
  // Stage 1: Input Processing
  useActionHandler('processOrder', (payload, controller) => {
    const processedPayload = {
      ...payload,
      orderId: generateOrderId(),
      processedAt: Date.now()
    };
    
    controller.modifyPayload(() => processedPayload);
    controller.setPipelineState('stage', 'input-processed');
    
    return { stage: 'input', success: true };
  }, { priority: 100, id: 'input-processor' });
  
  // Stage 2: Validation
  useActionHandler('processOrder', (payload, controller) => {
    const validationResult = validateOrder(payload);
    
    if (!validationResult.valid) {
      controller.abort(`Validation failed: ${validationResult.errors.join(', ')}`);
    }
    
    controller.setPipelineState('stage', 'validated');
    controller.setResult({
      step: 'validation',
      valid: true,
      checks: validationResult.checks
    });
    
    return { stage: 'validation', success: true };
  }, { priority: 90, id: 'validator' });
  
  // Stage 3: Business Logic
  useActionHandler('processOrder', async (payload, controller) => {
    const stage = controller.getPipelineState('stage');
    
    if (stage !== 'validated') {
      controller.abort('Order not properly validated');
    }
    
    const orderResult = await orderService.createOrder(payload);
    
    controller.setResult({
      step: 'order-creation',
      orderId: orderResult.id,
      amount: orderResult.amount,
      success: true
    });
    
    controller.setPipelineState('stage', 'completed');
    return orderResult;
  }, { priority: 80, id: 'order-processor' });
  
  return null;
}
```

### Conditional Pipeline Branching

```typescript
function ConditionalBranching() {
  // Route to different handlers based on payload
  useActionHandler('processPayment', (payload, controller) => {
    controller.setPipelineState('paymentMethod', payload.method);
    
    if (payload.method === 'credit_card') {
      controller.setPipelineState('processor', 'stripe');
    } else if (payload.method === 'paypal') {
      controller.setPipelineState('processor', 'paypal');
    } else {
      controller.abort(`Unsupported payment method: ${payload.method}`);
    }
    
    return { routed: true, processor: controller.getPipelineState('processor') };
  }, { priority: 100, id: 'payment-router' });
  
  // Stripe handler (conditional)
  useActionHandler('processPayment', async (payload, controller) => {
    const processor = controller.getPipelineState('processor');
    
    if (processor !== 'stripe') {
      return controller.skip('Not a Stripe payment');
    }
    
    const result = await stripeService.charge(payload);
    controller.setResult({ processor: 'stripe', ...result });
    
    return result;
  }, { priority: 80, id: 'stripe-processor' });
  
  // PayPal handler (conditional)
  useActionHandler('processPayment', async (payload, controller) => {
    const processor = controller.getPipelineState('processor');
    
    if (processor !== 'paypal') {
      return controller.skip('Not a PayPal payment');
    }
    
    const result = await paypalService.charge(payload);
    controller.setResult({ processor: 'paypal', ...result });
    
    return result;
  }, { priority: 80, id: 'paypal-processor' });
  
  return null;
}
```

## Controller State Inspection

### `controller.getExecutionContext()`

Gets information about the current execution context.

**Returns:** Execution context object

```typescript
useActionHandler('debugHandler', (payload, controller) => {
  const context = controller.getExecutionContext();
  
  console.log('Execution context:', {
    actionName: context.actionName,
    handlerId: context.currentHandlerId,
    executionId: context.executionId,
    startTime: context.startTime,
    remainingHandlers: context.remainingHandlers
  });
  
  return { debugInfo: context };
});
```

### `controller.getHandlerInfo()`

Gets information about the current handler.

**Returns:** Handler information object

```typescript
useActionHandler('selfAwareHandler', (payload, controller) => {
  const handlerInfo = controller.getHandlerInfo();
  
  console.log('Current handler:', {
    id: handlerInfo.id,
    priority: handlerInfo.priority,
    registeredAt: handlerInfo.registeredAt,
    executionCount: handlerInfo.executionCount
  });
  
  return handlerInfo;
}, { id: 'self-aware', priority: 50 });
```

## Error Handling

### Pipeline Error Recovery

```typescript
function ErrorRecoveryHandler() {
  useActionHandler('riskyOperation', async (payload, controller) => {
    try {
      const result = await riskyService.performOperation(payload);
      
      controller.setResult({
        step: 'risky-operation',
        success: true,
        data: result
      });
      
      return result;
      
    } catch (error) {
      // Log error but don't abort - let recovery handler try
      controller.setResult({
        step: 'risky-operation',
        success: false,
        error: error.message,
        needsRecovery: true
      });
      
      return { error: error.message, recovered: false };
    }
  }, { priority: 90, id: 'risky-handler' });
  
  // Recovery handler
  useActionHandler('riskyOperation', async (payload, controller) => {
    const results = controller.getResults();
    const needsRecovery = results.some(r => r.needsRecovery);
    
    if (needsRecovery) {
      try {
        const result = await fallbackService.performOperation(payload);
        
        controller.setResult({
          step: 'recovery',
          success: true,
          data: result,
          recoveredFrom: 'risky-operation'
        });
        
        return { recovered: true, data: result };
        
      } catch (error) {
        controller.abort(`Recovery failed: ${error.message}`);
      }
    }
    
    return controller.skip('No recovery needed');
  }, { priority: 80, id: 'recovery-handler' });
  
  return null;
}
```

## Advanced Pipeline Control

### Dynamic Handler Execution

```typescript
function DynamicHandler() {
  useActionHandler('dynamicAction', async (payload, controller) => {
    // Modify execution based on results
    const results = controller.getResults();
    const hasValidation = results.some(r => r.step === 'validation');
    
    if (!hasValidation) {
      // Trigger validation dynamically
      controller.modifyPayload(current => ({
        ...current,
        needsValidation: true
      }));
      
      // Set state to trigger validation in next handler
      controller.setPipelineState('requireValidation', true);
    }
    
    return { dynamicExecutionApplied: true };
  }, { priority: 85 });
  
  // Conditional validation handler
  useActionHandler('dynamicAction', (payload, controller) => {
    const needsValidation = controller.getPipelineState('requireValidation');
    
    if (needsValidation) {
      const isValid = performValidation(payload);
      
      if (!isValid) {
        controller.abort('Dynamic validation failed');
      }
      
      controller.setResult({ step: 'validation', success: true });
      return { validated: true };
    }
    
    return controller.skip('Validation not required');
  }, { priority: 80, id: 'dynamic-validator' });
  
  return null;
}
```

### Pipeline Coordination

```typescript
function PipelineCoordinator() {
  // Coordinator handler
  useActionHandler('complexWorkflow', async (payload, controller) => {
    // Check if all prerequisites are met
    const results = controller.getResults();
    const hasAuth = results.some(r => r.step === 'authentication' && r.success);
    const hasValidation = results.some(r => r.step === 'validation' && r.success);
    const hasPermission = results.some(r => r.step === 'permission' && r.success);
    
    if (!hasAuth || !hasValidation || !hasPermission) {
      const missing = [];
      if (!hasAuth) missing.push('authentication');
      if (!hasValidation) missing.push('validation');
      if (!hasPermission) missing.push('permission');
      
      controller.abort(`Missing prerequisites: ${missing.join(', ')}`);
      return;
    }
    
    // All prerequisites met, proceed with main operation
    const mainResult = await performMainOperation(payload);
    
    controller.setResult({
      step: 'main-operation',
      success: true,
      data: mainResult,
      prerequisites: { hasAuth, hasValidation, hasPermission }
    });
    
    return mainResult;
    
  }, { priority: 50, id: 'workflow-coordinator' });
  
  return null;
}
```

## Controller Configuration

### `controller.setTimeout(timeout)`

Sets a timeout for the current handler execution.

**Parameters:**
- `timeout`: Timeout in milliseconds

```typescript
useActionHandler('longRunningTask', async (payload, controller) => {
  controller.setTimeout(30000); // 30 second timeout
  
  try {
    const result = await longRunningService.process(payload);
    return { success: true, data: result };
  } catch (error) {
    if (error.name === 'TimeoutError') {
      controller.abort('Operation timed out after 30 seconds');
    } else {
      controller.abort(`Operation failed: ${error.message}`);
    }
  }
});
```

### `controller.setMetadata(metadata)`

Sets metadata for the current execution.

**Parameters:**
- `metadata`: Metadata object

```typescript
useActionHandler('trackedAction', (payload, controller) => {
  controller.setMetadata({
    handlerVersion: '1.2.0',
    environment: process.env.NODE_ENV,
    component: 'UserManager',
    feature: 'profile-update'
  });
  
  // Business logic
  return { success: true };
}, { id: 'tracked-handler' });
```

## Pipeline Debugging

### `controller.enableDebug()`

Enables debug logging for the current pipeline.

```typescript
useActionHandler('debuggableAction', (payload, controller) => {
  if (process.env.NODE_ENV === 'development') {
    controller.enableDebug();
  }
  
  controller.setResult({ step: 'debug-setup', enabled: true });
  return { debugEnabled: true };
}, { priority: 100 });
```

### `controller.log(message, data?)`

Logs debug information during pipeline execution.

**Parameters:**
- `message`: Log message
- `data?`: Optional data to log

```typescript
useActionHandler('verboseHandler', async (payload, controller) => {
  controller.log('Starting user validation');
  
  const user = await userService.getUser(payload.userId);
  controller.log('User retrieved', { userId: user.id, name: user.name });
  
  const isValid = validateUser(user);
  controller.log('Validation completed', { isValid });
  
  if (!isValid) {
    controller.log('Validation failed - aborting');
    controller.abort('User validation failed');
  }
  
  return { user, validated: true };
});
```

## Pipeline Metrics

### `controller.recordMetric(name, value)`

Records a custom metric for the current execution.

**Parameters:**
- `name`: Metric name
- `value`: Metric value

```typescript
useActionHandler('performanceTrackedAction', async (payload, controller) => {
  const startTime = performance.now();
  
  try {
    const result = await expensiveOperation(payload);
    
    const duration = performance.now() - startTime;
    controller.recordMetric('execution_time', duration);
    controller.recordMetric('payload_size', JSON.stringify(payload).length);
    controller.recordMetric('result_size', JSON.stringify(result).length);
    
    return result;
    
  } catch (error) {
    const duration = performance.now() - startTime;
    controller.recordMetric('error_time', duration);
    controller.recordMetric('error_type', error.constructor.name);
    
    controller.abort(`Operation failed after ${duration}ms: ${error.message}`);
  }
});
```

## Best Practices

### 1. Error Handling
- Use `abort()` for critical failures that should stop execution
- Use result sharing for non-critical errors
- Implement proper error recovery strategies

### 2. Payload Management
- Modify payloads early in the pipeline (high priority)
- Validate payload modifications for type safety
- Document payload structure changes

### 3. Result Coordination
- Use meaningful result structures for inter-handler communication
- Include step identifiers and success flags
- Share results that other handlers might need

### 4. Performance
- Set appropriate timeouts for long-running handlers
- Record metrics for performance monitoring
- Use pipeline state for expensive computations

### 5. Debugging
- Enable debug mode in development
- Use descriptive log messages
- Include relevant context in logs

---

# Declarative Store Pattern API

# Declarative Store Pattern API

Complete API reference for the Declarative Store Pattern implementation, the recommended approach for type-safe state management.

## Overview

The Declarative Store Pattern provides excellent type inference without manual type annotations and a simplified API focused on store management. This is the recommended pattern for most state management scenarios.

## Pattern Creation

### `createDeclarativeStorePattern(contextName, storeConfig)`

Creates a declarative store pattern with automatic type inference.

**Parameters:**
- `contextName`: Unique identifier for the store context
- `storeConfig`: Store configuration with initial values and optional validators

**Returns:**
```typescript
{
  Provider: React.ComponentType<{ children: React.ReactNode }>,
  useStore: <K extends keyof T>(storeName: K) => Store<T[K]>,
  useStoreManager: () => StoreManager<T>,
  withProvider: (Component: React.ComponentType) => React.ComponentType
}
```

**Type Inference:**
The pattern automatically infers types from the configuration:

```typescript
// Configuration with automatic type inference
const { Provider, useStore, useStoreManager, withProvider } = 
  createDeclarativeStorePattern('App', {
    // Simple values - type inferred as string
    username: '',
    
    // Complex objects - type inferred automatically
    user: {
      id: '',
      name: '',
      email: '',
      isAuthenticated: false
    },
    
    // Arrays - type inferred with proper array types
    notifications: [] as Array<{ id: string; message: string; type: 'info' | 'warning' | 'error' }>,
    
    // With validator - type preserved
    settings: {
      initialValue: { theme: 'light' as 'light' | 'dark', fontSize: 14 },
      validator: (value): value is { theme: 'light' | 'dark'; fontSize: number } => {
        return typeof value === 'object' &&
          'theme' in value &&
          'fontSize' in value &&
          ['light', 'dark'].includes(value.theme) &&
          typeof value.fontSize === 'number';
      }
    }
  });

// TypeScript automatically knows:
// - useStore('username') returns Store<string>
// - useStore('user') returns Store<{ id: string; name: string; email: string; isAuthenticated: boolean }>
// - useStore('notifications') returns Store<Array<{ id: string; message: string; type: 'info' | 'warning' | 'error' }>>
// - useStore('settings') returns Store<{ theme: 'light' | 'dark'; fontSize: number }>
```

## Store Configuration Patterns

### Simple Value Configuration

Direct value assignment for primitive types:

```typescript
const simpleConfig = {
  // String type inferred
  title: 'My App',
  
  // Number type inferred
  counter: 0,
  
  // Boolean type inferred
  isLoading: false,
  
  // Null union type inferred
  selectedItem: null as string | null,
  
  // Array type inferred with explicit typing
  items: [] as Array<{ id: string; name: string }>
};

const { useStore } = createDeclarativeStorePattern('Simple', simpleConfig);

// TypeScript knows exact types:
const titleStore = useStore('title');      // Store<string>
const counterStore = useStore('counter');  // Store<number>
const itemsStore = useStore('items');      // Store<Array<{ id: string; name: string }>>
```

### Advanced Configuration

With validators and complex objects:

```typescript
const advancedConfig = {
  // Complex object with nested structure
  userProfile: {
    personal: {
      firstName: '',
      lastName: '',
      dateOfBirth: null as Date | null
    },
    contact: {
      email: '',
      phone: '',
      address: {
        street: '',
        city: '',
        country: ''
      }
    },
    preferences: {
      notifications: true,
      theme: 'light' as 'light' | 'dark',
      language: 'en' as 'en' | 'es' | 'fr'
    }
  },
  
  // With validator for runtime validation
  appSettings: {
    initialValue: {
      maxRetries: 3,
      timeout: 5000,
      enableAnalytics: true
    },
    validator: (value): value is { maxRetries: number; timeout: number; enableAnalytics: boolean } => {
      return typeof value === 'object' &&
        typeof value.maxRetries === 'number' && value.maxRetries >= 0 &&
        typeof value.timeout === 'number' && value.timeout > 0 &&
        typeof value.enableAnalytics === 'boolean';
    }
  },
  
  // Computed initial values
  sessionInfo: {
    id: generateSessionId(),
    startTime: Date.now(),
    lastActivity: Date.now(),
    isActive: true
  }
};

const { useStore } = createDeclarativeStorePattern('Advanced', advancedConfig);
```

## Provider Pattern

### `Provider` Component

The context provider that makes stores available to child components.

```typescript
function App() {
  return (
    <Provider>
      <UserInterface />
      <DataLayer />
      <NotificationSystem />
    </Provider>
  );
}
```

### `withProvider(Component)` HOC

Higher-order component that automatically wraps a component with the provider.

**Parameters:**
- `Component`: React component to wrap

**Returns:** Wrapped component with provider

```typescript
// Manual provider wrapping
function ManualApp() {
  return (
    <Provider>
      <UserInterface />
    </Provider>
  );
}

// Automatic provider wrapping with HOC
const AutoApp = withProvider(() => (
  <UserInterface />
));

// Both approaches are equivalent
export default AutoApp;
```

## Store Type Safety

### Type Inference Examples

```typescript
const config = {
  // Primitives
  userName: 'john',           // Store<string>
  age: 25,                   // Store<number>
  isActive: true,            // Store<boolean>
  
  // Objects
  profile: {                 // Store<{ name: string; email: string }>
    name: 'John Doe',
    email: 'john@example.com'
  },
  
  // Arrays with explicit typing
  tags: [] as string[],      // Store<string[]>
  
  // Complex arrays
  items: [] as Array<{       // Store<Array<{ id: string; title: string; completed: boolean }>>
    id: string;
    title: string;
    completed: boolean;
  }>,
  
  // Union types
  status: 'idle' as 'idle' | 'loading' | 'success' | 'error',  // Store<'idle' | 'loading' | 'success' | 'error'>
  
  // Optional properties
  selectedId: null as string | null,  // Store<string | null>
  
  // Date objects
  lastUpdated: new Date(),   // Store<Date>
  
  // Generic objects
  metadata: {} as Record<string, any>  // Store<Record<string, any>>
};

function TypeSafeComponent() {
  // All these have perfect type inference
  const userNameStore = useStore('userName');        // Store<string>
  const profileStore = useStore('profile');          // Store<{ name: string; email: string }>
  const statusStore = useStore('status');            // Store<'idle' | 'loading' | 'success' | 'error'>
  
  // Values are properly typed
  const userName = useStoreValue(userNameStore);     // string
  const profile = useStoreValue(profileStore);       // { name: string; email: string }
  const status = useStoreValue(statusStore);         // 'idle' | 'loading' | 'success' | 'error'
  
  // Store methods are type-safe
  userNameStore.setValue('newName');                 // ✅ string
  // userNameStore.setValue(123);                    // ❌ TypeScript error
  
  profileStore.update(current => ({                  // ✅ Proper object structure
    ...current,
    name: 'Updated Name'
  }));
  
  statusStore.setValue('loading');                   // ✅ Valid union value
  // statusStore.setValue('invalid');               // ❌ TypeScript error
  
  return <div>Type-safe component</div>;
}
```

## Store Configuration Validation

### Runtime Validation

```typescript
const validatedConfig = {
  userSettings: {
    initialValue: {
      theme: 'light' as 'light' | 'dark',
      fontSize: 14,
      notifications: true
    },
    validator: (value): value is { theme: 'light' | 'dark'; fontSize: number; notifications: boolean } => {
      return typeof value === 'object' &&
        value !== null &&
        'theme' in value &&
        'fontSize' in value &&
        'notifications' in value &&
        ['light', 'dark'].includes(value.theme) &&
        typeof value.fontSize === 'number' &&
        value.fontSize >= 8 && value.fontSize <= 32 &&
        typeof value.notifications === 'boolean';
    }
  },
  
  apiConfiguration: {
    initialValue: {
      baseUrl: 'https://api.example.com',
      timeout: 5000,
      retries: 3
    },
    validator: (value): value is { baseUrl: string; timeout: number; retries: number } => {
      return typeof value === 'object' &&
        value !== null &&
        'baseUrl' in value &&
        'timeout' in value &&
        'retries' in value &&
        typeof value.baseUrl === 'string' &&
        value.baseUrl.startsWith('https://') &&
        typeof value.timeout === 'number' &&
        value.timeout > 0 &&
        typeof value.retries === 'number' &&
        value.retries >= 0;
    }
  }
};

function ValidatedStoreUsage() {
  const settingsStore = useStore('userSettings');
  
  const updateTheme = (newTheme: 'light' | 'dark') => {
    try {
      settingsStore.update(current => ({
        ...current,
        theme: newTheme
      }));
      console.log('Theme updated successfully');
    } catch (error) {
      console.error('Theme update failed validation:', error);
      // Handle validation error
    }
  };
  
  return <button onClick={() => updateTheme('dark')}>Dark Theme</button>;
}
```

## Advanced Store Patterns

### Computed Store Values

```typescript
function ComputedValues() {
  const userStore = useStore('user');
  const settingsStore = useStore('settings');
  
  const user = useStoreValue(userStore);
  const settings = useStoreValue(settingsStore);
  
  // Computed values with proper typing
  const displayName = useMemo(() => {
    return user.name || user.email?.split('@')[0] || 'Anonymous';
  }, [user.name, user.email]);
  
  const themeClass = useMemo(() => {
    return `theme-${settings.theme}`;
  }, [settings.theme]);
  
  const userStatus = useMemo(() => {
    if (!user.isAuthenticated) return 'guest';
    if (user.isAdmin) return 'admin';
    return 'user';
  }, [user.isAuthenticated, user.isAdmin]);
  
  return (
    <div className={themeClass}>
      <span>Welcome {displayName} ({userStatus})</span>
    </div>
  );
}
```

### Store Relationships

```typescript
function RelatedStores() {
  const userStore = useStore('user');
  const preferencesStore = useStore('preferences');
  const cacheStore = useStore('cache');
  
  // Sync user changes to preferences
  useEffect(() => {
    return userStore.subscribe((newUser, previousUser) => {
      if (newUser.id !== previousUser?.id) {
        // User changed - load their preferences
        preferencesStore.setValue({
          theme: newUser.preferredTheme || 'light',
          language: newUser.language || 'en',
          notifications: newUser.notificationsEnabled ?? true
        });
      }
    });
  }, [userStore, preferencesStore]);
  
  // Cache user data
  useEffect(() => {
    return userStore.subscribe((newUser) => {
      cacheStore.update(cache => ({
        ...cache,
        lastUser: newUser,
        lastUserUpdate: Date.now()
      }));
    });
  }, [userStore, cacheStore]);
  
  return null;
}
```

### Store Persistence

```typescript
function PersistentStores() {
  const storeManager = useStoreManager();
  
  // Save to localStorage on changes
  useEffect(() => {
    const persistentStores = ['user', 'settings', 'preferences'];
    const unsubscribers: (() => void)[] = [];
    
    persistentStores.forEach(storeName => {
      const store = storeManager.getStore(storeName);
      
      const unsubscribe = store.subscribe((newValue) => {
        try {
          localStorage.setItem(`store_${storeName}`, JSON.stringify(newValue));
        } catch (error) {
          console.error(`Failed to persist store ${storeName}:`, error);
        }
      });
      
      unsubscribers.push(unsubscribe);
    });
    
    return () => {
      unsubscribers.forEach(unsub => unsub());
    };
  }, [storeManager]);
  
  // Load from localStorage on mount
  useEffect(() => {
    const persistentStores = ['user', 'settings', 'preferences'];
    
    persistentStores.forEach(storeName => {
      try {
        const saved = localStorage.getItem(`store_${storeName}`);
        if (saved) {
          const value = JSON.parse(saved);
          const store = storeManager.getStore(storeName);
          store.setValue(value);
        }
      } catch (error) {
        console.error(`Failed to load store ${storeName}:`, error);
      }
    });
  }, [storeManager]);
  
  return null;
}
```

## React Integration Patterns

### Component Pattern Integration

```typescript
// Define store configuration
const appStoreConfig = {
  todos: [] as Array<{
    id: string;
    text: string;
    completed: boolean;
    createdAt: Date;
  }>,
  
  filter: 'all' as 'all' | 'active' | 'completed',
  
  ui: {
    loading: false,
    error: null as string | null,
    editingId: null as string | null
  }
};

const {
  Provider: TodoStoreProvider,
  useStore: useTodoStore,
  useStoreManager: useTodoStoreManager,
  withProvider: withTodoStoreProvider
} = createDeclarativeStorePattern('TodoApp', appStoreConfig);

// Component using the pattern
const TodoApp = withTodoStoreProvider(() => {
  return (
    <div className="todo-app">
      <TodoHeader />
      <TodoList />
      <TodoFooter />
    </div>
  );
});

function TodoList() {
  const todosStore = useTodoStore('todos');
  const filterStore = useTodoStore('filter');
  const uiStore = useTodoStore('ui');
  
  const todos = useStoreValue(todosStore);
  const filter = useStoreValue(filterStore);
  const ui = useStoreValue(uiStore);
  
  // Filtered todos with proper typing
  const filteredTodos = useMemo(() => {
    switch (filter) {
      case 'active': return todos.filter(todo => !todo.completed);
      case 'completed': return todos.filter(todo => todo.completed);
      default: return todos;
    }
  }, [todos, filter]);
  
  const addTodo = (text: string) => {
    todosStore.update(current => [...current, {
      id: generateId(),
      text,
      completed: false,
      createdAt: new Date()
    }]);
  };
  
  const toggleTodo = (id: string) => {
    todosStore.update(current => 
      current.map(todo => 
        todo.id === id 
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    );
  };
  
  const removeTodo = (id: string) => {
    todosStore.update(current => current.filter(todo => todo.id !== id));
  };
  
  return (
    <div className="todo-list">
      {filteredTodos.map(todo => (
        <TodoItem 
          key={todo.id}
          todo={todo}
          onToggle={() => toggleTodo(todo.id)}
          onRemove={() => removeTodo(todo.id)}
        />
      ))}
    </div>
  );
}
```

### Store Manager Integration

```typescript
function TodoManager() {
  const storeManager = useTodoStoreManager();
  
  const exportTodos = () => {
    const state = storeManager.exportState();
    const todoData = {
      todos: state.todos,
      filter: state.filter,
      exportedAt: new Date().toISOString()
    };
    
    const json = JSON.stringify(todoData, null, 2);
    downloadAsFile(json, 'todos.json');
  };
  
  const importTodos = (file: File) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target?.result as string);
        
        if (data.todos && Array.isArray(data.todos)) {
          const todosStore = storeManager.getStore('todos');
          todosStore.setValue(data.todos);
          
          if (data.filter) {
            const filterStore = storeManager.getStore('filter');
            filterStore.setValue(data.filter);
          }
        }
      } catch (error) {
        console.error('Import failed:', error);
      }
    };
    reader.readAsText(file);
  };
  
  const clearAllData = () => {
    if (confirm('Clear all todos?')) {
      storeManager.resetAll();
    }
  };
  
  return (
    <div className="todo-manager">
      <button onClick={exportTodos}>Export Todos</button>
      <input 
        type="file" 
        accept=".json" 
        onChange={(e) => e.target.files?.[0] && importTodos(e.target.files[0])} 
      />
      <button onClick={clearAllData}>Clear All</button>
    </div>
  );
}
```

## Performance Optimization

### Selective Re-rendering

```typescript
function OptimizedComponent() {
  const userStore = useStore('user');
  
  // Only re-render when name changes
  const userName = useStoreValue(userStore, user => user.name);
  
  // Only re-render when authentication status changes
  const isAuthenticated = useStoreValue(userStore, user => user.isAuthenticated);
  
  // Memoized expensive computation
  const expensiveValue = useMemo(() => {
    return computeExpensiveValue(userName);
  }, [userName]);
  
  return (
    <div>
      {isAuthenticated ? (
        <span>Welcome {userName}</span>
      ) : (
        <span>Please log in</span>
      )}
      <div>Computed: {expensiveValue}</div>
    </div>
  );
}
```

### Batched Updates

```typescript
function BatchedUpdater() {
  const userStore = useStore('user');
  const settingsStore = useStore('settings');
  const uiStore = useStore('ui');
  
  const updateUserProfile = (profileData: any) => {
    // Batch multiple store updates
    const updates = [
      () => userStore.update(current => ({
        ...current,
        ...profileData,
        lastUpdated: Date.now()
      })),
      () => settingsStore.update(current => ({
        ...current,
        lastProfileUpdate: Date.now()
      })),
      () => uiStore.update(current => ({
        ...current,
        notification: {
          message: 'Profile updated successfully',
          type: 'success' as const
        }
      }))
    ];
    
    // Execute all updates
    updates.forEach(update => update());
  };
  
  return (
    <button onClick={() => updateUserProfile({ name: 'New Name' })}>
      Update Profile
    </button>
  );
}
```

## Advanced Type Patterns

### Conditional Store Types

```typescript
// Configuration with conditional types
const conditionalConfig = {
  // Different shapes based on user type
  userData: null as {
    type: 'guest';
    sessionId: string;
  } | {
    type: 'user';
    id: string;
    name: string;
    email: string;
  } | {
    type: 'admin';
    id: string;
    name: string;
    email: string;
    permissions: string[];
  } | null,
  
  // State machines with type safety
  requestState: {
    status: 'idle',
    data: null,
    error: null
  } as 
    | { status: 'idle'; data: null; error: null }
    | { status: 'loading'; data: null; error: null }
    | { status: 'success'; data: any; error: null }
    | { status: 'error'; data: null; error: string }
};

function ConditionalComponent() {
  const userDataStore = useStore('userData');
  const requestStore = useStore('requestState');
  
  const userData = useStoreValue(userDataStore);
  const requestState = useStoreValue(requestStore);
  
  // Type-safe conditional rendering
  if (userData?.type === 'admin') {
    // TypeScript knows userData has permissions property
    return <AdminPanel permissions={userData.permissions} />;
  }
  
  if (userData?.type === 'user') {
    // TypeScript knows userData has user properties
    return <UserPanel user={userData} />;
  }
  
  // Handle request states
  switch (requestState.status) {
    case 'loading':
      return <LoadingSpinner />;
    case 'success':
      // TypeScript knows data is available
      return <SuccessView data={requestState.data} />;
    case 'error':
      // TypeScript knows error is available
      return <ErrorView error={requestState.error} />;
    default:
      return <IdleView />;
  }
}
```

### Generic Store Configuration

```typescript
// Generic configuration helper
function createTypedStoreConfig<T extends Record<string, any>>(config: T) {
  return config;
}

// Usage with perfect type inference
const typedConfig = createTypedStoreConfig({
  products: [] as Array<{
    id: string;
    name: string;
    price: number;
    category: string;
  }>,
  
  cart: {
    items: [] as Array<{
      productId: string;
      quantity: number;
      addedAt: Date;
    }>,
    total: 0,
    currency: 'USD' as const
  },
  
  checkout: {
    step: 1 as 1 | 2 | 3 | 4,
    isProcessing: false,
    paymentMethod: null as 'card' | 'paypal' | null
  }
});

const { useStore, withProvider } = createDeclarativeStorePattern('Shop', typedConfig);
```

## Integration with External Systems

### Redux DevTools Integration

```typescript
function DevToolsIntegration() {
  const storeManager = useStoreManager();
  
  useEffect(() => {
    if (typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__) {
      const devTools = window.__REDUX_DEVTOOLS_EXTENSION__.connect({
        name: 'Context-Action Stores'
      });
      
      // Send initial state
      devTools.init(storeManager.exportState());
      
      // Subscribe to all store changes
      const stores = storeManager.getAllStores();
      const unsubscribers: (() => void)[] = [];
      
      for (const [storeName, store] of stores) {
        const unsubscribe = store.subscribe((newValue, previousValue) => {
          devTools.send(
            { type: `UPDATE_${storeName.toUpperCase()}`, payload: newValue },
            storeManager.exportState()
          );
        });
        
        unsubscribers.push(unsubscribe);
      }
      
      return () => {
        unsubscribers.forEach(unsub => unsub());
        devTools.disconnect();
      };
    }
  }, [storeManager]);
  
  return null;
}
```

## Best Practices

### 1. Configuration Design
- Use explicit type annotations for complex types
- Provide validators for runtime safety
- Use meaningful store names that reflect their purpose

### 2. Type Safety
- Leverage TypeScript's type inference
- Use union types for state machines
- Implement proper validation for user inputs

### 3. Performance
- Use selective subscriptions with selectors
- Batch related updates together
- Implement proper memoization for computed values

### 4. Integration
- Use the HOC pattern for clean provider wrapping
- Implement proper persistence strategies
- Consider DevTools integration for debugging

### 5. Testing
- Test store configurations with various data shapes
- Validate that validators work correctly
- Test persistence and restoration logic

---

# Basic Setup Example

// src/types/actions.ts
import type { ActionPayloadMap } from '@context-action/core';

export interface AppActions extends ActionPayloadMap {
  // User actions
  updateProfile: { name: string; email: string };
  login: { username: string; password: string };
  logout: void;
  
  // Event tracking
  trackEvent: { event: string; data: any };
  logError: { error: string; context: any };
  
  // UI actions
  showNotification: { message: string; type: 'success' | 'error' | 'info' };
  hideNotification: void;
}

---

// src/contexts/actions.tsx
import { createActionContext } from '@context-action/react';
import type { AppActions } from '../types/actions';

export const {
  Provider: AppActionProvider,
  useActionDispatch: useAppAction,
  useActionHandler: useAppActionHandler
} = createActionContext<AppActions>('App');

---

// src/contexts/stores.tsx
import { createDeclarativeStorePattern } from '@context-action/react';

export const {
  Provider: AppStoreProvider,
  useStore: useAppStore,
  useStoreManager: useAppStoreManager,
  withProvider: withAppStoreProvider
} = createDeclarativeStorePattern('App', {
  // User state
  user: {
    id: '',
    name: '',
    email: '',
    isAuthenticated: false
  },
  
  // UI state
  ui: {
    loading: false,
    notification: null as { message: string; type: 'success' | 'error' | 'info' } | null
  },
  
  // Application settings
  settings: {
    initialValue: { theme: 'light', language: 'en' },
    validator: (value) => 
      typeof value === 'object' && 
      'theme' in value && 
      'language' in value
  }
});

---

// src/components/App.tsx
import React from 'react';
import { AppActionProvider } from '../contexts/actions';
import { withAppStoreProvider } from '../contexts/stores';
import { UserProfile } from './UserProfile';
import { EventLogger } from './EventLogger';

// Use HOC pattern to automatically wrap with store provider
const App = withAppStoreProvider(() => (
  <AppActionProvider>
    <div className="app">
      <header>
        <h1>Context-Action Example</h1>
      </header>
      
      <main>
        <UserProfile />
        <EventLogger />
      </main>
    </div>
  </AppActionProvider>
));

export default App;

---

// src/components/UserProfile.tsx
import React, { useCallback } from 'react';
import { useStoreValue } from '@context-action/react';
import { useAppAction, useAppActionHandler } from '../contexts/actions';
import { useAppStore } from '../contexts/stores';

export function UserProfile() {
  const dispatch = useAppAction();
  const userStore = useAppStore('user');
  const uiStore = useAppStore('ui');
  
  // Subscribe to store values
  const user = useStoreValue(userStore);
  const ui = useStoreValue(uiStore);
  
  // Register action handlers
  useAppActionHandler('updateProfile', useCallback(async (payload, controller) => {
    try {
      // Set loading state
      uiStore.update(current => ({ ...current, loading: true }));
      
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Update user store
      userStore.update(current => ({
        ...current,
        name: payload.name,
        email: payload.email
      }));
      
      // Show success notification
      dispatch('showNotification', {
        message: 'Profile updated successfully!',
        type: 'success'
      });
      
    } catch (error) {
      // Handle error
      dispatch('logError', {
        error: (error as Error).message,
        context: { component: 'UserProfile', action: 'updateProfile' }
      });
      
      controller.abort('Profile update failed');
    } finally {
      // Clear loading state
      uiStore.update(current => ({ ...current, loading: false }));
    }
  }, [dispatch, userStore, uiStore]));
  
  // Login handler
  useAppActionHandler('login', useCallback(async (payload) => {
    uiStore.update(current => ({ ...current, loading: true }));
    
    try {
      // Simulate login API call
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      // Update user state
      userStore.setValue({
        id: '123',
        name: 'John Doe',
        email: payload.username + '@example.com',
        isAuthenticated: true
      });
      
      dispatch('trackEvent', {
        event: 'user_login',
        data: { username: payload.username, timestamp: Date.now() }
      });
      
    } catch (error) {
      dispatch('showNotification', {
        message: 'Login failed. Please try again.',
        type: 'error'
      });
    } finally {
      uiStore.update(current => ({ ...current, loading: false }));
    }
  }, [dispatch, userStore, uiStore]));
  
  // Notification handler
  useAppActionHandler('showNotification', useCallback((payload) => {
    uiStore.update(current => ({
      ...current,
      notification: { message: payload.message, type: payload.type }
    }));
    
    // Auto-hide notification after 3 seconds
    setTimeout(() => {
      dispatch('hideNotification');
    }, 3000);
  }, [dispatch, uiStore]));
  
  useAppActionHandler('hideNotification', useCallback(() => {
    uiStore.update(current => ({ ...current, notification: null }));
  }, [uiStore]));
  
  // Event handlers
  const handleUpdateProfile = () => {
    dispatch('updateProfile', {
      name: 'John Doe Updated',
      email: 'john.updated@example.com'
    });
  };
  
  const handleLogin = () => {
    dispatch('login', {
      username: 'john.doe',
      password: 'secret123'
    });
  };
  
  const handleLogout = () => {
    userStore.setValue({
      id: '',
      name: '',
      email: '',
      isAuthenticated: false
    });
    
    dispatch('trackEvent', {
      event: 'user_logout',
      data: { timestamp: Date.now() }
    });
  };
  
  return (
    <div className="user-profile">
      <h2>User Profile</h2>
      
      {/* Loading indicator */}
      {ui.loading && <div className="loading">Loading...</div>}
      
      {/* Notification */}
      {ui.notification && (
        <div className={`notification notification--${ui.notification.type}`}>
          {ui.notification.message}
        </div>
      )}
      
      {/* User info */}
      {user.isAuthenticated ? (
        <div className="user-info">
          <p><strong>ID:</strong> {user.id}</p>
          <p><strong>Name:</strong> {user.name}</p>
          <p><strong>Email:</strong> {user.email}</p>
          
          <div className="actions">
            <button onClick={handleUpdateProfile} disabled={ui.loading}>
              Update Profile
            </button>
            <button onClick={handleLogout}>
              Logout
            </button>
          </div>
        </div>
      ) : (
        <div className="login-form">
          <p>Please log in to continue</p>
          <button onClick={handleLogin} disabled={ui.loading}>
            Login as John Doe
          </button>
        </div>
      )}
    </div>
  );
}

---

// src/components/EventLogger.tsx
import React, { useCallback, useState } from 'react';
import { useAppActionHandler } from '../contexts/actions';

export function EventLogger() {
  const [events, setEvents] = useState<Array<{ event: string; data: any; timestamp: number }>>([]);
  const [errors, setErrors] = useState<Array<{ error: string; context: any; timestamp: number }>>([]);
  
  // Register event tracking handler
  useAppActionHandler('trackEvent', useCallback((payload) => {
    const eventLog = {
      event: payload.event,
      data: payload.data,
      timestamp: Date.now()
    };
    
    setEvents(current => [...current, eventLog]);
    console.log('Event tracked:', eventLog);
    
    // In a real app, send to analytics service
    // analytics.track(payload.event, payload.data);
  }, []));
  
  // Register error logging handler
  useAppActionHandler('logError', useCallback((payload) => {
    const errorLog = {
      error: payload.error,
      context: payload.context,
      timestamp: Date.now()
    };
    
    setErrors(current => [...current, errorLog]);
    console.error('Error logged:', errorLog);
    
    // In a real app, send to error reporting service
    // errorReporter.captureException(payload.error, payload.context);
  }, []));
  
  return (
    <div className="event-logger">
      <h2>Event Logger</h2>
      
      {/* Recent Events */}
      <div className="events-section">
        <h3>Recent Events ({events.length})</h3>
        <div className="log-container">
          {events.slice(-5).reverse().map((event, index) => (
            <div key={index} className="log-entry log-entry--event">
              <div className="log-time">
                {new Date(event.timestamp).toLocaleTimeString()}
              </div>
              <div className="log-content">
                <strong>{event.event}</strong>
                <pre>{JSON.stringify(event.data, null, 2)}</pre>
              </div>
            </div>
          ))}
        </div>
      </div>
      
      {/* Recent Errors */}
      <div className="errors-section">
        <h3>Recent Errors ({errors.length})</h3>
        <div className="log-container">
          {errors.slice(-3).reverse().map((error, index) => (
            <div key={index} className="log-entry log-entry--error">
              <div className="log-time">
                {new Date(error.timestamp).toLocaleTimeString()}
              </div>
              <div className="log-content">
                <strong>Error:</strong> {error.error}
                <pre>{JSON.stringify(error.context, null, 2)}</pre>
              </div>
            </div>
          ))}
        </div>
      </div>
      
      {/* Clear buttons */}
      <div className="actions">
        <button onClick={() => setEvents([])}>
          Clear Events
        </button>
        <button onClick={() => setErrors([])}>
          Clear Errors
        </button>
      </div>
    </div>
  );
}

---



---

## Development Commands

### Essential Commands
```bash
# Setup
pnpm install                # Install dependencies
pnpm build                  # Build all packages

# Development
pnpm dev                    # Example app dev server
pnpm test                   # Run tests
pnpm lint                   # ESLint check
pnpm type-check             # TypeScript compilation

# Package-specific
pnpm build:core             # Build core package
pnpm build:react            # Build React package
pnpm test:core              # Test core package

# Documentation
pnpm docs:dev               # VitePress dev server
pnpm docs:build             # Build documentation
pnpm docs:api               # Generate API docs
```

### Version Management
```bash
pnpm version:patch          # Patch version bump
pnpm version:minor          # Minor version bump
pnpm version:major          # Major version bump
pnpm release                # Publish changed packages
```

## Quick Implementation Checklist

### For Action Only Pattern:
- [ ] Define action interface extending `ActionPayloadMap`
- [ ] Use `createActionContext<T>()` with domain-specific renaming
- [ ] Register handlers with `useCallback` and proper options
- [ ] Implement error handling with `controller.abort()` or result sharing
- [ ] Use appropriate priorities for execution order

### For Store Only Pattern:
- [ ] Design store configuration with type inference
- [ ] Use `createDeclarativeStorePattern()` with domain-specific renaming
- [ ] Subscribe reactively with `useStoreValue()`
- [ ] Use store methods (`setValue`, `update`) appropriately
- [ ] Implement validation for complex store types

### For Pattern Composition:
- [ ] Separate concerns: actions for logic, stores for state
- [ ] Use proper provider hierarchy
- [ ] Implement Store Integration 3-Step Process in handlers
- [ ] Consider using HOC pattern for cleaner provider wrapping

---

This guide provides comprehensive information for LLMs to understand and effectively work with the Context-Action framework, covering all essential patterns, APIs, conventions, and best practices.

Generated automatically from documentation sources. Do not edit directly.
