import React, { useState, useCallback, useRef, useEffect } from 'react';
import { ActionRegister, ActionPayloadMap } from '@context-action/react';

// Action Guard Ïï°ÏÖò Îßµ
interface ActionGuardMap extends ActionPayloadMap {
  searchInput: string;
  scrollEvent: { scrollTop: number };
  apiCall: { endpoint: string };
  buttonClick: { buttonId: string };
  formSubmit: { formData: any };
  mouseMove: { x: number; y: number };
  resize: { width: number; height: number };
}

// ÎîîÎ∞îÏö¥Ïä§ ÌõÖ
function useDebounce<T extends any[]>(callback: (...args: T) => void, delay: number) {
  const timeoutRef = useRef<NodeJS.Timeout>();
  
  return useCallback((...args: T) => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    timeoutRef.current = setTimeout(() => {
      callback(...args);
    }, delay);
  }, [callback, delay]);
}

// Ïä§Î°úÌãÄ ÌõÖ
function useThrottle<T extends any[]>(callback: (...args: T) => void, delay: number) {
  const lastCallRef = useRef<number>(0);
  const timeoutRef = useRef<NodeJS.Timeout>();
  
  return useCallback((...args: T) => {
    const now = Date.now();
    const timeSinceLastCall = now - lastCallRef.current;
    
    if (timeSinceLastCall >= delay) {
      lastCallRef.current = now;
      callback(...args);
    } else {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      timeoutRef.current = setTimeout(() => {
        lastCallRef.current = Date.now();
        callback(...args);
      }, delay - timeSinceLastCall);
    }
  }, [callback, delay]);
}

// Î∏îÎ°úÌÇπ ÌõÖ
function useActionBlock(duration: number = 1000) {
  const [isBlocked, setIsBlocked] = useState(false);
  const [lastAction, setLastAction] = useState<string>('');
  
  const blockAction = useCallback((actionName: string) => {
    if (isBlocked) {
      return false;
    }
    
    setIsBlocked(true);
    setLastAction(actionName);
    setTimeout(() => {
      setIsBlocked(false);
      setLastAction('');
    }, duration);
    
    return true;
  }, [isBlocked, duration]);
  
  return { isBlocked, lastAction, blockAction };
}

// Í≤ÄÏÉâ Îç∞Î™®
function SearchDemo() {
  const [searchTerm, setSearchTerm] = useState('');
  const [searchResults, setSearchResults] = useState<string[]>([]);
  const [searchCount, setSearchCount] = useState(0);
  const [actionRegister] = useState(() => new ActionRegister<ActionGuardMap>());
  
  // Ïã§Ï†ú Í≤ÄÏÉâ Ìï®Ïàò (Î™®Ïùò)
  const performSearch = useCallback((term: string) => {
    setSearchCount(prev => prev + 1);
    // Î™®Ïùò Í≤ÄÏÉâ Í≤∞Í≥º
    const mockResults = term
      ? [`Result 1 for "${term}"`, `Result 2 for "${term}"`, `Result 3 for "${term}"`]
      : [];
    setSearchResults(mockResults);
  }, []);
  
  // ÎîîÎ∞îÏö¥Ïä§Îêú Í≤ÄÏÉâ
  const debouncedSearch = useDebounce(performSearch, 500);
  
  useEffect(() => {
    const unsubscribe = actionRegister.register('searchInput', (term, controller) => {
      debouncedSearch(term);
      controller.next();
    });
    
    return unsubscribe;
  }, [actionRegister, debouncedSearch]);
  
  const handleSearchChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setSearchTerm(value);
    actionRegister.dispatch('searchInput', value);
  }, [actionRegister]);
  
  return (
    <div className="demo-card">
      <h3>Search with Debouncing</h3>
      <p>Search input is debounced by 500ms to prevent excessive API calls.</p>
      
      <div className="search-demo">
        <input
          type="text"
          value={searchTerm}
          onChange={handleSearchChange}
          placeholder="Type to search..."
          className="text-input"
        />
        
        <div className="search-stats">
          <span>Search calls: {searchCount}</span>
        </div>
        
        <div className="search-results">
          {searchResults.map((result, index) => (
            <div key={index} className="search-result">
              {result}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

// Ïä§ÌÅ¨Î°§ Îç∞Î™®
function ScrollDemo() {
  const [scrollEvents, setScrollEvents] = useState(0);
  const [throttledEvents, setThrottledEvents] = useState(0);
  const [scrollPosition, setScrollPosition] = useState(0);
  const [actionRegister] = useState(() => new ActionRegister<ActionGuardMap>());
  
  const handleScrollEvent = useCallback((scrollTop: number) => {
    setThrottledEvents(prev => prev + 1);
    setScrollPosition(scrollTop);
  }, []);
  
  const throttledScrollHandler = useThrottle(handleScrollEvent, 100);
  
  useEffect(() => {
    const unsubscribe = actionRegister.register('scrollEvent', ({ scrollTop }, controller) => {
      throttledScrollHandler(scrollTop);
      controller.next();
    });
    
    return unsubscribe;
  }, [actionRegister, throttledScrollHandler]);
  
  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
    const scrollTop = e.currentTarget.scrollTop;
    setScrollEvents(prev => prev + 1);
    actionRegister.dispatch('scrollEvent', { scrollTop });
  }, [actionRegister]);
  
  return (
    <div className="demo-card">
      <h3>Scroll with Throttling</h3>
      <p>Scroll events are throttled to fire at most once every 100ms.</p>
      
      <div className="scroll-stats">
        <div>Raw scroll events: {scrollEvents}</div>
        <div>Throttled events: {throttledEvents}</div>
        <div>Scroll position: {scrollPosition}px</div>
      </div>
      
      <div className="scroll-container" onScroll={handleScroll}>
        <div className="scroll-content">
          {Array.from({ length: 50 }, (_, i) => (
            <div key={i} className="scroll-item">
              Scroll item {i + 1}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

// API Ìò∏Ï∂ú Î∏îÎ°úÌÇπ Îç∞Î™®
function ApiBlockingDemo() {
  const [apiCalls, setApiCalls] = useState<Array<{ endpoint: string; timestamp: string }>>([]);
  const { isBlocked, lastAction, blockAction } = useActionBlock(2000);
  const [actionRegister] = useState(() => new ActionRegister<ActionGuardMap>());
  
  useEffect(() => {
    const unsubscribe = actionRegister.register('apiCall', ({ endpoint }, controller) => {
      if (!blockAction(`API: ${endpoint}`)) {
        controller.abort('API call blocked - too frequent');
        return;
      }
      
      // Î™®Ïùò API Ìò∏Ï∂ú
      setApiCalls(prev => [...prev, {
        endpoint,
        timestamp: new Date().toLocaleTimeString()
      }]);
      
      controller.next();
    });
    
    return unsubscribe;
  }, [actionRegister, blockAction]);
  
  const handleApiCall = useCallback((endpoint: string) => {
    actionRegister.dispatch('apiCall', { endpoint });
  }, [actionRegister]);
  
  return (
    <div className="demo-card">
      <h3>API Call Blocking</h3>
      <p>API calls are blocked for 2 seconds after each successful call.</p>
      
      <div className="api-controls">
        <button 
          onClick={() => handleApiCall('/users')} 
          className={`btn ${isBlocked ? 'btn-secondary' : 'btn-primary'}`}
          disabled={isBlocked}
        >
          Call /users API
        </button>
        <button 
          onClick={() => handleApiCall('/posts')} 
          className={`btn ${isBlocked ? 'btn-secondary' : 'btn-primary'}`}
          disabled={isBlocked}
        >
          Call /posts API
        </button>
        <button 
          onClick={() => handleApiCall('/comments')} 
          className={`btn ${isBlocked ? 'btn-secondary' : 'btn-primary'}`}
          disabled={isBlocked}
        >
          Call /comments API
        </button>
      </div>
      
      {isBlocked && (
        <div className="blocking-status">
          üö´ Blocked: {lastAction} (cooling down...)
        </div>
      )}
      
      <div className="api-log">
        <h4>API Call Log:</h4>
        {apiCalls.length === 0 ? (
          <div className="log-empty">No API calls made yet</div>
        ) : (
          apiCalls.slice(-5).map((call, index) => (
            <div key={index} className="api-call-entry">
              <span className="api-endpoint">{call.endpoint}</span>
              <span className="api-timestamp">{call.timestamp}</span>
            </div>
          ))
        )}
      </div>
    </div>
  );
}

// ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏ Îç∞Î™®
function MouseEventDemo() {
  const [mouseEvents, setMouseEvents] = useState(0);
  const [throttledEvents, setThrottledEvents] = useState(0);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const [actionRegister] = useState(() => new ActionRegister<ActionGuardMap>());
  
  const handleMouseMove = useCallback((x: number, y: number) => {
    setThrottledEvents(prev => prev + 1);
    setMousePosition({ x, y });
  }, []);
  
  const throttledMouseHandler = useThrottle(handleMouseMove, 50);
  
  useEffect(() => {
    const unsubscribe = actionRegister.register('mouseMove', ({ x, y }, controller) => {
      throttledMouseHandler(x, y);
      controller.next();
    });
    
    return unsubscribe;
  }, [actionRegister, throttledMouseHandler]);
  
  const handleMouseMoveEvent = useCallback((e: React.MouseEvent<HTMLDivElement>) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    setMouseEvents(prev => prev + 1);
    actionRegister.dispatch('mouseMove', { x, y });
  }, [actionRegister]);
  
  return (
    <div className="demo-card">
      <h3>Mouse Events with Throttling</h3>
      <p>Mouse move events are throttled to fire at most once every 50ms.</p>
      
      <div className="mouse-stats">
        <div>Raw mouse events: {mouseEvents}</div>
        <div>Throttled events: {throttledEvents}</div>
        <div>Position: ({mousePosition.x}, {mousePosition.y})</div>
      </div>
      
      <div className="mouse-area" onMouseMove={handleMouseMoveEvent}>
        <div 
          className="mouse-cursor" 
          style={{ 
            left: mousePosition.x - 5, 
            top: mousePosition.y - 5 
          }}
        />
        <div className="mouse-instructions">
          Move your mouse in this area
        </div>
      </div>
    </div>
  );
}

function ActionGuardPage() {
  return (
    <div className="page-container">
      <header className="page-header">
        <h1>Action Guard System</h1>
        <p className="page-description">
          Learn how to implement debouncing, throttling, and action blocking patterns
          to optimize user experience and prevent excessive action execution.
        </p>
      </header>

      <div className="demo-grid">
        <SearchDemo />
        <ScrollDemo />
        <ApiBlockingDemo />
        <MouseEventDemo />
        
        {/* Action Guard Í∞úÎÖê */}
        <div className="demo-card info-card">
          <h3>Action Guard Patterns</h3>
          <ul className="guard-pattern-list">
            <li>
              <strong>Debouncing:</strong> Ïó∞ÏÜçÎêú Ïù¥Î≤§Ìä∏ÏóêÏÑú ÎßàÏßÄÎßâ Ïù¥Î≤§Ìä∏Îßå Ï≤òÎ¶¨ (Í≤ÄÏÉâ, ÏûÖÎ†• Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨)
            </li>
            <li>
              <strong>Throttling:</strong> ÏßÄÏ†ïÎêú Ï£ºÍ∏∞ÎßàÎã§ Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨ (Ïä§ÌÅ¨Î°§, ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏)
            </li>
            <li>
              <strong>Blocking:</strong> ÏùºÏ†ï ÏãúÍ∞Ñ ÎèôÏïà Ï§ëÎ≥µ Ïã§Ìñâ Î∞©ÏßÄ (API Ìò∏Ï∂ú, Ìèº Ï†úÏ∂ú)
            </li>
            <li>
              <strong>Rate Limiting:</strong> ÏãúÍ∞ÑÎãπ ÏµúÎåÄ Ïã§Ìñâ ÌöüÏàò Ï†úÌïú
            </li>
          </ul>
        </div>
        
        {/* ÏÇ¨Ïö© ÏÇ¨Î°Ä */}
        <div className="demo-card info-card">
          <h3>Use Cases</h3>
          <ul className="use-case-list">
            <li>‚úì Í≤ÄÏÉâ ÏûÖÎ†• ÏµúÏ†ÅÌôî</li>
            <li>‚úì API Ìò∏Ï∂ú ÎπàÎèÑ Ï†úÏñ¥</li>
            <li>‚úì Ïä§ÌÅ¨Î°§ ÏÑ±Îä• Í∞úÏÑ†</li>
            <li>‚úì Î≤ÑÌäº Ïó∞Ìñâ ÌÅ¥Î¶≠ Î∞©ÏßÄ</li>
            <li>‚úì ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏ ÏµúÏ†ÅÌôî</li>
            <li>‚úì Î¶¨ÏÇ¨Ïù¥Ïßï Ïù¥Î≤§Ìä∏ Ï†úÏñ¥</li>
          </ul>
        </div>
      </div>

      {/* ÏΩîÎìú ÏòàÏ†ú */}
      <div className="code-example">
        <h3>Action Guard Implementation</h3>
        <pre className="code-block">
{`// 1. ÎîîÎ∞îÏö¥Ïä§ ÌõÖ
const useDebounce = (callback, delay) => {
  const timeoutRef = useRef();
  return useCallback((...args) => {
    clearTimeout(timeoutRef.current);
    timeoutRef.current = setTimeout(() => callback(...args), delay);
  }, [callback, delay]);
};

// 2. Ïä§Î°úÌãÄ ÌõÖ
const useThrottle = (callback, delay) => {
  const lastCallRef = useRef(0);
  return useCallback((...args) => {
    const now = Date.now();
    if (now - lastCallRef.current >= delay) {
      lastCallRef.current = now;
      callback(...args);
    }
  }, [callback, delay]);
};

// 3. Ïï°ÏÖò Î∏îÎ°úÌÇπ
const useActionBlock = (duration = 1000) => {
  const [isBlocked, setIsBlocked] = useState(false);
  
  const blockAction = useCallback((actionName) => {
    if (isBlocked) return false;
    setIsBlocked(true);
    setTimeout(() => setIsBlocked(false), duration);
    return true;
  }, [isBlocked, duration]);
  
  return { isBlocked, blockAction };
};

// 4. ActionRegisterÏôÄ ÌÜµÌï©
actionRegister.register('searchInput', (term, controller) => {
  debouncedSearch(term);
  controller.next();
});`}
        </pre>
      </div>
    </div>
  );
}

export default ActionGuardPage;