/**
 * @fileoverview VitePress sidebar configuration generator
 */

import fs from 'fs'
import path from 'path'
import type { 
  ApiStructure, 
  ApiItem, 
  SidebarSection,
  Logger 
} from '../types/index.js'
import { MarkdownProcessor } from './MarkdownProcessor.js'

export class SidebarGenerator {
  private markdownProcessor: MarkdownProcessor
  private logger?: Logger

  constructor(logger?: Logger) {
    this.markdownProcessor = new MarkdownProcessor()
    this.logger = logger
  }

  /**
   * Parse API structure from target directory
   */
  parseApiStructure(
    targetDir: string, 
    packageMapping: Record<string, string>
  ): ApiStructure {
    const structure: ApiStructure = {}
    
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for (const [_packageName, targetName] of Object.entries(packageMapping)) {
      const packagePath = path.join(targetDir, targetName)
      if (!fs.existsSync(packagePath)) {
        this.logger?.warn(`Package directory not found: ${packagePath}`)
        continue
      }
      
      structure[targetName] = {
        text: `${targetName.charAt(0).toUpperCase() + targetName.slice(1)} API`,
        items: []
      }
      
      // Parse src directory
      const srcPath = path.join(packagePath, 'src')
      if (fs.existsSync(srcPath)) {
        const items = this.parseDirectoryItems(srcPath, targetName)
        structure[targetName].items.push(...items)
      }
    }
    
    return structure
  }

  /**
   * Parse items from a directory
   */
  private parseDirectoryItems(dirPath: string, packageName: string): ApiItem[] {
    const items: ApiItem[] = []
    
    try {
      const dirItems = fs.readdirSync(dirPath)
      
      for (const item of dirItems) {
        const itemPath = path.join(dirPath, item)
        const stat = fs.statSync(itemPath)
        
        if (stat.isDirectory()) {
          // Process subdirectory
          const subItems = this.parseSubDirectory(itemPath, item, packageName)
          items.push(...subItems)
        } else if (stat.isFile() && item.endsWith('.md')) {
          // Process direct markdown file
          const filename = item.replace('.md', '')
          items.push({
            text: this.markdownProcessor.formatDisplayName(filename),
            path: `/${packageName}/src/${filename}`
          })
        }
      }
    } catch (error) {
      this.logger?.error(`Failed to parse directory ${dirPath}:`, error)
    }
    
    return items
  }

  /**
   * Parse subdirectory items
   */
  private parseSubDirectory(dirPath: string, dirName: string, packageName: string): ApiItem[] {
    const items: ApiItem[] = []
    
    try {
      const files = fs.readdirSync(dirPath)
        .filter(file => file.endsWith('.md'))
        .sort()
      
      for (const file of files) {
        const filename = file.replace('.md', '')
        items.push({
          text: this.markdownProcessor.formatDisplayName(filename),
          path: `/${packageName}/src/${dirName}/${filename}`
        })
      }
    } catch (error) {
      this.logger?.error(`Failed to parse subdirectory ${dirPath}:`, error)
    }
    
    return items
  }

  /**
   * Generate VitePress sidebar configuration
   */
  generateSidebarConfig(
    structure: ApiStructure, 
    outputPath: string
  ): void {
    const configContent = this.createConfigContent(structure)
    
    try {
      // Ensure directory exists
      const configDir = path.dirname(outputPath)
      if (!fs.existsSync(configDir)) {
        fs.mkdirSync(configDir, { recursive: true })
      }
      
      fs.writeFileSync(outputPath, configContent)
      this.logger?.info(`Sidebar configuration generated: ${outputPath}`)
    } catch (error) {
      this.logger?.error(`Failed to generate sidebar configuration:`, error)
    }
  }

  /**
   * Create TypeScript configuration content
   */
  private createConfigContent(structure: ApiStructure): string {
    return `// Auto-generated API sidebar configuration
// This file is generated by @context-action/typedoc-vitepress-sync

// Locale path utility
function createLocalePath(locale: string, path: string): string {
  return \`/\${locale}\${path}\`
}

// Type definitions
type SidebarItem = {
  text: string
  link: string
}

type SidebarSection = {
  text: string
  collapsed: boolean
  items: SidebarItem[]
}

// API structure (auto-generated)
export const API_STRUCTURE = ${JSON.stringify(structure, null, 2)}

// Sidebar section factory
function createSidebarSection(locale: string, section: any): SidebarSection {
  return {
    text: section.text,
    collapsed: false,
    items: section.items.map((item: any) => ({
      text: item.text,
      link: createLocalePath(locale, item.path)
    }))
  }
}

// Sidebar generators for different locales
export function sidebarApiEn() {
  return Object.values(API_STRUCTURE).map(section => 
    createSidebarSection('en', section)
  )
}

export function sidebarApiKo() {
  return Object.values(API_STRUCTURE).map(section => 
    createSidebarSection('ko', section)
  )
}

// Utility functions
export function getSidebarForLocale(locale: string) {
  switch (locale) {
    case 'ko':
      return sidebarApiKo()
    case 'en':
    default:
      return sidebarApiEn()
  }
}

export function getApiPackages(): string[] {
  return Object.keys(API_STRUCTURE)
}

export function getApiItemsForPackage(packageName: string): any[] {
  return API_STRUCTURE[packageName]?.items || []
}
`
  }

  /**
   * Generate sidebar sections directly
   */
  generateSidebarSections(structure: ApiStructure, locale: string = 'en'): SidebarSection[] {
    return Object.values(structure).map(section => ({
      text: section.text,
      collapsed: false,
      items: section.items.map(item => ({
        text: item.text,
        link: `/${locale}${item.path}`
      }))
    }))
  }

  /**
   * Validate API structure
   */
  validateStructure(structure: ApiStructure): Array<{ type: string; message: string; package?: string }> {
    const issues: Array<{ type: string; message: string; package?: string }> = []
    
    for (const [packageName, packageInfo] of Object.entries(structure)) {
      // Check for empty packages
      if (packageInfo.items.length === 0) {
        issues.push({
          type: 'empty-package',
          message: `Package has no API items`,
          package: packageName
        })
      }
      
      // Check for duplicate items
      const itemPaths = new Set<string>()
      for (const item of packageInfo.items) {
        if (itemPaths.has(item.path)) {
          issues.push({
            type: 'duplicate-path',
            message: `Duplicate path found: ${item.path}`,
            package: packageName
          })
        }
        itemPaths.add(item.path)
      }
      
      // Check for missing overview
      const hasOverview = packageInfo.items.some(item => 
        item.text === 'Overview' || item.path.endsWith('/README')
      )
      if (!hasOverview) {
        issues.push({
          type: 'missing-overview',
          message: `Package missing overview/README`,
          package: packageName
        })
      }
    }
    
    return issues
  }

  /**
   * Sort API items by category and name
   */
  sortApiItems(items: ApiItem[]): ApiItem[] {
    return items.sort((a, b) => {
      // Special case for Overview
      if (a.text === 'Overview') return -1
      if (b.text === 'Overview') return 1
      
      // Sort alphabetically within same category
      return a.text.localeCompare(b.text)
    })
  }

  /**
   * Group API items by category
   */
  groupByCategory(items: ApiItem[]): Record<string, ApiItem[]> {
    const groups: Record<string, ApiItem[]> = {
      overview: [],
      classes: [],
      functions: [],
      interfaces: [],
      types: [],
      variables: []
    }
    
    for (const item of items) {
      const path = item.path.toLowerCase()
      
      if (item.text === 'Overview' || path.includes('readme')) {
        groups.overview.push(item)
      } else if (path.includes('/classes/')) {
        groups.classes.push(item)
      } else if (path.includes('/functions/')) {
        groups.functions.push(item)
      } else if (path.includes('/interfaces/')) {
        groups.interfaces.push(item)
      } else if (path.includes('/type-aliases/')) {
        groups.types.push(item)
      } else if (path.includes('/variables/')) {
        groups.variables.push(item)
      } else {
        // Default to functions if unclear
        groups.functions.push(item)
      }
    }
    
    return groups
  }

  /**
   * Create grouped sidebar structure
   */
  createGroupedSidebar(structure: ApiStructure, locale: string = 'en'): SidebarSection[] {
    const sections: SidebarSection[] = []
    
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for (const [_packageName, packageInfo] of Object.entries(structure)) {
      const groups = this.groupByCategory(packageInfo.items)
      
      // Add overview section first
      if (groups.overview.length > 0) {
        sections.push({
          text: `${packageInfo.text} - Overview`,
          collapsed: false,
          items: groups.overview.map(item => ({
            text: item.text,
            link: `/${locale}${item.path}`
          }))
        })
      }
      
      // Add other categories
      const categoryTitles = {
        classes: 'Classes',
        functions: 'Functions',
        interfaces: 'Interfaces',
        types: 'Type Aliases',
        variables: 'Variables'
      }
      
      for (const [category, title] of Object.entries(categoryTitles)) {
        if (groups[category].length > 0) {
          sections.push({
            text: `${packageInfo.text} - ${title}`,
            collapsed: true,
            items: this.sortApiItems(groups[category]).map(item => ({
              text: item.text,
              link: `/${locale}${item.path}`
            }))
          })
        }
      }
    }
    
    return sections
  }

  /**
   * Generate config file (alias for generateSidebarConfig)
   */
  generateConfigFile(outputPath: string, structure: ApiStructure): void {
    this.generateSidebarConfig(structure, outputPath)
  }

  /**
   * Generate API structure from source directory (alias for parseApiStructure)
   */
  generateApiStructure(targetDir: string, packageMapping: Record<string, string>): ApiStructure {
    return this.parseApiStructure(targetDir, packageMapping)
  }

  /**
   * Write TypeScript config (alias for generateSidebarConfig) 
   */
  writeTypeScriptConfig(outputPath: string, structure: ApiStructure): void {
    this.generateSidebarConfig(structure, outputPath)
  }
}