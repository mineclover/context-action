import { ConflictDetector } from '../../../src/core/ConflictDetector';
import { EnhancedLLMSConfig, DocumentMetadata } from '../../../src/types/config';
import { TestDataGenerator } from '../../helpers/test-data-generator';

describe('ConflictDetector', () => {
  let detector: ConflictDetector;
  let mockConfig: EnhancedLLMSConfig;

  beforeEach(() => {
    mockConfig = {
      paths: { docs: 'docs', output: 'output', priority: 'priority' },
      generation: {
        defaultCharacterLimits: [100, 300, 1000],
        qualityThreshold: 70,
        defaultStrategy: 'concept-first'
      },
      categories: {
        guide: {
          name: '가이드',
          description: 'Step-by-step guides',
          priority: 90,
          defaultStrategy: 'tutorial-first',
          tags: ['beginner', 'step-by-step', 'practical']
        },
        api: {
          name: 'API',
          description: 'API documentation',
          priority: 85,
          defaultStrategy: 'reference-first',
          tags: ['technical', 'reference', 'developer']
        }
      },
      tags: {
        beginner: {
          name: '초보자',
          description: 'Beginner-friendly content',
          weight: 1.2,
          compatibleWith: ['step-by-step', 'practical'],
          audience: ['new-users', 'beginners'],
          incompatibleWith: ['advanced', 'expert']
        },
        advanced: {
          name: '고급',
          description: 'Advanced content',
          weight: 0.9,
          compatibleWith: ['technical', 'expert'],
          audience: ['experts', 'contributors'],
          incompatibleWith: ['beginner', 'step-by-step']
        },
        'step-by-step': {
          name: '단계별',
          description: 'Step-by-step instructions',
          weight: 1.1,
          compatibleWith: ['beginner', 'practical'],
          audience: ['new-users']
        },
        technical: {
          name: '기술적',
          description: 'Technical documentation',
          weight: 1.0,
          compatibleWith: ['advanced', 'reference'],
          audience: ['developers']
        }
      },
      dependencies: {
        enabled: true,
        maxDepth: 3,
        includeOptional: false,
        conflictResolution: 'exclude-conflicts'
      },
      composition: {
        strategies: {
          balanced: {
            name: 'Balanced Strategy',
            algorithm: 'hybrid',
            criteria: {
              categoryWeight: 0.4,
              tagWeight: 0.3,
              dependencyWeight: 0.2,
              priorityWeight: 0.1
            }
          }
        },
        defaultStrategy: 'balanced'
      },
      extraction: {
        enableSmartExtraction: true,
        contextAwareExtraction: true,
        preserveCodeBlocks: true
      },
      validation: {
        enabled: true,
        strictMode: false,
        validateDependencies: true
      },
      ui: {
        language: 'ko',
        theme: 'default'
      }
    };

    detector = new ConflictDetector(mockConfig);
  });

  describe('Constructor', () => {
    it('should initialize with valid config', () => {
      expect(detector).toBeInstanceOf(ConflictDetector);
    });

    it('should load conflict rules from config', () => {
      const rules = (detector as any).conflictRules;
      expect(rules).toBeDefined();
      expect(rules.length).toBeGreaterThan(0);
    });
  });

  describe('detectConflicts()', () => {
    it('should detect tag incompatibilities', () => {
      const conflictingDocs: DocumentMetadata[] = [
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'beginner-doc', title: 'Beginner Guide', source_path: 'beginner.md', category: 'guide' },
          tags: {
            primary: ['beginner', 'step-by-step'],
            audience: ['new-users'],
            complexity: 'basic'
          }
        },
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'advanced-doc', title: 'Advanced Guide', source_path: 'advanced.md', category: 'guide' },
          tags: {
            primary: ['advanced', 'technical'],
            audience: ['experts'],
            complexity: 'advanced'
          }
        },
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'mixed-doc', title: 'Mixed Doc', source_path: 'mixed.md', category: 'guide' },
          tags: {
            primary: ['beginner', 'advanced'], // Incompatible combination
            audience: ['all-users'],
            complexity: 'intermediate'
          }
        }
      ];

      const options = {
        enabledRules: ['tag-incompatible'],
        severityThreshold: 'minor' as const,
        autoResolve: false
      };

      const analysis = detector.detectConflicts(conflictingDocs, options);

      expect(analysis.conflicts.length).toBeGreaterThan(0);
      
      // Should detect the beginner+advanced incompatibility
      const tagConflict = analysis.conflicts.find(c => c.type === 'tag-incompatible');
      expect(tagConflict).toBeDefined();
      expect(tagConflict?.documentIds).toContain('mixed-doc');
      expect(tagConflict?.severity).toBeDefined();
      expect(tagConflict?.reason).toContain('incompatible');
    });

    it('should identify content duplicates', () => {
      const duplicateDocs: DocumentMetadata[] = [
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'guide-1', title: 'Getting Started Guide', source_path: 'guide1.md', category: 'guide' },
          keywords: {
            primary: ['getting-started', 'tutorial', 'beginner'],
            technical: ['setup', 'installation']
          },
          tags: { primary: ['beginner', 'tutorial'], audience: ['new-users'], complexity: 'basic' }
        },
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'guide-2', title: 'Getting Started Tutorial', source_path: 'guide2.md', category: 'guide' },
          keywords: {
            primary: ['getting-started', 'tutorial', 'introduction'],
            technical: ['setup', 'initialization']
          },
          tags: { primary: ['beginner', 'tutorial'], audience: ['new-users'], complexity: 'basic' }
        }
      ];

      const options = {
        enabledRules: ['content-duplicate'],
        severityThreshold: 'minor' as const,
        autoResolve: false
      };

      const analysis = detector.detectConflicts(duplicateDocs, options);

      const duplicateConflict = analysis.conflicts.find(c => c.type === 'content-duplicate');
      expect(duplicateConflict).toBeDefined();
      expect(duplicateConflict?.documentIds).toHaveLength(2);
      expect(duplicateConflict?.documentIds).toContain('guide-1');
      expect(duplicateConflict?.documentIds).toContain('guide-2');
    });

    it('should find audience mismatches', () => {
      const mismatchedDocs: DocumentMetadata[] = [
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'beginner-doc', title: 'Beginner Doc', source_path: 'beginner.md', category: 'guide' },
          tags: {
            primary: ['beginner'],
            audience: ['new-users', 'beginners'],
            complexity: 'basic'
          }
        },
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'expert-doc', title: 'Expert Doc', source_path: 'expert.md', category: 'api' },
          tags: {
            primary: ['advanced'],
            audience: ['experts', 'contributors'],
            complexity: 'expert'
          }
        }
      ];

      const options = {
        enabledRules: ['audience-mismatch'],
        severityThreshold: 'moderate' as const,
        autoResolve: false
      };

      const analysis = detector.detectConflicts(mismatchedDocs, options);

      const audienceConflict = analysis.conflicts.find(c => c.type === 'audience-mismatch');
      expect(audienceConflict).toBeDefined();
      expect(audienceConflict?.severity).toBe('moderate');
    });

    it('should detect complexity gaps', () => {
      const gappedDocs: DocumentMetadata[] = [
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'basic-doc', title: 'Basic Doc', source_path: 'basic.md', category: 'guide' },
          tags: { primary: ['beginner'], audience: ['new-users'], complexity: 'basic' }
        },
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'expert-doc', title: 'Expert Doc', source_path: 'expert.md', category: 'guide' },
          tags: { primary: ['advanced'], audience: ['experts'], complexity: 'expert' }
        }
      ];

      const options = {
        enabledRules: ['complexity-gap'],
        severityThreshold: 'minor' as const,
        autoResolve: false,
        complexityGapThreshold: 2 // Basic to Expert is a gap of 3
      };

      const analysis = detector.detectConflicts(gappedDocs, options);

      const gapConflict = analysis.conflicts.find(c => c.type === 'complexity-gap');
      expect(gapConflict).toBeDefined();
      expect(gapConflict?.reason).toContain('complexity gap');
    });

    it('should handle multiple conflict types simultaneously', () => {
      const complexConflictDocs = TestDataGenerator.generateConflictingDocuments();
      
      const options = {
        enabledRules: ['tag-incompatible', 'content-duplicate', 'audience-mismatch', 'complexity-gap'],
        severityThreshold: 'minor' as const,
        autoResolve: false
      };

      const analysis = detector.detectConflicts(complexConflictDocs, options);

      expect(analysis.conflicts.length).toBeGreaterThan(0);
      expect(analysis.summary.total).toBe(analysis.conflicts.length);
      
      const conflictTypes = new Set(analysis.conflicts.map(c => c.type));
      expect(conflictTypes.size).toBeGreaterThan(1); // Multiple types detected
    });

    it('should respect severity thresholds', () => {
      const conflictingDocs = TestDataGenerator.generateConflictingDocuments();
      
      const strictOptions = {
        enabledRules: ['tag-incompatible', 'content-duplicate', 'audience-mismatch'],
        severityThreshold: 'major' as const,
        autoResolve: false
      };

      const lenientOptions = {
        enabledRules: ['tag-incompatible', 'content-duplicate', 'audience-mismatch'],
        severityThreshold: 'minor' as const,
        autoResolve: false
      };

      const strictAnalysis = detector.detectConflicts(conflictingDocs, strictOptions);
      const lenientAnalysis = detector.detectConflicts(conflictingDocs, lenientOptions);

      // Lenient threshold should detect more conflicts
      expect(lenientAnalysis.conflicts.length).toBeGreaterThanOrEqual(strictAnalysis.conflicts.length);
    });

    it('should auto-resolve when configured', () => {
      const conflictingDocs: DocumentMetadata[] = [
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'high-priority', title: 'High Priority', source_path: 'high.md', category: 'guide' },
          priority: { score: 95, tier: 'critical' },
          tags: { primary: ['beginner'], audience: ['new-users'], complexity: 'basic' }
        },
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'low-priority', title: 'Low Priority', source_path: 'low.md', category: 'guide' },
          priority: { score: 30, tier: 'optional' },
          tags: { primary: ['beginner'], audience: ['new-users'], complexity: 'basic' }
        }
      ];

      // Make them duplicates
      conflictingDocs[0].keywords = { primary: ['tutorial', 'guide'], technical: ['setup'] };
      conflictingDocs[1].keywords = { primary: ['tutorial', 'guide'], technical: ['setup'] };

      const options = {
        enabledRules: ['content-duplicate'],
        severityThreshold: 'minor' as const,
        autoResolve: true,
        autoResolveStrategy: 'higher-score-wins' as const
      };

      const analysis = detector.detectConflicts(conflictingDocs, options);

      expect(analysis.resolutions.length).toBeGreaterThan(0);
      expect(analysis.summary.autoResolvable).toBeGreaterThan(0);
      
      const resolution = analysis.resolutions[0];
      expect(resolution.strategy).toBe('higher-score-wins');
      expect(resolution.action).toBe('exclude-second');
    });
  });

  describe('applyConflictResolutions()', () => {
    it('should apply exclude-conflicts strategy', () => {
      const documents: DocumentMetadata[] = [
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'doc-1', title: 'Doc 1', source_path: 'doc1.md', category: 'guide' },
          priority: { score: 80, tier: 'important' }
        },
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'doc-2', title: 'Doc 2', source_path: 'doc2.md', category: 'guide' },
          priority: { score: 60, tier: 'useful' }
        }
      ];

      const conflicts = [
        {
          id: 'conflict-1',
          type: 'content-duplicate' as const,
          documentIds: ['doc-1', 'doc-2'],
          severity: 'moderate' as const,
          reason: 'Duplicate content detected',
          confidence: 0.9,
          resolutionStrategies: ['exclude-first', 'exclude-second', 'exclude-both']
        }
      ];

      const resolution = detector.applyConflictResolutions(documents, conflicts);

      expect(resolution.resolvedDocuments.length).toBe(2);
      expect(resolution.excludedDocuments.length).toBe(0);
      // Since no automatic resolution is applied without resolution strategy in conflicts
    });

    it('should apply higher-score-wins strategy', () => {
      const documents: DocumentMetadata[] = [
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'high-score', title: 'High Score', source_path: 'high.md', category: 'guide' },
          priority: { score: 95, tier: 'critical' }
        },
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'low-score', title: 'Low Score', source_path: 'low.md', category: 'guide' },
          priority: { score: 25, tier: 'optional' }
        }
      ];

      const conflicts = [
        {
          id: 'score-conflict',
          type: 'audience-mismatch' as const,
          documentIds: ['high-score', 'low-score'],
          severity: 'major' as const,
          reason: 'Conflicting target audiences',
          confidence: 0.85,
          resolutionStrategies: ['exclude-first', 'exclude-second']
        }
      ];

      const resolution = detector.applyConflictResolutions(documents, conflicts);

      expect(resolution.resolvedDocuments.length).toBe(2);
      expect(resolution.excludedDocuments.length).toBe(0);
      // Without specific resolution in conflict rules, both documents remain
    });

    it('should apply keep-both strategy with warnings', () => {
      const documents: DocumentMetadata[] = [
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'doc-a', title: 'Doc A', source_path: 'doca.md', category: 'guide' }
        },
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'doc-b', title: 'Doc B', source_path: 'docb.md', category: 'guide' }
        }
      ];

      const conflicts = [
        {
          id: 'minor-conflict',
          type: 'complexity-gap' as const,
          documentIds: ['doc-a', 'doc-b'],
          severity: 'minor' as const,
          reason: 'Small complexity gap',
          confidence: 0.6,
          resolutionStrategies: ['keep-both', 'exclude-first', 'exclude-second']
        }
      ];

      const resolution = detector.applyConflictResolutions(documents, conflicts);

      expect(resolution.resolvedDocuments.length).toBe(2);
      expect(resolution.unresolved.length).toBe(1);
      expect(resolution.unresolved[0].rule.type).toBe('tag-incompatible');
    });

    it('should handle manual-review conflicts', () => {
      const documents = TestDataGenerator.generateDocuments(2);
      const conflicts = [
        {
          id: 'complex-conflict',
          type: 'category-exclusive' as const,
          documentIds: [documents[0].document.id, documents[1].document.id],
          severity: 'major' as const,
          reason: 'Complex conflict requiring manual review',
          confidence: 0.7,
          resolutionStrategies: ['manual-review']
        }
      ];

      const resolution = detector.applyConflictResolutions(documents, conflicts);

      expect(resolution.unresolved.length).toBe(1);
      expect(resolution.unresolved[0].id).toBe('complex-conflict');
    });
  });

  describe('Custom conflict rules', () => {
    it('should allow adding custom conflict rules', () => {
      const customRule = {
        id: 'custom-rule',
        type: 'custom-conflict' as const,
        severity: 'moderate' as const,
        description: 'Custom conflict detection',
        detectFunction: (docA: DocumentMetadata, docB: DocumentMetadata, config: EnhancedLLMSConfig) => {
          return docA.document.category === docB.document.category && 
                 docA.document.title.includes('test') && 
                 docB.document.title.includes('test');
        },
        resolveFunction: (docA: DocumentMetadata, docB: DocumentMetadata, config: EnhancedLLMSConfig) => {
          return {
            strategy: 'exclude-second' as const,
            reason: 'Custom resolution logic',
            confidence: 0.8
          };
        }
      };

      detector.addCustomRule('custom-rule', customRule);

      const testDocs: DocumentMetadata[] = [
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'test-1', title: 'Test Document 1', source_path: 'test1.md', category: 'guide' }
        },
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'test-2', title: 'Test Document 2', source_path: 'test2.md', category: 'guide' }
        }
      ];

      const analysis = detector.detectConflicts(testDocs, {
        enabledRules: ['custom-conflict'],
        severityThreshold: 'minor',
        autoResolve: false
      });

      const customConflict = analysis.conflicts.find(c => c.type === 'custom-conflict');
      expect(customConflict).toBeDefined();
    });
  });

  describe('Performance optimization', () => {
    it('should handle large document collections efficiently', () => {
      const largeDocs = TestDataGenerator.generateDocuments(200);
      
      const startTime = Date.now();
      const analysis = detector.detectConflicts(largeDocs, {
        enabledRules: ['tag-incompatible', 'content-duplicate'],
        severityThreshold: 'minor',
        autoResolve: false
      });
      const processingTime = Date.now() - startTime;

      expect(processingTime).toBeLessThan(3000); // Should complete in under 3 seconds
      expect(analysis).toBeDefined();
    });

    it('should optimize repeated conflict detection', () => {
      const documents = TestDataGenerator.generateDocuments(20);
      const options = {
        enabledRules: ['tag-incompatible', 'audience-mismatch'],
        severityThreshold: 'moderate' as const,
        autoResolve: false
      };

      // First run
      const startTime1 = Date.now();
      detector.detectConflicts(documents, options);
      const time1 = Date.now() - startTime1;

      // Second run (should benefit from caching)
      const startTime2 = Date.now();
      detector.detectConflicts(documents, options);
      const time2 = Date.now() - startTime2;

      expect(time2).toBeLessThanOrEqual(time1 * 1.3); // Allow some variance
    });
  });

  describe('Edge cases', () => {
    it('should handle empty document collection', () => {
      const analysis = detector.detectConflicts([], {
        enabledRules: ['tag-incompatible'],
        severityThreshold: 'minor',
        autoResolve: false
      });

      expect(analysis.conflicts).toHaveLength(0);
      expect(analysis.summary.total).toBe(0);
    });

    it('should handle single document', () => {
      const singleDoc = TestDataGenerator.generateDocuments(1);
      
      const analysis = detector.detectConflicts(singleDoc, {
        enabledRules: ['tag-incompatible', 'content-duplicate'],
        severityThreshold: 'minor',
        autoResolve: false
      });

      expect(analysis.conflicts).toHaveLength(0);
    });

    it('should handle documents with missing metadata', () => {
      const incompleteDoc = {
        document: {
          id: 'incomplete',
          title: 'Incomplete',
          source_path: 'incomplete.md',
          category: 'guide' as const
        }
        // Missing tags, keywords, etc.
      } as DocumentMetadata;

      const analysis = detector.detectConflicts([incompleteDoc], {
        enabledRules: ['tag-incompatible'],
        severityThreshold: 'minor',
        autoResolve: false
      });

      expect(analysis).toBeDefined();
      expect(analysis.conflicts).toHaveLength(0);
    });

    it('should handle invalid conflict rule configurations', () => {
      expect(() => {
        detector.detectConflicts([], {
          enabledRules: ['non-existent-rule'],
          severityThreshold: 'minor',
          autoResolve: false
        });
      }).not.toThrow(); // Should ignore invalid rules gracefully
    });

    it('should handle circular conflict dependencies', () => {
      const docs: DocumentMetadata[] = [
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'doc-a', title: 'Doc A', source_path: 'doca.md', category: 'guide' },
          dependencies: {
            conflicts: [{ documentId: 'doc-b', reason: 'Conflicting approach', severity: 'moderate' }]
          }
        },
        {
          ...TestDataGenerator.generateDocuments(1)[0],
          document: { id: 'doc-b', title: 'Doc B', source_path: 'docb.md', category: 'guide' },
          dependencies: {
            conflicts: [{ documentId: 'doc-a', reason: 'Conflicting approach', severity: 'moderate' }]
          }
        }
      ];

      const analysis = detector.detectConflicts(docs, {
        enabledRules: ['explicit-conflict'],
        severityThreshold: 'minor',
        autoResolve: false
      });

      // Should detect conflict without infinite loops
      expect(analysis.conflicts.length).toBeGreaterThan(0);
    });
  });
});