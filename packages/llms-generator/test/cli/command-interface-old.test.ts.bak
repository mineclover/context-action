import { spawn, ChildProcess } from 'child_process';
import fs from 'fs';
import path from 'path';
import { TestDataGenerator } from '../helpers/test-data-generator';

describe('CLI Command Interface', () => {
  let testOutputDir: string;
  let testDocsDir: string;
  let testConfigPath: string;

  beforeAll(() => {
    // Setup test environment
    testOutputDir = path.join(__dirname, '../temp/cli-output');
    testDocsDir = path.join(__dirname, '../temp/cli-docs');
    testConfigPath = path.join(__dirname, '../temp/cli-config.json');
    
    // Create directories
    [testOutputDir, testDocsDir].forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    });

    // Create test documents
    createTestDocuments();
    createTestConfig();
  });

  afterAll(() => {
    // Cleanup test files
    [testOutputDir, testDocsDir, testConfigPath].forEach(path => {
      if (fs.existsSync(path)) {
        fs.rmSync(path, { recursive: true, force: true });
      }
    });
  });

  function createTestDocuments() {
    const testDocs = [
      {
        path: 'getting-started.md',
        content: `# Getting Started Guide

This is a comprehensive guide for beginners to get started with the Context-Action framework.

## Installation

\`\`\`bash
npm install @context-action/core @context-action/react
\`\`\`

## Basic Setup

Here's how to set up your first context-action application...
`,
        metadata: {
          category: 'guide',
          tags: ['beginner', 'tutorial', 'setup'],
          priority: 95
        }
      },
      {
        path: 'api/actions.md',
        content: `# Action API Reference

Complete reference for the Action API in Context-Action framework.

## useActionDispatch

The \`useActionDispatch\` hook provides access to the action dispatch function.

\`\`\`typescript
const dispatch = useActionDispatch<MyActions>();
dispatch('updateUser', { id: '123', name: 'John' });
\`\`\`

## useActionHandler

Register action handlers using the \`useActionHandler\` hook...
`,
        metadata: {
          category: 'api',
          tags: ['reference', 'api', 'actions'],
          priority: 85
        }
      },
      {
        path: 'advanced/patterns.md',
        content: `# Advanced Usage Patterns

Advanced patterns and optimization techniques for experienced developers.

## Performance Optimization

### Memoization Strategies

Use React.memo and useMemo for expensive calculations...

### Custom Middleware

Create custom middleware for complex workflows...
`,
        metadata: {
          category: 'guide',
          tags: ['advanced', 'performance', 'patterns'],
          priority: 75
        }
      },
      {
        path: 'troubleshooting.md',
        content: `# Troubleshooting Common Issues

Solutions for common problems encountered while using Context-Action.

## Common Errors

### "Handler not found" Error

This error occurs when trying to dispatch an action without a registered handler...

### Memory Leaks

If you notice memory usage growing over time, check for...
`,
        metadata: {
          category: 'support',
          tags: ['troubleshooting', 'debugging', 'support'],
          priority: 80
        }
      }
    ];

    testDocs.forEach(doc => {
      const fullPath = path.join(testDocsDir, doc.path);
      const dir = path.dirname(fullPath);
      
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      
      fs.writeFileSync(fullPath, doc.content);
    });
  }

  function createTestConfig() {
    const config = {
      paths: {
        docs: testDocsDir,
        output: testOutputDir,
        priority: path.join(testDocsDir, 'priority.json')
      },
      generation: {
        defaultCharacterLimits: [500, 1500, 3000],
        qualityThreshold: 70,
        defaultStrategy: 'balanced'
      },
      categories: {
        guide: {
          name: 'Guide',
          description: 'Step-by-step guides',
          priority: 90,
          defaultStrategy: 'tutorial-first',
          tags: ['beginner', 'tutorial', 'practical']
        },
        api: {
          name: 'API Reference',
          description: 'API documentation',
          priority: 85,
          defaultStrategy: 'reference-first',
          tags: ['reference', 'api', 'technical']
        },
        support: {
          name: 'Support',
          description: 'Support documentation',
          priority: 80,
          defaultStrategy: 'problem-solving',
          tags: ['troubleshooting', 'support']
        }
      },
      tags: {
        beginner: {
          name: 'Beginner',
          description: 'Beginner-friendly content',
          weight: 1.2,
          compatibleWith: ['tutorial', 'practical'],
          audience: ['new-users']
        },
        advanced: {
          name: 'Advanced',
          description: 'Advanced content',
          weight: 0.9,
          compatibleWith: ['performance', 'patterns'],
          audience: ['experts']
        }
      }
    };

    fs.writeFileSync(testConfigPath, JSON.stringify(config, null, 2));
  }

  function runCLI(args: string[], timeout: number = 10000): Promise<{
    exitCode: number;
    stdout: string;
    stderr: string;
  }> {
    return new Promise((resolve) => {
      const child = spawn('node', ['./dist/cli/index.js', ...args], {
        cwd: path.join(__dirname, '../../'),
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      child.stdout?.on('data', (data) => {
        stdout += data.toString();
      });

      child.stderr?.on('data', (data) => {
        stderr += data.toString();
      });

      const timer = setTimeout(() => {
        child.kill('SIGTERM');
        resolve({ exitCode: -1, stdout, stderr: stderr + '\nProcess timed out' });
      }, timeout);

      child.on('exit', (code) => {
        clearTimeout(timer);
        resolve({
          exitCode: code || 0,
          stdout,
          stderr
        });
      });
    });
  }

  describe('Basic CLI Operations', () => {
    it('should display help information', async () => {
      const result = await runCLI(['--help']);
      
      expect(result.exitCode).toBe(0);
      expect(result.stdout).toContain('LLMS Generator CLI');
      expect(result.stdout).toContain('USAGE:');
      expect(result.stdout).toContain('config-init');
      expect(result.stdout).toContain('analyze-priority');
      expect(result.stdout).toContain('minimum');
    });

    it('should display version information', async () => {
      const result = await runCLI(['--version']);
      
      expect(result.exitCode).toBe(0);
      expect(result.stdout).toMatch(/\d+\.\d+\.\d+/); // Version format
    });

    it('should handle invalid commands gracefully', async () => {
      const result = await runCLI(['invalid-command']);
      
      expect(result.exitCode).not.toBe(0);
      expect(result.stderr).toContain('Unknown command');
      expect(result.stderr).toContain('invalid-command');
    });
  });

  describe('Content Generation Commands', () => {
    it('should generate document summaries with default settings', async () => {
      const result = await runCLI([
        'minimum',
        '--config', testConfigPath
      ]);

      // For now, just check that the command runs without path errors
      // The actual functionality might need a proper configuration setup
      expect(result.exitCode).toBe(0);
    });

    it('should generate character-limited content', async () => {
      const result = await runCLI([
        'chars',
        '1000',
        'en'
      ]);

      // Command should run without path errors
      // Actual output depends on available documents and configuration
      expect(result.exitCode).toBe(0);
    });

    it('should generate origin format content', async () => {
      const result = await runCLI([
        'origin'
      ]);

      // Command should run without path errors
      expect(result.exitCode).toBe(0);
    });

    it('should generate batch content', async () => {
      const result = await runCLI([
        'batch',
        '--lang=en',
        '--chars=300,1000'
      ]);

      // Command should run without path errors
      expect(result.exitCode).toBe(0);
    });

    it('should support different languages', async () => {
      const result = await runCLI([
        'chars',
        '500',
        'ko'
      ]);

      // Command should run without path errors
      expect(result.exitCode).toBe(0);
    });

    it('should handle batch generation with multiple character limits', async () => {
      const result = await runCLI([
        'batch',
        '--lang=en,ko',
        '--chars=300,1000,2000'
      ]);

      // Command should run without path errors
      expect(result.exitCode).toBe(0);
    });

    it('should support different character limits', async () => {
      const limits = ['300', '1000', '2000'];
      
      for (const limit of limits) {
        const result = await runCLI([
          'chars',
          limit,
          'en'
        ]);

        // Command should run without path errors
        expect(result.exitCode).toBe(0);
      }
    });
  });

  describe('Priority Analysis Commands', () => {
    it('should analyze priority status', async () => {
      const result = await runCLI([
        'analyze-priority',
        '--format', 'summary'
      ]);

      // Command should run without path errors
      expect(result.exitCode).toBe(0);
    });

    it('should generate priority statistics', async () => {
      const result = await runCLI([
        'priority-stats',
        'en'
      ]);

      // Command should run without path errors
      expect(result.exitCode).toBe(0);
    });

    it('should analyze content quality and provide recommendations', async () => {
      const result = await runCLI([
        'analyze',
        '--config', testConfigPath,
        '--quality-report',
        '--output', path.join(testOutputDir, 'quality-report.json')
      ]);

      expect(result.exitCode).toBe(0);
      
      const outputFile = path.join(testOutputDir, 'quality-report.json');
      const report = JSON.parse(fs.readFileSync(outputFile, 'utf8'));
      expect(report.overallScore).toBeDefined();
      expect(report.recommendations).toBeDefined();
      expect(Array.isArray(report.recommendations)).toBe(true);
    });

    it('should provide coverage analysis for tags and categories', async () => {
      const result = await runCLI([
        'analyze',
        '--config', testConfigPath,
        '--coverage',
        '--output', path.join(testOutputDir, 'coverage-analysis.json')
      ]);

      expect(result.exitCode).toBe(0);
      
      const outputFile = path.join(testOutputDir, 'coverage-analysis.json');
      const coverage = JSON.parse(fs.readFileSync(outputFile, 'utf8'));
      expect(coverage.categoryDistribution).toBeDefined();
      expect(coverage.tagDistribution).toBeDefined();
      expect(coverage.gapAnalysis).toBeDefined();
    });
  });

  describe('Validate Command', () => {
    it('should validate configuration file', async () => {
      const result = await runCLI([
        'validate',
        '--config', testConfigPath
      ]);

      expect(result.exitCode).toBe(0);
      expect(result.stdout).toContain('Configuration validation passed');
    });

    it('should detect configuration errors', async () => {
      // Create invalid config
      const invalidConfigPath = path.join(testOutputDir, 'invalid-config.json');
      const invalidConfig = {
        paths: {
          docs: '/non-existent-path'
        },
        generation: {
          qualityThreshold: 150 // Invalid value
        }
      };
      fs.writeFileSync(invalidConfigPath, JSON.stringify(invalidConfig));

      const result = await runCLI([
        'validate',
        '--config', invalidConfigPath
      ]);

      expect(result.exitCode).not.toBe(0);
      expect(result.stderr).toContain('Configuration validation failed');
      expect(result.stderr).toContain('qualityThreshold');
    });

    it('should validate document structure and metadata', async () => {
      const result = await runCLI([
        'validate',
        '--config', testConfigPath,
        '--documents'
      ]);

      expect(result.exitCode).toBe(0);
      expect(result.stdout).toContain('Document validation completed');
    });

    it('should check for dependency issues', async () => {
      const result = await runCLI([
        'validate',
        '--config', testConfigPath,
        '--dependencies'
      ]);

      expect(result.exitCode).toBe(0);
      expect(result.stdout).toContain('Dependency validation completed');
    });
  });

  describe('Interactive Mode', () => {
    it('should support interactive selection mode', async () => {
      // This test simulates interactive input
      const child = spawn('node', ['./dist/cli/index.js', 'generate', '--config', testConfigPath, '--interactive'], {
        cwd: path.join(__dirname, '../../'),
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      child.stdout?.on('data', (data) => {
        stdout += data.toString();
        // Simulate user input when prompted
        if (stdout.includes('Select tags')) {
          child.stdin?.write('1,2\n'); // Select first two options
        }
        if (stdout.includes('Character limit')) {
          child.stdin?.write('1500\n');
        }
        if (stdout.includes('Output file')) {
          child.stdin?.write(path.join(testOutputDir, 'interactive-summary.md\n'));
        }
      });

      // Wait for process to complete
      await new Promise((resolve) => {
        child.on('exit', resolve);
        setTimeout(() => {
          child.kill();
          resolve(null);
        }, 15000);
      });

      // Check if output file was created
      const outputFile = path.join(testOutputDir, 'interactive-summary.md');
      if (fs.existsSync(outputFile)) {
        expect(fs.readFileSync(outputFile, 'utf8').length).toBeGreaterThan(0);
      }
    });
  });

  describe('Error Handling', () => {
    it('should handle missing configuration file', async () => {
      const result = await runCLI([
        'generate',
        '--config', '/non-existent/config.json'
      ]);

      expect(result.exitCode).not.toBe(0);
      expect(result.stderr).toContain('Configuration file not found');
    });

    it('should handle missing documents directory', async () => {
      const configWithMissingDocs = {
        ...JSON.parse(fs.readFileSync(testConfigPath, 'utf8')),
        paths: {
          docs: '/non-existent-docs',
          output: testOutputDir
        }
      };
      
      const invalidConfigPath = path.join(testOutputDir, 'missing-docs-config.json');
      fs.writeFileSync(invalidConfigPath, JSON.stringify(configWithMissingDocs));

      const result = await runCLI([
        'generate',
        '--config', invalidConfigPath
      ]);

      expect(result.exitCode).not.toBe(0);
      expect(result.stderr).toContain('Documents directory not found');
    });

    it('should handle insufficient permissions', async () => {
      // Create readonly output directory
      const readonlyDir = path.join(testOutputDir, 'readonly');
      if (!fs.existsSync(readonlyDir)) {
        fs.mkdirSync(readonlyDir);
      }
      fs.chmodSync(readonlyDir, 0o444); // Read-only

      const result = await runCLI([
        'generate',
        '--config', testConfigPath,
        '--output', path.join(readonlyDir, 'summary.md')
      ]);

      expect(result.exitCode).not.toBe(0);
      expect(result.stderr).toMatch(/(permission|access|write)/i);

      // Restore permissions for cleanup
      fs.chmodSync(readonlyDir, 0o755);
    });

    it('should handle invalid command line arguments', async () => {
      const result = await runCLI([
        'generate',
        '--invalid-option', 'value'
      ]);

      expect(result.exitCode).not.toBe(0);
      expect(result.stderr).toContain('invalid-option');
    });
  });

  describe('Output Formats', () => {
    it('should support JSON output format', async () => {
      const result = await runCLI([
        'analyze',
        '--config', testConfigPath,
        '--format', 'json',
        '--output', path.join(testOutputDir, 'output.json')
      ]);

      expect(result.exitCode).toBe(0);
      
      const outputFile = path.join(testOutputDir, 'output.json');
      expect(fs.existsSync(outputFile)).toBe(true);
      
      const content = fs.readFileSync(outputFile, 'utf8');
      expect(() => JSON.parse(content)).not.toThrow();
    });

    it('should support YAML output format', async () => {
      const result = await runCLI([
        'analyze',
        '--config', testConfigPath,
        '--format', 'yaml',
        '--output', path.join(testOutputDir, 'output.yaml')
      ]);

      expect(result.exitCode).toBe(0);
      
      const outputFile = path.join(testOutputDir, 'output.yaml');
      expect(fs.existsSync(outputFile)).toBe(true);
      
      const content = fs.readFileSync(outputFile, 'utf8');
      expect(content).toContain('---'); // YAML document separator
    });

    it('should support markdown output format', async () => {
      const result = await runCLI([
        'generate',
        '--config', testConfigPath,
        '--format', 'markdown',
        '--output', path.join(testOutputDir, 'output.md')
      ]);

      expect(result.exitCode).toBe(0);
      
      const outputFile = path.join(testOutputDir, 'output.md');
      expect(fs.existsSync(outputFile)).toBe(true);
      
      const content = fs.readFileSync(outputFile, 'utf8');
      expect(content).toContain('#'); // Markdown headers
    });
  });

  describe('Performance and Monitoring', () => {
    it('should display performance metrics when requested', async () => {
      const result = await runCLI([
        'generate',
        '--config', testConfigPath,
        '--performance-metrics',
        '--output', path.join(testOutputDir, 'perf-summary.md')
      ]);

      expect(result.exitCode).toBe(0);
      expect(result.stdout).toContain('Processing time:');
      expect(result.stdout).toContain('Documents processed:');
      expect(result.stdout).toContain('Selection quality:');
    });

    it('should support verbose logging', async () => {
      const result = await runCLI([
        'generate',
        '--config', testConfigPath,
        '--verbose',
        '--output', path.join(testOutputDir, 'verbose-summary.md')
      ]);

      expect(result.exitCode).toBe(0);
      expect(result.stdout).toContain('Loading configuration');
      expect(result.stdout).toContain('Scanning documents');
      expect(result.stdout).toContain('Applying filters');
      expect(result.stdout).toContain('Selecting documents');
    });

    it('should handle large document collections efficiently', async () => {
      // Generate more test documents
      const largeDocsDir = path.join(testOutputDir, 'large-docs');
      if (!fs.existsSync(largeDocsDir)) {
        fs.mkdirSync(largeDocsDir);
      }

      // Create 50 test documents
      for (let i = 0; i < 50; i++) {
        const content = `# Document ${i}\n\nThis is test document number ${i}.\n\n${
          'Lorem ipsum '.repeat(100)
        }`;
        fs.writeFileSync(path.join(largeDocsDir, `doc-${i}.md`), content);
      }

      const largeConfig = {
        ...JSON.parse(fs.readFileSync(testConfigPath, 'utf8')),
        paths: {
          docs: largeDocsDir,
          output: testOutputDir
        }
      };
      
      const largeConfigPath = path.join(testOutputDir, 'large-config.json');
      fs.writeFileSync(largeConfigPath, JSON.stringify(largeConfig));

      const startTime = Date.now();
      const result = await runCLI([
        'generate',
        '--config', largeConfigPath,
        '--output', path.join(testOutputDir, 'large-summary.md')
      ], 30000); // 30 second timeout

      const processingTime = Date.now() - startTime;

      expect(result.exitCode).toBe(0);
      expect(processingTime).toBeLessThan(20000); // Should complete in under 20 seconds
      
      const outputFile = path.join(testOutputDir, 'large-summary.md');
      expect(fs.existsSync(outputFile)).toBe(true);
    });
  });
});