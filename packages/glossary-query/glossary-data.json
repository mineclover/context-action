{
  "metadata": {
    "version": "1.0.0",
    "generated": "2025-08-03T10:58:38.213Z",
    "totalTerms": 97,
    "categories": [
      "VALIDATION",
      "api-terms",
      "architecture-terms",
      "core-concepts",
      "naming-conventions"
    ]
  },
  "categories": {
    "VALIDATION": {
      "name": "VALIDATION",
      "description": "This document contains validation results for the Context-Action Framework Glossary System.",
      "termCount": 6,
      "terms": [
        "validation-summary",
        "quality-metrics",
        "recommendations",
        "maintenance-schedule",
        "success-indicators",
        "next-steps"
      ]
    },
    "api-terms": {
      "name": "API Terms",
      "description": "Technical implementation and API concepts for the Context-Action framework.",
      "termCount": 40,
      "terms": [
        "actionregister",
        "storeprovider",
        "actionprovider",
        "store-hooks",
        "cross-store-coordination",
        "async-operations",
        "action-dispatcher",
        "priority-based-execution",
        "computed-store",
        "pipeline-context",
        "selective-subscription",
        "useactiondispatch",
        "useactionregister",
        "store-integration-pattern",
        "store-factory-functions",
        "managed-store",
        "jotai-integration",
        "logger-factory",
        "smart-logger-creation",
        "atom-context-config",
        "atom-provider",
        "useatomstate",
        "useatomreadonly",
        "useatomselect",
        "useatomsetter",
        "actionregister-configuration",
        "cleanup-function",
        "action-metrics",
        "performance-monitoring",
        "action-events",
        "event-driven-architecture",
        "event-handler",
        "event-emitter",
        "observer-pattern",
        "store-snapshot",
        "immutable-state",
        "store-interface",
        "usesyncexternalstore-compatible",
        "registry-pattern",
        "environment-configuration"
      ]
    },
    "architecture-terms": {
      "name": "Architecture Terms",
      "description": "MVVM architecture and design patterns used throughout the Context-Action framework.",
      "termCount": 18,
      "terms": [
        "mvvm-pattern",
        "view-layer",
        "viewmodel-layer",
        "model-layer",
        "lazy-evaluation",
        "decoupled-architecture",
        "unidirectional-data-flow",
        "type-safety",
        "business-logic",
        "deprecated-hoc-patterns",
        "store-integration-pattern",
        "model-layer",
        "fresh-state-access",
        "separation-of-concerns",
        "loose-coupling",
        "predictable-state-updates",
        "compile-time-validation",
        "domain-rules"
      ]
    },
    "core-concepts": {
      "name": "Core Concepts",
      "description": "Fundamental framework concepts and systems that form the foundation of the Context-Action framework.",
      "termCount": 20,
      "terms": [
        "action-pipeline-system",
        "store-integration-pattern",
        "action-handler",
        "pipeline-controller",
        "store-registry",
        "action-payload-map",
        "handler-configuration",
        "actionregister",
        "simple-event-emitter",
        "execution-modes",
        "action-guard",
        "logger-interface",
        "log-level",
        "logger-implementation",
        "console-logger",
        "execution-mode",
        "sequential-execution",
        "performance-optimization",
        "user-experience-optimization",
        "store-immutability"
      ]
    },
    "naming-conventions": {
      "name": "Naming Conventions",
      "description": "Coding standards and naming rules for consistent terminology throughout the Context-Action framework.",
      "termCount": 18,
      "terms": [
        "overview",
        "general-principles",
        "class-naming",
        "interface-naming",
        "function-naming",
        "constant-naming",
        "file-naming",
        "variable-naming",
        "generic-type-parameters",
        "documentation-naming",
        "validation-rules",
        "logger-system-naming",
        "store-system-naming",
        "react-integration-naming",
        "jotai-integration-naming",
        "core-framework-naming",
        "error-and-utility-naming",
        "environment-configuration"
      ]
    }
  },
  "terms": {
    "validation-summary": {
      "id": "validation-summary",
      "title": "Validation Summary",
      "category": "VALIDATION",
      "definition": "VALIDATION 카테고리의 용어",
      "keywords": [
        "validation",
        "summary"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.214Z"
    },
    "quality-metrics": {
      "id": "quality-metrics",
      "title": "Quality Metrics",
      "category": "VALIDATION",
      "definition": "VALIDATION 카테고리의 용어",
      "keywords": [
        "quality",
        "metrics"
      ],
      "aliases": [
        "Quality 메트릭"
      ],
      "implementations": [],
      "relatedTerms": [],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.215Z"
    },
    "recommendations": {
      "id": "recommendations",
      "title": "Recommendations",
      "category": "VALIDATION",
      "definition": "VALIDATION 카테고리의 용어",
      "keywords": [
        "recommendations"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.215Z"
    },
    "maintenance-schedule": {
      "id": "maintenance-schedule",
      "title": "Maintenance Schedule",
      "category": "VALIDATION",
      "definition": "VALIDATION 카테고리의 용어",
      "keywords": [
        "maintenance",
        "schedule"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.215Z"
    },
    "success-indicators": {
      "id": "success-indicators",
      "title": "Success Indicators",
      "category": "VALIDATION",
      "definition": "VALIDATION 카테고리의 용어",
      "keywords": [
        "success",
        "indicators"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.215Z"
    },
    "next-steps": {
      "id": "next-steps",
      "title": "Next Steps",
      "category": "VALIDATION",
      "definition": "VALIDATION 카테고리의 용어",
      "keywords": [
        "next",
        "steps"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.215Z"
    },
    "actionregister": {
      "id": "actionregister",
      "title": "ActionRegister",
      "category": "core-concepts",
      "definition": "중앙화된 액션 등록 및 디스패치 시스템으로, 타입 안전한 액션 파이프라인 관리를 제공하는 핵심 클래스.",
      "keywords": [
        "actionregister",
        "중앙화된",
        "액션",
        "등록",
        "디스패치",
        "시스템으로",
        "타입",
        "안전한",
        "액션",
        "파이프라인"
      ],
      "aliases": [
        "액션Register",
        "Action레지스터",
        "액션 레지스터",
        "액션 등록기"
      ],
      "implementations": [
        {
          "file": "example/src/demos/store-scenarios/actions/index.ts",
          "name": "logger",
          "type": "const",
          "line": 26,
          "description": "Store scenarios 데모용 액션 시스템 설정\nActionRegister를 중심으로 하는 액션 파이프라인과 로깅 시스템을 구성\n",
          "implements": [
            "actionregister",
            "action-pipeline-system"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// 액션 핸들러 등록 (컴포넌트 내부에서)\nuseEffect(() => {\n  const unsubscribe = storeActionRegister.register('updateUser', ({ user }, controller) => {\n    userStore.setValue(user);\n    controller.next();\n  });\n  return unsubscribe;\n}, [userStore]);"
          ],
          "since": "1.0.0",
          "signature": "export const logger = createLogger(LogLevel.DEBUG);",
          "lastModified": "2025-08-02T16:30:24.799Z"
        },
        {
          "file": "packages/core/src/ActionRegister.ts",
          "name": "ActionRegister",
          "type": "class",
          "line": 109,
          "description": "Central action registration and dispatch system",
          "implements": [
            "action-pipeline-system",
            "actionregister"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\ninterface AppActions extends ActionPayloadMap {\n  increment: void;\n  setCount: number;\n  updateUser: { id: string; name: string };\n}\n\nconst actionRegister = new ActionRegister<AppActions>();\n\n// Register handlers with priority and configuration\nactionRegister.register('increment', (_, controller) => {\n  console.log('Incremented');\n  controller.next();\n}, { priority: 10 });\n\nactionRegister.register('setCount', (count, controller) => {\n  console.log(`Count: ${count}`);\n  controller.next();\n});\n\n// Dispatch actions with type safety\nawait actionRegister.dispatch('increment');\nawait actionRegister.dispatch('setCount', 42);\n```"
          ],
          "signature": "export class ActionRegister<T extends ActionPayloadMap = ActionPayloadMap> {",
          "lastModified": "2025-08-02T16:30:24.805Z"
        }
      ],
      "relatedTerms": [
        "action-pipeline-system",
        "action-handler",
        "pipeline-controller"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "storeprovider": {
      "id": "storeprovider",
      "title": "StoreProvider",
      "category": "api-terms",
      "definition": "A React context provider that manages store instances and provides them to child components through the React context system.",
      "keywords": [
        "storeprovider",
        "react",
        "context",
        "provider",
        "that",
        "manages",
        "store",
        "instances",
        "provides",
        "them"
      ],
      "aliases": [
        "스토어Provider",
        "Store프로바이더"
      ],
      "implementations": [
        {
          "file": "packages/react/src/StoreProvider.tsx",
          "name": "StoreProvider",
          "type": "function",
          "line": 67,
          "description": "React context provider for store system",
          "implements": [
            "storeprovider"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nfunction App() {\n  return (\n    <StoreProvider>\n      <ActionProvider>\n        <UserProfile />\n      </ActionProvider>\n    </StoreProvider>\n  );\n}\n\nfunction UserProfile() {\n  const user = useStoreValue(userStore);\n  const settings = useStoreValue(settingsStore);\n  const dispatch = useActionDispatch();\n  \n  const updateUserName = (name: string) => {\n    dispatch('updateUser', { id: user.id, name });\n  };\n  \n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <input \n        value={user.name}\n        onChange={(e) => updateUserName(e.target.value)}\n      />\n      <span>Theme: {settings.theme}</span>\n    </div>\n  );\n}\n```"
          ],
          "signature": "export function StoreProvider({ children, registry }: StoreProviderProps) {",
          "lastModified": "2025-08-02T16:30:24.799Z"
        }
      ],
      "relatedTerms": [
        "actionprovider",
        "store-registry",
        "store-hooks"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "actionprovider": {
      "id": "actionprovider",
      "title": "ActionProvider",
      "category": "api-terms",
      "definition": "A React context provider that manages action registration and dispatch functionality within the React component tree.",
      "keywords": [
        "actionprovider",
        "react",
        "context",
        "provider",
        "that",
        "manages",
        "action",
        "registration",
        "dispatch",
        "functionality"
      ],
      "aliases": [
        "액션Provider",
        "Action프로바이더"
      ],
      "implementations": [],
      "relatedTerms": [
        "storeprovider",
        "action-dispatcher",
        "useactiondispatch"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "store-hooks": {
      "id": "store-hooks",
      "title": "Store Hooks",
      "category": "api-terms",
      "definition": "React hooks that provide reactive access to store values and enable components to subscribe to store changes.",
      "keywords": [
        "store",
        "hooks",
        "react",
        "hooks",
        "that",
        "provide",
        "reactive",
        "access",
        "store",
        "values"
      ],
      "aliases": [
        "스토어 Hooks",
        "Store 훅s"
      ],
      "implementations": [
        {
          "file": "packages/react/src/store/hooks/useStoreValue.ts",
          "name": "useStoreValue",
          "type": "function",
          "line": 25,
          "description": "Hook to get current value from store with optional selector",
          "implements": [
            "store-hooks"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\n// Basic store subscription\nconst counterStore = createStore(0);\nconst count = useStoreValue(counterStore); // number | undefined\n\n// Selective subscription (only re-renders when name changes)\nconst userStore = createStore({ id: '1', name: 'John', email: 'john@example.com' });\nconst userName = useStoreValue(userStore, user => user.name); // string | undefined\n\n// Complex selector\nconst cartStore = createStore({ items: [{ id: '1', price: 10 }, { id: '2', price: 20 }] });\nconst totalPrice = useStoreValue(cartStore, cart => \n  cart.items.reduce((sum, item) => sum + item.price, 0)\n); // number | undefined\n```"
          ],
          "signature": "export function useStoreValue<T>(store: IStore<T> | undefined | null): T | undefined;",
          "lastModified": "2025-08-02T16:30:24.809Z"
        },
        {
          "file": "packages/react/src/store/hooks/useStoreActions.ts",
          "name": "useStoreActions",
          "type": "function",
          "line": 33,
          "description": "Store 액션 핸들러들을 메모이제이션하여 반환\n핵심 기능: Store의 메서드들을 안전하게 바인딩하고 메모이제이션으로 성능 최적화\n",
          "implements": [
            "store-hooks",
            "performance-optimization"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nconst userStore = createStore({ name: 'John', age: 30 });\nconst { setValue, update, getValue } = useStoreActions(userStore);\n\n// 전체 값 교체\nsetValue({ name: 'Jane', age: 25 });\n\n// 부분 업데이트\nupdate(user => ({ ...user, age: user.age + 1 }));\n\n// 현재 값 읽기 (액션 핸들러에서 유용)\nconst currentUser = getValue();\n```"
          ],
          "since": "1.0.0",
          "signature": "export function useStoreActions<T>(store: Store<T> | null | undefined) {",
          "lastModified": "2025-08-02T16:30:24.809Z"
        },
        {
          "file": "packages/react/src/store/hooks/useRegistryStore.ts",
          "name": "useRegistryStore",
          "type": "function",
          "line": 30,
          "description": "Get a specific store from the registry by name\nReplaces deprecated withRegistryStores HOC pattern with modern hook approach\n",
          "implements": [
            "store-hooks"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\n// Basic registry store usage\nconst userStore = useRegistryStore(registry, 'user');\nconst user = useStoreValue(userStore);\n\n// Multiple stores from registry\nconst userStore = useRegistryStore(registry, 'user');\nconst settingsStore = useRegistryStore(registry, 'settings');\nconst user = useStoreValue(userStore);\nconst settings = useStoreValue(settingsStore);\n```"
          ],
          "signature": "export function useRegistryStore(registry: IStoreRegistry, name: string): IStore | undefined {",
          "lastModified": "2025-08-02T16:30:24.809Z"
        },
        {
          "file": "packages/react/src/store/hooks/useRegistry.ts",
          "name": "useRegistry",
          "type": "function",
          "line": 29,
          "description": "Registry 변경사항을 구독하고 등록된 모든 Store 목록 반환\n핵심 기능: Registry의 Store 목록 변경을 감지하여 React 컴포넌트 업데이트\n",
          "implements": [
            "store-hooks"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nfunction StoreList() {\n  const registry = useStoreRegistry();\n  const stores = useRegistry(registry);\n  \n  return (\n    <ul>\n      {stores.map(([name, store]) => (\n        <li key={name}>{name}: {store.getListenerCount()} 구독자</li>\n      ))}\n    </ul>\n  );\n}\n```"
          ],
          "signature": "export function useRegistry(registry: IStoreRegistry | undefined | null): Array<[string, IStore]> {",
          "lastModified": "2025-08-02T16:30:24.809Z"
        },
        {
          "file": "packages/react/src/store/hooks/useLocalStore.ts",
          "name": "useLocalStore",
          "type": "function",
          "line": 39,
          "description": "Create a component-local store that persists across renders\nReplaces deprecated withStore HOC pattern with modern hook approach\nFollowing ARCHITECTURE.md pattern for local store creation\n",
          "implements": [
            "store-hooks"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\n// Basic local store\nconst { value: count, store: counterStore } = useLocalStore(0);\n\n// Named local store\nconst { value: user, store: userStore } = useLocalStore(\n  { id: '', name: '' }, \n  'localUser'\n);\n\n// Use store actions\nconst handleIncrement = () => counterStore.setValue(count + 1);\nconst handleUpdateUser = (name: string) => userStore.update(u => ({ ...u, name }));\n```"
          ],
          "signature": "export function useLocalStore<T>(",
          "lastModified": "2025-08-02T16:30:24.809Z"
        }
      ],
      "relatedTerms": [
        "store-integration-pattern",
        "computed-store",
        "selective-subscription"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "cross-store-coordination": {
      "id": "cross-store-coordination",
      "title": "Cross-Store Coordination",
      "category": "api-terms",
      "definition": "A pattern for coordinating actions across multiple stores within a single action handler, enabling complex business logic that spans multiple data domains.",
      "keywords": [
        "cross",
        "store",
        "coordination",
        "pattern",
        "coordinating",
        "actions",
        "across",
        "multiple",
        "stores",
        "within"
      ],
      "aliases": [
        "Cross-스토어 Coordination"
      ],
      "implementations": [],
      "relatedTerms": [
        "store-integration-pattern",
        "action-handler",
        "atomic-updates"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "async-operations": {
      "id": "async-operations",
      "title": "Async Operations",
      "category": "api-terms",
      "definition": "Asynchronous operations within action handlers that handle external API calls, database operations, and other non-blocking tasks while maintaining proper error handling and state management.",
      "keywords": [
        "async",
        "operations",
        "asynchronous",
        "operations",
        "within",
        "action",
        "handlers",
        "that",
        "handle",
        "external"
      ],
      "aliases": [
        "Async 연산"
      ],
      "implementations": [],
      "relatedTerms": [
        "action-handler",
        "error-handling",
        "loading-states"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "action-dispatcher": {
      "id": "action-dispatcher",
      "title": "Action Dispatcher",
      "category": "api-terms",
      "definition": "A type-safe function interface that enables dispatching actions with proper payload validation and type checking.",
      "keywords": [
        "action",
        "dispatcher",
        "type",
        "safe",
        "function",
        "interface",
        "that",
        "enables",
        "dispatching",
        "actions"
      ],
      "aliases": [
        "액션 Dispatcher",
        "Action 디스패처"
      ],
      "implementations": [
        {
          "file": "packages/react/src/ActionProvider.tsx",
          "name": "useActionDispatch",
          "type": "function",
          "line": 155,
          "description": "Hook to get action dispatch function",
          "implements": [
            "action-dispatcher",
            "useactiondispatch"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nfunction UserProfile() {\n  const dispatch = useActionDispatch<AppActions>();\n  const user = useStoreValue(userStore);\n  \n  const updateName = (name: string) => {\n    dispatch('updateUser', { id: user.id, name });\n  };\n  \n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <button onClick={() => updateName('New Name')}>\n        Update Name\n      </button>\n    </div>\n  );\n}\n```"
          ],
          "signature": "export function useActionDispatch<T extends ActionPayloadMap = ActionPayloadMap>(): ActionRegister<T>['dispatch'] {",
          "lastModified": "2025-08-02T16:30:24.800Z"
        },
        {
          "file": "packages/core/src/types.ts",
          "name": "ActionDispatcher",
          "type": "interface",
          "line": 318,
          "description": "Type-safe action dispatcher interface",
          "implements": [
            "action-dispatcher"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\ninterface AppActions extends ActionPayloadMap {\n  increment: void;\n  setCount: number;\n  updateUser: { id: string; name: string };\n}\n\nconst dispatch: ActionDispatcher<AppActions> = actionRegister.dispatch;\n\n// Type-safe dispatching\nawait dispatch('increment');              // No payload required\nawait dispatch('setCount', 42);          // Number payload required\nawait dispatch('updateUser', { id: '1', name: 'John' }); // Object payload\n```"
          ],
          "since": "1.0.0",
          "signature": "export interface ActionDispatcher<T extends ActionPayloadMap> {",
          "lastModified": "2025-08-02T16:30:24.804Z"
        }
      ],
      "relatedTerms": [
        "action-payload-map",
        "type-safety",
        "useactiondispatch"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "priority-based-execution": {
      "id": "priority-based-execution",
      "title": "Priority-based Execution",
      "category": "api-terms",
      "definition": "A handler execution strategy where action handlers are executed in order of their assigned priority values, with higher priorities running first.",
      "keywords": [
        "priority",
        "based",
        "execution",
        "handler",
        "execution",
        "strategy",
        "where",
        "action",
        "handlers",
        "executed"
      ],
      "aliases": [
        "Priority-based 실행"
      ],
      "implementations": [],
      "relatedTerms": [
        "handler-configuration",
        "action-handler",
        "pipeline-execution"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "computed-store": {
      "id": "computed-store",
      "title": "Computed Store",
      "category": "api-terms",
      "definition": "A reactive store that derives its value from one or more source stores, automatically updating when dependencies change.",
      "keywords": [
        "computed",
        "store",
        "reactive",
        "store",
        "that",
        "derives",
        "its",
        "value",
        "from",
        "one"
      ],
      "aliases": [
        "Computed 스토어"
      ],
      "implementations": [],
      "relatedTerms": [
        "store-hooks",
        "reactive-updates",
        "performance-optimization"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "pipeline-context": {
      "id": "pipeline-context",
      "title": "Pipeline Context",
      "category": "api-terms",
      "definition": "Internal execution context that maintains state during action pipeline processing, including current payload, handler queue, and execution status.",
      "keywords": [
        "pipeline",
        "context",
        "internal",
        "execution",
        "context",
        "that",
        "maintains",
        "state",
        "during",
        "action"
      ],
      "aliases": [
        "파이프라인 Context",
        "Pipeline 컨텍스트",
        "파이프라인 컨텍스트",
        "파이프라인 상황"
      ],
      "implementations": [
        {
          "file": "packages/core/src/types.ts",
          "name": "PipelineContext",
          "type": "interface",
          "line": 222,
          "description": "Internal execution context for action pipeline processing",
          "implements": [
            "pipeline-context"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\n// Internal usage in ActionRegister\nconst context: PipelineContext<UserPayload> = {\n  action: 'updateUser',\n  payload: { id: '123', name: 'John' },\n  handlers: registeredHandlers,\n  aborted: false,\n  currentIndex: 0,\n  executionMode: 'sequential'\n};\n```"
          ],
          "since": "1.0.0",
          "signature": "export interface PipelineContext<T = any> {",
          "lastModified": "2025-08-02T16:30:24.804Z"
        }
      ],
      "relatedTerms": [
        "pipeline-controller",
        "action-pipeline-system",
        "handler-execution"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "selective-subscription": {
      "id": "selective-subscription",
      "title": "Selective Subscription",
      "category": "api-terms",
      "definition": "A pattern that allows components to subscribe to specific parts of store state, enabling optimized re-rendering by only updating when the selected values change.",
      "keywords": [
        "selective",
        "subscription",
        "pattern",
        "that",
        "allows",
        "components",
        "subscribe",
        "specific",
        "parts",
        "store"
      ],
      "aliases": [],
      "implementations": [
        {
          "file": "packages/jotai/src/index.tsx",
          "name": "useAtomSelect",
          "type": "const",
          "line": 346,
          "description": "Hook for selective atom subscription with derived values",
          "implements": [
            "useatomselect",
            "selective-subscription"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nfunction UserThemeDisplay() {\n  // Only re-renders when theme changes, not other user properties\n  const theme = UserAtomContext.useAtomSelect(user => user.preferences.theme);\n  const notificationEnabled = UserAtomContext.useAtomSelect(\n    user => user.preferences.notifications\n  );\n  \n  return (\n    <div className={`theme-${theme}`}>\n      Notifications: {notificationEnabled ? 'On' : 'Off'}\n    </div>\n  );\n}\n```"
          ],
          "since": "1.0.0",
          "signature": "const useAtomSelect = <R,>(callback: (item: T) => R) => {",
          "lastModified": "2025-08-02T16:30:24.801Z"
        },
        {
          "file": "packages/react/src/store/hooks/useStoreValue.ts",
          "name": "useStoreValues",
          "type": "function",
          "line": 74,
          "description": "Hook to get multiple values from a store using selectors",
          "implements": [
            "selective-subscription"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nconst userStore = createStore({ \n  id: '1', \n  name: 'John', \n  email: 'john@example.com',\n  settings: { theme: 'dark', notifications: true }\n});\n\nconst { name, theme } = useStoreValues(userStore, {\n  name: user => user.name,\n  theme: user => user.settings.theme\n});\n// Only re-renders when name or theme changes\n```"
          ],
          "signature": "export function useStoreValues<T, S extends Record<string, (value: T) => any>>(",
          "lastModified": "2025-08-02T16:30:24.809Z"
        }
      ],
      "relatedTerms": [
        "store-hooks",
        "performance-optimization",
        "reactive-updates"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "useactiondispatch": {
      "id": "useactiondispatch",
      "title": "useActionDispatch",
      "category": "api-terms",
      "definition": "액션 디스패치 함수를 반환하는 React Hook으로, 컴포넌트에서 타입 안전한 액션 발생을 위해 사용.",
      "keywords": [
        "useactiondispatch",
        "액션",
        "디스패치",
        "함수를",
        "반환하는",
        "react",
        "hook으로",
        "컴포넌트에서",
        "타입",
        "안전한"
      ],
      "aliases": [
        "use액션Dispatch",
        "액션 디스패치 훅",
        "useAction",
        "액션 훅"
      ],
      "implementations": [
        {
          "file": "packages/react/src/ActionProvider.tsx",
          "name": "useActionDispatch",
          "type": "function",
          "line": 155,
          "description": "Hook to get action dispatch function",
          "implements": [
            "action-dispatcher",
            "useactiondispatch"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nfunction UserProfile() {\n  const dispatch = useActionDispatch<AppActions>();\n  const user = useStoreValue(userStore);\n  \n  const updateName = (name: string) => {\n    dispatch('updateUser', { id: user.id, name });\n  };\n  \n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <button onClick={() => updateName('New Name')}>\n        Update Name\n      </button>\n    </div>\n  );\n}\n```"
          ],
          "signature": "export function useActionDispatch<T extends ActionPayloadMap = ActionPayloadMap>(): ActionRegister<T>['dispatch'] {",
          "lastModified": "2025-08-02T16:30:24.800Z"
        }
      ],
      "relatedTerms": [
        "actionprovider",
        "action-dispatcher",
        "action-payload-map"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "useactionregister": {
      "id": "useactionregister",
      "title": "useActionRegister",
      "category": "api-terms",
      "definition": "ActionRegister 인스턴스에 직접 접근할 수 있는 React Hook으로, 핸들러 등록 및 관리를 위해 사용.",
      "keywords": [
        "useactionregister",
        "actionregister",
        "인스턴스에",
        "직접",
        "접근할",
        "있는",
        "react",
        "hook으로",
        "핸들러",
        "등록"
      ],
      "aliases": [
        "use액션Register",
        "useAction레지스터"
      ],
      "implementations": [
        {
          "file": "packages/react/src/ActionProvider.tsx",
          "name": "useActionRegister",
          "type": "function",
          "line": 202,
          "description": "Hook to get ActionRegister instance for handler registration\nFollowing ARCHITECTURE.md pattern for action handler registration\n",
          "implements": [
            "useactionregister"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\nfunction useUserActions() {\n  const actionRegister = useActionRegister<AppActions>();\n  const registry = useStoreRegistry();\n  \n  useEffect(() => {\n    const userStore = registry.getStore('user');\n    const settingsStore = registry.getStore('settings');\n    \n    const unregister = actionRegister.register('updateUser', \n      async (payload, controller) => {\n        const user = userStore.getValue();\n        const settings = settingsStore.getValue();\n        \n        // Business logic\n        if (settings.validateNames && !isValidName(payload.name)) {\n          controller.abort('Invalid name');\n          return;\n        }\n        \n        userStore.setValue({\n          ...user,\n          ...payload,\n          updatedAt: Date.now()\n        });\n      },\n      { priority: 10, blocking: true }\n    );\n    \n    return unregister;\n  }, [registry]);\n}\n```"
          ],
          "signature": "export function useActionRegister<T extends ActionPayloadMap = ActionPayloadMap>(): ActionRegister<T> {",
          "lastModified": "2025-08-02T16:30:24.800Z"
        }
      ],
      "relatedTerms": [
        "actionprovider",
        "actionregister",
        "action-handler"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "store-integration-pattern": {
      "id": "store-integration-pattern",
      "title": "Store Integration Pattern",
      "category": "core-concepts",
      "definition": "The architectural pattern that enables action handlers to read and update stores while maintaining loose coupling between components.",
      "keywords": [
        "store",
        "integration",
        "pattern",
        "architectural",
        "pattern",
        "that",
        "enables",
        "action",
        "handlers",
        "read"
      ],
      "aliases": [
        "스토어 Integration Pattern",
        "Store Integration 패턴",
        "Store 통합 Pattern",
        "스토어 통합 패턴"
      ],
      "implementations": [
        {
          "file": "example/src/pages/store/StoreFullDemoPage.tsx",
          "name": "StoreActionSetup",
          "type": "function",
          "line": 35,
          "description": "모듈화된 Store 시스템 데모 페이지\n8개의 실제 시나리오를 통해 Context Store 패턴의 활용을 보여주는 종합 데모\n",
          "implements": [
            "store-integration-pattern",
            "action-pipeline-system"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// 모듈화된 Store 시스템 사용 예제\n<StoreScenarios.Provider registryId=\"store-full-demo\">\n  <UserProfileDemo />\n  <ShoppingCartDemo />\n  <TodoListDemo />\n  <ChatDemo />\n</StoreScenarios.Provider>"
          ],
          "since": "1.0.0",
          "signature": "function StoreActionSetup() {",
          "lastModified": "2025-08-02T16:30:24.794Z"
        },
        {
          "file": "example/src/pages/react/ReactHooksPage.tsx",
          "name": "HooksStores",
          "type": "const",
          "line": 44,
          "description": "React Hooks 최적화 데모용 Context Store 패턴\n메모이제이션과 성능 최적화 예제를 위한 Store 격리 시스템\n",
          "implements": [
            "store-registry",
            "performance-optimization",
            "store-integration-pattern"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// React Hooks 최적화를 위한 Context Store 패턴\nconst HooksStores = createContextStorePattern('ReactHooks');\n\n// 컴포넌트에서 Store 사용\nconst calculationStore = HooksStores.useStore('calculation', { result: 0, computeTime: 0 });\nconst memoryStore = HooksStores.useStore('memory', { objects: 0, allocatedMB: 0 });"
          ],
          "since": "1.0.0",
          "signature": "const HooksStores = createContextStorePattern('ReactHooks');",
          "lastModified": "2025-08-02T16:30:24.795Z"
        },
        {
          "file": "example/src/pages/react/ReactContextPage.tsx",
          "name": "GlobalStores",
          "type": "const",
          "line": 60,
          "description": "React 다중 컨텍스트 시스템용 Context Store 패턴\n계층적 컨텍스트에서 Store Registry 격리를 제공\n",
          "implements": [
            "store-registry",
            "store-integration-pattern"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// 전역 스토어들을 위한 Context Store 패턴\nconst GlobalStores = createContextStorePattern('ReactContextGlobal');\n\n// Provider 계층 구조\n<GlobalStores.Provider>\n  <LocalContextProvider contextId=\"local-A\">\n    <NestedContextProvider level={1}>\n      <InteractiveControls />\n    </NestedContextProvider>\n  </LocalContextProvider>\n</GlobalStores.Provider>"
          ],
          "since": "1.0.0",
          "signature": "const GlobalStores = createContextStorePattern('ReactContextGlobal');",
          "lastModified": "2025-08-02T16:30:24.796Z"
        },
        {
          "file": "example/src/demos/store-scenarios/stores/index.ts",
          "name": "StoreScenarios",
          "type": "const",
          "line": 33,
          "description": "Store-scenarios용 Context Store 패턴 팩토리\nProvider별 독립적인 Registry 영역을 생성하여 Store 격리를 제공\n",
          "implements": [
            "store-registry",
            "store-integration-pattern"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// Context Store 패턴 사용법\nexport const StoreScenarios = createContextStorePattern('StoreScenarios');\n\n// Provider로 감싸기\n<StoreScenarios.Provider registryId=\"demo\">\n  <UserProfileDemo />\n</StoreScenarios.Provider>\n\n// 컴포넌트에서 Store 사용\nconst userStore = StoreScenarios.useStore('user', defaultUser);"
          ],
          "since": "1.0.0",
          "signature": "export const StoreScenarios = createContextStorePattern('StoreScenarios');",
          "lastModified": "2025-08-02T16:30:24.798Z"
        },
        {
          "file": "example/src/demos/store-scenarios/components/UserProfileDemo.tsx",
          "name": "UserProfileDemo",
          "type": "function",
          "line": 22,
          "description": "사용자 프로필 관리 데모 컴포넌트\n복잡한 객체 업데이트와 중첩된 속성 관리를 보여주는 Context Store 패턴 예제\n",
          "implements": [
            "store-integration-pattern",
            "action-handler"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// Context Store 패턴을 사용한 사용자 프로필 관리\n<StoreScenarios.Provider registryId=\"user-profile-demo\">\n  <UserProfileDemo />\n</StoreScenarios.Provider>"
          ],
          "since": "1.0.0",
          "signature": "export function UserProfileDemo() {",
          "lastModified": "2025-08-02T16:30:24.798Z"
        },
        {
          "file": "example/src/demos/store-scenarios/components/TodoListDemo.tsx",
          "name": "TodoListDemo",
          "type": "function",
          "line": 21,
          "description": "할일 목록 관리 데모 컴포넌트\nCRUD 작업과 필터링, 정렬 기능을 보여주는 Context Store 패턴 예제\n",
          "implements": [
            "store-integration-pattern",
            "action-handler"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// 할일 목록 관리를 위한 Context Store 패턴\nconst todosStore = StoreScenarios.useStore('todos', initialTodos);\nconst todos = useStoreValue(todosStore);"
          ],
          "since": "1.0.0",
          "signature": "export function TodoListDemo() {",
          "lastModified": "2025-08-02T16:30:24.798Z"
        },
        {
          "file": "example/src/demos/store-scenarios/components/ShoppingCartDemo.tsx",
          "name": "ShoppingCartDemo",
          "type": "function",
          "line": 21,
          "description": "쇼핑카트 시스템 데모 컴포넌트\n배열 조작과 수량 추적, 계산된 총합을 관리하는 Context Store 패턴 예제\n",
          "implements": [
            "store-integration-pattern",
            "action-handler"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// 쇼핑카트 관리를 위한 Context Store 패턴\nconst productsStore = StoreScenarios.useStore('products', initialProducts);\nconst cartStore = StoreScenarios.useStore('cart', [] as CartItem[]);"
          ],
          "since": "1.0.0",
          "signature": "export function ShoppingCartDemo() {",
          "lastModified": "2025-08-02T16:30:24.798Z"
        },
        {
          "file": "example/src/demos/store-scenarios/components/ChatDemo.tsx",
          "name": "ChatDemo",
          "type": "function",
          "line": 23,
          "description": "실시간 채팅 시스템 데모 컴포넌트\n메시지 스트리밍과 자동 스크롤 기능을 보여주는 Context Store 패턴 예제\n",
          "implements": [
            "store-integration-pattern",
            "action-handler"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// 실시간 채팅을 위한 Context Store 패턴\nconst chatStore = StoreScenarios.useStore('chat', initialMessages);\nconst messages = useStoreValue(chatStore);"
          ],
          "since": "1.0.0",
          "signature": "export function ChatDemo() {",
          "lastModified": "2025-08-02T16:30:24.799Z"
        },
        {
          "file": "packages/react/src/store/Store.ts",
          "name": "Store",
          "type": "class",
          "line": 25,
          "description": "Store 클래스 - 중앙화된 상태 관리의 핵심\n\n핵심 기능:\n1. 상태 저장 (_value) - 실제 데이터 보관\n2. 구독 관리 (listeners) - React 컴포넌트들의 구독 추적\n3. 스냅샷 관리 (_snapshot) - 불변성과 최적화를 위한 스냅샷\n4. 변경 알림 (_notifyListeners) - 상태 변경 시 구독자들에게 알림\n",
          "implements": [
            "store-integration-pattern",
            "model-layer"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [],
          "signature": "export class Store<T = any> implements IStore<T> {",
          "lastModified": "2025-08-02T16:30:24.808Z"
        }
      ],
      "relatedTerms": [
        "action-handler",
        "cross-store-coordination",
        "lazy-evaluation"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "store-factory-functions": {
      "id": "store-factory-functions",
      "title": "Store Factory Functions",
      "category": "api-terms",
      "definition": "Store 인스턴스 생성을 위한 팩토리 함수들로, 타입 안전하고 간편한 Store 생성을 제공.",
      "keywords": [
        "store",
        "factory",
        "functions",
        "store",
        "인스턴스",
        "생성을",
        "위한",
        "팩토리",
        "함수들로",
        "타입"
      ],
      "aliases": [
        "스토어 Factory Functions"
      ],
      "implementations": [],
      "relatedTerms": [
        "store-integration-pattern",
        "store-registry",
        "managed-store"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "managed-store": {
      "id": "managed-store",
      "title": "Managed Store",
      "category": "api-terms",
      "definition": "자동 레지스트리 등록 기능을 갖춘 향상된 Store 클래스로, 라이프사이클 관리를 자동화.",
      "keywords": [
        "managed",
        "store",
        "자동",
        "레지스트리",
        "등록",
        "기능을",
        "갖춘",
        "향상된",
        "store",
        "클래스로"
      ],
      "aliases": [
        "Managed 스토어"
      ],
      "implementations": [],
      "relatedTerms": [
        "store-integration-pattern",
        "store-registry",
        "store-factory-functions"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "jotai-integration": {
      "id": "jotai-integration",
      "title": "Jotai Integration",
      "category": "api-terms",
      "definition": "Jotai 상태 관리 라이브러리와 Context-Action 프레임워크를 통합하는 유틸리티 시스템.",
      "keywords": [
        "jotai",
        "integration",
        "jotai",
        "상태",
        "관리",
        "라이브러리와",
        "context",
        "action",
        "프레임워크를",
        "통합하는"
      ],
      "aliases": [
        "Jotai 통합"
      ],
      "implementations": [],
      "relatedTerms": [
        "store-integration-pattern",
        "selective-subscription",
        "context-integration"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "logger-factory": {
      "id": "logger-factory",
      "title": "Logger Factory",
      "category": "api-terms",
      "definition": "Factory function for creating appropriately configured logger instances with automatic environment detection and optimal logger selection.",
      "keywords": [
        "logger",
        "factory",
        "factory",
        "function",
        "creating",
        "appropriately",
        "configured",
        "logger",
        "instances",
        "automatic"
      ],
      "aliases": [
        "로거 Factory"
      ],
      "implementations": [
        {
          "file": "packages/logger/src/index.ts",
          "name": "createLogger",
          "type": "function",
          "line": 304,
          "description": "Create a logger instance with specified or environment-based level",
          "implements": [
            "logger-factory",
            "smart-logger-creation"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\n// Environment-based logger creation\nconst logger = createLogger(); // Uses NODE_ENV and environment variables\n\n// Explicit level logger creation\nconst debugLogger = createLogger(LogLevel.DEBUG);\nconst productionLogger = createLogger(LogLevel.ERROR);\nconst silentLogger = createLogger(LogLevel.NONE); // Returns NoopLogger\n\n// Usage in ActionRegister\nconst actionRegister = new ActionRegister({ \n  logger: createLogger(LogLevel.DEBUG),\n  name: 'UserActions' \n});\n```"
          ],
          "since": "1.0.0",
          "signature": "export function createLogger(level?: LogLevel): Logger {",
          "lastModified": "2025-08-02T16:30:24.800Z"
        }
      ],
      "relatedTerms": [
        "logger-system",
        "environment-configuration"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "smart-logger-creation": {
      "id": "smart-logger-creation",
      "title": "Smart Logger Creation",
      "category": "api-terms",
      "definition": "Intelligent logger creation process that automatically detects appropriate configuration from environment variables and application context.",
      "keywords": [
        "smart",
        "logger",
        "creation",
        "intelligent",
        "logger",
        "creation",
        "process",
        "that",
        "automatically",
        "detects"
      ],
      "aliases": [
        "Smart 로거 Creation"
      ],
      "implementations": [
        {
          "file": "packages/logger/src/index.ts",
          "name": "createLogger",
          "type": "function",
          "line": 304,
          "description": "Create a logger instance with specified or environment-based level",
          "implements": [
            "logger-factory",
            "smart-logger-creation"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\n// Environment-based logger creation\nconst logger = createLogger(); // Uses NODE_ENV and environment variables\n\n// Explicit level logger creation\nconst debugLogger = createLogger(LogLevel.DEBUG);\nconst productionLogger = createLogger(LogLevel.ERROR);\nconst silentLogger = createLogger(LogLevel.NONE); // Returns NoopLogger\n\n// Usage in ActionRegister\nconst actionRegister = new ActionRegister({ \n  logger: createLogger(LogLevel.DEBUG),\n  name: 'UserActions' \n});\n```"
          ],
          "since": "1.0.0",
          "signature": "export function createLogger(level?: LogLevel): Logger {",
          "lastModified": "2025-08-02T16:30:24.800Z"
        }
      ],
      "relatedTerms": [
        "logger-factory",
        "environment-configuration"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "atom-context-config": {
      "id": "atom-context-config",
      "title": "Atom Context Config",
      "category": "api-terms",
      "definition": "Configuration options for Jotai atom context creation with logging support and behavior customization.",
      "keywords": [
        "atom",
        "context",
        "config",
        "configuration",
        "options",
        "jotai",
        "atom",
        "context",
        "creation",
        "logging"
      ],
      "aliases": [
        "Atom 컨텍스트 Config"
      ],
      "implementations": [
        {
          "file": "packages/jotai/src/index.tsx",
          "name": "AtomContextConfig",
          "type": "interface",
          "line": 109,
          "description": "Configuration options for createAtomContext",
          "implements": [
            "atom-context-config"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nconst config: AtomContextConfig = {\n  logger: createLogger(LogLevel.DEBUG),\n  logLevel: LogLevel.DEBUG\n};\n\nconst AtomContext = createAtomContext(initialValue, config);\n```"
          ],
          "since": "1.0.0",
          "signature": "export interface AtomContextConfig {",
          "lastModified": "2025-08-02T16:30:24.801Z"
        }
      ],
      "relatedTerms": [
        "jotai-integration",
        "logger-system"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "atom-provider": {
      "id": "atom-provider",
      "title": "Atom Provider",
      "category": "api-terms",
      "definition": "React Context Provider component for Jotai atoms that provides atom instance and logger to child components within the context tree.",
      "keywords": [
        "atom",
        "provider",
        "react",
        "context",
        "provider",
        "component",
        "jotai",
        "atoms",
        "that",
        "provides"
      ],
      "aliases": [
        "Atom 프로바이더"
      ],
      "implementations": [
        {
          "file": "packages/jotai/src/index.tsx",
          "name": "Provider",
          "type": "const",
          "line": 209,
          "description": "Provider component for atom context sharing",
          "implements": [
            "atom-provider"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [],
          "since": "1.0.0",
          "signature": "const Provider = ({ children }: { children: ReactNode }) => {",
          "lastModified": "2025-08-02T16:30:24.801Z"
        }
      ],
      "relatedTerms": [
        "jotai-integration",
        "context-integration"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "useatomstate": {
      "id": "useatomstate",
      "title": "useAtomState",
      "category": "api-terms",
      "definition": "Primary hook for full Jotai atom state management, returning both current value and setter function for state updates.",
      "keywords": [
        "useatomstate",
        "primary",
        "hook",
        "full",
        "jotai",
        "atom",
        "state",
        "management",
        "returning",
        "both"
      ],
      "aliases": [],
      "implementations": [
        {
          "file": "packages/jotai/src/index.tsx",
          "name": "useAtomState",
          "type": "const",
          "line": 268,
          "description": "Hook that returns both atom value and setter",
          "implements": [
            "useatomstate"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nfunction UserEditor() {\n  const [user, setUser] = UserAtomContext.useAtomState();\n  \n  const handleUpdate = (field: string, value: any) => {\n    setUser(prev => ({ ...prev, [field]: value }));\n  };\n  \n  return (\n    <form>\n      <input \n        value={user.name} \n        onChange={e => handleUpdate('name', e.target.value)} \n      />\n    </form>\n  );\n}\n```"
          ],
          "since": "1.0.0",
          "signature": "const useAtomState = () => {",
          "lastModified": "2025-08-02T16:30:24.801Z"
        }
      ],
      "relatedTerms": [
        "jotai-integration",
        "useatomreadonly"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.216Z"
    },
    "useatomreadonly": {
      "id": "useatomreadonly",
      "title": "useAtomReadOnly",
      "category": "api-terms",
      "definition": "Performance-optimized hook for read-only access to Jotai atom value, ideal for display components that don't need to update state.",
      "keywords": [
        "useatomreadonly",
        "performance",
        "optimized",
        "hook",
        "read",
        "only",
        "access",
        "jotai",
        "atom",
        "value"
      ],
      "aliases": [],
      "implementations": [
        {
          "file": "packages/jotai/src/index.tsx",
          "name": "useAtomReadOnly",
          "type": "const",
          "line": 305,
          "description": "Hook that returns read-only atom value",
          "implements": [
            "useatomreadonly"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nfunction UserDisplay() {\n  const user = UserAtomContext.useAtomReadOnly();\n  \n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n    </div>\n  );\n}\n```"
          ],
          "since": "1.0.0",
          "signature": "const useAtomReadOnly = () => {",
          "lastModified": "2025-08-02T16:30:24.801Z"
        }
      ],
      "relatedTerms": [
        "useatomstate",
        "useatomselect"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "useatomselect": {
      "id": "useatomselect",
      "title": "useAtomSelect",
      "category": "api-terms",
      "definition": "Performance optimization hook that creates derived atoms for selective subscriptions, minimizing re-renders by subscribing only to specific parts of the atom state.",
      "keywords": [
        "useatomselect",
        "performance",
        "optimization",
        "hook",
        "that",
        "creates",
        "derived",
        "atoms",
        "selective",
        "subscriptions"
      ],
      "aliases": [],
      "implementations": [
        {
          "file": "packages/jotai/src/index.tsx",
          "name": "useAtomSelect",
          "type": "const",
          "line": 346,
          "description": "Hook for selective atom subscription with derived values",
          "implements": [
            "useatomselect",
            "selective-subscription"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nfunction UserThemeDisplay() {\n  // Only re-renders when theme changes, not other user properties\n  const theme = UserAtomContext.useAtomSelect(user => user.preferences.theme);\n  const notificationEnabled = UserAtomContext.useAtomSelect(\n    user => user.preferences.notifications\n  );\n  \n  return (\n    <div className={`theme-${theme}`}>\n      Notifications: {notificationEnabled ? 'On' : 'Off'}\n    </div>\n  );\n}\n```"
          ],
          "since": "1.0.0",
          "signature": "const useAtomSelect = <R,>(callback: (item: T) => R) => {",
          "lastModified": "2025-08-02T16:30:24.801Z"
        }
      ],
      "relatedTerms": [
        "selective-subscription",
        "useatomstate"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "useatomsetter": {
      "id": "useatomsetter",
      "title": "useAtomSetter",
      "category": "api-terms",
      "definition": "Write-only hook for Jotai atoms that returns only the setter function, avoiding unnecessary re-renders for components that update state but don't need to subscribe to value changes.",
      "keywords": [
        "useatomsetter",
        "write",
        "only",
        "hook",
        "jotai",
        "atoms",
        "that",
        "returns",
        "only",
        "setter"
      ],
      "aliases": [],
      "implementations": [
        {
          "file": "packages/jotai/src/index.tsx",
          "name": "useAtomSetter",
          "type": "const",
          "line": 401,
          "description": "Hook that returns only the atom setter function",
          "implements": [
            "useatomsetter"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nfunction UserActionButtons() {\n  const setUser = UserAtomContext.useAtomSetter();\n  \n  const resetUser = () => {\n    setUser({ id: '', name: '', email: '', preferences: defaultPrefs });\n  };\n  \n  const toggleNotifications = () => {\n    setUser(prev => ({\n      ...prev,\n      preferences: {\n        ...prev.preferences,\n        notifications: !prev.preferences.notifications\n      }\n    }));\n  };\n  \n  return (\n    <div>\n      <button onClick={resetUser}>Reset</button>\n      <button onClick={toggleNotifications}>Toggle Notifications</button>\n    </div>\n  );\n}\n```"
          ],
          "since": "1.0.0",
          "signature": "const useAtomSetter = () => {",
          "lastModified": "2025-08-02T16:30:24.801Z"
        }
      ],
      "relatedTerms": [
        "useatomstate",
        "performance-optimization"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "actionregister-configuration": {
      "id": "actionregister-configuration",
      "title": "ActionRegister Configuration",
      "category": "api-terms",
      "definition": "Configuration options for ActionRegister instances, including logging setup, debugging options, and default execution behavior.",
      "keywords": [
        "actionregister",
        "configuration",
        "configuration",
        "options",
        "actionregister",
        "instances",
        "including",
        "logging",
        "setup",
        "debugging"
      ],
      "aliases": [
        "액션Register Configuration",
        "ActionRegister 설정",
        "Action레지스터 Configuration"
      ],
      "implementations": [
        {
          "file": "packages/core/src/types.ts",
          "name": "ActionRegisterConfig",
          "type": "interface",
          "line": 255,
          "description": "Configuration options for ActionRegister",
          "implements": [
            "actionregister-configuration"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nconst config: ActionRegisterConfig = {\n  logger: createLogger(LogLevel.DEBUG),\n  logLevel: LogLevel.INFO,\n  name: 'UserActions',\n  debug: true,\n  defaultExecutionMode: 'sequential'\n};\n\nconst actionRegister = new ActionRegister(config);\n```"
          ],
          "since": "1.0.0",
          "signature": "export interface ActionRegisterConfig {",
          "lastModified": "2025-08-02T16:30:24.804Z"
        }
      ],
      "relatedTerms": [
        "actionregister",
        "logger-system"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "cleanup-function": {
      "id": "cleanup-function",
      "title": "Cleanup Function",
      "category": "api-terms",
      "definition": "Function type for unregistering action handlers from the pipeline, returned by the register method to provide cleanup capability.",
      "keywords": [
        "cleanup",
        "function",
        "function",
        "type",
        "unregistering",
        "action",
        "handlers",
        "from",
        "pipeline",
        "returned"
      ],
      "aliases": [
        "정리 Function"
      ],
      "implementations": [
        {
          "file": "packages/core/src/types.ts",
          "name": "UnregisterFunction",
          "type": "type",
          "line": 289,
          "description": "Unregister function returned by register method",
          "implements": [
            "cleanup-function"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nconst unregister = actionRegister.register('updateUser', handler);\n\n// Later, remove the handler\nunregister();\n```"
          ],
          "since": "1.0.0",
          "signature": "export type UnregisterFunction = () => void;",
          "lastModified": "2025-08-02T16:30:24.804Z"
        }
      ],
      "relatedTerms": [
        "action-handler",
        "actionregister"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "action-metrics": {
      "id": "action-metrics",
      "title": "Action Metrics",
      "category": "api-terms",
      "definition": "Performance metrics interface for action execution performance and status, used for monitoring, debugging, and performance optimization.",
      "keywords": [
        "action",
        "metrics",
        "performance",
        "metrics",
        "interface",
        "action",
        "execution",
        "performance",
        "status",
        "used"
      ],
      "aliases": [
        "액션 Metrics",
        "Action 메트릭"
      ],
      "implementations": [
        {
          "file": "packages/core/src/types.ts",
          "name": "ActionMetrics",
          "type": "interface",
          "line": 344,
          "description": "Performance metrics for action execution",
          "implements": [
            "action-metrics",
            "performance-monitoring"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nactionRegister.on('action:complete', ({ metrics }) => {\n  console.log(`Action ${metrics.action} took ${metrics.executionTime}ms`);\n  console.log(`Success: ${metrics.success}, Handlers: ${metrics.handlerCount}`);\n});\n```"
          ],
          "since": "1.0.0",
          "signature": "export interface ActionMetrics {",
          "lastModified": "2025-08-02T16:30:24.804Z"
        }
      ],
      "relatedTerms": [
        "performance-monitoring",
        "actionregister"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "performance-monitoring": {
      "id": "performance-monitoring",
      "title": "Performance Monitoring",
      "category": "api-terms",
      "definition": "Comprehensive system for tracking and analyzing performance metrics across the Context-Action framework components.",
      "keywords": [
        "performance",
        "monitoring",
        "comprehensive",
        "system",
        "tracking",
        "analyzing",
        "performance",
        "metrics",
        "across",
        "context"
      ],
      "aliases": [],
      "implementations": [
        {
          "file": "packages/core/src/types.ts",
          "name": "ActionMetrics",
          "type": "interface",
          "line": 344,
          "description": "Performance metrics for action execution",
          "implements": [
            "action-metrics",
            "performance-monitoring"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nactionRegister.on('action:complete', ({ metrics }) => {\n  console.log(`Action ${metrics.action} took ${metrics.executionTime}ms`);\n  console.log(`Success: ${metrics.success}, Handlers: ${metrics.handlerCount}`);\n});\n```"
          ],
          "since": "1.0.0",
          "signature": "export interface ActionMetrics {",
          "lastModified": "2025-08-02T16:30:24.804Z"
        }
      ],
      "relatedTerms": [
        "action-metrics",
        "performance-optimization"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "action-events": {
      "id": "action-events",
      "title": "Action Events",
      "category": "api-terms",
      "definition": "Event types emitted by ActionRegister instances that enable reactive programming and monitoring of action lifecycle events.",
      "keywords": [
        "action",
        "events",
        "event",
        "types",
        "emitted",
        "actionregister",
        "instances",
        "that",
        "enable",
        "reactive"
      ],
      "aliases": [
        "액션 Events",
        "Action 이벤트"
      ],
      "implementations": [
        {
          "file": "packages/core/src/types.ts",
          "name": "ActionRegisterEvents",
          "type": "interface",
          "line": 382,
          "description": "Event types emitted by ActionRegister",
          "implements": [
            "action-events",
            "event-driven-architecture"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\ninterface AppActions extends ActionPayloadMap {\n  updateUser: { id: string; name: string };\n}\n\nconst actionRegister = new ActionRegister<AppActions>();\n\nactionRegister.on('action:start', ({ action, payload }) => {\n  console.log(`Starting action: ${action}`, payload);\n});\n\nactionRegister.on('action:complete', ({ action, metrics }) => {\n  console.log(`Completed: ${action} in ${metrics.executionTime}ms`);\n});\n```"
          ],
          "since": "1.0.0",
          "signature": "export interface ActionRegisterEvents<T extends ActionPayloadMap = ActionPayloadMap> {",
          "lastModified": "2025-08-02T16:30:24.804Z"
        }
      ],
      "relatedTerms": [
        "event-driven-architecture",
        "actionregister"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "event-driven-architecture": {
      "id": "event-driven-architecture",
      "title": "Event Driven Architecture",
      "category": "api-terms",
      "definition": "Architectural pattern that enables reactive programming and monitoring through event emission and handling across framework components.",
      "keywords": [
        "event",
        "driven",
        "architecture",
        "architectural",
        "pattern",
        "that",
        "enables",
        "reactive",
        "programming",
        "monitoring"
      ],
      "aliases": [
        "Event Driven 아키텍처"
      ],
      "implementations": [
        {
          "file": "packages/core/src/types.ts",
          "name": "ActionRegisterEvents",
          "type": "interface",
          "line": 382,
          "description": "Event types emitted by ActionRegister",
          "implements": [
            "action-events",
            "event-driven-architecture"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\ninterface AppActions extends ActionPayloadMap {\n  updateUser: { id: string; name: string };\n}\n\nconst actionRegister = new ActionRegister<AppActions>();\n\nactionRegister.on('action:start', ({ action, payload }) => {\n  console.log(`Starting action: ${action}`, payload);\n});\n\nactionRegister.on('action:complete', ({ action, metrics }) => {\n  console.log(`Completed: ${action} in ${metrics.executionTime}ms`);\n});\n```"
          ],
          "since": "1.0.0",
          "signature": "export interface ActionRegisterEvents<T extends ActionPayloadMap = ActionPayloadMap> {",
          "lastModified": "2025-08-02T16:30:24.804Z"
        }
      ],
      "relatedTerms": [
        "action-events",
        "event-handler"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "event-handler": {
      "id": "event-handler",
      "title": "Event Handler",
      "category": "api-terms",
      "definition": "Function type for handling events emitted by ActionRegister and other framework components.",
      "keywords": [
        "event",
        "handler",
        "function",
        "type",
        "handling",
        "events",
        "emitted",
        "actionregister",
        "other",
        "framework"
      ],
      "aliases": [
        "Event 핸들러"
      ],
      "implementations": [
        {
          "file": "packages/core/src/types.ts",
          "name": "EventHandler",
          "type": "type",
          "line": 412,
          "description": "Event handler type for ActionRegister events",
          "implements": [
            "event-handler"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [],
          "since": "1.0.0",
          "signature": "export type EventHandler<T = any> = (data: T) => void;",
          "lastModified": "2025-08-02T16:30:24.804Z"
        }
      ],
      "relatedTerms": [
        "event-driven-architecture",
        "event-emitter"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "event-emitter": {
      "id": "event-emitter",
      "title": "Event Emitter",
      "category": "api-terms",
      "definition": "Basic event emitter interface for ActionRegister event system, providing methods for subscribing, emitting, and unsubscribing from events.",
      "keywords": [
        "event",
        "emitter",
        "basic",
        "event",
        "emitter",
        "interface",
        "actionregister",
        "event",
        "system",
        "providing"
      ],
      "aliases": [],
      "implementations": [
        {
          "file": "packages/core/src/types.ts",
          "name": "EventEmitter",
          "type": "interface",
          "line": 425,
          "description": "Simple event emitter interface",
          "implements": [
            "event-emitter"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [],
          "since": "1.0.0",
          "signature": "export interface EventEmitter<T extends Record<string, any> = Record<string, any>> {",
          "lastModified": "2025-08-02T16:30:24.804Z"
        }
      ],
      "relatedTerms": [
        "event-handler",
        "event-driven-architecture"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "observer-pattern": {
      "id": "observer-pattern",
      "title": "Observer Pattern",
      "category": "api-terms",
      "definition": "Design pattern implementation for reactive state management where Store instances notify subscribed components of state changes.",
      "keywords": [
        "observer",
        "pattern",
        "design",
        "pattern",
        "implementation",
        "reactive",
        "state",
        "management",
        "where",
        "store"
      ],
      "aliases": [
        "Observer 패턴"
      ],
      "implementations": [
        {
          "file": "packages/react/src/store/types.ts",
          "name": "Listener",
          "type": "type",
          "line": 34,
          "description": "Basic subscription types for Observer pattern implementation",
          "implements": [
            "observer-pattern"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [],
          "since": "1.0.0",
          "signature": "export type Listener = () => void;",
          "lastModified": "2025-08-02T16:30:24.806Z"
        },
        {
          "file": "packages/react/src/store/types.ts",
          "name": "Listener",
          "type": "type",
          "line": 34,
          "description": "Core Store interface for reactive state management",
          "implements": [
            "store-interface",
            "usesyncexternalstore-compatible",
            "observer-pattern"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\nconst userStore: IStore<User> = createStore('user', { \n  id: '', \n  name: '', \n  email: '' \n});\n\n// Subscribe to changes\nconst unsubscribe = userStore.subscribe(() => {\n  console.log('User store updated:', userStore.getSnapshot().value);\n});\n\n// Update store value\nuserStore.setValue({ id: '1', name: 'John', email: 'john@example.com' });\n\n// Get current value for action handlers\nconst currentUser = userStore.getValue();\n```"
          ],
          "since": "1.0.0",
          "signature": "export type Listener = () => void;",
          "lastModified": "2025-08-02T16:30:24.806Z"
        }
      ],
      "relatedTerms": [
        "store-integration-pattern",
        "reactive-updates"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "store-snapshot": {
      "id": "store-snapshot",
      "title": "Store Snapshot",
      "category": "api-terms",
      "definition": "Immutable snapshot interface for Store state representation, used for optimization and debugging, compatible with React's useSyncExternalStore pattern.",
      "keywords": [
        "store",
        "snapshot",
        "immutable",
        "snapshot",
        "interface",
        "store",
        "state",
        "representation",
        "used",
        "optimization"
      ],
      "aliases": [
        "스토어 Snapshot"
      ],
      "implementations": [
        {
          "file": "packages/react/src/store/types.ts",
          "name": "Snapshot",
          "type": "interface",
          "line": 54,
          "description": "Store snapshot interface for immutable state representation",
          "implements": [
            "store-snapshot",
            "immutable-state"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [],
          "since": "1.0.0",
          "signature": "export interface Snapshot<T = any> {",
          "lastModified": "2025-08-02T16:30:24.806Z"
        }
      ],
      "relatedTerms": [
        "immutable-state",
        "store-integration-pattern"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "immutable-state": {
      "id": "immutable-state",
      "title": "Immutable State",
      "category": "api-terms",
      "definition": "State management principle ensuring that state objects cannot be modified after creation, instead requiring new objects for updates.",
      "keywords": [
        "immutable",
        "state",
        "state",
        "management",
        "principle",
        "ensuring",
        "that",
        "state",
        "objects",
        "cannot"
      ],
      "aliases": [],
      "implementations": [
        {
          "file": "packages/react/src/store/types.ts",
          "name": "Snapshot",
          "type": "interface",
          "line": 54,
          "description": "Store snapshot interface for immutable state representation",
          "implements": [
            "store-snapshot",
            "immutable-state"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [],
          "since": "1.0.0",
          "signature": "export interface Snapshot<T = any> {",
          "lastModified": "2025-08-02T16:30:24.806Z"
        }
      ],
      "relatedTerms": [
        "store-snapshot",
        "observer-pattern"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "store-interface": {
      "id": "store-interface",
      "title": "Store Interface",
      "category": "api-terms",
      "definition": "Core interface defining the contract for Store instances, including subscription methods, value access, and React integration compatibility.",
      "keywords": [
        "store",
        "interface",
        "core",
        "interface",
        "defining",
        "contract",
        "store",
        "instances",
        "including",
        "subscription"
      ],
      "aliases": [
        "스토어 Interface",
        "Store 인터페이스"
      ],
      "implementations": [
        {
          "file": "packages/react/src/store/types.ts",
          "name": "Listener",
          "type": "type",
          "line": 34,
          "description": "Core Store interface for reactive state management",
          "implements": [
            "store-interface",
            "usesyncexternalstore-compatible",
            "observer-pattern"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\nconst userStore: IStore<User> = createStore('user', { \n  id: '', \n  name: '', \n  email: '' \n});\n\n// Subscribe to changes\nconst unsubscribe = userStore.subscribe(() => {\n  console.log('User store updated:', userStore.getSnapshot().value);\n});\n\n// Update store value\nuserStore.setValue({ id: '1', name: 'John', email: 'john@example.com' });\n\n// Get current value for action handlers\nconst currentUser = userStore.getValue();\n```"
          ],
          "since": "1.0.0",
          "signature": "export type Listener = () => void;",
          "lastModified": "2025-08-02T16:30:24.806Z"
        }
      ],
      "relatedTerms": [
        "usesyncexternalstore-compatible",
        "observer-pattern"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "usesyncexternalstore-compatible": {
      "id": "usesyncexternalstore-compatible",
      "title": "useSyncExternalStore Compatible",
      "category": "api-terms",
      "definition": "Compatibility with React's useSyncExternalStore hook, ensuring proper integration with React's concurrent features and state management.",
      "keywords": [
        "usesyncexternalstore",
        "compatible",
        "compatibility",
        "react",
        "usesyncexternalstore",
        "hook",
        "ensuring",
        "proper",
        "integration",
        "react"
      ],
      "aliases": [
        "useSyncExternal스토어 Compatible"
      ],
      "implementations": [
        {
          "file": "packages/react/src/store/types.ts",
          "name": "Listener",
          "type": "type",
          "line": 34,
          "description": "Core Store interface for reactive state management",
          "implements": [
            "store-interface",
            "usesyncexternalstore-compatible",
            "observer-pattern"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\nconst userStore: IStore<User> = createStore('user', { \n  id: '', \n  name: '', \n  email: '' \n});\n\n// Subscribe to changes\nconst unsubscribe = userStore.subscribe(() => {\n  console.log('User store updated:', userStore.getSnapshot().value);\n});\n\n// Update store value\nuserStore.setValue({ id: '1', name: 'John', email: 'john@example.com' });\n\n// Get current value for action handlers\nconst currentUser = userStore.getValue();\n```"
          ],
          "since": "1.0.0",
          "signature": "export type Listener = () => void;",
          "lastModified": "2025-08-02T16:30:24.806Z"
        }
      ],
      "relatedTerms": [
        "store-interface",
        "react-integration"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "registry-pattern": {
      "id": "registry-pattern",
      "title": "Registry Pattern",
      "category": "api-terms",
      "definition": "Design pattern for centralized management of Store instances with dynamic access and lifecycle management capabilities.",
      "keywords": [
        "registry",
        "pattern",
        "design",
        "pattern",
        "centralized",
        "management",
        "store",
        "instances",
        "dynamic",
        "access"
      ],
      "aliases": [
        "Registry 패턴",
        "레지스트리 Pattern"
      ],
      "implementations": [
        {
          "file": "packages/react/src/store/types.ts",
          "name": "IStoreRegistry",
          "type": "interface",
          "line": 149,
          "description": "Store Registry interface for centralized store management",
          "implements": [
            "store-registry",
            "registry-pattern"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\nconst registry = new StoreRegistry('app-registry');\n\n// Register stores\nconst userStore = createStore('user', { name: '', email: '' });\nconst settingsStore = createStore('settings', { theme: 'light' });\n\nregistry.register('user', userStore);\nregistry.register('settings', settingsStore);\n\n// Access stores dynamically\nconst user = registry.getStore('user');\nconst settings = registry.getStore('settings');\n\n// Subscribe to registry changes\nregistry.subscribe(() => {\n  console.log('Registry changed, store count:', registry.getStoreCount());\n});\n```"
          ],
          "since": "1.0.0",
          "signature": "export interface IStoreRegistry {",
          "lastModified": "2025-08-02T16:30:24.806Z"
        }
      ],
      "relatedTerms": [
        "store-registry",
        "store-integration-pattern"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.217Z"
    },
    "environment-configuration": {
      "id": "environment-configuration",
      "title": "Environment Configuration",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "environment",
        "configuration"
      ],
      "aliases": [
        "Environment 설정"
      ],
      "implementations": [],
      "relatedTerms": [
        "logger-system-naming",
        "cross-platform-support"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.220Z"
    },
    "mvvm-pattern": {
      "id": "mvvm-pattern",
      "title": "MVVM Pattern",
      "category": "architecture-terms",
      "definition": "Model-View-ViewModel architectural pattern adapted for React applications with centralized state management and action-based business logic.",
      "keywords": [
        "mvvm",
        "pattern",
        "model",
        "view",
        "viewmodel",
        "architectural",
        "pattern",
        "adapted",
        "react",
        "applications"
      ],
      "aliases": [
        "MVVM 패턴",
        "MVVM 패턴"
      ],
      "implementations": [],
      "relatedTerms": [
        "view-layer",
        "viewmodel-layer",
        "model-layer",
        "unidirectional-data-flow"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.218Z"
    },
    "view-layer": {
      "id": "view-layer",
      "title": "View Layer",
      "category": "architecture-terms",
      "definition": "The presentation layer consisting of React components responsible for rendering UI and capturing user interactions.",
      "keywords": [
        "view",
        "layer",
        "presentation",
        "layer",
        "consisting",
        "react",
        "components",
        "responsible",
        "rendering",
        "ui"
      ],
      "aliases": [
        "View 레이어",
        "뷰 Layer"
      ],
      "implementations": [],
      "relatedTerms": [
        "viewmodel-layer",
        "model-layer",
        "store-hooks",
        "action-dispatcher"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.218Z"
    },
    "viewmodel-layer": {
      "id": "viewmodel-layer",
      "title": "ViewModel Layer",
      "category": "architecture-terms",
      "definition": "The business logic layer implemented through action handlers that process user actions and coordinate between View and Model layers.",
      "keywords": [
        "viewmodel",
        "layer",
        "business",
        "logic",
        "layer",
        "implemented",
        "through",
        "action",
        "handlers",
        "that"
      ],
      "aliases": [
        "ViewModel 레이어",
        "View모델 Layer",
        "뷰Model Layer"
      ],
      "implementations": [],
      "relatedTerms": [
        "view-layer",
        "model-layer",
        "action-handler",
        "business-logic"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.218Z"
    },
    "model-layer": {
      "id": "model-layer",
      "title": "Model Layer",
      "category": "architecture-terms",
      "definition": "MVVM 패턴의 데이터 계층으로, Store 시스템을 통해 애플리케이션 상태를 관리하는 계층.",
      "keywords": [
        "model",
        "layer",
        "mvvm",
        "패턴의",
        "데이터",
        "계층으로",
        "store",
        "시스템을",
        "통해",
        "애플리케이션"
      ],
      "aliases": [
        "Model 레이어",
        "모델 Layer"
      ],
      "implementations": [
        {
          "file": "packages/react/src/store/Store.ts",
          "name": "Store",
          "type": "class",
          "line": 25,
          "description": "Store 클래스 - 중앙화된 상태 관리의 핵심\n\n핵심 기능:\n1. 상태 저장 (_value) - 실제 데이터 보관\n2. 구독 관리 (listeners) - React 컴포넌트들의 구독 추적\n3. 스냅샷 관리 (_snapshot) - 불변성과 최적화를 위한 스냅샷\n4. 변경 알림 (_notifyListeners) - 상태 변경 시 구독자들에게 알림\n",
          "implements": [
            "store-integration-pattern",
            "model-layer"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [],
          "signature": "export class Store<T = any> implements IStore<T> {",
          "lastModified": "2025-08-02T16:30:24.808Z"
        }
      ],
      "relatedTerms": [
        "view-layer",
        "viewmodel-layer",
        "store-registry",
        "store-integration-pattern"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.218Z"
    },
    "lazy-evaluation": {
      "id": "lazy-evaluation",
      "title": "Lazy Evaluation",
      "category": "architecture-terms",
      "definition": "A design pattern where store values are retrieved at execution time rather than at registration time, ensuring handlers always receive fresh state.",
      "keywords": [
        "lazy",
        "evaluation",
        "design",
        "pattern",
        "where",
        "store",
        "values",
        "retrieved",
        "execution",
        "time"
      ],
      "aliases": [],
      "implementations": [
        {
          "file": "packages/react/src/store/StoreRegistry.ts",
          "name": "store",
          "type": "const",
          "line": 131,
          "description": "Get a specific store",
          "implements": [
            "lazy-evaluation"
          ],
          "memberOf": [
            "architecture-terms"
          ],
          "examples": [],
          "signature": "const store = this.stores.get(name);",
          "lastModified": "2025-08-02T16:30:24.808Z"
        },
        {
          "file": "packages/react/src/store/Store.ts",
          "name": "options",
          "type": "const",
          "line": 92,
          "description": "현재 값 직접 가져오기 (액션 핸들러용)\n핵심 로직: 불변성을 보장하는 깊은 복사본 반환\n",
          "implements": [
            "lazy-evaluation",
            "store-immutability"
          ],
          "memberOf": [
            "architecture-terms"
          ],
          "examples": [],
          "signature": "const options = getGlobalImmutabilityOptions();",
          "lastModified": "2025-08-02T16:30:24.808Z"
        }
      ],
      "relatedTerms": [
        "action-handler",
        "store-integration-pattern",
        "fresh-state-access"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.218Z"
    },
    "decoupled-architecture": {
      "id": "decoupled-architecture",
      "title": "Decoupled Architecture",
      "category": "architecture-terms",
      "definition": "An architectural approach where components, actions, and stores are loosely coupled, communicating through well-defined interfaces rather than direct dependencies.",
      "keywords": [
        "decoupled",
        "architecture",
        "architectural",
        "approach",
        "where",
        "components",
        "actions",
        "stores",
        "loosely",
        "coupled"
      ],
      "aliases": [
        "Decoupled 아키텍처"
      ],
      "implementations": [],
      "relatedTerms": [
        "mvvm-pattern",
        "separation-of-concerns",
        "loose-coupling"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.218Z"
    },
    "unidirectional-data-flow": {
      "id": "unidirectional-data-flow",
      "title": "Unidirectional Data Flow",
      "category": "architecture-terms",
      "definition": "A data flow pattern where information moves in a single direction: from user interactions through actions to state updates and back to UI rendering.",
      "keywords": [
        "unidirectional",
        "data",
        "flow",
        "data",
        "flow",
        "pattern",
        "where",
        "information",
        "moves",
        "single"
      ],
      "aliases": [],
      "implementations": [
        {
          "file": "packages/react/src/store/Store.ts",
          "name": "options",
          "type": "const",
          "line": 92,
          "description": "Store 값 설정 및 구독자 알림\n핵심 로직: \n1. 입력값의 불변성 보장을 위한 깊은 복사\n2. 강화된 값 비교 시스템으로 불필요한 리렌더링 방지\n3. 값 변경 시에만 스냅샷 재생성 및 알림\n",
          "implements": [
            "unidirectional-data-flow",
            "store-immutability"
          ],
          "memberOf": [
            "architecture-terms"
          ],
          "examples": [],
          "signature": "const options = getGlobalImmutabilityOptions();",
          "lastModified": "2025-08-02T16:30:24.808Z"
        }
      ],
      "relatedTerms": [
        "mvvm-pattern",
        "action-pipeline-system",
        "predictable-state-updates"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.218Z"
    },
    "type-safety": {
      "id": "type-safety",
      "title": "Type Safety",
      "category": "architecture-terms",
      "definition": "Compile-time type checking that ensures type correctness across all layers of the architecture, from action payloads to store values.",
      "keywords": [
        "type",
        "safety",
        "compile",
        "time",
        "type",
        "checking",
        "that",
        "ensures",
        "type",
        "correctness"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "action-payload-map",
        "action-handler",
        "compile-time-validation"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.218Z"
    },
    "business-logic": {
      "id": "business-logic",
      "title": "Business Logic",
      "category": "architecture-terms",
      "definition": "The core application rules, processes, and workflows that define how data is processed and business requirements are implemented.",
      "keywords": [
        "business",
        "logic",
        "core",
        "application",
        "rules",
        "processes",
        "workflows",
        "that",
        "define",
        "how"
      ],
      "aliases": [],
      "implementations": [
        {
          "file": "packages/react/src/store/ActionHandlerUtils.ts",
          "name": "createValidatedHandler",
          "type": "function",
          "line": 338,
          "description": "Helper for creating action handlers with validation patterns\nFollowing ARCHITECTURE.md business logic validation patterns\n",
          "implements": [
            "business-logic",
            "domain-rules"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [],
          "signature": "export function createValidatedHandler<T>(",
          "lastModified": "2025-08-02T16:30:24.808Z"
        }
      ],
      "relatedTerms": [
        "viewmodel-layer",
        "action-handler",
        "domain-rules"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.218Z"
    },
    "deprecated-hoc-patterns": {
      "id": "deprecated-hoc-patterns",
      "title": "Deprecated HOC Patterns",
      "category": "architecture-terms",
      "definition": "Legacy Higher-Order Component patterns that have been deprecated in favor of modern React hook-based approaches for better type safety, bundle size optimization, and code maintainability.",
      "keywords": [
        "deprecated",
        "hoc",
        "patterns",
        "legacy",
        "higher",
        "order",
        "component",
        "patterns",
        "that",
        "have"
      ],
      "aliases": [
        "Deprecated HOC 패턴s"
      ],
      "implementations": [],
      "relatedTerms": [
        "store-hooks",
        "type-safety",
        "view-layer",
        "store-registry"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.218Z"
    },
    "fresh-state-access": {
      "id": "fresh-state-access",
      "title": "Fresh State Access",
      "category": "architecture-terms",
      "definition": "액션 핸들러가 항상 최신 상태 값을 보장받는 메커니즘으로, 클로저로 인한 stale 값 문제를 해결.",
      "keywords": [
        "fresh",
        "state",
        "access",
        "액션",
        "핸들러가",
        "항상",
        "최신",
        "상태",
        "값을",
        "보장받는"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "lazy-evaluation",
        "store-integration-pattern",
        "action-handler"
      ],
      "examples": [
        "```typescript"
      ],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.218Z"
    },
    "separation-of-concerns": {
      "id": "separation-of-concerns",
      "title": "Separation of Concerns",
      "category": "architecture-terms",
      "definition": "각 시스템 계층이 명확하게 구분된 책임을 갖도록 하는 아키텍처 원칙.",
      "keywords": [
        "separation",
        "concerns",
        "시스템",
        "계층이",
        "명확하게",
        "구분된",
        "책임을",
        "갖도록",
        "하는",
        "아키텍처"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "mvvm-pattern",
        "decoupled-architecture",
        "loose-coupling"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.218Z"
    },
    "loose-coupling": {
      "id": "loose-coupling",
      "title": "Loose Coupling",
      "category": "architecture-terms",
      "definition": "시스템 컴포넌트 간의 의존성을 최소화하여 독립성과 유연성을 극대화하는 설계 원칙.",
      "keywords": [
        "loose",
        "coupling",
        "시스템",
        "컴포넌트",
        "간의",
        "의존성을",
        "최소화하여",
        "독립성과",
        "유연성을",
        "극대화하는"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "decoupled-architecture",
        "separation-of-concerns",
        "interface-abstraction"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.218Z"
    },
    "predictable-state-updates": {
      "id": "predictable-state-updates",
      "title": "Predictable State Updates",
      "category": "architecture-terms",
      "definition": "상태 변경이 예측 가능하고 추적 가능한 방식으로 이루어지는 패턴.",
      "keywords": [
        "predictable",
        "state",
        "updates",
        "상태",
        "변경이",
        "예측",
        "가능하고",
        "추적",
        "가능한",
        "방식으로"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "unidirectional-data-flow",
        "mvvm-pattern",
        "state-management"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.218Z"
    },
    "compile-time-validation": {
      "id": "compile-time-validation",
      "title": "Compile-time Validation",
      "category": "architecture-terms",
      "definition": "TypeScript 컴파일 시점에 타입 안전성과 API 계약을 검증하는 시스템.",
      "keywords": [
        "compile",
        "time",
        "validation",
        "typescript",
        "컴파일",
        "시점에",
        "타입",
        "안전성과",
        "api",
        "계약을"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "type-safety",
        "action-payload-map",
        "generic-programming"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.218Z"
    },
    "domain-rules": {
      "id": "domain-rules",
      "title": "Domain Rules",
      "category": "architecture-terms",
      "definition": "비즈니스 도메인의 규칙과 제약 조건을 코드로 구현한 것으로, ViewModel 계층에서 관리.",
      "keywords": [
        "domain",
        "rules",
        "비즈니스",
        "도메인의",
        "규칙과",
        "제약",
        "조건을",
        "코드로",
        "구현한",
        "것으로"
      ],
      "aliases": [],
      "implementations": [
        {
          "file": "packages/react/src/store/ActionHandlerUtils.ts",
          "name": "createValidatedHandler",
          "type": "function",
          "line": 338,
          "description": "Helper for creating action handlers with validation patterns\nFollowing ARCHITECTURE.md business logic validation patterns\n",
          "implements": [
            "business-logic",
            "domain-rules"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [],
          "signature": "export function createValidatedHandler<T>(",
          "lastModified": "2025-08-02T16:30:24.808Z"
        }
      ],
      "relatedTerms": [
        "business-logic",
        "viewmodel-layer",
        "action-handler"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.218Z"
    },
    "action-pipeline-system": {
      "id": "action-pipeline-system",
      "title": "Action Pipeline System",
      "category": "core-concepts",
      "definition": "The central orchestration system that processes dispatched actions through a series of registered handlers in priority order.",
      "keywords": [
        "action",
        "pipeline",
        "system",
        "central",
        "orchestration",
        "system",
        "that",
        "processes",
        "dispatched",
        "actions"
      ],
      "aliases": [
        "액션 Pipeline System",
        "Action 파이프라인 System",
        "Action Pipeline 시스템",
        "APS",
        "액션 파이프라인"
      ],
      "implementations": [
        {
          "file": "example/src/pages/store/StoreFullDemoPage.tsx",
          "name": "StoreActionSetup",
          "type": "function",
          "line": 35,
          "description": "모듈화된 Store 시스템 데모 페이지\n8개의 실제 시나리오를 통해 Context Store 패턴의 활용을 보여주는 종합 데모\n",
          "implements": [
            "store-integration-pattern",
            "action-pipeline-system"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// 모듈화된 Store 시스템 사용 예제\n<StoreScenarios.Provider registryId=\"store-full-demo\">\n  <UserProfileDemo />\n  <ShoppingCartDemo />\n  <TodoListDemo />\n  <ChatDemo />\n</StoreScenarios.Provider>"
          ],
          "since": "1.0.0",
          "signature": "function StoreActionSetup() {",
          "lastModified": "2025-08-02T16:30:24.794Z"
        },
        {
          "file": "example/src/demos/store-scenarios/actions/index.ts",
          "name": "logger",
          "type": "const",
          "line": 26,
          "description": "Store scenarios 데모용 액션 시스템 설정\nActionRegister를 중심으로 하는 액션 파이프라인과 로깅 시스템을 구성\n",
          "implements": [
            "actionregister",
            "action-pipeline-system"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// 액션 핸들러 등록 (컴포넌트 내부에서)\nuseEffect(() => {\n  const unsubscribe = storeActionRegister.register('updateUser', ({ user }, controller) => {\n    userStore.setValue(user);\n    controller.next();\n  });\n  return unsubscribe;\n}, [userStore]);"
          ],
          "since": "1.0.0",
          "signature": "export const logger = createLogger(LogLevel.DEBUG);",
          "lastModified": "2025-08-02T16:30:24.799Z"
        },
        {
          "file": "packages/core/src/ActionRegister.ts",
          "name": "ActionRegister",
          "type": "class",
          "line": 109,
          "description": "Central action registration and dispatch system",
          "implements": [
            "action-pipeline-system",
            "actionregister"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\ninterface AppActions extends ActionPayloadMap {\n  increment: void;\n  setCount: number;\n  updateUser: { id: string; name: string };\n}\n\nconst actionRegister = new ActionRegister<AppActions>();\n\n// Register handlers with priority and configuration\nactionRegister.register('increment', (_, controller) => {\n  console.log('Incremented');\n  controller.next();\n}, { priority: 10 });\n\nactionRegister.register('setCount', (count, controller) => {\n  console.log(`Count: ${count}`);\n  controller.next();\n});\n\n// Dispatch actions with type safety\nawait actionRegister.dispatch('increment');\nawait actionRegister.dispatch('setCount', 42);\n```"
          ],
          "signature": "export class ActionRegister<T extends ActionPayloadMap = ActionPayloadMap> {",
          "lastModified": "2025-08-02T16:30:24.805Z"
        }
      ],
      "relatedTerms": [
        "action-handler",
        "pipeline-controller",
        "store-integration-pattern"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "action-handler": {
      "id": "action-handler",
      "title": "Action Handler",
      "category": "core-concepts",
      "definition": "A function that processes a specific action within the pipeline, containing business logic and store interactions.",
      "keywords": [
        "action",
        "handler",
        "function",
        "that",
        "processes",
        "specific",
        "action",
        "within",
        "pipeline",
        "containing"
      ],
      "aliases": [
        "액션 Handler",
        "Action 핸들러",
        "액션 핸들러"
      ],
      "implementations": [
        {
          "file": "example/src/demos/store-scenarios/components/UserProfileDemo.tsx",
          "name": "UserProfileDemo",
          "type": "function",
          "line": 22,
          "description": "사용자 프로필 관리 데모 컴포넌트\n복잡한 객체 업데이트와 중첩된 속성 관리를 보여주는 Context Store 패턴 예제\n",
          "implements": [
            "store-integration-pattern",
            "action-handler"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// Context Store 패턴을 사용한 사용자 프로필 관리\n<StoreScenarios.Provider registryId=\"user-profile-demo\">\n  <UserProfileDemo />\n</StoreScenarios.Provider>"
          ],
          "since": "1.0.0",
          "signature": "export function UserProfileDemo() {",
          "lastModified": "2025-08-02T16:30:24.798Z"
        },
        {
          "file": "example/src/demos/store-scenarios/components/TodoListDemo.tsx",
          "name": "TodoListDemo",
          "type": "function",
          "line": 21,
          "description": "할일 목록 관리 데모 컴포넌트\nCRUD 작업과 필터링, 정렬 기능을 보여주는 Context Store 패턴 예제\n",
          "implements": [
            "store-integration-pattern",
            "action-handler"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// 할일 목록 관리를 위한 Context Store 패턴\nconst todosStore = StoreScenarios.useStore('todos', initialTodos);\nconst todos = useStoreValue(todosStore);"
          ],
          "since": "1.0.0",
          "signature": "export function TodoListDemo() {",
          "lastModified": "2025-08-02T16:30:24.798Z"
        },
        {
          "file": "example/src/demos/store-scenarios/components/ShoppingCartDemo.tsx",
          "name": "ShoppingCartDemo",
          "type": "function",
          "line": 21,
          "description": "쇼핑카트 시스템 데모 컴포넌트\n배열 조작과 수량 추적, 계산된 총합을 관리하는 Context Store 패턴 예제\n",
          "implements": [
            "store-integration-pattern",
            "action-handler"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// 쇼핑카트 관리를 위한 Context Store 패턴\nconst productsStore = StoreScenarios.useStore('products', initialProducts);\nconst cartStore = StoreScenarios.useStore('cart', [] as CartItem[]);"
          ],
          "since": "1.0.0",
          "signature": "export function ShoppingCartDemo() {",
          "lastModified": "2025-08-02T16:30:24.798Z"
        },
        {
          "file": "example/src/demos/store-scenarios/components/ChatDemo.tsx",
          "name": "ChatDemo",
          "type": "function",
          "line": 23,
          "description": "실시간 채팅 시스템 데모 컴포넌트\n메시지 스트리밍과 자동 스크롤 기능을 보여주는 Context Store 패턴 예제\n",
          "implements": [
            "store-integration-pattern",
            "action-handler"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// 실시간 채팅을 위한 Context Store 패턴\nconst chatStore = StoreScenarios.useStore('chat', initialMessages);\nconst messages = useStoreValue(chatStore);"
          ],
          "since": "1.0.0",
          "signature": "export function ChatDemo() {",
          "lastModified": "2025-08-02T16:30:24.799Z"
        },
        {
          "file": "packages/core/src/types.ts",
          "name": "ActionHandler",
          "type": "type",
          "line": 104,
          "description": "Action handler function type for processing actions in the pipeline",
          "implements": [
            "action-handler"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\nconst userUpdateHandler: ActionHandler<{id: string, name: string}> = \n  async (payload, controller) => {\n    // Validate payload\n    if (!payload.id) {\n      controller.abort('User ID is required');\n      return;\n    }\n    \n    // Update user store\n    const user = userStore.getValue();\n    userStore.setValue({ ...user, ...payload });\n  };\n```"
          ],
          "since": "1.0.0",
          "signature": "export type ActionHandler<T = any> = (",
          "lastModified": "2025-08-02T16:30:24.804Z"
        }
      ],
      "relatedTerms": [
        "pipeline-controller",
        "action-pipeline-system",
        "handler-configuration"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "pipeline-controller": {
      "id": "pipeline-controller",
      "title": "Pipeline Controller",
      "category": "core-concepts",
      "definition": "An interface provided to action handlers for managing pipeline execution flow and payload modification.",
      "keywords": [
        "pipeline",
        "controller",
        "interface",
        "provided",
        "action",
        "handlers",
        "managing",
        "pipeline",
        "execution",
        "flow"
      ],
      "aliases": [
        "파이프라인 Controller",
        "Pipeline 컨트롤러",
        "파이프라인 컨트롤러"
      ],
      "implementations": [
        {
          "file": "packages/core/src/types.ts",
          "name": "PipelineController",
          "type": "interface",
          "line": 57,
          "description": "Controller object provided to action handlers for pipeline management",
          "implements": [
            "pipeline-controller"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [],
          "since": "1.0.0",
          "signature": "export interface PipelineController<T = any> {",
          "lastModified": "2025-08-02T16:30:24.804Z"
        }
      ],
      "relatedTerms": [
        "action-handler",
        "action-pipeline-system",
        "pipeline-context"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "store-registry": {
      "id": "store-registry",
      "title": "Store Registry",
      "category": "core-concepts",
      "definition": "A centralized registry that manages store instances and provides access to stores within the application context.",
      "keywords": [
        "store",
        "registry",
        "centralized",
        "registry",
        "that",
        "manages",
        "store",
        "instances",
        "provides",
        "access"
      ],
      "aliases": [
        "스토어 Registry",
        "Store 레지스트리",
        "스토어 레지스트리"
      ],
      "implementations": [
        {
          "file": "example/src/pages/react/ReactHooksPage.tsx",
          "name": "HooksStores",
          "type": "const",
          "line": 44,
          "description": "React Hooks 최적화 데모용 Context Store 패턴\n메모이제이션과 성능 최적화 예제를 위한 Store 격리 시스템\n",
          "implements": [
            "store-registry",
            "performance-optimization",
            "store-integration-pattern"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// React Hooks 최적화를 위한 Context Store 패턴\nconst HooksStores = createContextStorePattern('ReactHooks');\n\n// 컴포넌트에서 Store 사용\nconst calculationStore = HooksStores.useStore('calculation', { result: 0, computeTime: 0 });\nconst memoryStore = HooksStores.useStore('memory', { objects: 0, allocatedMB: 0 });"
          ],
          "since": "1.0.0",
          "signature": "const HooksStores = createContextStorePattern('ReactHooks');",
          "lastModified": "2025-08-02T16:30:24.795Z"
        },
        {
          "file": "example/src/pages/react/ReactContextPage.tsx",
          "name": "GlobalStores",
          "type": "const",
          "line": 60,
          "description": "React 다중 컨텍스트 시스템용 Context Store 패턴\n계층적 컨텍스트에서 Store Registry 격리를 제공\n",
          "implements": [
            "store-registry",
            "store-integration-pattern"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// 전역 스토어들을 위한 Context Store 패턴\nconst GlobalStores = createContextStorePattern('ReactContextGlobal');\n\n// Provider 계층 구조\n<GlobalStores.Provider>\n  <LocalContextProvider contextId=\"local-A\">\n    <NestedContextProvider level={1}>\n      <InteractiveControls />\n    </NestedContextProvider>\n  </LocalContextProvider>\n</GlobalStores.Provider>"
          ],
          "since": "1.0.0",
          "signature": "const GlobalStores = createContextStorePattern('ReactContextGlobal');",
          "lastModified": "2025-08-02T16:30:24.796Z"
        },
        {
          "file": "example/src/demos/store-scenarios/stores/index.ts",
          "name": "StoreScenarios",
          "type": "const",
          "line": 33,
          "description": "Store-scenarios용 Context Store 패턴 팩토리\nProvider별 독립적인 Registry 영역을 생성하여 Store 격리를 제공\n",
          "implements": [
            "store-registry",
            "store-integration-pattern"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// Context Store 패턴 사용법\nexport const StoreScenarios = createContextStorePattern('StoreScenarios');\n\n// Provider로 감싸기\n<StoreScenarios.Provider registryId=\"demo\">\n  <UserProfileDemo />\n</StoreScenarios.Provider>\n\n// 컴포넌트에서 Store 사용\nconst userStore = StoreScenarios.useStore('user', defaultUser);"
          ],
          "since": "1.0.0",
          "signature": "export const StoreScenarios = createContextStorePattern('StoreScenarios');",
          "lastModified": "2025-08-02T16:30:24.798Z"
        },
        {
          "file": "packages/react/src/store/types.ts",
          "name": "IStoreRegistry",
          "type": "interface",
          "line": 149,
          "description": "Store Registry interface for centralized store management",
          "implements": [
            "store-registry",
            "registry-pattern"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\nconst registry = new StoreRegistry('app-registry');\n\n// Register stores\nconst userStore = createStore('user', { name: '', email: '' });\nconst settingsStore = createStore('settings', { theme: 'light' });\n\nregistry.register('user', userStore);\nregistry.register('settings', settingsStore);\n\n// Access stores dynamically\nconst user = registry.getStore('user');\nconst settings = registry.getStore('settings');\n\n// Subscribe to registry changes\nregistry.subscribe(() => {\n  console.log('Registry changed, store count:', registry.getStoreCount());\n});\n```"
          ],
          "since": "1.0.0",
          "signature": "export interface IStoreRegistry {",
          "lastModified": "2025-08-02T16:30:24.806Z"
        },
        {
          "file": "packages/react/src/store/StoreRegistry.ts",
          "name": "StoreRegistry",
          "type": "class",
          "line": 26,
          "description": "Store Registry - 여러 Store 인스턴스를 중앙 관리\n\n핵심 기능:\n1. Store 등록/해제 (register/unregister) - 이름으로 Store 관리\n2. Store 조회 (getStore) - 이름으로 Store 인스턴스 반환\n3. Registry 구독 (subscribe) - Store 목록 변경 감지\n4. 메타데이터 관리 - Store별 추가 정보 저장\n",
          "implements": [
            "store-registry"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [],
          "signature": "export class StoreRegistry implements IStoreRegistry {",
          "lastModified": "2025-08-02T16:30:24.807Z"
        }
      ],
      "relatedTerms": [
        "store-provider",
        "action-provider",
        "store-integration-pattern"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "action-payload-map": {
      "id": "action-payload-map",
      "title": "Action Payload Map",
      "category": "core-concepts",
      "definition": "A TypeScript interface that defines the mapping between action names and their corresponding payload types.",
      "keywords": [
        "action",
        "payload",
        "map",
        "typescript",
        "interface",
        "that",
        "defines",
        "mapping",
        "between",
        "action"
      ],
      "aliases": [
        "액션 Payload Map",
        "Action 페이로드 Map"
      ],
      "implementations": [],
      "relatedTerms": [
        "action-handler",
        "action-dispatcher",
        "type-safety"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "handler-configuration": {
      "id": "handler-configuration",
      "title": "Handler Configuration",
      "category": "core-concepts",
      "definition": "Configuration options that control the behavior of action handlers within the pipeline.",
      "keywords": [
        "handler",
        "configuration",
        "configuration",
        "options",
        "that",
        "control",
        "behavior",
        "action",
        "handlers",
        "within"
      ],
      "aliases": [
        "핸들러 Configuration",
        "Handler 설정"
      ],
      "implementations": [
        {
          "file": "packages/core/src/types.ts",
          "name": "HandlerConfig",
          "type": "interface",
          "line": 132,
          "description": "Configuration options for action handlers",
          "implements": [
            "handler-configuration"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\nconst config: HandlerConfig = {\n  priority: 10,        // Higher priority runs first\n  id: 'userValidator', // Unique identifier\n  blocking: true,      // Wait for async completion\n  once: false,         // Run multiple times\n  condition: () => isLoggedIn(), // Conditional execution\n  debounce: 500,       // Debounce delay in ms\n  throttle: 1000,      // Throttle interval in ms\n  validation: (payload) => payload?.id != null\n};\n```"
          ],
          "since": "1.0.0",
          "signature": "export interface HandlerConfig {",
          "lastModified": "2025-08-02T16:30:24.804Z"
        }
      ],
      "relatedTerms": [
        "action-handler",
        "pipeline-controller",
        "priority-based-execution"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "simple-event-emitter": {
      "id": "simple-event-emitter",
      "title": "Simple Event Emitter",
      "category": "core-concepts",
      "definition": "ActionRegister 이벤트를 위한 경량화된 이벤트 방출 시스템 구현체.",
      "keywords": [
        "simple",
        "event",
        "emitter",
        "actionregister",
        "이벤트를",
        "위한",
        "경량화된",
        "이벤트",
        "방출",
        "시스템"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "actionregister",
        "event-handler",
        "action-register-events"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "execution-modes": {
      "id": "execution-modes",
      "title": "Execution Modes",
      "category": "core-concepts",
      "definition": "액션 파이프라인에서 핸들러들의 실행 방식을 결정하는 전략 패턴.",
      "keywords": [
        "execution",
        "modes",
        "액션",
        "파이프라인에서",
        "핸들러들의",
        "실행",
        "방식을",
        "결정하는",
        "전략",
        "패턴"
      ],
      "aliases": [
        "실행 Modes"
      ],
      "implementations": [
        {
          "file": "packages/core/src/execution-modes.ts",
          "name": "executeSequential",
          "type": "function",
          "line": 37,
          "description": "Execute handlers in sequential mode (one after another)",
          "implements": [
            "execution-modes",
            "sequential-execution"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [],
          "since": "1.0.0",
          "signature": "export async function executeSequential<T>(",
          "lastModified": "2025-08-02T16:30:24.804Z"
        }
      ],
      "relatedTerms": [
        "action-pipeline-system",
        "handler-configuration",
        "pipeline-controller"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "action-guard": {
      "id": "action-guard",
      "title": "Action Guard",
      "category": "core-concepts",
      "definition": "액션 실행 타이밍을 관리하는 시스템으로, 디바운싱과 쓰로틀링 기능을 제공.",
      "keywords": [
        "action",
        "guard",
        "액션",
        "실행",
        "타이밍을",
        "관리하는",
        "시스템으로",
        "디바운싱과",
        "쓰로틀링",
        "기능을"
      ],
      "aliases": [
        "액션 Guard",
        "Action 가드"
      ],
      "implementations": [
        {
          "file": "packages/core/src/action-guard.ts",
          "name": "ActionGuard",
          "type": "class",
          "line": 53,
          "description": "Action Guard system for managing action execution timing",
          "implements": [
            "action-guard",
            "performance-optimization",
            "user-experience-optimization"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\nconst guard = new ActionGuard(logger);\n\n// Debounce search input (wait 300ms after typing stops)\nif (await guard.debounce('search', 300)) {\n  executeSearch();  \n}\n\n// Throttle scroll handler (max once per 100ms)\nif (guard.throttle('scroll', 100)) {\n  updateScrollPosition();\n}\n```"
          ],
          "since": "1.0.0",
          "signature": "export class ActionGuard {",
          "lastModified": "2025-08-02T16:30:24.805Z"
        }
      ],
      "relatedTerms": [
        "actionregister",
        "handler-configuration",
        "performance-optimization"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "logger-interface": {
      "id": "logger-interface",
      "title": "Logger Interface",
      "category": "core-concepts",
      "definition": "core-concepts 카테고리의 용어",
      "keywords": [
        "logger",
        "interface"
      ],
      "aliases": [
        "로거 Interface",
        "Logger 인터페이스"
      ],
      "implementations": [
        {
          "file": "packages/logger/src/types.ts",
          "name": "Logger",
          "type": "interface",
          "line": 28,
          "description": "Logger interface for customizable logging",
          "implements": [
            "logger-interface"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\nconst logger: Logger = createLogger(LogLevel.DEBUG);\n\nlogger.trace('Detailed execution flow', { step: 1, data: payload });\nlogger.debug('Development info', { userId: '123' });\nlogger.info('General information', { status: 'ready' });\nlogger.warn('Potential issues', { performance: 'slow' });\nlogger.error('Critical errors', error);\n\nlogger.setLevel(LogLevel.WARN); // Only WARN and ERROR will be logged\n```"
          ],
          "since": "1.0.0",
          "signature": "export interface Logger {",
          "lastModified": "2025-08-02T16:30:24.800Z"
        }
      ],
      "relatedTerms": [
        "log-level",
        "logger-implementation",
        "console-logger"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "log-level": {
      "id": "log-level",
      "title": "Log Level",
      "category": "core-concepts",
      "definition": "core-concepts 카테고리의 용어",
      "keywords": [
        "log",
        "level"
      ],
      "aliases": [],
      "implementations": [
        {
          "file": "packages/logger/src/types.ts",
          "name": "LogLevel",
          "type": "enum",
          "line": 64,
          "description": "Log levels for filtering log output",
          "implements": [
            "log-level"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\n// Manual level setting\nconst logger = createLogger(LogLevel.DEBUG);\n\n// Environment-based level (NODE_ENV=development -> DEBUG)\nconst envLogger = createLogger(); // Auto-detects from environment\n\n// Runtime level change\nlogger.setLevel(LogLevel.WARN); // Only warnings and errors\n```"
          ],
          "since": "1.0.0",
          "signature": "export enum LogLevel {",
          "lastModified": "2025-08-02T16:30:24.800Z"
        }
      ],
      "relatedTerms": [
        "logger-interface",
        "logger-implementation"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "logger-implementation": {
      "id": "logger-implementation",
      "title": "Logger Implementation",
      "category": "core-concepts",
      "definition": "core-concepts 카테고리의 용어",
      "keywords": [
        "logger",
        "implementation"
      ],
      "aliases": [
        "로거 Implementation"
      ],
      "implementations": [
        {
          "file": "packages/logger/src/index.ts",
          "name": "ConsoleLogger",
          "type": "class",
          "line": 113,
          "description": "Simple console-based logger implementation",
          "implements": [
            "logger-implementation",
            "console-logger"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\n// Create logger with specific level\nconst logger = new ConsoleLogger(LogLevel.DEBUG);\n\n// Use logger methods\nlogger.trace('Execution step', { step: 1, data: payload });\nlogger.debug('Debug info', { state: 'processing' });\nlogger.info('Operation complete');\nlogger.warn('Performance issue detected');\nlogger.error('Critical error', error);\n\n// Change level at runtime\nlogger.setLevel(LogLevel.WARN);\n```"
          ],
          "since": "0.0.1",
          "signature": "export class ConsoleLogger implements Logger {",
          "lastModified": "2025-08-02T16:30:24.800Z"
        }
      ],
      "relatedTerms": [
        "logger-interface",
        "console-logger",
        "log-level"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "console-logger": {
      "id": "console-logger",
      "title": "Console Logger",
      "category": "core-concepts",
      "definition": "core-concepts 카테고리의 용어",
      "keywords": [
        "console",
        "logger"
      ],
      "aliases": [
        "Console 로거"
      ],
      "implementations": [
        {
          "file": "packages/logger/src/index.ts",
          "name": "ConsoleLogger",
          "type": "class",
          "line": 113,
          "description": "Simple console-based logger implementation",
          "implements": [
            "logger-implementation",
            "console-logger"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\n// Create logger with specific level\nconst logger = new ConsoleLogger(LogLevel.DEBUG);\n\n// Use logger methods\nlogger.trace('Execution step', { step: 1, data: payload });\nlogger.debug('Debug info', { state: 'processing' });\nlogger.info('Operation complete');\nlogger.warn('Performance issue detected');\nlogger.error('Critical error', error);\n\n// Change level at runtime\nlogger.setLevel(LogLevel.WARN);\n```"
          ],
          "since": "0.0.1",
          "signature": "export class ConsoleLogger implements Logger {",
          "lastModified": "2025-08-02T16:30:24.800Z"
        }
      ],
      "relatedTerms": [
        "logger-interface",
        "logger-implementation",
        "log-level"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "execution-mode": {
      "id": "execution-mode",
      "title": "Execution Mode",
      "category": "core-concepts",
      "definition": "core-concepts 카테고리의 용어",
      "keywords": [
        "execution",
        "mode"
      ],
      "aliases": [
        "실행 Mode"
      ],
      "implementations": [
        {
          "file": "packages/core/src/types.ts",
          "name": "ExecutionMode",
          "type": "type",
          "line": 195,
          "description": "Execution modes for action pipeline",
          "implements": [
            "execution-mode"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\nconst register = new ActionRegister({ \n  defaultExecutionMode: 'parallel' \n});\n\n// Or set per action\nregister.setExecutionMode('validateUser', 'sequential');\nregister.setExecutionMode('fetchData', 'race');\n```"
          ],
          "since": "1.0.0",
          "signature": "export type ExecutionMode = 'sequential' | 'parallel' | 'race';",
          "lastModified": "2025-08-02T16:30:24.804Z"
        }
      ],
      "relatedTerms": [
        "sequential-execution",
        "actionregister",
        "handler-configuration"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "sequential-execution": {
      "id": "sequential-execution",
      "title": "Sequential Execution",
      "category": "core-concepts",
      "definition": "core-concepts 카테고리의 용어",
      "keywords": [
        "sequential",
        "execution"
      ],
      "aliases": [
        "Sequential 실행"
      ],
      "implementations": [
        {
          "file": "packages/core/src/execution-modes.ts",
          "name": "executeSequential",
          "type": "function",
          "line": 37,
          "description": "Execute handlers in sequential mode (one after another)",
          "implements": [
            "execution-modes",
            "sequential-execution"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [],
          "since": "1.0.0",
          "signature": "export async function executeSequential<T>(",
          "lastModified": "2025-08-02T16:30:24.804Z"
        }
      ],
      "relatedTerms": [
        "execution-mode",
        "pipeline-controller",
        "handler-configuration"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "performance-optimization": {
      "id": "performance-optimization",
      "title": "Performance Optimization",
      "category": "core-concepts",
      "definition": "core-concepts 카테고리의 용어",
      "keywords": [
        "performance",
        "optimization"
      ],
      "aliases": [],
      "implementations": [
        {
          "file": "example/src/pages/react/ReactHooksPage.tsx",
          "name": "HooksStores",
          "type": "const",
          "line": 44,
          "description": "React Hooks 최적화 데모용 Context Store 패턴\n메모이제이션과 성능 최적화 예제를 위한 Store 격리 시스템\n",
          "implements": [
            "store-registry",
            "performance-optimization",
            "store-integration-pattern"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n// React Hooks 최적화를 위한 Context Store 패턴\nconst HooksStores = createContextStorePattern('ReactHooks');\n\n// 컴포넌트에서 Store 사용\nconst calculationStore = HooksStores.useStore('calculation', { result: 0, computeTime: 0 });\nconst memoryStore = HooksStores.useStore('memory', { objects: 0, allocatedMB: 0 });"
          ],
          "since": "1.0.0",
          "signature": "const HooksStores = createContextStorePattern('ReactHooks');",
          "lastModified": "2025-08-02T16:30:24.795Z"
        },
        {
          "file": "packages/core/src/action-guard.ts",
          "name": "ActionGuard",
          "type": "class",
          "line": 53,
          "description": "Action Guard system for managing action execution timing",
          "implements": [
            "action-guard",
            "performance-optimization",
            "user-experience-optimization"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\nconst guard = new ActionGuard(logger);\n\n// Debounce search input (wait 300ms after typing stops)\nif (await guard.debounce('search', 300)) {\n  executeSearch();  \n}\n\n// Throttle scroll handler (max once per 100ms)\nif (guard.throttle('scroll', 100)) {\n  updateScrollPosition();\n}\n```"
          ],
          "since": "1.0.0",
          "signature": "export class ActionGuard {",
          "lastModified": "2025-08-02T16:30:24.805Z"
        },
        {
          "file": "packages/react/src/store/hooks/useStoreActions.ts",
          "name": "useStoreActions",
          "type": "function",
          "line": 33,
          "description": "Store 액션 핸들러들을 메모이제이션하여 반환\n핵심 기능: Store의 메서드들을 안전하게 바인딩하고 메모이제이션으로 성능 최적화\n",
          "implements": [
            "store-hooks",
            "performance-optimization"
          ],
          "memberOf": [
            "api-terms"
          ],
          "examples": [
            "\n```typescript\nconst userStore = createStore({ name: 'John', age: 30 });\nconst { setValue, update, getValue } = useStoreActions(userStore);\n\n// 전체 값 교체\nsetValue({ name: 'Jane', age: 25 });\n\n// 부분 업데이트\nupdate(user => ({ ...user, age: user.age + 1 }));\n\n// 현재 값 읽기 (액션 핸들러에서 유용)\nconst currentUser = getValue();\n```"
          ],
          "since": "1.0.0",
          "signature": "export function useStoreActions<T>(store: Store<T> | null | undefined) {",
          "lastModified": "2025-08-02T16:30:24.809Z"
        }
      ],
      "relatedTerms": [
        "action-guard",
        "user-experience-optimization"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "user-experience-optimization": {
      "id": "user-experience-optimization",
      "title": "User Experience Optimization",
      "category": "core-concepts",
      "definition": "core-concepts 카테고리의 용어",
      "keywords": [
        "user",
        "experience",
        "optimization"
      ],
      "aliases": [],
      "implementations": [
        {
          "file": "packages/core/src/action-guard.ts",
          "name": "ActionGuard",
          "type": "class",
          "line": 53,
          "description": "Action Guard system for managing action execution timing",
          "implements": [
            "action-guard",
            "performance-optimization",
            "user-experience-optimization"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [
            "\n```typescript\nconst guard = new ActionGuard(logger);\n\n// Debounce search input (wait 300ms after typing stops)\nif (await guard.debounce('search', 300)) {\n  executeSearch();  \n}\n\n// Throttle scroll handler (max once per 100ms)\nif (guard.throttle('scroll', 100)) {\n  updateScrollPosition();\n}\n```"
          ],
          "since": "1.0.0",
          "signature": "export class ActionGuard {",
          "lastModified": "2025-08-02T16:30:24.805Z"
        }
      ],
      "relatedTerms": [
        "action-guard",
        "performance-optimization"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "store-immutability": {
      "id": "store-immutability",
      "title": "Store Immutability",
      "category": "core-concepts",
      "definition": "Store의 상태 불변성을 보장하는 시스템으로, 외부 수정으로부터 내부 상태를 보호하고 데이터 무결성을 유지합니다.",
      "keywords": [
        "store",
        "immutability",
        "store의",
        "상태",
        "불변성을",
        "보장하는",
        "시스템으로",
        "외부",
        "수정으로부터",
        "내부"
      ],
      "aliases": [
        "스토어 Immutability"
      ],
      "implementations": [
        {
          "file": "packages/react/src/store/immutable.ts",
          "name": "logger",
          "type": "const",
          "line": 15,
          "description": "Store 불변성 보장을 위한 유틸리티 함수들\n\n핵심 기능:\n1. 깊은 복사 (Deep Clone) - 중첩된 객체/배열의 완전한 복사본 생성\n2. 불변성 검증 - 복사본이 원본과 독립적인지 확인\n3. 성능 최적화 - primitive 값에 대한 불필요한 복사 방지\n",
          "implements": [
            "store-immutability"
          ],
          "memberOf": [
            "core-concepts"
          ],
          "examples": [],
          "signature": "const logger = createLogger();",
          "lastModified": "2025-08-02T16:30:24.807Z"
        },
        {
          "file": "packages/react/src/store/Store.ts",
          "name": "options",
          "type": "const",
          "line": 92,
          "description": "현재 값 직접 가져오기 (액션 핸들러용)\n핵심 로직: 불변성을 보장하는 깊은 복사본 반환\n",
          "implements": [
            "lazy-evaluation",
            "store-immutability"
          ],
          "memberOf": [
            "architecture-terms"
          ],
          "examples": [],
          "signature": "const options = getGlobalImmutabilityOptions();",
          "lastModified": "2025-08-02T16:30:24.808Z"
        },
        {
          "file": "packages/react/src/store/Store.ts",
          "name": "options",
          "type": "const",
          "line": 92,
          "description": "Store 값 설정 및 구독자 알림\n핵심 로직: \n1. 입력값의 불변성 보장을 위한 깊은 복사\n2. 강화된 값 비교 시스템으로 불필요한 리렌더링 방지\n3. 값 변경 시에만 스냅샷 재생성 및 알림\n",
          "implements": [
            "unidirectional-data-flow",
            "store-immutability"
          ],
          "memberOf": [
            "architecture-terms"
          ],
          "examples": [],
          "signature": "const options = getGlobalImmutabilityOptions();",
          "lastModified": "2025-08-02T16:30:24.808Z"
        },
        {
          "file": "packages/react/src/store/Store.ts",
          "name": "options",
          "type": "const",
          "line": 92,
          "description": "Update value using updater function\n핵심 로직: \n1. 현재 값의 안전한 복사본을 updater에 전달\n2. updater 결과를 setValue로 안전하게 설정\n",
          "implements": [
            "store-immutability"
          ],
          "memberOf": [],
          "examples": [],
          "signature": "const options = getGlobalImmutabilityOptions();",
          "lastModified": "2025-08-02T16:30:24.808Z"
        }
      ],
      "relatedTerms": [
        "store-integration-pattern",
        "fresh-state-access",
        "unidirectional-data-flow"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "overview": {
      "id": "overview",
      "title": "Overview",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "overview"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "general-principles": {
      "id": "general-principles",
      "title": "General Principles",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "general",
        "principles"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "class-naming": {
      "id": "class-naming",
      "title": "Class Naming",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "class",
        "naming"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "actionregister",
        "storeprovider"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "interface-naming": {
      "id": "interface-naming",
      "title": "Interface Naming",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "interface",
        "naming"
      ],
      "aliases": [
        "인터페이스 Naming"
      ],
      "implementations": [],
      "relatedTerms": [
        "action-payload-map",
        "handler-configuration"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "function-naming": {
      "id": "function-naming",
      "title": "Function Naming",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "function",
        "naming"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "store-hooks",
        "action-handler"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "constant-naming": {
      "id": "constant-naming",
      "title": "Constant Naming",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "constant",
        "naming"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "actionregister",
        "handler-configuration"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "file-naming": {
      "id": "file-naming",
      "title": "File Naming",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "file",
        "naming"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "project-structure",
        "module-organization"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "variable-naming": {
      "id": "variable-naming",
      "title": "Variable Naming",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "variable",
        "naming"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "type-safety",
        "code-clarity"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "generic-type-parameters": {
      "id": "generic-type-parameters",
      "title": "Generic Type Parameters",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "generic",
        "type",
        "parameters"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "type-safety",
        "generic-programming"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "documentation-naming": {
      "id": "documentation-naming",
      "title": "Documentation Naming",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "documentation",
        "naming"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "documentation-structure",
        "link-management"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "validation-rules": {
      "id": "validation-rules",
      "title": "Validation Rules",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "validation",
        "rules"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "code-quality",
        "framework-consistency"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "logger-system-naming": {
      "id": "logger-system-naming",
      "title": "Logger System Naming",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "logger",
        "system",
        "naming"
      ],
      "aliases": [
        "Logger 시스템 Naming",
        "로거 System Naming"
      ],
      "implementations": [],
      "relatedTerms": [
        "logger-interface",
        "environment-configuration"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "store-system-naming": {
      "id": "store-system-naming",
      "title": "Store System Naming",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "store",
        "system",
        "naming"
      ],
      "aliases": [
        "스토어 System Naming",
        "Store 시스템 Naming"
      ],
      "implementations": [],
      "relatedTerms": [
        "store-integration-pattern",
        "store-hooks"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.219Z"
    },
    "react-integration-naming": {
      "id": "react-integration-naming",
      "title": "React Integration Naming",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "react",
        "integration",
        "naming"
      ],
      "aliases": [
        "React 통합 Naming"
      ],
      "implementations": [],
      "relatedTerms": [
        "actionprovider",
        "storeprovider",
        "react-hooks"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.220Z"
    },
    "jotai-integration-naming": {
      "id": "jotai-integration-naming",
      "title": "Jotai Integration Naming",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "jotai",
        "integration",
        "naming"
      ],
      "aliases": [
        "Jotai 통합 Naming"
      ],
      "implementations": [],
      "relatedTerms": [
        "jotai-integration",
        "context-integration"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.220Z"
    },
    "core-framework-naming": {
      "id": "core-framework-naming",
      "title": "Core Framework Naming",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "core",
        "framework",
        "naming"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "actionregister",
        "action-pipeline-system"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.220Z"
    },
    "error-and-utility-naming": {
      "id": "error-and-utility-naming",
      "title": "Error and Utility Naming",
      "category": "naming-conventions",
      "definition": "naming-conventions 카테고리의 용어",
      "keywords": [
        "error",
        "utility",
        "naming"
      ],
      "aliases": [],
      "implementations": [],
      "relatedTerms": [
        "action-guard",
        "performance-optimization"
      ],
      "examples": [],
      "since": "1.0.0",
      "lastModified": "2025-08-03T10:58:38.220Z"
    }
  },
  "index": {
    "byKeyword": {
      "validation": [
        "validation-summary",
        "compile-time-validation",
        "validation-rules"
      ],
      "summary": [
        "validation-summary"
      ],
      "quality": [
        "quality-metrics"
      ],
      "metrics": [
        "quality-metrics",
        "action-metrics",
        "performance-monitoring"
      ],
      "recommendations": [
        "recommendations"
      ],
      "maintenance": [
        "maintenance-schedule"
      ],
      "schedule": [
        "maintenance-schedule"
      ],
      "success": [
        "success-indicators"
      ],
      "indicators": [
        "success-indicators"
      ],
      "next": [
        "next-steps"
      ],
      "steps": [
        "next-steps"
      ],
      "actionregister": [
        "actionregister",
        "useactionregister",
        "actionregister-configuration",
        "action-events",
        "event-handler",
        "event-emitter",
        "simple-event-emitter"
      ],
      "core": [
        "actionregister",
        "store-interface",
        "business-logic",
        "core-framework-naming"
      ],
      "class": [
        "actionregister",
        "class-naming"
      ],
      "that": [
        "actionregister",
        "storeprovider",
        "actionprovider",
        "store-hooks",
        "async-operations",
        "action-dispatcher",
        "computed-store",
        "pipeline-context",
        "selective-subscription",
        "smart-logger-creation",
        "atom-provider",
        "useatomselect",
        "useatomsetter",
        "action-events",
        "event-driven-architecture",
        "immutable-state",
        "viewmodel-layer",
        "model-layer",
        "type-safety",
        "business-logic",
        "deprecated-hoc-patterns",
        "action-pipeline-system",
        "store-integration-pattern",
        "action-handler",
        "store-registry",
        "action-payload-map",
        "handler-configuration"
      ],
      "manages": [
        "actionregister",
        "storeprovider",
        "actionprovider",
        "store-registry"
      ],
      "action": [
        "actionregister",
        "actionprovider",
        "async-operations",
        "action-dispatcher",
        "priority-based-execution",
        "pipeline-context",
        "jotai-integration",
        "cleanup-function",
        "action-metrics",
        "action-events",
        "viewmodel-layer",
        "action-pipeline-system",
        "store-integration-pattern",
        "action-handler",
        "pipeline-controller",
        "action-payload-map",
        "handler-configuration",
        "action-guard"
      ],
      "pipelines": [
        "actionregister"
      ],
      "handler": [
        "actionregister",
        "priority-based-execution",
        "event-handler",
        "action-handler",
        "handler-configuration"
      ],
      "registration": [
        "actionregister",
        "actionprovider"
      ],
      "provides": [
        "actionregister",
        "storeprovider",
        "atom-provider",
        "store-registry"
      ],
      "storeprovider": [
        "storeprovider"
      ],
      "react": [
        "storeprovider",
        "actionprovider",
        "store-hooks",
        "useactiondispatch",
        "useactionregister",
        "atom-provider",
        "usesyncexternalstore-compatible",
        "mvvm-pattern",
        "view-layer",
        "react-integration-naming"
      ],
      "context": [
        "storeprovider",
        "actionprovider",
        "pipeline-context",
        "jotai-integration",
        "atom-context-config",
        "atom-provider",
        "performance-monitoring"
      ],
      "provider": [
        "storeprovider",
        "actionprovider",
        "atom-provider"
      ],
      "store": [
        "storeprovider",
        "store-hooks",
        "cross-store-coordination",
        "computed-store",
        "selective-subscription",
        "store-integration-pattern",
        "store-factory-functions",
        "managed-store",
        "observer-pattern",
        "store-snapshot",
        "store-interface",
        "registry-pattern",
        "lazy-evaluation",
        "model-layer",
        "store-registry",
        "store-immutability",
        "store-system-naming"
      ],
      "instances": [
        "storeprovider",
        "logger-factory",
        "actionregister-configuration",
        "action-events",
        "store-interface",
        "registry-pattern",
        "store-registry"
      ],
      "them": [
        "storeprovider"
      ],
      "actionprovider": [
        "actionprovider"
      ],
      "dispatch": [
        "actionprovider"
      ],
      "functionality": [
        "actionprovider"
      ],
      "hooks": [
        "store-hooks"
      ],
      "provide": [
        "store-hooks"
      ],
      "reactive": [
        "store-hooks",
        "computed-store",
        "action-events",
        "event-driven-architecture",
        "observer-pattern"
      ],
      "access": [
        "store-hooks",
        "useatomreadonly",
        "registry-pattern",
        "fresh-state-access",
        "store-registry"
      ],
      "values": [
        "store-hooks",
        "lazy-evaluation"
      ],
      "cross": [
        "cross-store-coordination",
        "environment-configuration"
      ],
      "coordination": [
        "cross-store-coordination"
      ],
      "pattern": [
        "cross-store-coordination",
        "selective-subscription",
        "store-integration-pattern",
        "event-driven-architecture",
        "observer-pattern",
        "registry-pattern",
        "mvvm-pattern",
        "lazy-evaluation",
        "unidirectional-data-flow"
      ],
      "coordinating": [
        "cross-store-coordination"
      ],
      "actions": [
        "cross-store-coordination",
        "action-dispatcher",
        "decoupled-architecture",
        "action-pipeline-system"
      ],
      "across": [
        "cross-store-coordination",
        "performance-monitoring"
      ],
      "multiple": [
        "cross-store-coordination"
      ],
      "stores": [
        "cross-store-coordination",
        "model-layer",
        "decoupled-architecture"
      ],
      "within": [
        "cross-store-coordination",
        "async-operations",
        "action-handler",
        "handler-configuration"
      ],
      "async": [
        "async-operations"
      ],
      "operations": [
        "async-operations"
      ],
      "asynchronous": [
        "async-operations"
      ],
      "handlers": [
        "async-operations",
        "priority-based-execution",
        "cleanup-function",
        "viewmodel-layer",
        "store-integration-pattern",
        "pipeline-controller",
        "handler-configuration"
      ],
      "handle": [
        "async-operations",
        "model-layer"
      ],
      "external": [
        "async-operations"
      ],
      "dispatcher": [
        "action-dispatcher"
      ],
      "type": [
        "action-dispatcher",
        "cleanup-function",
        "event-handler",
        "type-safety",
        "generic-type-parameters"
      ],
      "safe": [
        "action-dispatcher"
      ],
      "function": [
        "action-dispatcher",
        "logger-factory",
        "cleanup-function",
        "event-handler",
        "action-handler",
        "function-naming"
      ],
      "interface": [
        "action-dispatcher",
        "action-metrics",
        "event-emitter",
        "store-snapshot",
        "store-interface",
        "pipeline-controller",
        "action-payload-map",
        "logger-interface",
        "interface-naming"
      ],
      "enables": [
        "action-dispatcher",
        "event-driven-architecture",
        "store-integration-pattern"
      ],
      "dispatching": [
        "action-dispatcher"
      ],
      "priority": [
        "priority-based-execution"
      ],
      "based": [
        "priority-based-execution"
      ],
      "execution": [
        "priority-based-execution",
        "pipeline-context",
        "action-metrics",
        "lazy-evaluation",
        "pipeline-controller",
        "execution-modes",
        "execution-mode",
        "sequential-execution"
      ],
      "strategy": [
        "priority-based-execution"
      ],
      "where": [
        "priority-based-execution",
        "observer-pattern",
        "lazy-evaluation",
        "decoupled-architecture",
        "unidirectional-data-flow"
      ],
      "executed": [
        "priority-based-execution"
      ],
      "computed": [
        "computed-store"
      ],
      "derives": [
        "computed-store"
      ],
      "its": [
        "computed-store"
      ],
      "value": [
        "computed-store",
        "useatomreadonly"
      ],
      "from": [
        "computed-store",
        "cleanup-function"
      ],
      "one": [
        "computed-store"
      ],
      "pipeline": [
        "pipeline-context",
        "cleanup-function",
        "action-pipeline-system",
        "action-handler",
        "pipeline-controller"
      ],
      "internal": [
        "pipeline-context"
      ],
      "maintains": [
        "pipeline-context"
      ],
      "state": [
        "pipeline-context",
        "useatomstate",
        "observer-pattern",
        "store-snapshot",
        "immutable-state",
        "fresh-state-access",
        "predictable-state-updates"
      ],
      "during": [
        "pipeline-context"
      ],
      "selective": [
        "selective-subscription",
        "useatomselect"
      ],
      "subscription": [
        "selective-subscription",
        "store-interface"
      ],
      "allows": [
        "selective-subscription"
      ],
      "components": [
        "selective-subscription",
        "view-layer",
        "decoupled-architecture"
      ],
      "subscribe": [
        "selective-subscription"
      ],
      "specific": [
        "selective-subscription",
        "action-handler"
      ],
      "parts": [
        "selective-subscription"
      ],
      "useactiondispatch": [
        "useactiondispatch"
      ],
      "액션": [
        "useactiondispatch",
        "store-integration-pattern",
        "fresh-state-access",
        "actionregister",
        "execution-modes",
        "action-guard"
      ],
      "디스패치": [
        "useactiondispatch",
        "actionregister"
      ],
      "함수를": [
        "useactiondispatch"
      ],
      "반환하는": [
        "useactiondispatch"
      ],
      "hook으로": [
        "useactiondispatch",
        "useactionregister"
      ],
      "컴포넌트에서": [
        "useactiondispatch"
      ],
      "타입": [
        "useactiondispatch",
        "store-factory-functions",
        "compile-time-validation",
        "actionregister"
      ],
      "안전한": [
        "useactiondispatch",
        "actionregister"
      ],
      "useactionregister": [
        "useactionregister"
      ],
      "인스턴스에": [
        "useactionregister"
      ],
      "직접": [
        "useactionregister"
      ],
      "접근할": [
        "useactionregister"
      ],
      "있는": [
        "useactionregister"
      ],
      "핸들러": [
        "useactionregister"
      ],
      "등록": [
        "useactionregister",
        "managed-store",
        "actionregister"
      ],
      "integration": [
        "store-integration-pattern",
        "jotai-integration",
        "usesyncexternalstore-compatible",
        "react-integration-naming",
        "jotai-integration-naming"
      ],
      "클래스의": [
        "store-integration-pattern"
      ],
      "핵심": [
        "store-integration-pattern"
      ],
      "상태": [
        "store-integration-pattern",
        "jotai-integration",
        "fresh-state-access",
        "predictable-state-updates",
        "store-immutability"
      ],
      "관리": [
        "store-integration-pattern",
        "jotai-integration"
      ],
      "패턴으로": [
        "store-integration-pattern"
      ],
      "중앙화된": [
        "store-integration-pattern",
        "actionregister"
      ],
      "factory": [
        "store-factory-functions",
        "logger-factory"
      ],
      "functions": [
        "store-factory-functions"
      ],
      "인스턴스": [
        "store-factory-functions"
      ],
      "생성을": [
        "store-factory-functions"
      ],
      "위한": [
        "store-factory-functions",
        "simple-event-emitter"
      ],
      "팩토리": [
        "store-factory-functions"
      ],
      "함수들로": [
        "store-factory-functions"
      ],
      "managed": [
        "managed-store"
      ],
      "자동": [
        "managed-store"
      ],
      "레지스트리": [
        "managed-store"
      ],
      "기능을": [
        "managed-store",
        "action-guard"
      ],
      "갖춘": [
        "managed-store"
      ],
      "향상된": [
        "managed-store"
      ],
      "클래스로": [
        "managed-store"
      ],
      "jotai": [
        "jotai-integration",
        "atom-context-config",
        "atom-provider",
        "useatomstate",
        "useatomreadonly",
        "useatomsetter",
        "jotai-integration-naming"
      ],
      "라이브러리와": [
        "jotai-integration"
      ],
      "프레임워크를": [
        "jotai-integration"
      ],
      "통합하는": [
        "jotai-integration"
      ],
      "logger": [
        "logger-factory",
        "smart-logger-creation",
        "logger-interface",
        "logger-implementation",
        "console-logger",
        "logger-system-naming"
      ],
      "creating": [
        "logger-factory"
      ],
      "appropriately": [
        "logger-factory"
      ],
      "configured": [
        "logger-factory"
      ],
      "automatic": [
        "logger-factory"
      ],
      "smart": [
        "smart-logger-creation"
      ],
      "creation": [
        "smart-logger-creation",
        "atom-context-config"
      ],
      "intelligent": [
        "smart-logger-creation"
      ],
      "process": [
        "smart-logger-creation"
      ],
      "automatically": [
        "smart-logger-creation"
      ],
      "detects": [
        "smart-logger-creation"
      ],
      "atom": [
        "atom-context-config",
        "atom-provider",
        "useatomstate",
        "useatomreadonly"
      ],
      "config": [
        "atom-context-config"
      ],
      "configuration": [
        "atom-context-config",
        "actionregister-configuration",
        "environment-configuration",
        "handler-configuration"
      ],
      "options": [
        "atom-context-config",
        "actionregister-configuration",
        "handler-configuration"
      ],
      "logging": [
        "atom-context-config",
        "actionregister-configuration"
      ],
      "component": [
        "atom-provider",
        "deprecated-hoc-patterns"
      ],
      "atoms": [
        "atom-provider",
        "useatomselect",
        "useatomsetter"
      ],
      "useatomstate": [
        "useatomstate"
      ],
      "primary": [
        "useatomstate"
      ],
      "hook": [
        "useatomstate",
        "useatomreadonly",
        "useatomselect",
        "useatomsetter",
        "usesyncexternalstore-compatible"
      ],
      "full": [
        "useatomstate"
      ],
      "management": [
        "useatomstate",
        "observer-pattern",
        "immutable-state",
        "registry-pattern",
        "model-layer"
      ],
      "returning": [
        "useatomstate"
      ],
      "both": [
        "useatomstate"
      ],
      "useatomreadonly": [
        "useatomreadonly"
      ],
      "performance": [
        "useatomreadonly",
        "useatomselect",
        "action-metrics",
        "performance-monitoring",
        "performance-optimization"
      ],
      "optimized": [
        "useatomreadonly"
      ],
      "read": [
        "useatomreadonly",
        "store-integration-pattern"
      ],
      "only": [
        "useatomreadonly",
        "useatomsetter"
      ],
      "useatomselect": [
        "useatomselect"
      ],
      "optimization": [
        "useatomselect",
        "store-snapshot",
        "performance-optimization",
        "user-experience-optimization"
      ],
      "creates": [
        "useatomselect"
      ],
      "derived": [
        "useatomselect"
      ],
      "subscriptions": [
        "useatomselect"
      ],
      "useatomsetter": [
        "useatomsetter"
      ],
      "write": [
        "useatomsetter"
      ],
      "returns": [
        "useatomsetter"
      ],
      "setter": [
        "useatomsetter"
      ],
      "including": [
        "actionregister-configuration",
        "store-interface"
      ],
      "setup": [
        "actionregister-configuration"
      ],
      "debugging": [
        "actionregister-configuration"
      ],
      "cleanup": [
        "cleanup-function"
      ],
      "unregistering": [
        "cleanup-function"
      ],
      "returned": [
        "cleanup-function"
      ],
      "status": [
        "action-metrics"
      ],
      "used": [
        "action-metrics",
        "store-snapshot"
      ],
      "monitoring": [
        "performance-monitoring",
        "event-driven-architecture"
      ],
      "comprehensive": [
        "performance-monitoring"
      ],
      "system": [
        "performance-monitoring",
        "event-emitter",
        "environment-configuration",
        "action-pipeline-system",
        "logger-system-naming",
        "store-system-naming"
      ],
      "tracking": [
        "performance-monitoring"
      ],
      "analyzing": [
        "performance-monitoring"
      ],
      "events": [
        "action-events",
        "event-handler"
      ],
      "event": [
        "action-events",
        "event-driven-architecture",
        "event-handler",
        "event-emitter",
        "simple-event-emitter"
      ],
      "types": [
        "action-events"
      ],
      "emitted": [
        "action-events",
        "event-handler"
      ],
      "enable": [
        "action-events"
      ],
      "driven": [
        "event-driven-architecture"
      ],
      "architecture": [
        "event-driven-architecture",
        "decoupled-architecture"
      ],
      "architectural": [
        "event-driven-architecture",
        "mvvm-pattern",
        "decoupled-architecture",
        "store-integration-pattern"
      ],
      "programming": [
        "event-driven-architecture"
      ],
      "handling": [
        "event-handler"
      ],
      "other": [
        "event-handler"
      ],
      "framework": [
        "event-handler",
        "environment-configuration",
        "core-framework-naming"
      ],
      "emitter": [
        "event-emitter",
        "simple-event-emitter"
      ],
      "basic": [
        "event-emitter"
      ],
      "providing": [
        "event-emitter"
      ],
      "observer": [
        "observer-pattern"
      ],
      "design": [
        "observer-pattern",
        "registry-pattern",
        "lazy-evaluation"
      ],
      "implementation": [
        "observer-pattern",
        "logger-implementation"
      ],
      "snapshot": [
        "store-snapshot"
      ],
      "immutable": [
        "store-snapshot",
        "immutable-state"
      ],
      "representation": [
        "store-snapshot"
      ],
      "principle": [
        "immutable-state"
      ],
      "ensuring": [
        "immutable-state",
        "usesyncexternalstore-compatible"
      ],
      "objects": [
        "immutable-state"
      ],
      "cannot": [
        "immutable-state"
      ],
      "defining": [
        "store-interface"
      ],
      "contract": [
        "store-interface"
      ],
      "usesyncexternalstore": [
        "usesyncexternalstore-compatible"
      ],
      "compatible": [
        "usesyncexternalstore-compatible"
      ],
      "compatibility": [
        "usesyncexternalstore-compatible"
      ],
      "proper": [
        "usesyncexternalstore-compatible"
      ],
      "registry": [
        "registry-pattern",
        "store-registry"
      ],
      "centralized": [
        "registry-pattern",
        "store-registry"
      ],
      "dynamic": [
        "registry-pattern"
      ],
      "environment": [
        "environment-configuration"
      ],
      "configuring": [
        "environment-configuration"
      ],
      "behavior": [
        "environment-configuration",
        "handler-configuration"
      ],
      "through": [
        "environment-configuration",
        "viewmodel-layer"
      ],
      "variables": [
        "environment-configuration"
      ],
      "mvvm": [
        "mvvm-pattern",
        "model-layer"
      ],
      "model": [
        "mvvm-pattern",
        "model-layer"
      ],
      "view": [
        "mvvm-pattern",
        "view-layer"
      ],
      "viewmodel": [
        "mvvm-pattern",
        "viewmodel-layer"
      ],
      "adapted": [
        "mvvm-pattern"
      ],
      "applications": [
        "mvvm-pattern"
      ],
      "layer": [
        "view-layer",
        "viewmodel-layer",
        "model-layer"
      ],
      "presentation": [
        "view-layer"
      ],
      "consisting": [
        "view-layer",
        "model-layer"
      ],
      "responsible": [
        "view-layer"
      ],
      "rendering": [
        "view-layer"
      ],
      "ui": [
        "view-layer"
      ],
      "business": [
        "viewmodel-layer",
        "business-logic"
      ],
      "logic": [
        "viewmodel-layer",
        "business-logic"
      ],
      "implemented": [
        "viewmodel-layer"
      ],
      "data": [
        "model-layer",
        "unidirectional-data-flow"
      ],
      "application": [
        "model-layer",
        "business-logic"
      ],
      "lazy": [
        "lazy-evaluation"
      ],
      "evaluation": [
        "lazy-evaluation"
      ],
      "retrieved": [
        "lazy-evaluation"
      ],
      "time": [
        "lazy-evaluation",
        "type-safety",
        "compile-time-validation"
      ],
      "decoupled": [
        "decoupled-architecture"
      ],
      "approach": [
        "decoupled-architecture"
      ],
      "loosely": [
        "decoupled-architecture"
      ],
      "coupled": [
        "decoupled-architecture"
      ],
      "unidirectional": [
        "unidirectional-data-flow"
      ],
      "flow": [
        "unidirectional-data-flow",
        "pipeline-controller"
      ],
      "information": [
        "unidirectional-data-flow"
      ],
      "moves": [
        "unidirectional-data-flow"
      ],
      "single": [
        "unidirectional-data-flow"
      ],
      "safety": [
        "type-safety"
      ],
      "compile": [
        "type-safety",
        "compile-time-validation"
      ],
      "checking": [
        "type-safety"
      ],
      "ensures": [
        "type-safety"
      ],
      "correctness": [
        "type-safety"
      ],
      "rules": [
        "business-logic",
        "domain-rules",
        "validation-rules"
      ],
      "processes": [
        "business-logic",
        "action-pipeline-system",
        "action-handler"
      ],
      "workflows": [
        "business-logic"
      ],
      "define": [
        "business-logic"
      ],
      "how": [
        "business-logic"
      ],
      "deprecated": [
        "deprecated-hoc-patterns"
      ],
      "hoc": [
        "deprecated-hoc-patterns"
      ],
      "patterns": [
        "deprecated-hoc-patterns"
      ],
      "legacy": [
        "deprecated-hoc-patterns"
      ],
      "higher": [
        "deprecated-hoc-patterns"
      ],
      "order": [
        "deprecated-hoc-patterns"
      ],
      "have": [
        "deprecated-hoc-patterns"
      ],
      "핸들러가": [
        "store-integration-pattern",
        "fresh-state-access"
      ],
      "store와": [
        "store-integration-pattern"
      ],
      "상호작용하는": [
        "store-integration-pattern"
      ],
      "3단계": [
        "store-integration-pattern"
      ],
      "느슨한": [
        "store-integration-pattern"
      ],
      "패턴의": [
        "model-layer"
      ],
      "데이터": [
        "model-layer"
      ],
      "계층으로": [
        "model-layer"
      ],
      "시스템을": [
        "model-layer"
      ],
      "통해": [
        "model-layer"
      ],
      "애플리케이션": [
        "model-layer"
      ],
      "fresh": [
        "fresh-state-access"
      ],
      "항상": [
        "fresh-state-access"
      ],
      "최신": [
        "fresh-state-access"
      ],
      "값을": [
        "fresh-state-access"
      ],
      "보장받는": [
        "fresh-state-access"
      ],
      "separation": [
        "separation-of-concerns"
      ],
      "concerns": [
        "separation-of-concerns"
      ],
      "시스템": [
        "separation-of-concerns",
        "loose-coupling",
        "simple-event-emitter"
      ],
      "계층이": [
        "separation-of-concerns"
      ],
      "명확하게": [
        "separation-of-concerns"
      ],
      "구분된": [
        "separation-of-concerns"
      ],
      "책임을": [
        "separation-of-concerns"
      ],
      "갖도록": [
        "separation-of-concerns"
      ],
      "하는": [
        "separation-of-concerns"
      ],
      "아키텍처": [
        "separation-of-concerns"
      ],
      "loose": [
        "loose-coupling"
      ],
      "coupling": [
        "loose-coupling"
      ],
      "컴포넌트": [
        "loose-coupling"
      ],
      "간의": [
        "loose-coupling"
      ],
      "의존성을": [
        "loose-coupling"
      ],
      "최소화하여": [
        "loose-coupling"
      ],
      "독립성과": [
        "loose-coupling"
      ],
      "유연성을": [
        "loose-coupling"
      ],
      "극대화하는": [
        "loose-coupling"
      ],
      "predictable": [
        "predictable-state-updates"
      ],
      "updates": [
        "predictable-state-updates"
      ],
      "변경이": [
        "predictable-state-updates"
      ],
      "예측": [
        "predictable-state-updates"
      ],
      "가능하고": [
        "predictable-state-updates"
      ],
      "추적": [
        "predictable-state-updates"
      ],
      "가능한": [
        "predictable-state-updates"
      ],
      "방식으로": [
        "predictable-state-updates"
      ],
      "typescript": [
        "compile-time-validation",
        "action-payload-map"
      ],
      "컴파일": [
        "compile-time-validation"
      ],
      "시점에": [
        "compile-time-validation"
      ],
      "안전성과": [
        "compile-time-validation"
      ],
      "api": [
        "compile-time-validation"
      ],
      "계약을": [
        "compile-time-validation"
      ],
      "domain": [
        "domain-rules"
      ],
      "비즈니스": [
        "domain-rules"
      ],
      "도메인의": [
        "domain-rules"
      ],
      "규칙과": [
        "domain-rules"
      ],
      "제약": [
        "domain-rules"
      ],
      "조건을": [
        "domain-rules"
      ],
      "코드로": [
        "domain-rules"
      ],
      "구현한": [
        "domain-rules"
      ],
      "것으로": [
        "domain-rules"
      ],
      "central": [
        "action-pipeline-system"
      ],
      "orchestration": [
        "action-pipeline-system"
      ],
      "dispatched": [
        "action-pipeline-system"
      ],
      "containing": [
        "action-handler"
      ],
      "controller": [
        "pipeline-controller"
      ],
      "provided": [
        "pipeline-controller"
      ],
      "managing": [
        "pipeline-controller"
      ],
      "payload": [
        "action-payload-map"
      ],
      "map": [
        "action-payload-map"
      ],
      "defines": [
        "action-payload-map"
      ],
      "mapping": [
        "action-payload-map"
      ],
      "between": [
        "action-payload-map"
      ],
      "control": [
        "handler-configuration"
      ],
      "시스템으로": [
        "actionregister",
        "action-guard",
        "store-immutability"
      ],
      "파이프라인": [
        "actionregister"
      ],
      "simple": [
        "simple-event-emitter"
      ],
      "이벤트를": [
        "simple-event-emitter"
      ],
      "경량화된": [
        "simple-event-emitter"
      ],
      "이벤트": [
        "simple-event-emitter"
      ],
      "방출": [
        "simple-event-emitter"
      ],
      "modes": [
        "execution-modes"
      ],
      "파이프라인에서": [
        "execution-modes"
      ],
      "핸들러들의": [
        "execution-modes"
      ],
      "실행": [
        "execution-modes",
        "action-guard"
      ],
      "방식을": [
        "execution-modes"
      ],
      "결정하는": [
        "execution-modes"
      ],
      "전략": [
        "execution-modes"
      ],
      "패턴": [
        "execution-modes"
      ],
      "guard": [
        "action-guard"
      ],
      "타이밍을": [
        "action-guard"
      ],
      "관리하는": [
        "action-guard"
      ],
      "디바운싱과": [
        "action-guard"
      ],
      "쓰로틀링": [
        "action-guard"
      ],
      "log": [
        "log-level"
      ],
      "level": [
        "log-level"
      ],
      "console": [
        "console-logger"
      ],
      "mode": [
        "execution-mode"
      ],
      "sequential": [
        "sequential-execution"
      ],
      "user": [
        "user-experience-optimization"
      ],
      "experience": [
        "user-experience-optimization"
      ],
      "immutability": [
        "store-immutability"
      ],
      "store의": [
        "store-immutability"
      ],
      "불변성을": [
        "store-immutability"
      ],
      "보장하는": [
        "store-immutability"
      ],
      "외부": [
        "store-immutability"
      ],
      "수정으로부터": [
        "store-immutability"
      ],
      "내부": [
        "store-immutability"
      ],
      "overview": [
        "overview"
      ],
      "general": [
        "general-principles"
      ],
      "principles": [
        "general-principles"
      ],
      "naming": [
        "class-naming",
        "interface-naming",
        "function-naming",
        "constant-naming",
        "file-naming",
        "variable-naming",
        "documentation-naming",
        "logger-system-naming",
        "store-system-naming",
        "react-integration-naming",
        "jotai-integration-naming",
        "core-framework-naming",
        "error-and-utility-naming"
      ],
      "constant": [
        "constant-naming"
      ],
      "file": [
        "file-naming"
      ],
      "variable": [
        "variable-naming"
      ],
      "generic": [
        "generic-type-parameters"
      ],
      "parameters": [
        "generic-type-parameters"
      ],
      "documentation": [
        "documentation-naming"
      ],
      "error": [
        "error-and-utility-naming"
      ],
      "utility": [
        "error-and-utility-naming"
      ]
    },
    "byAlias": {
      "Quality 메트릭": "quality-metrics",
      "액션Register": "actionregister",
      "Action레지스터": "actionregister",
      "액션 레지스터": "actionregister",
      "액션 등록기": "actionregister",
      "스토어Provider": "storeprovider",
      "Store프로바이더": "storeprovider",
      "액션Provider": "actionprovider",
      "Action프로바이더": "actionprovider",
      "스토어 Hooks": "store-hooks",
      "Store 훅s": "store-hooks",
      "Cross-스토어 Coordination": "cross-store-coordination",
      "Async 연산": "async-operations",
      "액션 Dispatcher": "action-dispatcher",
      "Action 디스패처": "action-dispatcher",
      "Priority-based 실행": "priority-based-execution",
      "Computed 스토어": "computed-store",
      "파이프라인 Context": "pipeline-context",
      "Pipeline 컨텍스트": "pipeline-context",
      "파이프라인 컨텍스트": "pipeline-context",
      "파이프라인 상황": "pipeline-context",
      "use액션Dispatch": "useactiondispatch",
      "액션 디스패치 훅": "useactiondispatch",
      "useAction": "useactiondispatch",
      "액션 훅": "useactiondispatch",
      "use액션Register": "useactionregister",
      "useAction레지스터": "useactionregister",
      "스토어 Integration Pattern": "store-integration-pattern",
      "Store Integration 패턴": "store-integration-pattern",
      "Store 통합 Pattern": "store-integration-pattern",
      "스토어 통합 패턴": "store-integration-pattern",
      "스토어 Factory Functions": "store-factory-functions",
      "Managed 스토어": "managed-store",
      "Jotai 통합": "jotai-integration",
      "로거 Factory": "logger-factory",
      "Smart 로거 Creation": "smart-logger-creation",
      "Atom 컨텍스트 Config": "atom-context-config",
      "Atom 프로바이더": "atom-provider",
      "액션Register Configuration": "actionregister-configuration",
      "ActionRegister 설정": "actionregister-configuration",
      "Action레지스터 Configuration": "actionregister-configuration",
      "정리 Function": "cleanup-function",
      "액션 Metrics": "action-metrics",
      "Action 메트릭": "action-metrics",
      "액션 Events": "action-events",
      "Action 이벤트": "action-events",
      "Event Driven 아키텍처": "event-driven-architecture",
      "Event 핸들러": "event-handler",
      "Observer 패턴": "observer-pattern",
      "스토어 Snapshot": "store-snapshot",
      "스토어 Interface": "store-interface",
      "Store 인터페이스": "store-interface",
      "useSyncExternal스토어 Compatible": "usesyncexternalstore-compatible",
      "Registry 패턴": "registry-pattern",
      "레지스트리 Pattern": "registry-pattern",
      "Environment 설정": "environment-configuration",
      "MVVM 패턴": "mvvm-pattern",
      "View 레이어": "view-layer",
      "뷰 Layer": "view-layer",
      "ViewModel 레이어": "viewmodel-layer",
      "View모델 Layer": "viewmodel-layer",
      "뷰Model Layer": "viewmodel-layer",
      "Model 레이어": "model-layer",
      "모델 Layer": "model-layer",
      "Decoupled 아키텍처": "decoupled-architecture",
      "Deprecated HOC 패턴s": "deprecated-hoc-patterns",
      "스토어-Integration-Pattern": "store-integration-pattern",
      "Store-Integration-패턴": "store-integration-pattern",
      "Store-통합-Pattern": "store-integration-pattern",
      "액션 Pipeline System": "action-pipeline-system",
      "Action 파이프라인 System": "action-pipeline-system",
      "Action Pipeline 시스템": "action-pipeline-system",
      "APS": "action-pipeline-system",
      "액션 파이프라인": "action-pipeline-system",
      "액션 Handler": "action-handler",
      "Action 핸들러": "action-handler",
      "액션 핸들러": "action-handler",
      "파이프라인 Controller": "pipeline-controller",
      "Pipeline 컨트롤러": "pipeline-controller",
      "파이프라인 컨트롤러": "pipeline-controller",
      "스토어 Registry": "store-registry",
      "Store 레지스트리": "store-registry",
      "스토어 레지스트리": "store-registry",
      "액션 Payload Map": "action-payload-map",
      "Action 페이로드 Map": "action-payload-map",
      "핸들러 Configuration": "handler-configuration",
      "Handler 설정": "handler-configuration",
      "실행 Modes": "execution-modes",
      "액션 Guard": "action-guard",
      "Action 가드": "action-guard",
      "로거 Interface": "logger-interface",
      "Logger 인터페이스": "logger-interface",
      "로거 Implementation": "logger-implementation",
      "Console 로거": "console-logger",
      "실행 Mode": "execution-mode",
      "Sequential 실행": "sequential-execution",
      "스토어 Immutability": "store-immutability",
      "인터페이스 Naming": "interface-naming",
      "Logger 시스템 Naming": "logger-system-naming",
      "로거 System Naming": "logger-system-naming",
      "스토어 System Naming": "store-system-naming",
      "Store 시스템 Naming": "store-system-naming",
      "React 통합 Naming": "react-integration-naming",
      "Jotai 통합 Naming": "jotai-integration-naming"
    }
  }
}